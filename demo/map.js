!(function (e, t) {
    'object' == typeof exports && 'object' == typeof module
        ? (module.exports = t())
        : 'function' == typeof define && define.amd
        ? define([], t)
        : 'object' == typeof exports
        ? (exports.mapgl = t())
        : (e.mapgl = t());
})(self, () =>
    (() => {
        'use strict';
        var e = {
                5618: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl-hover {\n    cursor: pointer;\n}\n\n.mapgl-dragging {\n    cursor: grabbing;\n}\n\n.mapgl-rotating {\n    cursor: move;\n}\n',
                        '',
                    ]);
                    const a = s;
                },
                3103: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_lxLX8k02JhUZQLnJt5Mm {\n    font-family: Helvetica, Arial, sans-serif !important;\n    font-size: 8px !important;\n    line-height: 8px !important;\n    text-align: right !important;\n    display: flex;\n    align-items: flex-start;\n    color: #6d7173 !important;\n}\n\n.mapgl_AsSWrna6OS9VEoYItIZV {\n    display: block;\n}\n\na.mapgl_N4E6A6Wp5fYeXBf2QGWt {\n    color: #6d7173 !important;\n    text-decoration: none !important;\n}\n\na.mapgl_N4E6A6Wp5fYeXBf2QGWt:hover {\n    color: #929292 !important;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            container: 'mapgl_lxLX8k02JhUZQLnJt5Mm',
                            text: 'mapgl_AsSWrna6OS9VEoYItIZV',
                            link: 'mapgl_N4E6A6Wp5fYeXBf2QGWt',
                        });
                    const a = s;
                },
                3274: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_SqprqBDt0m3ck8ImwnZ0 {\n    position: absolute;\n    pointer-events: none;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n\n.mapgl_zXpm2Oitx3qOyLXwyVKj {\n    position: absolute;\n    display: flex;\n    z-index: 50;\n    pointer-events: none;\n    width: 100%;\n    height: 100%;\n}\n\n.mapgl_zXpm2Oitx3qOyLXwyVKj > div > * {\n    pointer-events: auto;\n}\n\n.mapgl_r_oD6okoyw2O0sKMERju {\n    flex-direction: column;\n    align-items: flex-start;\n}\n\n.mapgl_FmkgHxvqVart7hWj1dIm {\n    flex-direction: row;\n    justify-content: center;\n    align-items: flex-start;\n}\n\n.mapgl_OS0i93oEEcYSyKRHurat {\n    flex-direction: column;\n    align-items: flex-end;\n}\n\n.mapgl_BIfihGR7X9awnUFk62BQ {\n    flex-direction: column;\n    justify-content: center;\n    align-items: flex-start;\n}\n\n.mapgl_vpFke4npOo1b8whqwKPv {\n    flex-direction: column;\n    justify-content: center;\n    align-items: flex-end;\n}\n\n.mapgl_gLybMsoqNs2Phzvi6hS5 {\n    flex-direction: column-reverse;\n    align-items: flex-start;\n}\n\n.mapgl_GbiZTwfDOnlyI6flVbL_ {\n    flex-direction: row;\n    justify-content: center;\n    align-items: flex-end;\n}\n\n.mapgl_YoIqRTD9ccmcm_A81adk {\n    flex-direction: column-reverse;\n    align-items: flex-end;\n}\n\n.mapgl_r_oD6okoyw2O0sKMERju > div + div,\n.mapgl_OS0i93oEEcYSyKRHurat > div + div,\n.mapgl_BIfihGR7X9awnUFk62BQ > div + div,\n.mapgl_vpFke4npOo1b8whqwKPv > div + div {\n    margin-top: 10px;\n}\n\n.mapgl_gLybMsoqNs2Phzvi6hS5 > div + div,\n.mapgl_YoIqRTD9ccmcm_A81adk > div + div {\n    margin-bottom: 10px;\n}\n\n.mapgl_FmkgHxvqVart7hWj1dIm > div + div,\n.mapgl_GbiZTwfDOnlyI6flVbL_ > div + div {\n    margin-left: 10px;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            controlPane: 'mapgl_SqprqBDt0m3ck8ImwnZ0',
                            container: 'mapgl_zXpm2Oitx3qOyLXwyVKj',
                            topLeft: 'mapgl_r_oD6okoyw2O0sKMERju',
                            topCenter: 'mapgl_FmkgHxvqVart7hWj1dIm',
                            topRight: 'mapgl_OS0i93oEEcYSyKRHurat',
                            centerLeft: 'mapgl_BIfihGR7X9awnUFk62BQ',
                            centerRight: 'mapgl_vpFke4npOo1b8whqwKPv',
                            bottomLeft: 'mapgl_gLybMsoqNs2Phzvi6hS5',
                            bottomCenter: 'mapgl_GbiZTwfDOnlyI6flVbL_',
                            bottomRight: 'mapgl_YoIqRTD9ccmcm_A81adk',
                        });
                    const a = s;
                },
                4306: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_T5RQQ2NOfnY3_e00os8n {\n    display: block !important;\n}\n\n.mapgl_T5RQQ2NOfnY3_e00os8n .mapgl_BhGb3GmPN9rfS36yYYbH {\n    height: 20px !important;\n    display: block !important;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            container: 'mapgl_T5RQQ2NOfnY3_e00os8n',
                            logos: 'mapgl_BhGb3GmPN9rfS36yYYbH',
                        });
                    const a = s;
                },
                1704: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        ".mapgl_ByGR_EaTxrFwgYplL9Rn {\n    position: relative;\n}\n\n.mapgl_rV7SBEVklXHee7q0ro4A {\n    display: flex;\n    max-height: 40vh;\n    background: #ffffff;\n    width: 32px;\n    overflow: hidden;\n    border-radius: 4px;\n    box-shadow: 0 1px 3px 0 rgba(38, 38, 38, 0.5);\n}\n\n.mapgl_eTkkBoRhhRCs7jEwQ2Wb {\n    width: 100%;\n    overflow-x: hidden;\n    overflow-y: auto;\n    -moz-padding-end: 17px;\n    -webkit-padding-end: 17px;\n    -webkit-margin-end: -17px;\n}\n\n.mapgl_gnVYSnZbzDyDuJqZz3mJ {\n    display: flex;\n    flex-direction: column-reverse;\n}\n\n.mapgl_zsd_0yR5qXs0D4rXioaV {\n    all: revert;\n    padding: 0;\n    border: none;\n    background: #ffffff;\n    height: 32px;\n    width: 32px;\n    color: #262626;\n    cursor: pointer;\n    border-bottom: 1px solid #e6e6e6;\n    box-sizing: border-box;\n    flex-shrink: 0;\n}\n.mapgl_zsd_0yR5qXs0D4rXioaV:focus {\n    outline: 0;\n}\n.mapgl_zsd_0yR5qXs0D4rXioaV:first-child {\n    border-bottom: none;\n}\n.mapgl_zsd_0yR5qXs0D4rXioaV:hover {\n    color: rgba(38, 38, 38, 0.7);\n}\n.mapgl_zsd_0yR5qXs0D4rXioaV:active {\n    color: #028eff;\n}\n.mapgl_zsd_0yR5qXs0D4rXioaV:disabled {\n    background: #f2f2f2;\n    color: #929292;\n    cursor: default;\n}\n\n.mapgl_IpWyhNkbWQBqP479eDE2 {\n    font-size: 18px;\n    line-height: 32px;\n    font-weight: 400;\n    overflow-wrap: break-word;\n\n    position: relative;\n    text-align: center;\n    height: 100%;\n}\n\n.mapgl_yUGrJifDT7VmwlUOKi8_:after {\n    content: '';\n    position: absolute;\n    top: 4px;\n    bottom: 4px;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    background: #028eff;\n}\n",
                        '',
                    ]),
                        (s.locals = {
                            root: 'mapgl_ByGR_EaTxrFwgYplL9Rn',
                            container: 'mapgl_rV7SBEVklXHee7q0ro4A',
                            scroller: 'mapgl_eTkkBoRhhRCs7jEwQ2Wb',
                            content: 'mapgl_gnVYSnZbzDyDuJqZz3mJ',
                            control: 'mapgl_zsd_0yR5qXs0D4rXioaV',
                            label: 'mapgl_IpWyhNkbWQBqP479eDE2',
                            _hasResult: 'mapgl_yUGrJifDT7VmwlUOKi8_',
                        });
                    const a = s;
                },
                6032: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_y5CSWkmzFZelEK3XsNPI {\n    background: rgba(255, 255, 255, 0.68);\n    border-width: 0 1px 1px 1px;\n    border-color: #7a7a7a;\n    border-style: solid;\n    border-radius: 0;\n    min-width: 64px;\n    height: 16px;\n    overflow: hidden;\n    pointer-events: none !important;\n}\n\n.mapgl_jEDrEoj7PBYIc0hBFCRq {\n    min-width: 50px;\n    height: 12px;\n    margin-top: 2px;\n    margin-left: 6px;\n    font-family: Helvetica, Arial, sans-serif !important;\n    font-style: normal;\n    font-weight: 400;\n    font-size: 9px;\n    line-height: 12px;\n\n    color: #262626;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            root: 'mapgl_y5CSWkmzFZelEK3XsNPI',
                            label: 'mapgl_jEDrEoj7PBYIc0hBFCRq',
                        });
                    const a = s;
                },
                4928: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_XiKtyzV1PZ9N9z7NbBH0 {\n    background: #fff;\n    box-shadow: 0 1px 3px 0 rgba(38, 38, 38, 0.5);\n    border-radius: 4px;\n    width: 32px;\n    overflow: hidden;\n}\n\n.mapgl_TCECw1gCo4pPgxN8WlHv {\n    all: revert;\n    padding: 0;\n    outline: 0;\n    border: none;\n    cursor: pointer;\n    box-sizing: border-box;\n    font-size: 18px;\n    font-weight: 400;\n    width: 32px;\n    height: 32px;\n    color: #262626;\n    background: #fff;\n}\n\n.mapgl_aifLu_eH4oBoq5TCFEl1:hover {\n    opacity: 0.7;\n}\n\n.mapgl_AZeLf0JO9BdLfzixjszM {\n    background: #299400;\n    color: #fff;\n}\n.mapgl_g9fon0BTtGdnOX4Ce0gE {\n    background: #ffb81c;\n    color: #fff;\n}\n.mapgl_GDc542cVDcz8I8tKJtvz {\n    background: #fe5000;\n    color: #fff;\n}\n\n.mapgl_AZeLf0JO9BdLfzixjszM:hover,\n.mapgl_g9fon0BTtGdnOX4Ce0gE:hover,\n.mapgl_GDc542cVDcz8I8tKJtvz:hover {\n    color: rgba(38, 38, 38, 0.7);\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            root: 'mapgl_XiKtyzV1PZ9N9z7NbBH0',
                            button: 'mapgl_TCECw1gCo4pPgxN8WlHv',
                            none: 'mapgl_aifLu_eH4oBoq5TCFEl1',
                            easy: 'mapgl_AZeLf0JO9BdLfzixjszM',
                            medium: 'mapgl_g9fon0BTtGdnOX4Ce0gE',
                            hard: 'mapgl_GDc542cVDcz8I8tKJtvz',
                        });
                    const a = s;
                },
                8585: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_RyvsmCnoVe7ui2MClLMS {\n    width: 32px;\n    box-shadow: 0 1px 3px 0 rgba(38, 38, 38, 0.5);\n    border-radius: 4px;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    background: #fff;\n}\n\n.mapgl_Tdw0Vs7iQuaknNHHD21k {\n    all: revert;\n\n    padding: 0;\n    outline: 0;\n    border: none;\n    cursor: pointer;\n\n    background: #fff;\n    width: 32px;\n    height: 32px;\n    color: #262626;\n    box-sizing: border-box;\n}\n\n.mapgl_Tdw0Vs7iQuaknNHHD21k:hover {\n    opacity: 0.7;\n}\n\n.mapgl_Tdw0Vs7iQuaknNHHD21k:active {\n    color: #028eff;\n}\n\n.mapgl_Tdw0Vs7iQuaknNHHD21k:disabled {\n    background: #f2f2f2;\n    color: #929292;\n    cursor: default;\n}\n\n.mapgl_JwF7YmgOItTjpjwxORCk {\n    border-bottom: 1px solid #e6e6e6;\n}\n\n.mapgl_Tvr6BDuVyr8143cFJ4nJ {\n    border-bottom: none;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            root: 'mapgl_RyvsmCnoVe7ui2MClLMS',
                            button: 'mapgl_Tdw0Vs7iQuaknNHHD21k',
                            zoomIn: 'mapgl_JwF7YmgOItTjpjwxORCk',
                            zoomOut: 'mapgl_Tvr6BDuVyr8143cFJ4nJ',
                        });
                    const a = s;
                },
                438: (e, t, i) => {
                    i.d(t, { Z: () => a });
                    var n = i(8276),
                        o = i.n(n),
                        r = i(5368),
                        s = i.n(r)()(o());
                    s.push([
                        e.id,
                        '.mapgl_Zqe1f2Ik8_MdehkwZiwo {\n    pointer-events: none;\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 10px;\n    background-color: rgba(0, 0, 0, 0.2);\n    cursor: default;\n}\n\n.mapgl_RBLYLi7mJFgKIKMPLvv_ {\n    text-align: center;\n    font-size: 24px;\n    font-family: Helvetica, Arial, sans-serif;\n    font-weight: bold;\n    color: white;\n}\n',
                        '',
                    ]),
                        (s.locals = {
                            wrap: 'mapgl_Zqe1f2Ik8_MdehkwZiwo',
                            container: 'mapgl_RBLYLi7mJFgKIKMPLvv_',
                        });
                    const a = s;
                },
                3379: (e) => {
                    var t = [];
                    function i(e) {
                        for (var i = -1, n = 0; n < t.length; n++)
                            if (t[n].identifier === e) {
                                i = n;
                                break;
                            }
                        return i;
                    }
                    function n(e, n) {
                        for (var r = {}, s = [], a = 0; a < e.length; a++) {
                            var l = e[a],
                                c = n.base ? l[0] + n.base : l[0],
                                d = r[c] || 0,
                                h = ''.concat(c, ' ').concat(d);
                            r[c] = d + 1;
                            var u = i(h),
                                m = {
                                    css: l[1],
                                    media: l[2],
                                    sourceMap: l[3],
                                    supports: l[4],
                                    layer: l[5],
                                };
                            if (-1 !== u) t[u].references++, t[u].updater(m);
                            else {
                                var f = o(m, n);
                                (n.byIndex = a),
                                    t.splice(a, 0, { identifier: h, updater: f, references: 1 });
                            }
                            s.push(h);
                        }
                        return s;
                    }
                    function o(e, t) {
                        var i = t.domAPI(t);
                        i.update(e);
                        return function (t) {
                            if (t) {
                                if (
                                    t.css === e.css &&
                                    t.media === e.media &&
                                    t.sourceMap === e.sourceMap &&
                                    t.supports === e.supports &&
                                    t.layer === e.layer
                                )
                                    return;
                                i.update((e = t));
                            } else i.remove();
                        };
                    }
                    e.exports = function (e, o) {
                        var r = n((e = e || []), (o = o || {}));
                        return function (e) {
                            e = e || [];
                            for (var s = 0; s < r.length; s++) {
                                var a = i(r[s]);
                                t[a].references--;
                            }
                            for (var l = n(e, o), c = 0; c < r.length; c++) {
                                var d = i(r[c]);
                                0 === t[d].references && (t[d].updater(), t.splice(d, 1));
                            }
                            r = l;
                        };
                    };
                },
                569: (e) => {
                    var t = {};
                    e.exports = function (e, i) {
                        var n = (function (e) {
                            if (void 0 === t[e]) {
                                var i = document.querySelector(e);
                                if (
                                    window.HTMLIFrameElement &&
                                    i instanceof window.HTMLIFrameElement
                                )
                                    try {
                                        i = i.contentDocument.head;
                                    } catch (e) {
                                        i = null;
                                    }
                                t[e] = i;
                            }
                            return t[e];
                        })(e);
                        if (!n)
                            throw new Error(
                                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
                            );
                        n.appendChild(i);
                    };
                },
                9216: (e) => {
                    e.exports = function (e) {
                        var t = document.createElement('style');
                        return e.setAttributes(t, e.attributes), e.insert(t, e.options), t;
                    };
                },
                3565: (e, t, i) => {
                    e.exports = function (e) {
                        var t = i.nc;
                        t && e.setAttribute('nonce', t);
                    };
                },
                7795: (e) => {
                    e.exports = function (e) {
                        var t = e.insertStyleElement(e);
                        return {
                            update: function (i) {
                                !(function (e, t, i) {
                                    var n = '';
                                    i.supports && (n += '@supports ('.concat(i.supports, ') {')),
                                        i.media && (n += '@media '.concat(i.media, ' {'));
                                    var o = void 0 !== i.layer;
                                    o &&
                                        (n += '@layer'.concat(
                                            i.layer.length > 0 ? ' '.concat(i.layer) : '',
                                            ' {',
                                        )),
                                        (n += i.css),
                                        o && (n += '}'),
                                        i.media && (n += '}'),
                                        i.supports && (n += '}');
                                    var r = i.sourceMap;
                                    r &&
                                        'undefined' != typeof btoa &&
                                        (n +=
                                            '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                                                btoa(
                                                    unescape(encodeURIComponent(JSON.stringify(r))),
                                                ),
                                                ' */',
                                            )),
                                        t.styleTagTransform(n, e, t.options);
                                })(t, e, i);
                            },
                            remove: function () {
                                !(function (e) {
                                    if (null === e.parentNode) return !1;
                                    e.parentNode.removeChild(e);
                                })(t);
                            },
                        };
                    };
                },
                4589: (e) => {
                    e.exports = function (e, t) {
                        if (t.styleSheet) t.styleSheet.cssText = e;
                        else {
                            for (; t.firstChild; ) t.removeChild(t.firstChild);
                            t.appendChild(document.createTextNode(e));
                        }
                    };
                },
                3287: (e, t, i) => {
                    i.d(t, { Ib: () => n, WT: () => o });
                    const n = 1e-6;
                    let o = 'undefined' != typeof Float64Array ? Float64Array : Array;
                    Math.random;
                    Math.PI;
                },
                127: (e, t, i) => {
                    i.d(t, {
                        I6: () => v,
                        Iu: () => u,
                        Iw: () => p,
                        JG: () => s,
                        Jp: () => h,
                        U_: () => d,
                        Ue: () => o,
                        al: () => a,
                        bA: () => m,
                        d9: () => r,
                        dC: () => g,
                        p4: () => c,
                        t8: () => l,
                        wA: () => y,
                        xJ: () => f,
                        zB: () => _,
                    });
                    var n = i(3287);
                    function o() {
                        let e = new n.WT(16);
                        return (
                            (e[0] = 1),
                            (e[1] = 0),
                            (e[2] = 0),
                            (e[3] = 0),
                            (e[4] = 0),
                            (e[5] = 1),
                            (e[6] = 0),
                            (e[7] = 0),
                            (e[8] = 0),
                            (e[9] = 0),
                            (e[10] = 1),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            e
                        );
                    }
                    function r(e) {
                        let t = new n.WT(16);
                        return (
                            (t[0] = e[0]),
                            (t[1] = e[1]),
                            (t[2] = e[2]),
                            (t[3] = e[3]),
                            (t[4] = e[4]),
                            (t[5] = e[5]),
                            (t[6] = e[6]),
                            (t[7] = e[7]),
                            (t[8] = e[8]),
                            (t[9] = e[9]),
                            (t[10] = e[10]),
                            (t[11] = e[11]),
                            (t[12] = e[12]),
                            (t[13] = e[13]),
                            (t[14] = e[14]),
                            (t[15] = e[15]),
                            t
                        );
                    }
                    function s(e, t) {
                        return (
                            (e[0] = t[0]),
                            (e[1] = t[1]),
                            (e[2] = t[2]),
                            (e[3] = t[3]),
                            (e[4] = t[4]),
                            (e[5] = t[5]),
                            (e[6] = t[6]),
                            (e[7] = t[7]),
                            (e[8] = t[8]),
                            (e[9] = t[9]),
                            (e[10] = t[10]),
                            (e[11] = t[11]),
                            (e[12] = t[12]),
                            (e[13] = t[13]),
                            (e[14] = t[14]),
                            (e[15] = t[15]),
                            e
                        );
                    }
                    function a(e, t, i, o, r, s, a, l, c, d, h, u, m, f, p, _) {
                        let v = new n.WT(16);
                        return (
                            (v[0] = e),
                            (v[1] = t),
                            (v[2] = i),
                            (v[3] = o),
                            (v[4] = r),
                            (v[5] = s),
                            (v[6] = a),
                            (v[7] = l),
                            (v[8] = c),
                            (v[9] = d),
                            (v[10] = h),
                            (v[11] = u),
                            (v[12] = m),
                            (v[13] = f),
                            (v[14] = p),
                            (v[15] = _),
                            v
                        );
                    }
                    function l(e, t, i, n, o, r, s, a, l, c, d, h, u, m, f, p, _) {
                        return (
                            (e[0] = t),
                            (e[1] = i),
                            (e[2] = n),
                            (e[3] = o),
                            (e[4] = r),
                            (e[5] = s),
                            (e[6] = a),
                            (e[7] = l),
                            (e[8] = c),
                            (e[9] = d),
                            (e[10] = h),
                            (e[11] = u),
                            (e[12] = m),
                            (e[13] = f),
                            (e[14] = p),
                            (e[15] = _),
                            e
                        );
                    }
                    function c(e, t) {
                        if (e === t) {
                            let i = t[1],
                                n = t[2],
                                o = t[3],
                                r = t[6],
                                s = t[7],
                                a = t[11];
                            (e[1] = t[4]),
                                (e[2] = t[8]),
                                (e[3] = t[12]),
                                (e[4] = i),
                                (e[6] = t[9]),
                                (e[7] = t[13]),
                                (e[8] = n),
                                (e[9] = r),
                                (e[11] = t[14]),
                                (e[12] = o),
                                (e[13] = s),
                                (e[14] = a);
                        } else
                            (e[0] = t[0]),
                                (e[1] = t[4]),
                                (e[2] = t[8]),
                                (e[3] = t[12]),
                                (e[4] = t[1]),
                                (e[5] = t[5]),
                                (e[6] = t[9]),
                                (e[7] = t[13]),
                                (e[8] = t[2]),
                                (e[9] = t[6]),
                                (e[10] = t[10]),
                                (e[11] = t[14]),
                                (e[12] = t[3]),
                                (e[13] = t[7]),
                                (e[14] = t[11]),
                                (e[15] = t[15]);
                        return e;
                    }
                    function d(e, t) {
                        let i = t[0],
                            n = t[1],
                            o = t[2],
                            r = t[3],
                            s = t[4],
                            a = t[5],
                            l = t[6],
                            c = t[7],
                            d = t[8],
                            h = t[9],
                            u = t[10],
                            m = t[11],
                            f = t[12],
                            p = t[13],
                            _ = t[14],
                            v = t[15],
                            g = i * a - n * s,
                            y = i * l - o * s,
                            b = i * c - r * s,
                            w = n * l - o * a,
                            x = n * c - r * a,
                            S = o * c - r * l,
                            I = d * p - h * f,
                            M = d * _ - u * f,
                            T = d * v - m * f,
                            P = h * _ - u * p,
                            L = h * v - m * p,
                            k = u * v - m * _,
                            E = g * k - y * L + b * P + w * T - x * M + S * I;
                        return E
                            ? ((E = 1 / E),
                              (e[0] = (a * k - l * L + c * P) * E),
                              (e[1] = (o * L - n * k - r * P) * E),
                              (e[2] = (p * S - _ * x + v * w) * E),
                              (e[3] = (u * x - h * S - m * w) * E),
                              (e[4] = (l * T - s * k - c * M) * E),
                              (e[5] = (i * k - o * T + r * M) * E),
                              (e[6] = (_ * b - f * S - v * y) * E),
                              (e[7] = (d * S - u * b + m * y) * E),
                              (e[8] = (s * L - a * T + c * I) * E),
                              (e[9] = (n * T - i * L - r * I) * E),
                              (e[10] = (f * x - p * b + v * g) * E),
                              (e[11] = (h * b - d * x - m * g) * E),
                              (e[12] = (a * M - s * P - l * I) * E),
                              (e[13] = (i * P - n * M + o * I) * E),
                              (e[14] = (p * y - f * w - _ * g) * E),
                              (e[15] = (d * w - h * y + u * g) * E),
                              e)
                            : null;
                    }
                    function h(e, t, i) {
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = t[3],
                            a = t[4],
                            l = t[5],
                            c = t[6],
                            d = t[7],
                            h = t[8],
                            u = t[9],
                            m = t[10],
                            f = t[11],
                            p = t[12],
                            _ = t[13],
                            v = t[14],
                            g = t[15],
                            y = i[0],
                            b = i[1],
                            w = i[2],
                            x = i[3];
                        return (
                            (e[0] = y * n + b * a + w * h + x * p),
                            (e[1] = y * o + b * l + w * u + x * _),
                            (e[2] = y * r + b * c + w * m + x * v),
                            (e[3] = y * s + b * d + w * f + x * g),
                            (y = i[4]),
                            (b = i[5]),
                            (w = i[6]),
                            (x = i[7]),
                            (e[4] = y * n + b * a + w * h + x * p),
                            (e[5] = y * o + b * l + w * u + x * _),
                            (e[6] = y * r + b * c + w * m + x * v),
                            (e[7] = y * s + b * d + w * f + x * g),
                            (y = i[8]),
                            (b = i[9]),
                            (w = i[10]),
                            (x = i[11]),
                            (e[8] = y * n + b * a + w * h + x * p),
                            (e[9] = y * o + b * l + w * u + x * _),
                            (e[10] = y * r + b * c + w * m + x * v),
                            (e[11] = y * s + b * d + w * f + x * g),
                            (y = i[12]),
                            (b = i[13]),
                            (w = i[14]),
                            (x = i[15]),
                            (e[12] = y * n + b * a + w * h + x * p),
                            (e[13] = y * o + b * l + w * u + x * _),
                            (e[14] = y * r + b * c + w * m + x * v),
                            (e[15] = y * s + b * d + w * f + x * g),
                            e
                        );
                    }
                    function u(e, t, i) {
                        let n,
                            o,
                            r,
                            s,
                            a,
                            l,
                            c,
                            d,
                            h,
                            u,
                            m,
                            f,
                            p = i[0],
                            _ = i[1],
                            v = i[2];
                        return (
                            t === e
                                ? ((e[12] = t[0] * p + t[4] * _ + t[8] * v + t[12]),
                                  (e[13] = t[1] * p + t[5] * _ + t[9] * v + t[13]),
                                  (e[14] = t[2] * p + t[6] * _ + t[10] * v + t[14]),
                                  (e[15] = t[3] * p + t[7] * _ + t[11] * v + t[15]))
                                : ((n = t[0]),
                                  (o = t[1]),
                                  (r = t[2]),
                                  (s = t[3]),
                                  (a = t[4]),
                                  (l = t[5]),
                                  (c = t[6]),
                                  (d = t[7]),
                                  (h = t[8]),
                                  (u = t[9]),
                                  (m = t[10]),
                                  (f = t[11]),
                                  (e[0] = n),
                                  (e[1] = o),
                                  (e[2] = r),
                                  (e[3] = s),
                                  (e[4] = a),
                                  (e[5] = l),
                                  (e[6] = c),
                                  (e[7] = d),
                                  (e[8] = h),
                                  (e[9] = u),
                                  (e[10] = m),
                                  (e[11] = f),
                                  (e[12] = n * p + a * _ + h * v + t[12]),
                                  (e[13] = o * p + l * _ + u * v + t[13]),
                                  (e[14] = r * p + c * _ + m * v + t[14]),
                                  (e[15] = s * p + d * _ + f * v + t[15])),
                            e
                        );
                    }
                    function m(e, t, i) {
                        let n = i[0],
                            o = i[1],
                            r = i[2];
                        return (
                            (e[0] = t[0] * n),
                            (e[1] = t[1] * n),
                            (e[2] = t[2] * n),
                            (e[3] = t[3] * n),
                            (e[4] = t[4] * o),
                            (e[5] = t[5] * o),
                            (e[6] = t[6] * o),
                            (e[7] = t[7] * o),
                            (e[8] = t[8] * r),
                            (e[9] = t[9] * r),
                            (e[10] = t[10] * r),
                            (e[11] = t[11] * r),
                            (e[12] = t[12]),
                            (e[13] = t[13]),
                            (e[14] = t[14]),
                            (e[15] = t[15]),
                            e
                        );
                    }
                    function f(e, t) {
                        return (
                            (e[0] = t[0]),
                            (e[1] = 0),
                            (e[2] = 0),
                            (e[3] = 0),
                            (e[4] = 0),
                            (e[5] = t[1]),
                            (e[6] = 0),
                            (e[7] = 0),
                            (e[8] = 0),
                            (e[9] = 0),
                            (e[10] = t[2]),
                            (e[11] = 0),
                            (e[12] = 0),
                            (e[13] = 0),
                            (e[14] = 0),
                            (e[15] = 1),
                            e
                        );
                    }
                    function p(e, t, i, n) {
                        let o = t[0],
                            r = t[1],
                            s = t[2],
                            a = t[3],
                            l = o + o,
                            c = r + r,
                            d = s + s,
                            h = o * l,
                            u = o * c,
                            m = o * d,
                            f = r * c,
                            p = r * d,
                            _ = s * d,
                            v = a * l,
                            g = a * c,
                            y = a * d,
                            b = n[0],
                            w = n[1],
                            x = n[2];
                        return (
                            (e[0] = (1 - (f + _)) * b),
                            (e[1] = (u + y) * b),
                            (e[2] = (m - g) * b),
                            (e[3] = 0),
                            (e[4] = (u - y) * w),
                            (e[5] = (1 - (h + _)) * w),
                            (e[6] = (p + v) * w),
                            (e[7] = 0),
                            (e[8] = (m + g) * x),
                            (e[9] = (p - v) * x),
                            (e[10] = (1 - (h + f)) * x),
                            (e[11] = 0),
                            (e[12] = i[0]),
                            (e[13] = i[1]),
                            (e[14] = i[2]),
                            (e[15] = 1),
                            e
                        );
                    }
                    function _(e, t, i, o) {
                        let r,
                            s,
                            a,
                            l,
                            c,
                            d,
                            h,
                            u,
                            m,
                            f,
                            p = t[0],
                            _ = t[1],
                            v = t[2],
                            g = o[0],
                            y = o[1],
                            b = o[2],
                            w = i[0],
                            x = i[1],
                            S = i[2];
                        return Math.abs(p - w) < n.Ib &&
                            Math.abs(_ - x) < n.Ib &&
                            Math.abs(v - S) < n.Ib
                            ? mat4.identity(e)
                            : ((h = p - w),
                              (u = _ - x),
                              (m = v - S),
                              (f = 1 / Math.sqrt(h * h + u * u + m * m)),
                              (h *= f),
                              (u *= f),
                              (m *= f),
                              (r = y * m - b * u),
                              (s = b * h - g * m),
                              (a = g * u - y * h),
                              (f = Math.sqrt(r * r + s * s + a * a)),
                              f
                                  ? ((f = 1 / f), (r *= f), (s *= f), (a *= f))
                                  : ((r = 0), (s = 0), (a = 0)),
                              (l = u * a - m * s),
                              (c = m * r - h * a),
                              (d = h * s - u * r),
                              (f = Math.sqrt(l * l + c * c + d * d)),
                              f
                                  ? ((f = 1 / f), (l *= f), (c *= f), (d *= f))
                                  : ((l = 0), (c = 0), (d = 0)),
                              (e[0] = r),
                              (e[1] = l),
                              (e[2] = h),
                              (e[3] = 0),
                              (e[4] = s),
                              (e[5] = c),
                              (e[6] = u),
                              (e[7] = 0),
                              (e[8] = a),
                              (e[9] = d),
                              (e[10] = m),
                              (e[11] = 0),
                              (e[12] = -(r * p + s * _ + a * v)),
                              (e[13] = -(l * p + c * _ + d * v)),
                              (e[14] = -(h * p + u * _ + m * v)),
                              (e[15] = 1),
                              e);
                    }
                    function v(e, t) {
                        return (
                            e[0] === t[0] &&
                            e[1] === t[1] &&
                            e[2] === t[2] &&
                            e[3] === t[3] &&
                            e[4] === t[4] &&
                            e[5] === t[5] &&
                            e[6] === t[6] &&
                            e[7] === t[7] &&
                            e[8] === t[8] &&
                            e[9] === t[9] &&
                            e[10] === t[10] &&
                            e[11] === t[11] &&
                            e[12] === t[12] &&
                            e[13] === t[13] &&
                            e[14] === t[14] &&
                            e[15] === t[15]
                        );
                    }
                    const g = h;
                    function y(e, t, i) {
                        return (
                            (e[0] = i[0]),
                            (e[1] = 0),
                            (e[2] = 0),
                            (e[3] = 0),
                            (e[4] = 0),
                            (e[5] = i[1]),
                            (e[6] = 0),
                            (e[7] = 0),
                            (e[8] = 0),
                            (e[9] = 0),
                            (e[10] = i[2]),
                            (e[11] = 0),
                            (e[12] = t[0]),
                            (e[13] = t[1]),
                            (e[14] = t[2]),
                            (e[15] = 1),
                            e
                        );
                    }
                },
                378: (e, t, i) => {
                    i.d(t, {
                        $X: () => d,
                        AK: () => v,
                        Fp: () => u,
                        Fv: () => _,
                        I6: () => y,
                        IH: () => c,
                        JG: () => a,
                        TE: () => f,
                        TK: () => x,
                        Ue: () => o,
                        VV: () => h,
                        al: () => s,
                        bA: () => m,
                        d9: () => r,
                        fS: () => b,
                        kE: () => p,
                        lu: () => w,
                        t7: () => g,
                        t8: () => l,
                    });
                    var n = i(3287);
                    function o() {
                        let e = new n.WT(2);
                        return (e[0] = 0), (e[1] = 0), e;
                    }
                    function r(e) {
                        let t = new n.WT(2);
                        return (t[0] = e[0]), (t[1] = e[1]), t;
                    }
                    function s(e, t) {
                        let i = new n.WT(2);
                        return (i[0] = e), (i[1] = t), i;
                    }
                    function a(e, t) {
                        return (e[0] = t[0]), (e[1] = t[1]), e;
                    }
                    function l(e, t, i) {
                        return (e[0] = t), (e[1] = i), e;
                    }
                    function c(e, t, i) {
                        return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), e;
                    }
                    function d(e, t, i) {
                        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), e;
                    }
                    function h(e, t, i) {
                        return (e[0] = Math.min(t[0], i[0])), (e[1] = Math.min(t[1], i[1])), e;
                    }
                    function u(e, t, i) {
                        return (e[0] = Math.max(t[0], i[0])), (e[1] = Math.max(t[1], i[1])), e;
                    }
                    function m(e, t, i) {
                        return (e[0] = t[0] * i), (e[1] = t[1] * i), e;
                    }
                    function f(e, t) {
                        var i = t[0] - e[0],
                            n = t[1] - e[1];
                        return Math.sqrt(i * i + n * n);
                    }
                    function p(e) {
                        var t = e[0],
                            i = e[1];
                        return Math.sqrt(t * t + i * i);
                    }
                    function _(e, t) {
                        var i = t[0],
                            n = t[1],
                            o = i * i + n * n;
                        return (
                            o > 0 && ((o = 1 / Math.sqrt(o)), (e[0] = t[0] * o), (e[1] = t[1] * o)),
                            e
                        );
                    }
                    function v(e, t) {
                        return e[0] * t[0] + e[1] * t[1];
                    }
                    function g(e, t, i, n) {
                        var o = t[0],
                            r = t[1];
                        return (e[0] = o + n * (i[0] - o)), (e[1] = r + n * (i[1] - r)), e;
                    }
                    function y(e, t) {
                        return e[0] === t[0] && e[1] === t[1];
                    }
                    function b(e, t) {
                        let i = e[0],
                            o = e[1],
                            r = t[0],
                            s = t[1];
                        return (
                            Math.abs(i - r) <= n.Ib * Math.max(1, Math.abs(i), Math.abs(r)) &&
                            Math.abs(o - s) <= n.Ib * Math.max(1, Math.abs(o), Math.abs(s))
                        );
                    }
                    const w = d,
                        x = f;
                    !(function () {
                        let e = o();
                    })();
                },
                9450: (e, t, i) => {
                    i.d(t, {
                        AK: () => f,
                        Fv: () => m,
                        I6: () => y,
                        IH: () => d,
                        JG: () => l,
                        TE: () => u,
                        Ue: () => o,
                        Zh: () => x,
                        al: () => a,
                        bA: () => h,
                        d9: () => r,
                        fF: () => v,
                        fS: () => b,
                        jI: () => g,
                        kC: () => p,
                        kE: () => s,
                        lu: () => w,
                        t7: () => _,
                        t8: () => c,
                    });
                    var n = i(3287);
                    function o() {
                        let e = new n.WT(3);
                        return (e[0] = 0), (e[1] = 0), (e[2] = 0), e;
                    }
                    function r(e) {
                        var t = new n.WT(3);
                        return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t;
                    }
                    function s(e) {
                        let t = e[0],
                            i = e[1],
                            n = e[2];
                        return Math.sqrt(t * t + i * i + n * n);
                    }
                    function a(e, t, i) {
                        let o = new n.WT(3);
                        return (o[0] = e), (o[1] = t), (o[2] = i), o;
                    }
                    function l(e, t) {
                        return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
                    }
                    function c(e, t, i, n) {
                        return (e[0] = t), (e[1] = i), (e[2] = n), e;
                    }
                    function d(e, t, i) {
                        return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), e;
                    }
                    function h(e, t, i) {
                        return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), e;
                    }
                    function u(e, t) {
                        let i = t[0] - e[0],
                            n = t[1] - e[1],
                            o = t[2] - e[2];
                        return Math.sqrt(i * i + n * n + o * o);
                    }
                    function m(e, t) {
                        let i = t[0],
                            n = t[1],
                            o = t[2],
                            r = i * i + n * n + o * o;
                        return (
                            r > 0 &&
                                ((r = 1 / Math.sqrt(r)),
                                (e[0] = t[0] * r),
                                (e[1] = t[1] * r),
                                (e[2] = t[2] * r)),
                            e
                        );
                    }
                    function f(e, t) {
                        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
                    }
                    function p(e, t, i) {
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = i[0],
                            a = i[1],
                            l = i[2];
                        return (
                            (e[0] = o * l - r * a),
                            (e[1] = r * s - n * l),
                            (e[2] = n * a - o * s),
                            e
                        );
                    }
                    function _(e, t, i, n) {
                        let o = t[0],
                            r = t[1],
                            s = t[2];
                        return (
                            (e[0] = o + n * (i[0] - o)),
                            (e[1] = r + n * (i[1] - r)),
                            (e[2] = s + n * (i[2] - s)),
                            e
                        );
                    }
                    function v(e, t, i) {
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = i[3] * n + i[7] * o + i[11] * r + i[15];
                        return (
                            (s = s || 1),
                            (e[0] = (i[0] * n + i[4] * o + i[8] * r + i[12]) / s),
                            (e[1] = (i[1] * n + i[5] * o + i[9] * r + i[13]) / s),
                            (e[2] = (i[2] * n + i[6] * o + i[10] * r + i[14]) / s),
                            e
                        );
                    }
                    function g(e, t, i, n) {
                        let o = [],
                            r = [];
                        return (
                            (o[0] = t[0] - i[0]),
                            (o[1] = t[1] - i[1]),
                            (o[2] = t[2] - i[2]),
                            (r[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n)),
                            (r[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n)),
                            (r[2] = o[2]),
                            (e[0] = r[0] + i[0]),
                            (e[1] = r[1] + i[1]),
                            (e[2] = r[2] + i[2]),
                            e
                        );
                    }
                    function y(e, t) {
                        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
                    }
                    function b(e, t) {
                        let i = e[0],
                            o = e[1],
                            r = e[2],
                            s = t[0],
                            a = t[1],
                            l = t[2];
                        return (
                            Math.abs(i - s) <= n.Ib * Math.max(1, Math.abs(i), Math.abs(s)) &&
                            Math.abs(o - a) <= n.Ib * Math.max(1, Math.abs(o), Math.abs(a)) &&
                            Math.abs(r - l) <= n.Ib * Math.max(1, Math.abs(r), Math.abs(l))
                        );
                    }
                    const w = function (e, t, i) {
                            return (
                                (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), e
                            );
                        },
                        x = s;
                    !(function () {
                        let e = o();
                    })();
                },
                1245: (e, t, i) => {
                    i.d(t, {
                        AK: () => m,
                        Fv: () => u,
                        I6: () => _,
                        IH: () => l,
                        JG: () => s,
                        al: () => r,
                        bA: () => c,
                        d9: () => o,
                        fF: () => p,
                        fS: () => v,
                        kE: () => d,
                        t7: () => f,
                        t8: () => a,
                        we: () => h,
                    });
                    var n = i(3287);
                    function o(e) {
                        let t = new n.WT(4);
                        return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), t;
                    }
                    function r(e, t, i, o) {
                        let r = new n.WT(4);
                        return (r[0] = e), (r[1] = t), (r[2] = i), (r[3] = o), r;
                    }
                    function s(e, t) {
                        return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e;
                    }
                    function a(e, t, i, n, o) {
                        return (e[0] = t), (e[1] = i), (e[2] = n), (e[3] = o), e;
                    }
                    function l(e, t, i) {
                        return (
                            (e[0] = t[0] + i[0]),
                            (e[1] = t[1] + i[1]),
                            (e[2] = t[2] + i[2]),
                            (e[3] = t[3] + i[3]),
                            e
                        );
                    }
                    function c(e, t, i) {
                        return (
                            (e[0] = t[0] * i),
                            (e[1] = t[1] * i),
                            (e[2] = t[2] * i),
                            (e[3] = t[3] * i),
                            e
                        );
                    }
                    function d(e) {
                        let t = e[0],
                            i = e[1],
                            n = e[2],
                            o = e[3];
                        return Math.sqrt(t * t + i * i + n * n + o * o);
                    }
                    function h(e) {
                        let t = e[0],
                            i = e[1],
                            n = e[2],
                            o = e[3];
                        return t * t + i * i + n * n + o * o;
                    }
                    function u(e, t) {
                        let i = t[0],
                            n = t[1],
                            o = t[2],
                            r = t[3],
                            s = i * i + n * n + o * o + r * r;
                        return (
                            s > 0 &&
                                ((s = 1 / Math.sqrt(s)),
                                (e[0] = i * s),
                                (e[1] = n * s),
                                (e[2] = o * s),
                                (e[3] = r * s)),
                            e
                        );
                    }
                    function m(e, t) {
                        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
                    }
                    function f(e, t, i, n) {
                        let o = t[0],
                            r = t[1],
                            s = t[2],
                            a = t[3];
                        return (
                            (e[0] = o + n * (i[0] - o)),
                            (e[1] = r + n * (i[1] - r)),
                            (e[2] = s + n * (i[2] - s)),
                            (e[3] = a + n * (i[3] - a)),
                            e
                        );
                    }
                    function p(e, t, i) {
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = t[3];
                        return (
                            (e[0] = i[0] * n + i[4] * o + i[8] * r + i[12] * s),
                            (e[1] = i[1] * n + i[5] * o + i[9] * r + i[13] * s),
                            (e[2] = i[2] * n + i[6] * o + i[10] * r + i[14] * s),
                            (e[3] = i[3] * n + i[7] * o + i[11] * r + i[15] * s),
                            e
                        );
                    }
                    function _(e, t) {
                        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];
                    }
                    function v(e, t) {
                        let i = e[0],
                            o = e[1],
                            r = e[2],
                            s = e[3],
                            a = t[0],
                            l = t[1],
                            c = t[2],
                            d = t[3];
                        return (
                            Math.abs(i - a) <= n.Ib * Math.max(1, Math.abs(i), Math.abs(a)) &&
                            Math.abs(o - l) <= n.Ib * Math.max(1, Math.abs(o), Math.abs(l)) &&
                            Math.abs(r - c) <= n.Ib * Math.max(1, Math.abs(r), Math.abs(c)) &&
                            Math.abs(s - d) <= n.Ib * Math.max(1, Math.abs(s), Math.abs(d))
                        );
                    }
                    !(function () {
                        let e = (function () {
                            let e = new n.WT(4);
                            return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 0), e;
                        })();
                    })();
                },
                4716: (e, t) => {
                    !(function () {
                        for (
                            var e =
                                    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                                i = new Uint8Array(256),
                                n = 0;
                            n < e.length;
                            n++
                        )
                            i[e.charCodeAt(n)] = n;
                        (t.c = function (t) {
                            var i,
                                n = new Uint8Array(t),
                                o = n.length,
                                r = '';
                            for (i = 0; i < o; i += 3)
                                (r += e[n[i] >> 2]),
                                    (r += e[((3 & n[i]) << 4) | (n[i + 1] >> 4)]),
                                    (r += e[((15 & n[i + 1]) << 2) | (n[i + 2] >> 6)]),
                                    (r += e[63 & n[i + 2]]);
                            return (
                                o % 3 == 2
                                    ? (r = r.substring(0, r.length - 1) + '=')
                                    : o % 3 == 1 && (r = r.substring(0, r.length - 2) + '=='),
                                r
                            );
                        }),
                            function (e) {
                                var t,
                                    n,
                                    o,
                                    r,
                                    s,
                                    a = 0.75 * e.length,
                                    l = e.length,
                                    c = 0;
                                '=' === e[e.length - 1] && (a--, '=' === e[e.length - 2] && a--);
                                var d = new ArrayBuffer(a),
                                    h = new Uint8Array(d);
                                for (t = 0; t < l; t += 4)
                                    (n = i[e.charCodeAt(t)]),
                                        (o = i[e.charCodeAt(t + 1)]),
                                        (r = i[e.charCodeAt(t + 2)]),
                                        (s = i[e.charCodeAt(t + 3)]),
                                        (h[c++] = (n << 2) | (o >> 4)),
                                        (h[c++] = ((15 & o) << 4) | (r >> 2)),
                                        (h[c++] = ((3 & r) << 6) | (63 & s));
                                return d;
                            };
                    })();
                },
                6636: (e) => {
                    var t = 0.1,
                        i = 'function' == typeof Float32Array;
                    function n(e, t) {
                        return 1 - 3 * t + 3 * e;
                    }
                    function o(e, t) {
                        return 3 * t - 6 * e;
                    }
                    function r(e) {
                        return 3 * e;
                    }
                    function s(e, t, i) {
                        return ((n(t, i) * e + o(t, i)) * e + r(t)) * e;
                    }
                    function a(e, t, i) {
                        return 3 * n(t, i) * e * e + 2 * o(t, i) * e + r(t);
                    }
                    function l(e) {
                        return e;
                    }
                    e.exports = function (e, n, o, r) {
                        if (!(0 <= e && e <= 1 && 0 <= o && o <= 1))
                            throw new Error('bezier x values must be in [0, 1] range');
                        if (e === n && o === r) return l;
                        for (var c = i ? new Float32Array(11) : new Array(11), d = 0; d < 11; ++d)
                            c[d] = s(d * t, e, o);
                        function h(i) {
                            for (var n = 0, r = 1; 10 !== r && c[r] <= i; ++r) n += t;
                            --r;
                            var l = n + ((i - c[r]) / (c[r + 1] - c[r])) * t,
                                d = a(l, e, o);
                            return d >= 0.001
                                ? (function (e, t, i, n) {
                                      for (var o = 0; o < 4; ++o) {
                                          var r = a(t, i, n);
                                          if (0 === r) return t;
                                          t -= (s(t, i, n) - e) / r;
                                      }
                                      return t;
                                  })(i, l, e, o)
                                : 0 === d
                                ? l
                                : (function (e, t, i, n, o) {
                                      var r,
                                          a,
                                          l = 0;
                                      do {
                                          (r = s((a = t + (i - t) / 2), n, o) - e) > 0
                                              ? (i = a)
                                              : (t = a);
                                      } while (Math.abs(r) > 1e-7 && ++l < 10);
                                      return a;
                                  })(i, n, n + t, e, o);
                        }
                        return function (e) {
                            return 0 === e ? 0 : 1 === e ? 1 : s(h(e), n, r);
                        };
                    };
                },
                5368: (e) => {
                    e.exports = function (e) {
                        var t = [];
                        return (
                            (t.toString = function () {
                                return this.map(function (t) {
                                    var i = '',
                                        n = void 0 !== t[5];
                                    return (
                                        t[4] && (i += '@supports ('.concat(t[4], ') {')),
                                        t[2] && (i += '@media '.concat(t[2], ' {')),
                                        n &&
                                            (i += '@layer'.concat(
                                                t[5].length > 0 ? ' '.concat(t[5]) : '',
                                                ' {',
                                            )),
                                        (i += e(t)),
                                        n && (i += '}'),
                                        t[2] && (i += '}'),
                                        t[4] && (i += '}'),
                                        i
                                    );
                                }).join('');
                            }),
                            (t.i = function (e, i, n, o, r) {
                                'string' == typeof e && (e = [[null, e, void 0]]);
                                var s = {};
                                if (n)
                                    for (var a = 0; a < this.length; a++) {
                                        var l = this[a][0];
                                        null != l && (s[l] = !0);
                                    }
                                for (var c = 0; c < e.length; c++) {
                                    var d = [].concat(e[c]);
                                    (n && s[d[0]]) ||
                                        (void 0 !== r &&
                                            (void 0 === d[5] ||
                                                (d[1] = '@layer'
                                                    .concat(
                                                        d[5].length > 0 ? ' '.concat(d[5]) : '',
                                                        ' {',
                                                    )
                                                    .concat(d[1], '}')),
                                            (d[5] = r)),
                                        i &&
                                            (d[2]
                                                ? ((d[1] = '@media '
                                                      .concat(d[2], ' {')
                                                      .concat(d[1], '}')),
                                                  (d[2] = i))
                                                : (d[2] = i)),
                                        o &&
                                            (d[4]
                                                ? ((d[1] = '@supports ('
                                                      .concat(d[4], ') {')
                                                      .concat(d[1], '}')),
                                                  (d[4] = o))
                                                : (d[4] = ''.concat(o))),
                                        t.push(d));
                                }
                            }),
                            t
                        );
                    };
                },
                8276: (e) => {
                    e.exports = function (e) {
                        return e[1];
                    };
                },
                7084: (e) => {
                    function t(e, t, n) {
                        n = n || 2;
                        var r,
                            s,
                            a,
                            l,
                            h,
                            u,
                            f,
                            p = t && t.length,
                            _ = p ? t[0] * n : e.length,
                            v = i(e, 0, _, n, !0),
                            g = [];
                        if (!v || v.next === v.prev) return g;
                        if (
                            (p &&
                                (v = (function (e, t, n, o) {
                                    var r,
                                        s,
                                        a,
                                        l = [];
                                    for (r = 0, s = t.length; r < s; r++)
                                        (a = i(
                                            e,
                                            t[r] * o,
                                            r < s - 1 ? t[r + 1] * o : e.length,
                                            o,
                                            !1,
                                        )) === a.next && (a.steiner = !0),
                                            l.push(m(a));
                                    for (l.sort(c), r = 0; r < l.length; r++) n = d(l[r], n);
                                    return n;
                                })(e, t, v, n)),
                            e.length > 80 * n)
                        ) {
                            (r = a = e[0]), (s = l = e[1]);
                            for (var y = n; y < _; y += n)
                                (h = e[y]) < r && (r = h),
                                    (u = e[y + 1]) < s && (s = u),
                                    h > a && (a = h),
                                    u > l && (l = u);
                            f = 0 !== (f = Math.max(a - r, l - s)) ? 32767 / f : 0;
                        }
                        return o(v, g, n, r, s, f, 0), g;
                    }
                    function i(e, t, i, n, o) {
                        var r, s;
                        if (o === T(e, t, i, n) > 0)
                            for (r = t; r < i; r += n) s = S(r, e[r], e[r + 1], s);
                        else for (r = i - n; r >= t; r -= n) s = S(r, e[r], e[r + 1], s);
                        return s && v(s, s.next) && (I(s), (s = s.next)), s;
                    }
                    function n(e, t) {
                        if (!e) return e;
                        t || (t = e);
                        var i,
                            n = e;
                        do {
                            if (
                                ((i = !1),
                                n.steiner || (!v(n, n.next) && 0 !== _(n.prev, n, n.next)))
                            )
                                n = n.next;
                            else {
                                if ((I(n), (n = t = n.prev) === n.next)) break;
                                i = !0;
                            }
                        } while (i || n !== t);
                        return t;
                    }
                    function o(e, t, i, c, d, h, m) {
                        if (e) {
                            !m &&
                                h &&
                                (function (e, t, i, n) {
                                    var o = e;
                                    do {
                                        0 === o.z && (o.z = u(o.x, o.y, t, i, n)),
                                            (o.prevZ = o.prev),
                                            (o.nextZ = o.next),
                                            (o = o.next);
                                    } while (o !== e);
                                    (o.prevZ.nextZ = null),
                                        (o.prevZ = null),
                                        (function (e) {
                                            var t,
                                                i,
                                                n,
                                                o,
                                                r,
                                                s,
                                                a,
                                                l,
                                                c = 1;
                                            do {
                                                for (i = e, e = null, r = null, s = 0; i; ) {
                                                    for (
                                                        s++, n = i, a = 0, t = 0;
                                                        t < c && (a++, (n = n.nextZ));
                                                        t++
                                                    );
                                                    for (l = c; a > 0 || (l > 0 && n); )
                                                        0 !== a && (0 === l || !n || i.z <= n.z)
                                                            ? ((o = i), (i = i.nextZ), a--)
                                                            : ((o = n), (n = n.nextZ), l--),
                                                            r ? (r.nextZ = o) : (e = o),
                                                            (o.prevZ = r),
                                                            (r = o);
                                                    i = n;
                                                }
                                                (r.nextZ = null), (c *= 2);
                                            } while (s > 1);
                                        })(o);
                                })(e, c, d, h);
                            for (var f, p, _ = e; e.prev !== e.next; )
                                if (((f = e.prev), (p = e.next), h ? s(e, c, d, h) : r(e)))
                                    t.push((f.i / i) | 0),
                                        t.push((e.i / i) | 0),
                                        t.push((p.i / i) | 0),
                                        I(e),
                                        (e = p.next),
                                        (_ = p.next);
                                else if ((e = p) === _) {
                                    m
                                        ? 1 === m
                                            ? o((e = a(n(e), t, i)), t, i, c, d, h, 2)
                                            : 2 === m && l(e, t, i, c, d, h)
                                        : o(n(e), t, i, c, d, h, 1);
                                    break;
                                }
                        }
                    }
                    function r(e) {
                        var t = e.prev,
                            i = e,
                            n = e.next;
                        if (_(t, i, n) >= 0) return !1;
                        for (
                            var o = t.x,
                                r = i.x,
                                s = n.x,
                                a = t.y,
                                l = i.y,
                                c = n.y,
                                d = o < r ? (o < s ? o : s) : r < s ? r : s,
                                h = a < l ? (a < c ? a : c) : l < c ? l : c,
                                u = o > r ? (o > s ? o : s) : r > s ? r : s,
                                m = a > l ? (a > c ? a : c) : l > c ? l : c,
                                p = n.next;
                            p !== t;

                        ) {
                            if (
                                p.x >= d &&
                                p.x <= u &&
                                p.y >= h &&
                                p.y <= m &&
                                f(o, a, r, l, s, c, p.x, p.y) &&
                                _(p.prev, p, p.next) >= 0
                            )
                                return !1;
                            p = p.next;
                        }
                        return !0;
                    }
                    function s(e, t, i, n) {
                        var o = e.prev,
                            r = e,
                            s = e.next;
                        if (_(o, r, s) >= 0) return !1;
                        for (
                            var a = o.x,
                                l = r.x,
                                c = s.x,
                                d = o.y,
                                h = r.y,
                                m = s.y,
                                p = a < l ? (a < c ? a : c) : l < c ? l : c,
                                v = d < h ? (d < m ? d : m) : h < m ? h : m,
                                g = a > l ? (a > c ? a : c) : l > c ? l : c,
                                y = d > h ? (d > m ? d : m) : h > m ? h : m,
                                b = u(p, v, t, i, n),
                                w = u(g, y, t, i, n),
                                x = e.prevZ,
                                S = e.nextZ;
                            x && x.z >= b && S && S.z <= w;

                        ) {
                            if (
                                x.x >= p &&
                                x.x <= g &&
                                x.y >= v &&
                                x.y <= y &&
                                x !== o &&
                                x !== s &&
                                f(a, d, l, h, c, m, x.x, x.y) &&
                                _(x.prev, x, x.next) >= 0
                            )
                                return !1;
                            if (
                                ((x = x.prevZ),
                                S.x >= p &&
                                    S.x <= g &&
                                    S.y >= v &&
                                    S.y <= y &&
                                    S !== o &&
                                    S !== s &&
                                    f(a, d, l, h, c, m, S.x, S.y) &&
                                    _(S.prev, S, S.next) >= 0)
                            )
                                return !1;
                            S = S.nextZ;
                        }
                        for (; x && x.z >= b; ) {
                            if (
                                x.x >= p &&
                                x.x <= g &&
                                x.y >= v &&
                                x.y <= y &&
                                x !== o &&
                                x !== s &&
                                f(a, d, l, h, c, m, x.x, x.y) &&
                                _(x.prev, x, x.next) >= 0
                            )
                                return !1;
                            x = x.prevZ;
                        }
                        for (; S && S.z <= w; ) {
                            if (
                                S.x >= p &&
                                S.x <= g &&
                                S.y >= v &&
                                S.y <= y &&
                                S !== o &&
                                S !== s &&
                                f(a, d, l, h, c, m, S.x, S.y) &&
                                _(S.prev, S, S.next) >= 0
                            )
                                return !1;
                            S = S.nextZ;
                        }
                        return !0;
                    }
                    function a(e, t, i) {
                        var o = e;
                        do {
                            var r = o.prev,
                                s = o.next.next;
                            !v(r, s) &&
                                g(r, o, o.next, s) &&
                                w(r, s) &&
                                w(s, r) &&
                                (t.push((r.i / i) | 0),
                                t.push((o.i / i) | 0),
                                t.push((s.i / i) | 0),
                                I(o),
                                I(o.next),
                                (o = e = s)),
                                (o = o.next);
                        } while (o !== e);
                        return n(o);
                    }
                    function l(e, t, i, r, s, a) {
                        var l = e;
                        do {
                            for (var c = l.next.next; c !== l.prev; ) {
                                if (l.i !== c.i && p(l, c)) {
                                    var d = x(l, c);
                                    return (
                                        (l = n(l, l.next)),
                                        (d = n(d, d.next)),
                                        o(l, t, i, r, s, a, 0),
                                        void o(d, t, i, r, s, a, 0)
                                    );
                                }
                                c = c.next;
                            }
                            l = l.next;
                        } while (l !== e);
                    }
                    function c(e, t) {
                        return e.x - t.x;
                    }
                    function d(e, t) {
                        var i = (function (e, t) {
                            var i,
                                n = t,
                                o = e.x,
                                r = e.y,
                                s = -1 / 0;
                            do {
                                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                    var a = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                                    if (
                                        a <= o &&
                                        a > s &&
                                        ((s = a), (i = n.x < n.next.x ? n : n.next), a === o)
                                    )
                                        return i;
                                }
                                n = n.next;
                            } while (n !== t);
                            if (!i) return null;
                            var l,
                                c = i,
                                d = i.x,
                                u = i.y,
                                m = 1 / 0;
                            n = i;
                            do {
                                o >= n.x &&
                                    n.x >= d &&
                                    o !== n.x &&
                                    f(r < u ? o : s, r, d, u, r < u ? s : o, r, n.x, n.y) &&
                                    ((l = Math.abs(r - n.y) / (o - n.x)),
                                    w(n, e) &&
                                        (l < m ||
                                            (l === m && (n.x > i.x || (n.x === i.x && h(i, n))))) &&
                                        ((i = n), (m = l))),
                                    (n = n.next);
                            } while (n !== c);
                            return i;
                        })(e, t);
                        if (!i) return t;
                        var o = x(i, e);
                        return n(o, o.next), n(i, i.next);
                    }
                    function h(e, t) {
                        return _(e.prev, e, t.prev) < 0 && _(t.next, e, e.next) < 0;
                    }
                    function u(e, t, i, n, o) {
                        return (
                            (e =
                                1431655765 &
                                ((e =
                                    858993459 &
                                    ((e =
                                        252645135 &
                                        ((e = 16711935 & ((e = ((e - i) * o) | 0) | (e << 8))) |
                                            (e << 4))) |
                                        (e << 2))) |
                                    (e << 1))) |
                            ((t =
                                1431655765 &
                                ((t =
                                    858993459 &
                                    ((t =
                                        252645135 &
                                        ((t = 16711935 & ((t = ((t - n) * o) | 0) | (t << 8))) |
                                            (t << 4))) |
                                        (t << 2))) |
                                    (t << 1))) <<
                                1)
                        );
                    }
                    function m(e) {
                        var t = e,
                            i = e;
                        do {
                            (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
                        } while (t !== e);
                        return i;
                    }
                    function f(e, t, i, n, o, r, s, a) {
                        return (
                            (o - s) * (t - a) >= (e - s) * (r - a) &&
                            (e - s) * (n - a) >= (i - s) * (t - a) &&
                            (i - s) * (r - a) >= (o - s) * (n - a)
                        );
                    }
                    function p(e, t) {
                        return (
                            e.next.i !== t.i &&
                            e.prev.i !== t.i &&
                            !(function (e, t) {
                                var i = e;
                                do {
                                    if (
                                        i.i !== e.i &&
                                        i.next.i !== e.i &&
                                        i.i !== t.i &&
                                        i.next.i !== t.i &&
                                        g(i, i.next, e, t)
                                    )
                                        return !0;
                                    i = i.next;
                                } while (i !== e);
                                return !1;
                            })(e, t) &&
                            ((w(e, t) &&
                                w(t, e) &&
                                (function (e, t) {
                                    var i = e,
                                        n = !1,
                                        o = (e.x + t.x) / 2,
                                        r = (e.y + t.y) / 2;
                                    do {
                                        i.y > r != i.next.y > r &&
                                            i.next.y !== i.y &&
                                            o <
                                                ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) +
                                                    i.x &&
                                            (n = !n),
                                            (i = i.next);
                                    } while (i !== e);
                                    return n;
                                })(e, t) &&
                                (_(e.prev, e, t.prev) || _(e, t.prev, t))) ||
                                (v(e, t) && _(e.prev, e, e.next) > 0 && _(t.prev, t, t.next) > 0))
                        );
                    }
                    function _(e, t, i) {
                        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
                    }
                    function v(e, t) {
                        return e.x === t.x && e.y === t.y;
                    }
                    function g(e, t, i, n) {
                        var o = b(_(e, t, i)),
                            r = b(_(e, t, n)),
                            s = b(_(i, n, e)),
                            a = b(_(i, n, t));
                        return (
                            (o !== r && s !== a) ||
                            !(0 !== o || !y(e, i, t)) ||
                            !(0 !== r || !y(e, n, t)) ||
                            !(0 !== s || !y(i, e, n)) ||
                            !(0 !== a || !y(i, t, n))
                        );
                    }
                    function y(e, t, i) {
                        return (
                            t.x <= Math.max(e.x, i.x) &&
                            t.x >= Math.min(e.x, i.x) &&
                            t.y <= Math.max(e.y, i.y) &&
                            t.y >= Math.min(e.y, i.y)
                        );
                    }
                    function b(e) {
                        return e > 0 ? 1 : e < 0 ? -1 : 0;
                    }
                    function w(e, t) {
                        return _(e.prev, e, e.next) < 0
                            ? _(e, t, e.next) >= 0 && _(e, e.prev, t) >= 0
                            : _(e, t, e.prev) < 0 || _(e, e.next, t) < 0;
                    }
                    function x(e, t) {
                        var i = new M(e.i, e.x, e.y),
                            n = new M(t.i, t.x, t.y),
                            o = e.next,
                            r = t.prev;
                        return (
                            (e.next = t),
                            (t.prev = e),
                            (i.next = o),
                            (o.prev = i),
                            (n.next = i),
                            (i.prev = n),
                            (r.next = n),
                            (n.prev = r),
                            n
                        );
                    }
                    function S(e, t, i, n) {
                        var o = new M(e, t, i);
                        return (
                            n
                                ? ((o.next = n.next), (o.prev = n), (n.next.prev = o), (n.next = o))
                                : ((o.prev = o), (o.next = o)),
                            o
                        );
                    }
                    function I(e) {
                        (e.next.prev = e.prev),
                            (e.prev.next = e.next),
                            e.prevZ && (e.prevZ.nextZ = e.nextZ),
                            e.nextZ && (e.nextZ.prevZ = e.prevZ);
                    }
                    function M(e, t, i) {
                        (this.i = e),
                            (this.x = t),
                            (this.y = i),
                            (this.prev = null),
                            (this.next = null),
                            (this.z = 0),
                            (this.prevZ = null),
                            (this.nextZ = null),
                            (this.steiner = !1);
                    }
                    function T(e, t, i, n) {
                        for (var o = 0, r = t, s = i - n; r < i; r += n)
                            (o += (e[s] - e[r]) * (e[r + 1] + e[s + 1])), (s = r);
                        return o;
                    }
                    (e.exports = t),
                        (e.exports.default = t),
                        (t.deviation = function (e, t, i, n) {
                            var o = t && t.length,
                                r = o ? t[0] * i : e.length,
                                s = Math.abs(T(e, 0, r, i));
                            if (o)
                                for (var a = 0, l = t.length; a < l; a++) {
                                    var c = t[a] * i,
                                        d = a < l - 1 ? t[a + 1] * i : e.length;
                                    s -= Math.abs(T(e, c, d, i));
                                }
                            var h = 0;
                            for (a = 0; a < n.length; a += 3) {
                                var u = n[a] * i,
                                    m = n[a + 1] * i,
                                    f = n[a + 2] * i;
                                h += Math.abs(
                                    (e[u] - e[f]) * (e[m + 1] - e[u + 1]) -
                                        (e[u] - e[m]) * (e[f + 1] - e[u + 1]),
                                );
                            }
                            return 0 === s && 0 === h ? 0 : Math.abs((h - s) / s);
                        }),
                        (t.flatten = function (e) {
                            for (
                                var t = e[0][0].length,
                                    i = { vertices: [], holes: [], dimensions: t },
                                    n = 0,
                                    o = 0;
                                o < e.length;
                                o++
                            ) {
                                for (var r = 0; r < e[o].length; r++)
                                    for (var s = 0; s < t; s++) i.vertices.push(e[o][r][s]);
                                o > 0 && ((n += e[o - 1].length), i.holes.push(n));
                            }
                            return i;
                        });
                },
                6001: (e, t) => {
                    (t.read = function (e, t, i, n, o) {
                        var r,
                            s,
                            a = 8 * o - n - 1,
                            l = (1 << a) - 1,
                            c = l >> 1,
                            d = -7,
                            h = i ? o - 1 : 0,
                            u = i ? -1 : 1,
                            m = e[t + h];
                        for (
                            h += u, r = m & ((1 << -d) - 1), m >>= -d, d += a;
                            d > 0;
                            r = 256 * r + e[t + h], h += u, d -= 8
                        );
                        for (
                            s = r & ((1 << -d) - 1), r >>= -d, d += n;
                            d > 0;
                            s = 256 * s + e[t + h], h += u, d -= 8
                        );
                        if (0 === r) r = 1 - c;
                        else {
                            if (r === l) return s ? NaN : (1 / 0) * (m ? -1 : 1);
                            (s += Math.pow(2, n)), (r -= c);
                        }
                        return (m ? -1 : 1) * s * Math.pow(2, r - n);
                    }),
                        (t.write = function (e, t, i, n, o, r) {
                            var s,
                                a,
                                l,
                                c = 8 * r - o - 1,
                                d = (1 << c) - 1,
                                h = d >> 1,
                                u = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                                m = n ? 0 : r - 1,
                                f = n ? 1 : -1,
                                p = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
                            for (
                                t = Math.abs(t),
                                    isNaN(t) || t === 1 / 0
                                        ? ((a = isNaN(t) ? 1 : 0), (s = d))
                                        : ((s = Math.floor(Math.log(t) / Math.LN2)),
                                          t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                                          (t += s + h >= 1 ? u / l : u * Math.pow(2, 1 - h)) * l >=
                                              2 && (s++, (l /= 2)),
                                          s + h >= d
                                              ? ((a = 0), (s = d))
                                              : s + h >= 1
                                              ? ((a = (t * l - 1) * Math.pow(2, o)), (s += h))
                                              : ((a = t * Math.pow(2, h - 1) * Math.pow(2, o)),
                                                (s = 0)));
                                o >= 8;
                                e[i + m] = 255 & a, m += f, a /= 256, o -= 8
                            );
                            for (
                                s = (s << o) | a, c += o;
                                c > 0;
                                e[i + m] = 255 & s, m += f, s /= 256, c -= 8
                            );
                            e[i + m - f] |= 128 * p;
                        });
                },
                6208: (e, t, i) => {
                    e.exports = o;
                    var n = i(6001);
                    function o(e) {
                        (this.buf =
                            ArrayBuffer.isView && ArrayBuffer.isView(e)
                                ? e
                                : new Uint8Array(e || 0)),
                            (this.pos = 0),
                            (this.type = 0),
                            (this.length = this.buf.length);
                    }
                    (o.Varint = 0), (o.Fixed64 = 1), (o.Bytes = 2), (o.Fixed32 = 5);
                    var r = 4294967296,
                        s = 1 / r,
                        a = 'undefined' == typeof TextDecoder ? null : new TextDecoder('utf8');
                    function l(e) {
                        return e.type === o.Bytes ? e.readVarint() + e.pos : e.pos + 1;
                    }
                    function c(e, t, i) {
                        return i ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0);
                    }
                    function d(e, t, i) {
                        var n =
                            t <= 16383
                                ? 1
                                : t <= 2097151
                                ? 2
                                : t <= 268435455
                                ? 3
                                : Math.floor(Math.log(t) / (7 * Math.LN2));
                        i.realloc(n);
                        for (var o = i.pos - 1; o >= e; o--) i.buf[o + n] = i.buf[o];
                    }
                    function h(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeVarint(e[i]);
                    }
                    function u(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeSVarint(e[i]);
                    }
                    function m(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeFloat(e[i]);
                    }
                    function f(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeDouble(e[i]);
                    }
                    function p(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeBoolean(e[i]);
                    }
                    function _(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeFixed32(e[i]);
                    }
                    function v(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeSFixed32(e[i]);
                    }
                    function g(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeFixed64(e[i]);
                    }
                    function y(e, t) {
                        for (var i = 0; i < e.length; i++) t.writeSFixed64(e[i]);
                    }
                    function b(e, t) {
                        return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + 16777216 * e[t + 3];
                    }
                    function w(e, t, i) {
                        (e[i] = t),
                            (e[i + 1] = t >>> 8),
                            (e[i + 2] = t >>> 16),
                            (e[i + 3] = t >>> 24);
                    }
                    function x(e, t) {
                        return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + (e[t + 3] << 24);
                    }
                    o.prototype = {
                        destroy: function () {
                            this.buf = null;
                        },
                        readFields: function (e, t, i) {
                            for (i = i || this.length; this.pos < i; ) {
                                var n = this.readVarint(),
                                    o = n >> 3,
                                    r = this.pos;
                                (this.type = 7 & n), e(o, t, this), this.pos === r && this.skip(n);
                            }
                            return t;
                        },
                        readMessage: function (e, t) {
                            return this.readFields(e, t, this.readVarint() + this.pos);
                        },
                        readFixed32: function () {
                            var e = b(this.buf, this.pos);
                            return (this.pos += 4), e;
                        },
                        readSFixed32: function () {
                            var e = x(this.buf, this.pos);
                            return (this.pos += 4), e;
                        },
                        readFixed64: function () {
                            var e = b(this.buf, this.pos) + b(this.buf, this.pos + 4) * r;
                            return (this.pos += 8), e;
                        },
                        readSFixed64: function () {
                            var e = b(this.buf, this.pos) + x(this.buf, this.pos + 4) * r;
                            return (this.pos += 8), e;
                        },
                        readFloat: function () {
                            var e = n.read(this.buf, this.pos, !0, 23, 4);
                            return (this.pos += 4), e;
                        },
                        readDouble: function () {
                            var e = n.read(this.buf, this.pos, !0, 52, 8);
                            return (this.pos += 8), e;
                        },
                        readVarint: function (e) {
                            var t,
                                i,
                                n = this.buf;
                            return (
                                (t = 127 & (i = n[this.pos++])),
                                i < 128
                                    ? t
                                    : ((t |= (127 & (i = n[this.pos++])) << 7),
                                      i < 128
                                          ? t
                                          : ((t |= (127 & (i = n[this.pos++])) << 14),
                                            i < 128
                                                ? t
                                                : ((t |= (127 & (i = n[this.pos++])) << 21),
                                                  i < 128
                                                      ? t
                                                      : (function (e, t, i) {
                                                            var n,
                                                                o,
                                                                r = i.buf;
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n = (112 & o) >> 4),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n |= (127 & o) << 3),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n |= (127 & o) << 10),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n |= (127 & o) << 17),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n |= (127 & o) << 24),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            if (
                                                                ((o = r[i.pos++]),
                                                                (n |= (1 & o) << 31),
                                                                o < 128)
                                                            )
                                                                return c(e, n, t);
                                                            throw new Error(
                                                                'Expected varint not more than 10 bytes',
                                                            );
                                                        })(
                                                            (t |= (15 & (i = n[this.pos])) << 28),
                                                            e,
                                                            this,
                                                        ))))
                            );
                        },
                        readVarint64: function () {
                            return this.readVarint(!0);
                        },
                        readSVarint: function () {
                            var e = this.readVarint();
                            return e % 2 == 1 ? (e + 1) / -2 : e / 2;
                        },
                        readBoolean: function () {
                            return Boolean(this.readVarint());
                        },
                        readString: function () {
                            var e = this.readVarint() + this.pos,
                                t = this.pos;
                            return (
                                (this.pos = e),
                                e - t >= 12 && a
                                    ? (function (e, t, i) {
                                          return a.decode(e.subarray(t, i));
                                      })(this.buf, t, e)
                                    : (function (e, t, i) {
                                          var n = '',
                                              o = t;
                                          for (; o < i; ) {
                                              var r,
                                                  s,
                                                  a,
                                                  l = e[o],
                                                  c = null,
                                                  d = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                                              if (o + d > i) break;
                                              1 === d
                                                  ? l < 128 && (c = l)
                                                  : 2 === d
                                                  ? 128 == (192 & (r = e[o + 1])) &&
                                                    (c = ((31 & l) << 6) | (63 & r)) <= 127 &&
                                                    (c = null)
                                                  : 3 === d
                                                  ? ((r = e[o + 1]),
                                                    (s = e[o + 2]),
                                                    128 == (192 & r) &&
                                                        128 == (192 & s) &&
                                                        ((c =
                                                            ((15 & l) << 12) |
                                                            ((63 & r) << 6) |
                                                            (63 & s)) <= 2047 ||
                                                            (c >= 55296 && c <= 57343)) &&
                                                        (c = null))
                                                  : 4 === d &&
                                                    ((r = e[o + 1]),
                                                    (s = e[o + 2]),
                                                    (a = e[o + 3]),
                                                    128 == (192 & r) &&
                                                        128 == (192 & s) &&
                                                        128 == (192 & a) &&
                                                        ((c =
                                                            ((15 & l) << 18) |
                                                            ((63 & r) << 12) |
                                                            ((63 & s) << 6) |
                                                            (63 & a)) <= 65535 ||
                                                            c >= 1114112) &&
                                                        (c = null)),
                                                  null === c
                                                      ? ((c = 65533), (d = 1))
                                                      : c > 65535 &&
                                                        ((c -= 65536),
                                                        (n += String.fromCharCode(
                                                            ((c >>> 10) & 1023) | 55296,
                                                        )),
                                                        (c = 56320 | (1023 & c))),
                                                  (n += String.fromCharCode(c)),
                                                  (o += d);
                                          }
                                          return n;
                                      })(this.buf, t, e)
                            );
                        },
                        readBytes: function () {
                            var e = this.readVarint() + this.pos,
                                t = this.buf.subarray(this.pos, e);
                            return (this.pos = e), t;
                        },
                        readPackedVarint: function (e, t) {
                            if (this.type !== o.Bytes) return e.push(this.readVarint(t));
                            var i = l(this);
                            for (e = e || []; this.pos < i; ) e.push(this.readVarint(t));
                            return e;
                        },
                        readPackedSVarint: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readSVarint());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readSVarint());
                            return e;
                        },
                        readPackedBoolean: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readBoolean());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readBoolean());
                            return e;
                        },
                        readPackedFloat: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readFloat());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readFloat());
                            return e;
                        },
                        readPackedDouble: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readDouble());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readDouble());
                            return e;
                        },
                        readPackedFixed32: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readFixed32());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readFixed32());
                            return e;
                        },
                        readPackedSFixed32: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readSFixed32());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readSFixed32());
                            return e;
                        },
                        readPackedFixed64: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readFixed64());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readFixed64());
                            return e;
                        },
                        readPackedSFixed64: function (e) {
                            if (this.type !== o.Bytes) return e.push(this.readSFixed64());
                            var t = l(this);
                            for (e = e || []; this.pos < t; ) e.push(this.readSFixed64());
                            return e;
                        },
                        skip: function (e) {
                            var t = 7 & e;
                            if (t === o.Varint) for (; this.buf[this.pos++] > 127; );
                            else if (t === o.Bytes) this.pos = this.readVarint() + this.pos;
                            else if (t === o.Fixed32) this.pos += 4;
                            else {
                                if (t !== o.Fixed64) throw new Error('Unimplemented type: ' + t);
                                this.pos += 8;
                            }
                        },
                        writeTag: function (e, t) {
                            this.writeVarint((e << 3) | t);
                        },
                        realloc: function (e) {
                            for (var t = this.length || 16; t < this.pos + e; ) t *= 2;
                            if (t !== this.length) {
                                var i = new Uint8Array(t);
                                i.set(this.buf), (this.buf = i), (this.length = t);
                            }
                        },
                        finish: function () {
                            return (
                                (this.length = this.pos),
                                (this.pos = 0),
                                this.buf.subarray(0, this.length)
                            );
                        },
                        writeFixed32: function (e) {
                            this.realloc(4), w(this.buf, e, this.pos), (this.pos += 4);
                        },
                        writeSFixed32: function (e) {
                            this.realloc(4), w(this.buf, e, this.pos), (this.pos += 4);
                        },
                        writeFixed64: function (e) {
                            this.realloc(8),
                                w(this.buf, -1 & e, this.pos),
                                w(this.buf, Math.floor(e * s), this.pos + 4),
                                (this.pos += 8);
                        },
                        writeSFixed64: function (e) {
                            this.realloc(8),
                                w(this.buf, -1 & e, this.pos),
                                w(this.buf, Math.floor(e * s), this.pos + 4),
                                (this.pos += 8);
                        },
                        writeVarint: function (e) {
                            (e = +e || 0) > 268435455 || e < 0
                                ? (function (e, t) {
                                      var i, n;
                                      e >= 0
                                          ? ((i = e % 4294967296 | 0), (n = (e / 4294967296) | 0))
                                          : ((n = ~(-e / 4294967296)),
                                            4294967295 ^ (i = ~(-e % 4294967296))
                                                ? (i = (i + 1) | 0)
                                                : ((i = 0), (n = (n + 1) | 0)));
                                      if (e >= 0x10000000000000000 || e < -0x10000000000000000)
                                          throw new Error("Given varint doesn't fit into 10 bytes");
                                      t.realloc(10),
                                          (function (e, t, i) {
                                              (i.buf[i.pos++] = (127 & e) | 128),
                                                  (e >>>= 7),
                                                  (i.buf[i.pos++] = (127 & e) | 128),
                                                  (e >>>= 7),
                                                  (i.buf[i.pos++] = (127 & e) | 128),
                                                  (e >>>= 7),
                                                  (i.buf[i.pos++] = (127 & e) | 128),
                                                  (e >>>= 7),
                                                  (i.buf[i.pos] = 127 & e);
                                          })(i, 0, t),
                                          (function (e, t) {
                                              var i = (7 & e) << 4;
                                              if (
                                                  ((t.buf[t.pos++] |= i | ((e >>>= 3) ? 128 : 0)),
                                                  !e)
                                              )
                                                  return;
                                              if (
                                                  ((t.buf[t.pos++] =
                                                      (127 & e) | ((e >>>= 7) ? 128 : 0)),
                                                  !e)
                                              )
                                                  return;
                                              if (
                                                  ((t.buf[t.pos++] =
                                                      (127 & e) | ((e >>>= 7) ? 128 : 0)),
                                                  !e)
                                              )
                                                  return;
                                              if (
                                                  ((t.buf[t.pos++] =
                                                      (127 & e) | ((e >>>= 7) ? 128 : 0)),
                                                  !e)
                                              )
                                                  return;
                                              if (
                                                  ((t.buf[t.pos++] =
                                                      (127 & e) | ((e >>>= 7) ? 128 : 0)),
                                                  !e)
                                              )
                                                  return;
                                              t.buf[t.pos++] = 127 & e;
                                          })(n, t);
                                  })(e, this)
                                : (this.realloc(4),
                                  (this.buf[this.pos++] = (127 & e) | (e > 127 ? 128 : 0)),
                                  e <= 127 ||
                                      ((this.buf[this.pos++] =
                                          (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)),
                                      e <= 127 ||
                                          ((this.buf[this.pos++] =
                                              (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)),
                                          e <= 127 || (this.buf[this.pos++] = (e >>> 7) & 127))));
                        },
                        writeSVarint: function (e) {
                            this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
                        },
                        writeBoolean: function (e) {
                            this.writeVarint(Boolean(e));
                        },
                        writeString: function (e) {
                            (e = String(e)), this.realloc(4 * e.length), this.pos++;
                            var t = this.pos;
                            this.pos = (function (e, t, i) {
                                for (var n, o, r = 0; r < t.length; r++) {
                                    if ((n = t.charCodeAt(r)) > 55295 && n < 57344) {
                                        if (!o) {
                                            n > 56319 || r + 1 === t.length
                                                ? ((e[i++] = 239), (e[i++] = 191), (e[i++] = 189))
                                                : (o = n);
                                            continue;
                                        }
                                        if (n < 56320) {
                                            (e[i++] = 239), (e[i++] = 191), (e[i++] = 189), (o = n);
                                            continue;
                                        }
                                        (n = ((o - 55296) << 10) | (n - 56320) | 65536), (o = null);
                                    } else
                                        o &&
                                            ((e[i++] = 239),
                                            (e[i++] = 191),
                                            (e[i++] = 189),
                                            (o = null));
                                    n < 128
                                        ? (e[i++] = n)
                                        : (n < 2048
                                              ? (e[i++] = (n >> 6) | 192)
                                              : (n < 65536
                                                    ? (e[i++] = (n >> 12) | 224)
                                                    : ((e[i++] = (n >> 18) | 240),
                                                      (e[i++] = ((n >> 12) & 63) | 128)),
                                                (e[i++] = ((n >> 6) & 63) | 128)),
                                          (e[i++] = (63 & n) | 128));
                                }
                                return i;
                            })(this.buf, e, this.pos);
                            var i = this.pos - t;
                            i >= 128 && d(t, i, this),
                                (this.pos = t - 1),
                                this.writeVarint(i),
                                (this.pos += i);
                        },
                        writeFloat: function (e) {
                            this.realloc(4),
                                n.write(this.buf, e, this.pos, !0, 23, 4),
                                (this.pos += 4);
                        },
                        writeDouble: function (e) {
                            this.realloc(8),
                                n.write(this.buf, e, this.pos, !0, 52, 8),
                                (this.pos += 8);
                        },
                        writeBytes: function (e) {
                            var t = e.length;
                            this.writeVarint(t), this.realloc(t);
                            for (var i = 0; i < t; i++) this.buf[this.pos++] = e[i];
                        },
                        writeRawMessage: function (e, t) {
                            this.pos++;
                            var i = this.pos;
                            e(t, this);
                            var n = this.pos - i;
                            n >= 128 && d(i, n, this),
                                (this.pos = i - 1),
                                this.writeVarint(n),
                                (this.pos += n);
                        },
                        writeMessage: function (e, t, i) {
                            this.writeTag(e, o.Bytes), this.writeRawMessage(t, i);
                        },
                        writePackedVarint: function (e, t) {
                            t.length && this.writeMessage(e, h, t);
                        },
                        writePackedSVarint: function (e, t) {
                            t.length && this.writeMessage(e, u, t);
                        },
                        writePackedBoolean: function (e, t) {
                            t.length && this.writeMessage(e, p, t);
                        },
                        writePackedFloat: function (e, t) {
                            t.length && this.writeMessage(e, m, t);
                        },
                        writePackedDouble: function (e, t) {
                            t.length && this.writeMessage(e, f, t);
                        },
                        writePackedFixed32: function (e, t) {
                            t.length && this.writeMessage(e, _, t);
                        },
                        writePackedSFixed32: function (e, t) {
                            t.length && this.writeMessage(e, v, t);
                        },
                        writePackedFixed64: function (e, t) {
                            t.length && this.writeMessage(e, g, t);
                        },
                        writePackedSFixed64: function (e, t) {
                            t.length && this.writeMessage(e, y, t);
                        },
                        writeBytesField: function (e, t) {
                            this.writeTag(e, o.Bytes), this.writeBytes(t);
                        },
                        writeFixed32Field: function (e, t) {
                            this.writeTag(e, o.Fixed32), this.writeFixed32(t);
                        },
                        writeSFixed32Field: function (e, t) {
                            this.writeTag(e, o.Fixed32), this.writeSFixed32(t);
                        },
                        writeFixed64Field: function (e, t) {
                            this.writeTag(e, o.Fixed64), this.writeFixed64(t);
                        },
                        writeSFixed64Field: function (e, t) {
                            this.writeTag(e, o.Fixed64), this.writeSFixed64(t);
                        },
                        writeVarintField: function (e, t) {
                            this.writeTag(e, o.Varint), this.writeVarint(t);
                        },
                        writeSVarintField: function (e, t) {
                            this.writeTag(e, o.Varint), this.writeSVarint(t);
                        },
                        writeStringField: function (e, t) {
                            this.writeTag(e, o.Bytes), this.writeString(t);
                        },
                        writeFloatField: function (e, t) {
                            this.writeTag(e, o.Fixed32), this.writeFloat(t);
                        },
                        writeDoubleField: function (e, t) {
                            this.writeTag(e, o.Fixed64), this.writeDouble(t);
                        },
                        writeBooleanField: function (e, t) {
                            this.writeVarintField(e, Boolean(t));
                        },
                    };
                },
                5398: function (e) {
                    e.exports = (function () {
                        function e(e, i, o, r, s) {
                            t(e, i, o || 0, r || e.length - 1, s || n);
                        }
                        function t(e, n, o, r, s) {
                            for (; r > o; ) {
                                if (r - o > 600) {
                                    var a = r - o + 1,
                                        l = n - o + 1,
                                        c = Math.log(a),
                                        d = 0.5 * Math.exp((2 * c) / 3),
                                        h =
                                            0.5 *
                                            Math.sqrt((c * d * (a - d)) / a) *
                                            (l - a / 2 < 0 ? -1 : 1);
                                    t(
                                        e,
                                        n,
                                        Math.max(o, Math.floor(n - (l * d) / a + h)),
                                        Math.min(r, Math.floor(n + ((a - l) * d) / a + h)),
                                        s,
                                    );
                                }
                                var u = e[n],
                                    m = o,
                                    f = r;
                                for (i(e, o, n), s(e[r], u) > 0 && i(e, o, r); m < f; ) {
                                    for (i(e, m, f), m++, f--; s(e[m], u) < 0; ) m++;
                                    for (; s(e[f], u) > 0; ) f--;
                                }
                                0 === s(e[o], u) ? i(e, o, f) : i(e, ++f, r),
                                    f <= n && (o = f + 1),
                                    n <= f && (r = f - 1);
                            }
                        }
                        function i(e, t, i) {
                            var n = e[t];
                            (e[t] = e[i]), (e[i] = n);
                        }
                        function n(e, t) {
                            return e < t ? -1 : e > t ? 1 : 0;
                        }
                        return e;
                    })();
                },
                7123: (e, t, i) => {
                    (e.exports = o), (e.exports.default = o);
                    var n = i(5398);
                    function o(e, t) {
                        if (!(this instanceof o)) return new o(e, t);
                        (this._maxEntries = Math.max(4, e || 9)),
                            (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
                            t && this._initFormat(t),
                            this.clear();
                    }
                    function r(e, t, i) {
                        if (!i) return t.indexOf(e);
                        for (var n = 0; n < t.length; n++) if (i(e, t[n])) return n;
                        return -1;
                    }
                    function s(e, t) {
                        a(e, 0, e.children.length, t, e);
                    }
                    function a(e, t, i, n, o) {
                        o || (o = p(null)),
                            (o.minX = 1 / 0),
                            (o.minY = 1 / 0),
                            (o.maxX = -1 / 0),
                            (o.maxY = -1 / 0);
                        for (var r, s = t; s < i; s++) (r = e.children[s]), l(o, e.leaf ? n(r) : r);
                        return o;
                    }
                    function l(e, t) {
                        return (
                            (e.minX = Math.min(e.minX, t.minX)),
                            (e.minY = Math.min(e.minY, t.minY)),
                            (e.maxX = Math.max(e.maxX, t.maxX)),
                            (e.maxY = Math.max(e.maxY, t.maxY)),
                            e
                        );
                    }
                    function c(e, t) {
                        return e.minX - t.minX;
                    }
                    function d(e, t) {
                        return e.minY - t.minY;
                    }
                    function h(e) {
                        return (e.maxX - e.minX) * (e.maxY - e.minY);
                    }
                    function u(e) {
                        return e.maxX - e.minX + (e.maxY - e.minY);
                    }
                    function m(e, t) {
                        return (
                            e.minX <= t.minX &&
                            e.minY <= t.minY &&
                            t.maxX <= e.maxX &&
                            t.maxY <= e.maxY
                        );
                    }
                    function f(e, t) {
                        return (
                            t.minX <= e.maxX &&
                            t.minY <= e.maxY &&
                            t.maxX >= e.minX &&
                            t.maxY >= e.minY
                        );
                    }
                    function p(e) {
                        return {
                            children: e,
                            height: 1,
                            leaf: !0,
                            minX: 1 / 0,
                            minY: 1 / 0,
                            maxX: -1 / 0,
                            maxY: -1 / 0,
                        };
                    }
                    function _(e, t, i, o, r) {
                        for (var s, a = [t, i]; a.length; )
                            (i = a.pop()) - (t = a.pop()) <= o ||
                                ((s = t + Math.ceil((i - t) / o / 2) * o),
                                n(e, s, t, i, r),
                                a.push(t, s, s, i));
                    }
                    o.prototype = {
                        all: function () {
                            return this._all(this.data, []);
                        },
                        search: function (e) {
                            var t = this.data,
                                i = [],
                                n = this.toBBox;
                            if (!f(e, t)) return i;
                            for (var o, r, s, a, l = []; t; ) {
                                for (o = 0, r = t.children.length; o < r; o++)
                                    (s = t.children[o]),
                                        f(e, (a = t.leaf ? n(s) : s)) &&
                                            (t.leaf
                                                ? i.push(s)
                                                : m(e, a)
                                                ? this._all(s, i)
                                                : l.push(s));
                                t = l.pop();
                            }
                            return i;
                        },
                        collides: function (e) {
                            var t = this.data,
                                i = this.toBBox;
                            if (!f(e, t)) return !1;
                            for (var n, o, r, s, a = []; t; ) {
                                for (n = 0, o = t.children.length; n < o; n++)
                                    if (((r = t.children[n]), f(e, (s = t.leaf ? i(r) : r)))) {
                                        if (t.leaf || m(e, s)) return !0;
                                        a.push(r);
                                    }
                                t = a.pop();
                            }
                            return !1;
                        },
                        load: function (e) {
                            if (!e || !e.length) return this;
                            if (e.length < this._minEntries) {
                                for (var t = 0, i = e.length; t < i; t++) this.insert(e[t]);
                                return this;
                            }
                            var n = this._build(e.slice(), 0, e.length - 1, 0);
                            if (this.data.children.length)
                                if (this.data.height === n.height) this._splitRoot(this.data, n);
                                else {
                                    if (this.data.height < n.height) {
                                        var o = this.data;
                                        (this.data = n), (n = o);
                                    }
                                    this._insert(n, this.data.height - n.height - 1, !0);
                                }
                            else this.data = n;
                            return this;
                        },
                        insert: function (e) {
                            return e && this._insert(e, this.data.height - 1), this;
                        },
                        clear: function () {
                            return (this.data = p([])), this;
                        },
                        remove: function (e, t) {
                            if (!e) return this;
                            for (
                                var i, n, o, s, a = this.data, l = this.toBBox(e), c = [], d = [];
                                a || c.length;

                            ) {
                                if (
                                    (a ||
                                        ((a = c.pop()),
                                        (n = c[c.length - 1]),
                                        (i = d.pop()),
                                        (s = !0)),
                                    a.leaf && -1 !== (o = r(e, a.children, t)))
                                )
                                    return (
                                        a.children.splice(o, 1), c.push(a), this._condense(c), this
                                    );
                                s || a.leaf || !m(a, l)
                                    ? n
                                        ? (i++, (a = n.children[i]), (s = !1))
                                        : (a = null)
                                    : (c.push(a), d.push(i), (i = 0), (n = a), (a = a.children[0]));
                            }
                            return this;
                        },
                        toBBox: function (e) {
                            return e;
                        },
                        compareMinX: c,
                        compareMinY: d,
                        toJSON: function () {
                            return this.data;
                        },
                        fromJSON: function (e) {
                            return (this.data = e), this;
                        },
                        _all: function (e, t) {
                            for (var i = []; e; )
                                e.leaf ? t.push.apply(t, e.children) : i.push.apply(i, e.children),
                                    (e = i.pop());
                            return t;
                        },
                        _build: function (e, t, i, n) {
                            var o,
                                r = i - t + 1,
                                a = this._maxEntries;
                            if (r <= a) return s((o = p(e.slice(t, i + 1))), this.toBBox), o;
                            n ||
                                ((n = Math.ceil(Math.log(r) / Math.log(a))),
                                (a = Math.ceil(r / Math.pow(a, n - 1)))),
                                ((o = p([])).leaf = !1),
                                (o.height = n);
                            var l,
                                c,
                                d,
                                h,
                                u = Math.ceil(r / a),
                                m = u * Math.ceil(Math.sqrt(a));
                            for (_(e, t, i, m, this.compareMinX), l = t; l <= i; l += m)
                                for (
                                    _(e, l, (d = Math.min(l + m - 1, i)), u, this.compareMinY),
                                        c = l;
                                    c <= d;
                                    c += u
                                )
                                    (h = Math.min(c + u - 1, d)),
                                        o.children.push(this._build(e, c, h, n - 1));
                            return s(o, this.toBBox), o;
                        },
                        _chooseSubtree: function (e, t, i, n) {
                            for (
                                var o, r, s, a, l, c, d, u, m, f;
                                n.push(t), !t.leaf && n.length - 1 !== i;

                            ) {
                                for (d = u = 1 / 0, o = 0, r = t.children.length; o < r; o++)
                                    (l = h((s = t.children[o]))),
                                        (m = e),
                                        (f = s),
                                        (c =
                                            (Math.max(f.maxX, m.maxX) - Math.min(f.minX, m.minX)) *
                                                (Math.max(f.maxY, m.maxY) -
                                                    Math.min(f.minY, m.minY)) -
                                            l) < u
                                            ? ((u = c), (d = l < d ? l : d), (a = s))
                                            : c === u && l < d && ((d = l), (a = s));
                                t = a || t.children[0];
                            }
                            return t;
                        },
                        _insert: function (e, t, i) {
                            var n = this.toBBox,
                                o = i ? e : n(e),
                                r = [],
                                s = this._chooseSubtree(o, this.data, t, r);
                            for (
                                s.children.push(e), l(s, o);
                                t >= 0 && r[t].children.length > this._maxEntries;

                            )
                                this._split(r, t), t--;
                            this._adjustParentBBoxes(o, r, t);
                        },
                        _split: function (e, t) {
                            var i = e[t],
                                n = i.children.length,
                                o = this._minEntries;
                            this._chooseSplitAxis(i, o, n);
                            var r = this._chooseSplitIndex(i, o, n),
                                a = p(i.children.splice(r, i.children.length - r));
                            (a.height = i.height),
                                (a.leaf = i.leaf),
                                s(i, this.toBBox),
                                s(a, this.toBBox),
                                t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
                        },
                        _splitRoot: function (e, t) {
                            (this.data = p([e, t])),
                                (this.data.height = e.height + 1),
                                (this.data.leaf = !1),
                                s(this.data, this.toBBox);
                        },
                        _chooseSplitIndex: function (e, t, i) {
                            var n, o, r, s, l, c, d, u, m, f, p, _, v, g;
                            for (c = d = 1 / 0, n = t; n <= i - t; n++)
                                (o = a(e, 0, n, this.toBBox)),
                                    (r = a(e, n, i, this.toBBox)),
                                    (m = o),
                                    (f = r),
                                    (p = void 0),
                                    (_ = void 0),
                                    (v = void 0),
                                    (g = void 0),
                                    (p = Math.max(m.minX, f.minX)),
                                    (_ = Math.max(m.minY, f.minY)),
                                    (v = Math.min(m.maxX, f.maxX)),
                                    (g = Math.min(m.maxY, f.maxY)),
                                    (s = Math.max(0, v - p) * Math.max(0, g - _)),
                                    (l = h(o) + h(r)),
                                    s < c
                                        ? ((c = s), (u = n), (d = l < d ? l : d))
                                        : s === c && l < d && ((d = l), (u = n));
                            return u;
                        },
                        _chooseSplitAxis: function (e, t, i) {
                            var n = e.leaf ? this.compareMinX : c,
                                o = e.leaf ? this.compareMinY : d;
                            this._allDistMargin(e, t, i, n) < this._allDistMargin(e, t, i, o) &&
                                e.children.sort(n);
                        },
                        _allDistMargin: function (e, t, i, n) {
                            e.children.sort(n);
                            var o,
                                r,
                                s = this.toBBox,
                                c = a(e, 0, t, s),
                                d = a(e, i - t, i, s),
                                h = u(c) + u(d);
                            for (o = t; o < i - t; o++)
                                (r = e.children[o]), l(c, e.leaf ? s(r) : r), (h += u(c));
                            for (o = i - t - 1; o >= t; o--)
                                (r = e.children[o]), l(d, e.leaf ? s(r) : r), (h += u(d));
                            return h;
                        },
                        _adjustParentBBoxes: function (e, t, i) {
                            for (var n = i; n >= 0; n--) l(t[n], e);
                        },
                        _condense: function (e) {
                            for (var t, i = e.length - 1; i >= 0; i--)
                                0 === e[i].children.length
                                    ? i > 0
                                        ? (t = e[i - 1].children).splice(t.indexOf(e[i]), 1)
                                        : this.clear()
                                    : s(e[i], this.toBBox);
                        },
                        _initFormat: function (e) {
                            var t = ['return a', ' - b', ';'];
                            (this.compareMinX = new Function('a', 'b', t.join(e[0]))),
                                (this.compareMinY = new Function('a', 'b', t.join(e[1]))),
                                (this.toBBox = new Function(
                                    'a',
                                    'return {minX: a' +
                                        e[0] +
                                        ', minY: a' +
                                        e[1] +
                                        ', maxX: a' +
                                        e[2] +
                                        ', maxY: a' +
                                        e[3] +
                                        '};',
                                ));
                        },
                    };
                },
                7731: (e, t, i) => {
                    i.d(t, { mG: () => n });
                    function n(e, t, i, n) {
                        return new (i || (i = Promise))(function (o, r) {
                            function s(e) {
                                try {
                                    l(n.next(e));
                                } catch (e) {
                                    r(e);
                                }
                            }
                            function a(e) {
                                try {
                                    l(n.throw(e));
                                } catch (e) {
                                    r(e);
                                }
                            }
                            function l(e) {
                                var t;
                                e.done
                                    ? o(e.value)
                                    : ((t = e.value),
                                      t instanceof i
                                          ? t
                                          : new i(function (e) {
                                                e(t);
                                            })).then(s, a);
                            }
                            l((n = n.apply(e, t || [])).next());
                        });
                    }
                    Object.create;
                    Object.create;
                },
                7773: (e, t, i) => {
                    i.r(t),
                        i.d(t, {
                            AnimationOptions: () => w.AnimationOptions,
                            Circle: () => Oh,
                            CircleMarker: () => Rh,
                            CircleMarkerOptions: () => x.CircleMarkerOptions,
                            CircleOptions: () => x.CircleOptions,
                            Control: () => Od,
                            ControlOptions: () => x.ControlOptions,
                            ControlPosition: () => x.ControlPosition,
                            DefaultEventTargetData: () => g.DefaultEventTargetData,
                            DefaultSource: () => Sh,
                            DynamicObjectEventTable: () => g.DynamicObjectEventTable,
                            DynamicObjectPointerEvent: () => g.DynamicObjectPointerEvent,
                            Easing: () => w.Easing,
                            EventTarget: () => g.EventTarget,
                            EventTargetData: () => g.EventTargetData,
                            FeatureState: () => x.FeatureState,
                            FeatureStateMap: () => x.FeatureStateMap,
                            FitBoundsOptions: () => x.FitBoundsOptions,
                            FloorControl: () => ah,
                            FloorLevelChangeEvent: () => g.FloorLevelChangeEvent,
                            FloorPlanHideEvent: () => g.FloorPlanHideEvent,
                            FloorPlanShowEvent: () => g.FloorPlanShowEvent,
                            GeoJsonEventTargetData: () => g.GeoJsonEventTargetData,
                            GeoJsonSource: () => Vh,
                            GeoJsonSourceOptions: () => x.GeoJsonSourceOptions,
                            HtmlMarker: () => Ch,
                            HtmlMarkerOptions: () => x.HtmlMarkerOptions,
                            Label: () => Ah,
                            LabelImage: () => x.LabelImage,
                            LabelOptions: () => x.LabelOptions,
                            LngLatBounds: () => y.LngLatBounds,
                            LngLatBoundsClass: () => ih,
                            Map: () => Ih,
                            MapEvent: () => g.MapEvent,
                            MapEventTable: () => g.MapEventTable,
                            MapOptions: () => x.MapOptions,
                            MapPointerEvent: () => g.MapPointerEvent,
                            MapSupportOptions: () => x.MapSupportOptions,
                            Marker: () => Lh,
                            MarkerIconOptions: () => x.MarkerIconOptions,
                            MarkerLabelOptions: () => x.MarkerLabelOptions,
                            MarkerOptions: () => x.MarkerOptions,
                            Padding: () => x.Padding,
                            PointerEvent: () => g.PointerEvent,
                            Polygon: () => Uh,
                            PolygonOptions: () => x.PolygonOptions,
                            Polyline: () => Bh,
                            PolylineOptions: () => x.PolylineOptions,
                            Raster: () => Hh,
                            RasterOptions: () => x.RasterOptions,
                            RasterSource: () => x.RasterSource,
                            RasterTileSource: () => Kh,
                            RasterTileSourceOptions: () => x.RasterTileSourceOptions,
                            RotationAnimationOptions: () => w.RotationAnimationOptions,
                            ScaleControl: () => xh,
                            SourceAttributes: () => x.SourceAttributes,
                            StyleIconConfig: () => b.StyleIconConfig,
                            StyleLoadEvent: () => g.StyleLoadEvent,
                            StyleOptions: () => b.StyleOptions,
                            TrafficControl: () => Gd,
                            TrafficScoreEvent: () => g.TrafficScoreEvent,
                            TrafficVisibilityEvent: () => g.TrafficVisibilityEvent,
                            ZenithSource: () => Jh,
                            ZoomControl: () => Nd,
                            _J: () => v,
                            isSupported: () => vn,
                            isTerrainSupported: () => Sn,
                            notSupportedReason: () => gn,
                            terrainNotSupportedReason: () => xn,
                        });
                    var n = {};
                    i.r(n),
                        i.d(n, {
                            getMetersFromPixelsXY: () => L.$X,
                            getUrl: () => T.Gr,
                            hashToString: () => P.GG,
                        });
                    var o = {};
                    i.r(o), i.d(o, { Q: () => fc });
                    var r = {};
                    i.r(r), i.d(r, { e: () => Ic });
                    var s = {};
                    i.r(s), i.d(s, { X: () => md });
                    var a = {};
                    i.r(a), i.d(a, { S: () => gd });
                    var l = {};
                    i.r(l), i.d(l, { J: () => wd });
                    var c = {};
                    i.r(c), i.d(c, { U: () => Td });
                    var d = {};
                    i.r(d), i.d(d, { n: () => Pd });
                    var h = {};
                    i.r(h), i.d(h, { P: () => kd });
                    var u = {};
                    i.r(u), i.d(u, { c: () => Ed });
                    var m = {};
                    i.r(m);
                    var f = {};
                    i.r(f);
                    var p = {};
                    i.r(p);
                    var _ = {};
                    i.r(_), i.d(_, { l: () => Cd });
                    var v = {};
                    i.r(v),
                        i.d(v, {
                            Circle: () => Qc,
                            CircleMarker: () => X,
                            CircleMarkerOptions: () => f.CircleMarkerOptions,
                            CircleOptions: () => f.CircleOptions,
                            CommPoiEvent: () => m.CommPoiEvent,
                            DashedPolyline: () => Xc,
                            DashedPolylineOptions: () => f.DashedPolylineOptions,
                            DataTileLayer: () => Cd,
                            DataTileLayerOptions: () => _.DataTileLayerOptions,
                            DefaultSource: () => uc,
                            DraggablePointerEvent: () => m.DraggablePointerEvent,
                            DynamicObject: () => A,
                            DynamicObjectPointerEvent: () => m.DynamicObjectPointerEvent,
                            Entrance: () => Xa,
                            EntranceOptions: () => f.EntranceOptions,
                            FirmsToFloorIndexMap: () => p.FirmsToFloorIndexMap,
                            FloorComplexHideEvent: () => m.FloorComplexHideEvent,
                            FloorComplexShowEvent: () => m.FloorComplexShowEvent,
                            FontName: () => Ws.FontName,
                            GeoJsonSource: () => no.gs,
                            GeoJsonSourceOptions: () => no.GeoJsonSourceOptions,
                            GeoJsonTileSource: () => no.Xm,
                            GeoJsonTileSourceOptions: () => no.GeoJsonTileSourceOptions,
                            HTMLMarkerShownEvent: () => m.HTMLMarkerShownEvent,
                            Heatmap: () => md,
                            HeatmapOptions: () => s.HeatmapOptions,
                            HeatmapPalette: () => s.HeatmapPalette,
                            HeatmapPoint: () => s.HeatmapPoint,
                            HtmlMarker: () => Ga,
                            HtmlMarkerOptions: () => f.HtmlMarkerOptions,
                            IconTransformerParams: () => u.IconTransformerParams,
                            InteractionEvent: () => m.InteractionEvent,
                            InteractionTarget: () => m.InteractionTarget,
                            LabelsDebugOptions: () => o.LabelsDebugOptions,
                            Map: () => Hc,
                            MapClass: () => Hc,
                            MapEvent: () => m.MapEvent,
                            MapOptions: () => r.MapOptions,
                            MapPointerEvent: () => m.MapPointerEvent,
                            Marker: () => wd,
                            MarkerIconOptions: () => l.MarkerIconOptions,
                            MarkerLabelOptions: () => l.MarkerLabelOptions,
                            MarkerOptions: () => l.MarkerOptions,
                            OnlineMarker: () => Ed,
                            OnlineMarkerIcon: () => u.OnlineMarkerIcon,
                            OnlineMarkerOptions: () => u.OnlineMarkerOptions,
                            Padding: () => r.Padding,
                            PersonalPoi: () => r.PersonalPoi,
                            PointLabel: () => gd,
                            PointLabelOptions: () => a.PointLabelOptions,
                            Polygon: () => Jc,
                            PolygonOptions: () => f.PolygonOptions,
                            Polyline: () => qc,
                            PolylineOptions: () => f.PolylineOptions,
                            Raster: () => Pd,
                            RasterOptions: () => d.RasterOptions,
                            RasterTileSource: () => kd,
                            RasterTileSourceOptions: () => h.RasterTileSourceOptions,
                            Rect: () => Td,
                            RectOptions: () => c.RectOptions,
                            RulerChangeEvent: () => m.RulerChangeEvent,
                            SourceAttrs: () => r.SourceAttrs,
                            SourceMetatile: () => Ws.SourceMetatile,
                            Stats: () => r.Stats,
                            TileCoords: () => r.TileCoords,
                            TileLoadEvent: () => m.TileLoadEvent,
                            TrafficScoreEvent: () => m.TrafficScoreEvent,
                            Viewport: () => r.Viewport,
                            ZenithSource: () => dc,
                            ZenithSourceOptions: () => ea.ZenithSourceOptions,
                            config: () => I,
                            mapglUtils: () => n,
                            utils: () => M,
                        });
                    var g = {};
                    i.r(g), i.d(g, { C: () => $d });
                    var y = {};
                    i.r(y), i.d(y, { S: () => ih });
                    var b = {};
                    i.r(b);
                    var w = {};
                    i.r(w);
                    var x = {};
                    i.r(x);
                    var S = i(7731),
                        I = i(9218),
                        M = i(3741),
                        T = i(2435),
                        P = i(7188),
                        L = i(9073),
                        k = i(3675),
                        E = i(6874);
                    class A extends k.c {
                        constructor(e) {
                            super(),
                                (this.uniqId = (0, E.f)()),
                                (this.modules = e.modules),
                                (this.mapState = e.state),
                                (this.tileObjects = []),
                                (this.identifyIds = []);
                        }
                        update() {}
                        destroy() {
                            const e = this.modules;
                            this.tileObjects.forEach((t) => {
                                t.clean(this.mapState), e.tileManager.removeObject(t);
                            }),
                                (this.tileObjects = []),
                                e.layers.removeLayer(this),
                                (this.mapState.needRerender = !0);
                        }
                        getIdentifyData() {
                            return this.identifyIds.map((e) => ({
                                dynamicObjectId: this.uniqId,
                                metatileHash: -1,
                                ids: e,
                            }));
                        }
                    }
                    var z = i(378),
                        C = i(363),
                        F = i(1274),
                        O = i(3672),
                        D = i(9450),
                        R = i(7609);
                    function j(e, t) {
                        if (void 0 === t) return;
                        if (t.sourceId) {
                            const i = e.getSourceById(t.sourceId);
                            if (!(null == i ? void 0 : i.isIdentifiedAsDefault())) return;
                        }
                        const i = { id: (0, O.Ak)(t.id), symbol: t.symbol };
                        return (
                            'point' === t.symbol && (i.isText = 1 === t.instanceId),
                            t.sublayer &&
                                ((i.isCityCommercial = (0, R.wu)(t.sublayer)),
                                (i.isCommercial = (0, R.Ty)(t.sublayer)),
                                (i.isPersonal = (0, R.h3)(t.sublayer)),
                                'point' !== t.symbol ||
                                    i.isCommercial ||
                                    (i.sysCode = t.objectClass)),
                            t.center && (i.center = (0, M.projectMapToGeo)(t.center)),
                            i
                        );
                    }
                    function B(e, t) {
                        if (void 0 === t) return;
                        if (t.sourceId) {
                            const i = e.getSourceById(t.sourceId);
                            if (i)
                                switch (i.type) {
                                    case 'geojson':
                                        return 'internal' === i.subtype
                                            ? {
                                                  type: 'geojson',
                                                  id: (0, O.Ak)(t.id),
                                                  feature: i.getFeatureById(t.id),
                                                  source: i,
                                              }
                                            : {
                                                  type: 'geojsonTile',
                                                  getFeatureProperties: () =>
                                                      void 0 === t.tileKey
                                                          ? Promise.resolve()
                                                          : i.getObjectAttributes(t.id, t.tileKey),
                                                  source: i,
                                              };
                                    case 'zenith':
                                        return { type: 'zenith', id: (0, O.Ak)(t.id), source: i };
                                }
                        }
                        const i = { type: 'default', id: (0, O.Ak)(t.id) };
                        return t.floorId && (i.floorId = (0, O.Ak)(t.floorId)), i;
                    }
                    const N = [
                        'mousedown',
                        'touchstart',
                        'mouseup',
                        'touchend',
                        'click',
                        'dblclick',
                        'contextmenu',
                        'mousemove',
                        'mouseout',
                        'mouseover',
                    ];
                    function U(e, t, i, n, o) {
                        const r = (0, M.projectMapToGeo)(o.camera.unproject(n));
                        if (t && void 0 !== t.dynamicObjectId) {
                            const s = e,
                                a = o.layers
                                    .getDynamicObjectLayers()
                                    .find((e) => e.uniqId === t.dynamicObjectId);
                            if (!a) return;
                            const l = { lngLat: r, originalEvent: i, point: n, targetData: a };
                            return void a.emit(s, l);
                        }
                        const s = Object.assign(
                                { lngLat: r, originalEvent: i, point: n },
                                (function (e, t, i, n, o) {
                                    var r, s;
                                    const a =
                                        null !==
                                            (s =
                                                null === (r = o.threeJsSceneManager) || void 0 === r
                                                    ? void 0
                                                    : r.getEventTarget(i)) && void 0 !== s
                                            ? s
                                            : null;
                                    if (a && N.includes(e)) {
                                        const e = (0, D.TE)(
                                            o.camera.unproject(n),
                                            o.camera.position,
                                        );
                                        if (a.distance <= e)
                                            return {
                                                target: { id: a.id, symbol: a.symbol },
                                                targetData: { id: a.id, type: 'default' },
                                            };
                                    }
                                    return {
                                        target: j(o.sourceStorage, t),
                                        targetData: B(o.sourceStorage, t),
                                    };
                                })(e, t, i, n, o),
                            ),
                            a = e;
                        o.map.emit(a, s);
                    }
                    class Z extends A {
                        constructor(e, t) {
                            super(e),
                                (this.start = (e) => {
                                    const { modules: t, container: i } = this;
                                    if (0 !== e.button) return;
                                    const n = (0, F.yK)(i, e.clientX, e.clientY);
                                    this.contains(n) &&
                                        (t.handler.block(),
                                        t.mouseMoveHandler.block(),
                                        (this.dragStartCursorPoint = n),
                                        (this.dragStartAnchorPoint = t.camera.project(
                                            this.getPosition(),
                                        )),
                                        document.addEventListener('mouseup', this.stop),
                                        document.addEventListener('mousemove', this.move),
                                        this.emitEvent('dragstart', e));
                                }),
                                (this.move = (e) => {
                                    const {
                                        dragStartAnchorPoint: t,
                                        dragStartCursorPoint: i,
                                        container: n,
                                    } = this;
                                    if (void 0 === t || void 0 === i) return;
                                    const o = (0, F.yK)(n, e.clientX, e.clientY),
                                        r = z.d9(t);
                                    z.IH(r, r, o),
                                        z.lu(r, r, i),
                                        this.setPosition(this.modules.camera.unproject(r)),
                                        this.emitEvent('drag', e);
                                }),
                                (this.stop = (e) => {
                                    if (0 !== e.button) return;
                                    (this.dragStartCursorPoint = void 0),
                                        (this.dragStartAnchorPoint = void 0),
                                        document.removeEventListener('mouseup', this.stop),
                                        document.removeEventListener('mousemove', this.move);
                                    const { modules: t } = this;
                                    t.handler.unblock(),
                                        t.mouseMoveHandler.unblock(),
                                        this.emitEvent('dragend', e),
                                        this.isInteractive() && t.identifier.resetCache();
                                }),
                                (this.container = e.modules.layout.mapContainer),
                                t && this.container.addEventListener('mousedown', this.start, !0);
                        }
                        destroy() {
                            super.destroy(),
                                this.container.removeEventListener('mousedown', this.start, !0),
                                document.removeEventListener('mouseup', this.stop),
                                document.removeEventListener('mousemove', this.move);
                        }
                        emitEvent(e, t) {
                            const i = this.getPosition(),
                                n = (0, L.PA)(i),
                                o = this.modules.camera.project(i),
                                r = this.modules.identifier.searchSync(o),
                                s =
                                    void 0 !== r && void 0 === r.dynamicObjectId
                                        ? j(this.modules.sourceStorage, r)
                                        : void 0;
                            this.emit(e, {
                                originalEvent: t,
                                target: s,
                                targetData: this,
                                lngLat: n,
                                point: o,
                            });
                        }
                    }
                    var H = i(4372),
                        G = i(6392),
                        V = i(3249),
                        W = i(4575),
                        q = i(871),
                        $ = i(2543);
                    class X extends Z {
                        constructor(e, t) {
                            var i, n;
                            super(e, null !== (i = t.draggable) && void 0 !== i && i),
                                (this.options = t),
                                (this.interactive =
                                    null === (n = this.options.interactive) || void 0 === n || n),
                                (this.center = (0, L.yq)(this.options.coordinates));
                            const {
                                dynamicStyle: o,
                                collector: r,
                                renderer: s,
                                tileManager: a,
                                identifier: l,
                                layers: c,
                            } = this.modules;
                            if (
                                ((this.layer = (0, W.qw)({
                                    type: 'circle',
                                    id: `dynamic-circleMarker-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color: this.options.color,
                                        strokeColor: this.options.borderColor,
                                        strokeColor2: this.options.border2Color,
                                        width: this.options.width,
                                        strokeWidth: this.options.borderWidth,
                                        strokeWidth2: this.options.border2Width,
                                    },
                                })),
                                !this.layer)
                            )
                                return;
                            o.addLayer(this.layer, this.options.zIndex);
                            const d = (0, G.IR)(this.center),
                                h = (0, V.FJ)({ id: this.interactive ? (0, O.Ru)(0, 0) : NaN }),
                                u = (0, $.Yi)(this.mapState.styleState, P.i4, P.Dz, h, P.wz);
                            (0, H.XI)({
                                collector: r,
                                generator: q.p.generate,
                                args: [o.getStyle().id, this.layer, u, [[0], [0]]],
                            });
                            const m = r.getAccumulatedData(),
                                f = new C.W('dynamicObject', m.data, s, d);
                            a.addObject(f),
                                this.tileObjects.push(f),
                                this.interactive && this.identifyIds.push(m.identifyIds),
                                c.addLayer(this),
                                r.reset(),
                                (this.mapState.needRerender = !0),
                                this.interactive && l.resetCache();
                        }
                        remove() {
                            this.layer && this.modules.dynamicStyle.removeLayer(this.layer.innerId),
                                this.interactive && this.modules.identifier.resetCache(),
                                super.destroy();
                        }
                        setPosition(e) {
                            const { mapState: t } = this,
                                i = this.tileObjects[0];
                            void 0 !== i &&
                                ((this.center = e),
                                i.setTileCoords((0, G.IR)(e)),
                                (t.needRerender = !0));
                        }
                        getPosition() {
                            return this.center;
                        }
                        isInteractive() {
                            return this.interactive;
                        }
                        contains(e) {
                            if (!this.layer) return !1;
                            const { layer: t } = this,
                                i = this.modules.camera.project(this.center),
                                n =
                                    (0, $.vn)(
                                        t.style.width,
                                        (0, $.jJ)(
                                            this.mapState.styleZoom,
                                            this.mapState.styleState,
                                            [],
                                        ),
                                    ) /
                                        2 +
                                    (0, $.vn)(
                                        t.style.strokeWidth,
                                        (0, $.jJ)(
                                            this.mapState.styleZoom,
                                            this.mapState.styleState,
                                            [],
                                        ),
                                    );
                            return z.TK(i, e) <= n;
                        }
                    }
                    var Y = i(1913);
                    function K(e, t, i) {
                        const { top: n, right: o, bottom: r, left: s } = e.viewport,
                            { clientWidth: a, clientHeight: l } = t;
                        (e.size = [Math.max(1, a - s - o), Math.max(1, l - n - r)]),
                            i.updateIdentifySize(),
                            i.updateLabelingTextureBufferSize();
                    }
                    function J(e, t) {
                        return (function (e, t) {
                            return {
                                top: Math.min(e.top, t[1]),
                                bottom: Math.min(e.bottom, t[1]),
                                left: Math.min(e.left, t[0]),
                                right: Math.min(e.right, t[0]),
                            };
                        })(
                            (function (e) {
                                return {
                                    top: Math.max(e.top, 0),
                                    bottom: Math.max(e.bottom, 0),
                                    left: Math.max(e.left, 0),
                                    right: Math.max(e.right, 0),
                                };
                            })(e),
                            t,
                        );
                    }
                    function Q(e, t) {
                        const { top: i, right: n, bottom: o, left: r } = e.padding;
                        (e.padding = { top: i, right: n, bottom: o, left: r }),
                            (e.needRerender = !0),
                            t.updateIdentifySize(),
                            t.updateLabelingTextureBufferSize();
                    }
                    var ee = i(8194);
                    const te = 'inertia',
                        ie = Y.sT.bind(null, te),
                        ne = (e, t) => {
                            Y.Vx(
                                te,
                                {
                                    step: (e, i, n) => {
                                        const {
                                                startPoint: o,
                                                startSpeed: r,
                                                startTime: s,
                                                direction: a,
                                            } = n,
                                            l = D.d9(a);
                                        D.bA(l, l, i),
                                            D.IH(l, l, o),
                                            ee.r3(e.maxBounds, l) || oe(t, e),
                                            (e.center = l),
                                            'zoom' === e.zoomTypePreserving
                                                ? (e.styleZoom = (0, L.X$)(e.zoom, l))
                                                : (e.zoom = (0, L.Z3)(e.styleZoom, l));
                                        const c = ((e, t, i) =>
                                            e *
                                            Math.pow(
                                                1 - (i - t) / I.inertia.duration,
                                                I.inertia.nonLinearity,
                                            ))(r, s, e.time);
                                        (0, L.ik)(c, e.zoom) < I.inertia.minSpeed && oe(t, e);
                                    },
                                },
                                e,
                            );
                        },
                        oe = (e, t) => {
                            Y.sT(te, t), e.classList.remove('mapgl-inertia');
                        },
                        re = 'center',
                        se = (e, t, i = {}) => {
                            Y.sT(re, e), ie(e);
                            const n = D.Ue();
                            if ((ee.Rk(n, e.maxBounds, t), !1 === i.animate || 0 === i.duration))
                                (e.center = n),
                                    'zoom' === e.zoomTypePreserving
                                        ? (e.styleZoom = (0, L.X$)(e.zoom, t))
                                        : (e.zoom = (0, L.Z3)(e.styleZoom, t));
                            else {
                                const t = void 0 !== i.easing ? i.easing : 'linear',
                                    o = void 0 !== i.duration ? i.duration : 250;
                                Y.BL(re, { easing: t }, e, e.center, n, o);
                            }
                        },
                        ae = Y.sT.bind(null, re),
                        le = Y.Vx.bind(null, re, {
                            step: (e, t) => {
                                (e.center = t),
                                    'zoom' === e.zoomTypePreserving
                                        ? (e.styleZoom = (0, L.X$)(e.zoom, t))
                                        : (e.zoom = (0, L.Z3)(e.styleZoom, t));
                            },
                        }),
                        ce = 'rotation';
                    function de(e, t) {
                        return (
                            (e -= t) >= Math.PI
                                ? (e = ((e + Math.PI) % (2 * Math.PI)) - Math.PI)
                                : e < -Math.PI && (e = Math.PI - ((Math.PI - e) % (2 * Math.PI))),
                            (e += t)
                        );
                    }
                    function he(e, t, i = {}) {
                        if ((Y.sT(ce, e), !1 === i.animate || 0 === i.duration))
                            e.rotation = de(t, 0);
                        else {
                            const n = void 0 === i.normalize || i.normalize;
                            Y.BL(
                                ce,
                                { easing: i.easing || 'linear' },
                                e,
                                e.rotation,
                                n ? de(t, e.rotation) : t,
                                i.duration || 250,
                            );
                        }
                    }
                    const ue = Y.sT.bind(null, ce),
                        me = Y.Vx.bind(null, ce, { step: (e, t) => (e.rotation = de(t, 0)) });
                    var fe = i(6490);
                    const pe = 'pitch';
                    function _e(e, t, i = {}) {
                        Y.sT(pe, e);
                        const n = (0, fe.uZ)(t, e.minPitch, e.maxPitch);
                        !1 === i.animate || 0 === i.duration
                            ? (e.pitch = n)
                            : Y.BL(
                                  pe,
                                  { easing: i.easing || 'linear' },
                                  e,
                                  e.pitch,
                                  n,
                                  i.duration || 300,
                              );
                    }
                    const ve = Y.sT.bind(null, pe),
                        ge = Y.Vx.bind(null, pe, { step: (e, t) => (e.pitch = t) }),
                        ye = 'zoom',
                        be = (e, t, i = {}) => {
                            Y.sT(ye, e);
                            const n = (0, fe.uZ)(t, e.minZoom, e.maxZoom);
                            if (n !== e.zoom)
                                if (!1 === i.animate || 0 === i.duration)
                                    i.zoomPoint &&
                                        (D.IH(
                                            e.center,
                                            e.center,
                                            (0, fe.Kv)(e, i.zoomPoint, { zoom: n }),
                                        ),
                                        ee.Rk(e.center, e.maxBounds, e.center)),
                                        (e.zoom = n),
                                        (e.styleZoom = (0, L.X$)(n, e.center));
                                else {
                                    const t = i.useHeightForAnimation
                                            ? (0, L.r9)(e.zoom, e.size)
                                            : e.zoom,
                                        o = i.useHeightForAnimation ? (0, L.r9)(n, e.size) : n,
                                        r = void 0 !== i.easing ? i.easing : 'easeOutCubic',
                                        s = void 0 !== i.duration ? i.duration : 250;
                                    Y.BL(ye, { easing: r }, e, t, o, s, {
                                        zoomPoint: i.zoomPoint,
                                        useHeightForAnimation: !!i.useHeightForAnimation,
                                        blockBuildingAnimation: !!i.blockBuildingAnimation,
                                    });
                                }
                        },
                        we = Y.sT.bind(null, ye),
                        xe = Y.Vx.bind(null, ye, {
                            step: (e, t, i = {}) => {
                                const n = i && i.useHeightForAnimation ? (0, L.nn)(t, e.size) : t;
                                i &&
                                    i.zoomPoint &&
                                    (D.IH(
                                        e.center,
                                        e.center,
                                        (0, fe.Kv)(e, i.zoomPoint, { zoom: n }),
                                    ),
                                    ee.Rk(e.center, e.maxBounds, e.center)),
                                    (e.zoom = n),
                                    (e.styleZoom = (0, L.X$)(n, e.center));
                            },
                        }),
                        Se =
                            navigator.msPointerEnabled &&
                            navigator.msMaxTouchPoints &&
                            !window.PointerEvent,
                        Ie =
                            (window.PointerEvent &&
                                navigator.pointerEnabled &&
                                navigator.maxTouchPoints) ||
                            Se ||
                            'ontouchstart' in window ||
                            (window.DocumentTouch && document instanceof window.DocumentTouch),
                        Me = Ae('webkit'),
                        Te = Ae('chrome') || Ae('crios'),
                        Pe = 'ActiveXObject' in window,
                        Le = !Te && Ae('safari'),
                        ke =
                            (Ae('gecko') && !Me && window.opera,
                            navigator.platform.toUpperCase().indexOf('MAC') >= 0),
                        Ee = Ae('firefox');
                    function Ae(e) {
                        return navigator.userAgent.toLowerCase().indexOf(e) >= 0;
                    }
                    function ze(e, t) {
                        const i = Object.assign({ hitType: 'event', eventCategory: 'Metrics' }, e);
                        window.ga && window.ga(`${I.analytics.gaName}.send`, i);
                    }
                    function Ce(e, t) {
                        let i,
                            n = !1;
                        function o() {
                            (n = !1), i && (r(...i), (i = !1));
                        }
                        function r(...r) {
                            n ? (i = r) : (e(...r), setTimeout(o, t), (n = !0));
                        }
                        return r;
                    }
                    function Fe(e) {
                        we(e), ae(e), ue(e), ve(e), ie(e);
                    }
                    class Oe {
                        constructor(e, t) {
                            (this.onWheelScroll = (e) => {
                                e.preventDefault(),
                                    (void 0 === e.deltaMode && void 0 === e.deltaY) ||
                                        ((this.state.userHasInteracted = !0),
                                        (this.screenPoint = (0, F.yK)(
                                            this.container,
                                            e.clientX,
                                            e.clientY,
                                        )),
                                        e.ctrlKey
                                            ? (this.deltaAccumulator -= 10 * e.deltaY)
                                            : 1 === e.deltaMode
                                            ? (this.deltaAccumulator -= 20 * e.deltaY)
                                            : (this.deltaAccumulator -= e.deltaY),
                                        (this.eventCount += 1));
                            }),
                                (this.startZooming = () => {
                                    const e = this.state;
                                    let t;
                                    t = ke
                                        ? this.getDelta() * I.zoom.macTouchDelta
                                        : (0, fe.Xx)(this.getDelta()) * I.zoom.mouseDelta;
                                    const i = e.zoom + t,
                                        n = (0, fe.uZ)(i, e.minZoom, e.maxZoom);
                                    n !== e.zoom &&
                                        (Fe(e),
                                        be(e, n, {
                                            duration: I.zoom.animDuration,
                                            animate: !ke,
                                            zoomPoint: e.keepCenterWhileUserZoomRotate
                                                ? void 0
                                                : this.screenPoint,
                                            blockBuildingAnimation: !0,
                                        }));
                                }),
                                (this.stop = () => {
                                    (this.state.userHasInteracted = !0), we(this.state);
                                }),
                                (this.state = e),
                                (this.container = t),
                                ke ||
                                    (this.startZooming = Ce(
                                        this.startZooming,
                                        I.zoom.throttleDelay,
                                    )),
                                (this.deltaAccumulator = 0),
                                (this.eventCount = 0),
                                (this.screenPoint = [0, 0]),
                                this.container.addEventListener('wheel', this.onWheelScroll),
                                this.container.addEventListener('mousedown', this.stop);
                        }
                        destroy() {
                            this.container.removeEventListener('wheel', this.onWheelScroll),
                                this.container.removeEventListener('mousedown', this.stop);
                        }
                        update() {
                            0 !== this.eventCount &&
                                (this.startZooming(), (this.state.needRerender = !0));
                        }
                        getDelta() {
                            const e = this.deltaAccumulator / this.eventCount;
                            return (this.deltaAccumulator = 0), (this.eventCount = 0), e;
                        }
                    }
                    class De {
                        constructor(e) {
                            this.defs = e.map((e) => new Re(e));
                        }
                        check(e) {
                            const t = this.defs;
                            let i = !1;
                            for (let n = 0; n < t.length; n++)
                                i ? t[n].update(e) : (i = !t[n].equal(e));
                            return i;
                        }
                    }
                    class Re {
                        constructor(e) {
                            (this.path = Array.isArray(e.path) ? e.path : [e.path]),
                                (this.type = e.type),
                                'number' === this.type
                                    ? ((this.last = NaN),
                                      (this.compare = this.primitive),
                                      (this.updateFn = this.primitiveUpdate))
                                    : 'boolean' === this.type
                                    ? ((this.last = void 0),
                                      (this.compare = this.primitive),
                                      (this.updateFn = this.primitiveUpdate))
                                    : 'vec2' === this.type
                                    ? ((this.last = [NaN, NaN]),
                                      (this.compare = this.vec2),
                                      (this.updateFn = this.vec2Update))
                                    : 'string' === this.type
                                    ? ((this.last = ''),
                                      (this.compare = this.primitive),
                                      (this.updateFn = this.primitiveUpdate))
                                    : 'padding' === this.type &&
                                      ((this.last = { left: 0, right: 0, bottom: 0, top: 0 }),
                                      (this.compare = this.padding),
                                      (this.updateFn = this.paddingUpdate));
                        }
                        equal(e) {
                            const t = this.take(e),
                                i = this.compare(this.last, t);
                            return this.updateFn(t), i;
                        }
                        update(e) {
                            this.updateFn(this.take(e));
                        }
                        take(e) {
                            const t = this.path;
                            let i = 0;
                            do {
                                e = e[t[i++]];
                            } while (i < t.length);
                            return e;
                        }
                        primitive(e, t) {
                            return e === t;
                        }
                        padding(e, t) {
                            return (
                                e.top === t.top &&
                                e.bottom === t.bottom &&
                                e.left === t.left &&
                                e.right === t.right
                            );
                        }
                        paddingUpdate(e) {
                            (this.last.top = e.top),
                                (this.last.bottom = e.bottom),
                                (this.last.right = e.right),
                                (this.last.left = e.left);
                        }
                        vec2(e, t) {
                            return e[0] === t[0] && e[1] === t[1];
                        }
                        primitiveUpdate(e) {
                            this.last = e;
                        }
                        vec2Update(e) {
                            (this.last[0] = e[0]), (this.last[1] = e[1]);
                        }
                    }
                    class je {
                        constructor(e, t) {
                            (this.onMouseUp = (e) => {
                                1 === e.which && this.start();
                            }),
                                (this.onTouchEnd = (e) => {
                                    0 === e.touches.length && this.start();
                                }),
                                (this.start = () => {
                                    const e = this.state;
                                    e.userHasInteracted = !0;
                                    const t = this.getCurrentSpeed(e.time),
                                        i = D.kE(t);
                                    if ((0, L.ik)(i, e.zoom) <= I.inertia.minSpeed) return;
                                    const n = (0, L.h0)(I.inertia.maxSpeed, e.zoom),
                                        o = Math.min(i, n),
                                        r = this.calcDistanceByStartSpeed(o),
                                        s = D.d9(e.center),
                                        a = D.Ue();
                                    D.Fv(a, t),
                                        ((e, t, i, n, o) => {
                                            Y.BL(
                                                te,
                                                { easing: 'inertia' },
                                                e,
                                                0,
                                                o,
                                                I.inertia.duration,
                                                {
                                                    startPoint: t,
                                                    startSpeed: i,
                                                    direction: n,
                                                    startTime: e.time,
                                                },
                                            );
                                        })(e, s, o, a, r),
                                        this.container.classList.add('mapgl-inertia');
                                }),
                                (this.stop = () => {
                                    ie(this.state),
                                        this.container.classList.remove('mapgl-inertia'),
                                        (this.times = []),
                                        (this.positions = []);
                                }),
                                (this.state = e),
                                (this.container = t),
                                this.container.addEventListener('mouseup', this.onMouseUp),
                                this.container.addEventListener('mousedown', this.stop),
                                Ie &&
                                    (this.container.addEventListener('touchend', this.onTouchEnd),
                                    this.container.addEventListener('touchstart', this.stop)),
                                (this.zoomDiffer = new De([{ path: 'zoom', type: 'number' }])),
                                (this.styleZoomDiffer = new De([
                                    { path: 'styleZoom', type: 'number' },
                                ])),
                                (this.centerDiffer = new De([{ path: 'center', type: 'vec2' }])),
                                (this.times = []),
                                (this.positions = []);
                        }
                        destroy() {
                            this.container.removeEventListener('mouseup', this.onMouseUp),
                                this.container.removeEventListener('mousedown', this.stop),
                                this.container.removeEventListener('touchend', this.onTouchEnd),
                                this.container.removeEventListener('touchstart', this.stop);
                        }
                        update() {
                            const e = this.state;
                            this.centerDiffer.check(e) && this.rememberTimeAndPosition(e);
                            ('zoom' === e.zoomTypePreserving
                                ? this.zoomDiffer.check(e)
                                : this.styleZoomDiffer.check(e)) && this.stop();
                        }
                        removeOldRecords(e) {
                            for (; e - this.times[0] > 100 && this.times.length; )
                                this.times.shift(), this.positions.shift();
                        }
                        rememberTimeAndPosition(e) {
                            const t = e.time;
                            this.removeOldRecords(t),
                                this.times.push(t),
                                this.positions.push(D.d9(e.center));
                        }
                        getCurrentSpeed(e) {
                            if ((this.removeOldRecords(e), this.times.length < 2)) return D.Ue();
                            const t = D.d9(this.positions[this.positions.length - 1]);
                            return (
                                D.lu(t, t, this.positions[0]),
                                D.bA(t, t, 1 / (this.times[this.times.length - 1] - this.times[0])),
                                t
                            );
                        }
                        calcDistanceByStartSpeed(e) {
                            return (e * I.inertia.duration) / (I.inertia.nonLinearity + 1);
                        }
                    }
                    class Be {
                        constructor(e) {
                            (this.emitMouseEvent = (e) => {
                                const t = (0, F.yK)(this.container, e.clientX, e.clientY);
                                this.emitEvent(e, t);
                            }),
                                (this.emitTouchEvent = (e) => {
                                    const t = (0, F.yK)(
                                        this.container,
                                        e.changedTouches[0].clientX,
                                        e.changedTouches[0].clientY,
                                    );
                                    this.emitEvent(e, t);
                                }),
                                (this.container = e.layout.mapContainer),
                                (this.modules = e),
                                this.container.addEventListener('mouseup', this.emitMouseEvent),
                                this.container.addEventListener('touchend', this.emitTouchEvent);
                        }
                        destroy() {
                            this.container.removeEventListener('mouseup', this.emitMouseEvent),
                                this.container.removeEventListener('touchend', this.emitTouchEvent);
                        }
                        update() {}
                        emitEvent(e, t) {
                            if (!this.modules.layout.isActionWithCanvas(e)) return;
                            const i = e.type;
                            this.modules.identifier.search(i, t).then((n) => {
                                U(i, n, e, t, this.modules);
                            });
                        }
                    }
                    class Ne {
                        constructor(e, t, i) {
                            (this.rotationDetected = !1),
                                (this.onGestureStart = (e) => {
                                    e.preventDefault(),
                                        (this.startRotation = this.state.rotation),
                                        (this.rotationDetected = !1),
                                        (this.gestureRotation = 0),
                                        (this.isGestureStart = !0),
                                        (this.startZoom = this.state.zoom),
                                        (this.screenPoint = (0, F.yK)(
                                            this.container,
                                            e.clientX,
                                            e.clientY,
                                        )),
                                        (this.state.userHasInteracted = !0),
                                        this.state.disableRotationByUserInteraction ||
                                            this.container.classList.add('mapgl-rotating'),
                                        this.map.emit('interactionstart', {
                                            target: 'zoom/rotation',
                                        });
                                }),
                                (this.onGestureEnd = (e) => {
                                    e.preventDefault(),
                                        this.isGestureStart &&
                                            ((this.isGestureStart = !1),
                                            (this.state.userHasInteracted = !0),
                                            this.container.classList.remove('mapgl-rotating'),
                                            this.map.emit('interactionend', {
                                                target: 'zoom/rotation',
                                            }));
                                }),
                                (this.onGestureChange = (e) => {
                                    e.preventDefault(), (this.state.userHasInteracted = !0);
                                    const t = e.rotation / 40;
                                    !this.rotationDetected &&
                                        Math.abs(t) > this.state.touchRotationThreshold &&
                                        ((this.rotationDetected = !0),
                                        (this.startRotation = this.state.rotation - t)),
                                        this.rotationDetected && (this.gestureRotation = t),
                                        e.scale > 1
                                            ? (this.gestureZoom = e.scale - 1)
                                            : (this.gestureZoom = -1 / e.scale + 1);
                                }),
                                (this.state = e),
                                (this.container = t),
                                (this.map = i),
                                (this.isGestureStart = !1),
                                (this.gestureRotation = 0),
                                (this.gestureZoom = 0),
                                (this.screenPoint = [0, 0]),
                                (this.startRotation = 0),
                                (this.startZoom = 0),
                                this.container.addEventListener(
                                    'gesturestart',
                                    this.onGestureStart,
                                ),
                                this.container.addEventListener('gestureend', this.onGestureEnd),
                                this.container.addEventListener(
                                    'gesturechange',
                                    this.onGestureChange,
                                );
                        }
                        destroy() {
                            this.container.removeEventListener('gesturestart', this.onGestureStart),
                                this.container.removeEventListener('gestureend', this.onGestureEnd),
                                this.container.removeEventListener(
                                    'gesturechange',
                                    this.onGestureChange,
                                );
                        }
                        update() {
                            if (0 === this.gestureRotation && 0 === this.gestureZoom) return;
                            const e = this.state,
                                t = this.startZoom + this.gestureZoom,
                                i = this.startRotation + this.gestureRotation,
                                n = D.Ue(),
                                o = e.keepCenterWhileUserZoomRotate
                                    ? D.Ue()
                                    : (0, fe.Kv)(e, this.screenPoint, { zoom: t, rotation: i });
                            D.IH(n, e.center, o),
                                Fe(e),
                                se(e, n, { animate: !1 }),
                                be(e, t, { animate: !1 }),
                                e.disableRotationByUserInteraction || he(e, i, { animate: !1 }),
                                (this.gestureRotation = 0),
                                (this.gestureZoom = 0);
                        }
                    }
                    class Ue extends k.c {
                        constructor(e) {
                            super(),
                                (this.durations = []),
                                (this.earlyTimes = []),
                                (this.countToCheck = 75),
                                (this.mayCountMetrics = !1),
                                (this.startRenderTime = 0),
                                (this.catchNextUpdate = !1),
                                (this.mapState = e),
                                setTimeout(() => {
                                    this.mayCountMetrics = !0;
                                }, 1e4);
                        }
                        update() {
                            const { time: e, needRerender: t } = this.mapState;
                            this.mayCountMetrics
                                ? (this.catchNextUpdate &&
                                      (this.durations.push(e - this.startRenderTime),
                                      (this.catchNextUpdate = !1)),
                                  t && ((this.startRenderTime = e), (this.catchNextUpdate = !0)),
                                  this.durations.length > this.countToCheck && this.check())
                                : this.earlyTimes.push(e);
                        }
                        getEarlyFps() {
                            if (this.mayCountMetrics) return;
                            const e = [];
                            for (let t = 1; t < this.earlyTimes.length; t++)
                                e.push(this.earlyTimes[t] - this.earlyTimes[t - 1]);
                            return Ze(e);
                        }
                        check() {
                            const e = Ze(this.durations);
                            this.emit('fps', e),
                                e < I.performanceCheck.fpsCaveat &&
                                    ((this.mapState.performanceCaveatEmitted = !0),
                                    this.emit('performancecaveat')),
                                (this.durations = []),
                                (this.countToCheck = Math.min(1e3, 2 * this.countToCheck));
                        }
                    }
                    function Ze(e) {
                        e.sort((e, t) => e - t);
                        const t = e[Math.floor((3 * e.length) / 4)];
                        return Math.round(1e3 / t);
                    }
                    var He = i(9476);
                    class Ge {
                        constructor() {
                            (this.differ = new De([
                                { path: 'center', type: 'vec2' },
                                { path: 'zoom', type: 'number' },
                                { path: 'rotation', type: 'number' },
                                { path: 'pitch', type: 'number' },
                            ])),
                                (this.debouncedSet = (0, He.D)(
                                    (e) => {
                                        Y.BL('stillness', {}, e, e.stillness, 1, 400);
                                    },
                                    100,
                                    !1,
                                )),
                                (this.stillnessTickerUpdate = Y.Vx.bind(null, 'stillness', {
                                    step: (e, t) => {
                                        e.stillness = t;
                                    },
                                }));
                        }
                        update(e) {
                            this.differ.check(e) &&
                                ((e.stillness = 0), Y.sT('stillness', e), this.debouncedSet(e)),
                                this.stillnessTickerUpdate(e);
                        }
                    }
                    class Ve {
                        constructor(e) {
                            (this.onTouchStart = () => {
                                this.isTouchStartEmitted = !0;
                            }),
                                (this.onMouseOut = (e) => {
                                    if (!this.prevGeo) return;
                                    const t = (0, F.yK)(this.container, e.clientX, e.clientY);
                                    U('mouseout', this.prevGeo, e, t, this.modules),
                                        (this.prevGeo = void 0),
                                        (this.skipIdentifyEvents = !0),
                                        this.modules.defaultSource.resetHoverId(),
                                        this.container.classList.remove('mapgl-hover');
                                }),
                                (this.onMouseMove = (e) => {
                                    if (this.isTouchStartEmitted)
                                        return void (this.isTouchStartEmitted = !1);
                                    if (((this.skipIdentifyEvents = !1), this.isBlocked)) return;
                                    const t = (0, F.yK)(this.container, e.clientX, e.clientY);
                                    Promise.resolve()
                                        .then(() =>
                                            this.modules.layout.isActionWithCanvas(e)
                                                ? this.modules.identifier.search('mouseMove', t)
                                                : void 0,
                                        )
                                        .then((i) => {
                                            if (this.skipIdentifyEvents) return;
                                            const n =
                                                i &&
                                                this.prevGeo &&
                                                (!(0, O.v7)(i.id, this.prevGeo.id) ||
                                                    i.instanceId !== this.prevGeo.instanceId ||
                                                    i.dynamicObjectId !==
                                                        this.prevGeo.dynamicObjectId ||
                                                    i.symbol !== this.prevGeo.symbol);
                                            !this.prevGeo ||
                                                (i && !n) ||
                                                (U('mouseout', this.prevGeo, e, t, this.modules),
                                                (this.prevGeo = void 0),
                                                this.container.classList.remove('mapgl-hover'),
                                                this.modules.defaultSource.resetHoverId()),
                                                !i ||
                                                    (this.prevGeo && !n) ||
                                                    ((this.prevGeo = i),
                                                    this.container.classList.add('mapgl-hover'),
                                                    U('mouseover', i, e, t, this.modules),
                                                    this.modules.defaultSource.setHoverId(i.id)),
                                                U('mousemove', i, e, t, this.modules);
                                        });
                                }),
                                (this.modules = e),
                                (this.isTouchStartEmitted = !1),
                                (this.skipIdentifyEvents = !1),
                                (this.isBlocked = !1),
                                (this.prevGeo = void 0),
                                (this.container = this.modules.layout.mapContainer),
                                this.container.addEventListener('touchstart', this.onTouchStart),
                                this.container.addEventListener('mousemove', this.onMouseMove),
                                this.container.addEventListener('mouseout', this.onMouseOut);
                        }
                        destroy() {
                            this.container.removeEventListener('touchstart', this.onTouchStart),
                                this.container.removeEventListener('mousemove', this.onMouseMove),
                                this.container.removeEventListener('mouseout', this.onMouseOut);
                        }
                        update() {}
                        block() {
                            this.isBlocked = !0;
                        }
                        unblock() {
                            this.isBlocked = !1;
                        }
                    }
                    const We = (e, t, i, n) => {
                        Y.sT('buildingHeight' + n, e),
                            !1 === i.animate || 0 === i.duration
                                ? (t.set(n, i.to), (e.needLabeling = !0))
                                : Y.BL(
                                      'buildingHeight' + n,
                                      { easing: i.easing },
                                      e,
                                      i.from,
                                      i.to,
                                      i.duration,
                                  );
                    };
                    class qe {
                        constructor(e, t) {
                            (this.state = e),
                                (this.modules = t),
                                (this.differ = new De([{ path: 'styleZoom', type: 'number' }])),
                                (this.buildingHeights = new Map()),
                                (this.minZoomBuildingHeight = 1 / 0);
                        }
                        getBuildingHeight(e) {
                            return e === -1 / 0
                                ? 1
                                : void 0 !== e
                                ? (this.buildingHeights.has(e) || this.addBuildingHeightZoom(e),
                                  this.buildingHeights.get(e) || 0)
                                : this.getDefaultBuildingHeight();
                        }
                        update() {
                            this.buildingHeights.forEach((e, t) => {
                                this.updateByZoom(t, e),
                                    this.isAnimating() &&
                                        ((e, t, i) => {
                                            Y.Vx.call(
                                                null,
                                                'buildingHeight' + i,
                                                {
                                                    step: (e, n) => t.set(i, n),
                                                    complete: (e) => (e.needLabeling = !0),
                                                },
                                                e,
                                            );
                                        })(this.state, this.buildingHeights, t);
                            });
                        }
                        isAnimating() {
                            return Array.from(this.buildingHeights.keys()).some(
                                (e) => void 0 !== Y.U2('buildingHeight' + e, this.state),
                            );
                        }
                        clearBuildingHeights() {
                            this.buildingHeights.clear(), (this.minZoomBuildingHeight = 1 / 0);
                        }
                        getDefaultBuildingHeight() {
                            const e =
                                this.minZoomBuildingHeight !== 1 / 0
                                    ? this.minZoomBuildingHeight
                                    : 16;
                            return this.state.styleZoom < e ? 0 : 1;
                        }
                        updateByZoom(e, t) {
                            const i = this.state,
                                n = Y.U2('zoom', i),
                                o = Y.U2('buildingHeight' + e, i),
                                r = void 0 !== o ? o.to : t,
                                s =
                                    void 0 !== n
                                        ? n.attributes.blockBuildingAnimation
                                        : this.differ.check(i);
                            i.styleZoom >= e &&
                            this.modules.tileManager.viewportTilesReady() &&
                            1 !== r &&
                            !s
                                ? We(
                                      i,
                                      this.buildingHeights,
                                      {
                                          animate: !0,
                                          easing: I.buildingAnimation.easing,
                                          from: t,
                                          to: 1,
                                          duration: I.buildingAnimation.duration * (1 - t),
                                      },
                                      e,
                                  )
                                : i.styleZoom < e &&
                                  0 !== r &&
                                  We(i, this.buildingHeights, { animate: !1, to: 0 }, e);
                        }
                        addBuildingHeightZoom(e) {
                            const t = e < this.state.styleZoom ? 0 : 1;
                            this.buildingHeights.set(e, t),
                                this.minZoomBuildingHeight > e && (this.minZoomBuildingHeight = e);
                        }
                    }
                    var $e = i(127);
                    class Xe {
                        constructor(e, t = {}, i = null) {
                            (this._vao = null),
                                (this._vaoExt = null),
                                (this._gl = null),
                                (this.attributesAliases = {}),
                                (this._attributes = t),
                                (this._shaderProgram = e),
                                (this.indicesBuffer = i);
                        }
                        static merge(e) {
                            const t = e[0],
                                i = {},
                                n = {};
                            for (const t of e)
                                Object.assign(i, t._attributes),
                                    Object.assign(n, t.attributesAliases);
                            const o = new Xe(t._shaderProgram, i, t.indicesBuffer);
                            return o.setAttributesAliases(n), o;
                        }
                        bind(e) {
                            const t = e.extensions.OES_vertex_array_object,
                                i = e.extensions.ANGLE_instanced_arrays;
                            return this._bind(e.gl, t, i), this;
                        }
                        unbind() {
                            return this._glBindVertexArray(null), this;
                        }
                        setAttribute(e, t) {
                            this._attributes[e] = t;
                        }
                        remove() {
                            return (
                                this._vao &&
                                    (this._glDeleteVertexArray(this._vao), (this._vao = null)),
                                this
                            );
                        }
                        getElementsGLType(e) {
                            return this.indicesBuffer ? this.indicesBuffer.getGLType(e) : null;
                        }
                        setAttributesAliases(e) {
                            Object.assign(this.attributesAliases, e), this.remove();
                        }
                        setAttributes(e, t) {
                            const i = this._shaderProgram.attributes,
                                n = this._attributes;
                            for (const o in i) {
                                const r = n[this.attributesAliases[o] || o];
                                if (!r) continue;
                                const s = i[o];
                                !0 !== s.index && e.enableVertexAttribArray(s.location),
                                    r.bind(e, s.location, void 0, t);
                            }
                            this.indicesBuffer && this.indicesBuffer.bind(e);
                        }
                        _bind(e, t, i) {
                            this._vao ? this._glBindVertexArray(this._vao) : this._prepare(e, t, i);
                        }
                        _prepare(e, t, i) {
                            (this._gl = e),
                                t && (this._vaoExt = t),
                                (this._vao = this._glCreateVertexArray()),
                                this._glBindVertexArray(this._vao),
                                this.setAttributes(e, i);
                        }
                        _glCreateVertexArray() {
                            const e = this._gl,
                                t = this._vaoExt;
                            return e && this._isWebGL2(e)
                                ? e.createVertexArray()
                                : t
                                ? t.createVertexArrayOES()
                                : null;
                        }
                        _glBindVertexArray(e) {
                            const t = this._gl,
                                i = this._vaoExt;
                            t && this._isWebGL2(t)
                                ? t.bindVertexArray(e)
                                : i
                                ? i.bindVertexArrayOES(e)
                                : t && this._shaderProgram.bind(t, void 0, this._attributes);
                        }
                        _glDeleteVertexArray(e) {
                            const t = this._gl,
                                i = this._vaoExt;
                            t && this._isWebGL2(t)
                                ? t.deleteVertexArray(e)
                                : i && i.deleteVertexArrayOES(e);
                        }
                        _isWebGL2(e) {
                            return (
                                'undefined' != typeof window &&
                                'WebGL2RenderingContext' in window &&
                                e instanceof WebGL2RenderingContext
                            );
                        }
                    }
                    function Ye(e, t, i) {
                        e.linked || (e.linked = []);
                        const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                        !(function (e, t, i) {
                            $e.JG(e, t);
                            const n = $e.d9(i);
                            (n[12] = e[12]), (n[13] = e[13]), $e.U_(e, e), $e.dC(e, e, n);
                        })(n, e.tile.modelMatrix, t.tile.modelMatrix);
                        const o = Xe.merge([t.vao, e.vao]);
                        'gltfModel' === (null == i ? void 0 : i.type) &&
                            void 0 !== i.style.colorTextureUvIndex &&
                            o.setAttributesAliases({
                                texcoord_color: `texcoord_${i.style.colorTextureUvIndex}`,
                            }),
                            (e.linked[t.id] = { vao: o, transformMatrix: n });
                    }
                    function Ke(e) {
                        return 'instances' === e.sink;
                    }
                    function Je(e) {
                        return `gltf-fade-${e}`;
                    }
                    function Qe(e) {
                        return String(e.attributes.modelId);
                    }
                    class et {
                        constructor(e, t) {
                            (this.state = e),
                                (this.modules = t),
                                (this.zoomDiffer = new De([{ path: 'styleZoom', type: 'number' }])),
                                (this.minStyleZoom = 1 / 0),
                                (this.animationState = {}),
                                (this.animationByObjectId = {}),
                                (this.linkedIdsToObjectId = {}),
                                (this.hiddenObjects = new Set()),
                                (this.linkedIds = {}),
                                (this.buildingIds = new Set()),
                                (this.modelIdToBuildingId = {});
                        }
                        hasBuildingId(e) {
                            return this.buildingIds.has(e);
                        }
                        registerObject(e) {
                            var t;
                            const i = e.id,
                                { buildingId: n } = e.attributes,
                                o = null === (t = e.meta) || void 0 === t ? void 0 : t.linkedIds,
                                r = Qe(e);
                            if (((this.animationByObjectId[i] = r), !this.animationState[r])) {
                                const e = { tickerName: Je(r), readiness: 0 };
                                Y.BL(
                                    e.tickerName,
                                    { easing: I.buildingAnimation.easing },
                                    this.state,
                                    0,
                                    1,
                                    I.buildingAnimation.duration,
                                ),
                                    (this.animationState[r] = e);
                            }
                            if (
                                (this.buildingIds.add(n),
                                (this.modelIdToBuildingId[i] = n),
                                this.linkedIds[r] || (this.linkedIds[r] = []),
                                o)
                            ) {
                                for (const e of o) this.linkedIds[r].push(e);
                                const e = i.toString();
                                for (const t of o) this.linkedIdsToObjectId[t] = e;
                                this.modules.defaultSource.setHiddenBuildingIds(o.map(O.IL));
                            }
                        }
                        getModelOpacity(e, t) {
                            void 0 !== t && this.updateMinZoom(t);
                            const i = Qe(e);
                            if (!i) return 0;
                            const n = this.animationState[i];
                            return n ? n.readiness : 0;
                        }
                        getModelOpacityForLinkedObject(e) {
                            const t = this.linkedIdsToObjectId[e];
                            if (!t) return 1;
                            const i = this.animationByObjectId[t];
                            if (!i) return 1;
                            const n = this.animationState[i];
                            return n ? n.readiness : 0;
                        }
                        isAnimating(e) {
                            if (!e) {
                                for (const e in this.animationState)
                                    if (
                                        void 0 !==
                                        Y.U2(this.animationState[e].tickerName, this.state)
                                    )
                                        return !0;
                                return !1;
                            }
                            const t = this.linkedIdsToObjectId[e];
                            if (!t) return !1;
                            const i = this.animationByObjectId[t];
                            if (!i) return !1;
                            const n = this.animationState[i];
                            return !!n && void 0 !== Y.U2(n.tickerName, this.state);
                        }
                        hasModelFor(e) {
                            const t = this.linkedIdsToObjectId[e];
                            if (!t) return !1;
                            const i = this.animationByObjectId[t];
                            if (!i) return !1;
                            return void 0 !== this.animationState[i];
                        }
                        update() {
                            this.updateScene();
                            const e = Y.U2('zoom', this.state);
                            if (
                                !(void 0 !== e
                                    ? e.attributes.blockBuildingAnimation
                                    : this.zoomDiffer.check(this.state)) &&
                                this.modules.tileManager.viewportTilesReady() &&
                                this.state.styleZoom >= this.minStyleZoom
                            ) {
                                for (const e in this.animationState) {
                                    const t = this.animationState[e];
                                    if (
                                        (Y.Vx(
                                            t.tickerName,
                                            {
                                                step: (e, i) => {
                                                    t.readiness = i;
                                                },
                                            },
                                            this.state,
                                        ),
                                        1 === t.readiness && this.linkedIds[e])
                                    )
                                        for (const t of this.linkedIds[e])
                                            this.hiddenObjects.add(t);
                                }
                                this.hiddenObjects.forEach((e) => {
                                    this.state.hiddenObjects.other.add(e);
                                });
                            } else
                                this.state.styleZoom < this.minStyleZoom &&
                                    this.hiddenObjects.forEach((e) => {
                                        this.state.hiddenObjects.other.delete(e);
                                    });
                        }
                        updateScene() {
                            if (this.state.zoom < this.minStyleZoom)
                                return void (
                                    Object.keys(this.animationState).length > 0 && this.resetState()
                                );
                            const e = this.modules.tileManager.getTileObjects(),
                                t = new Set();
                            for (const i of e)
                                for (const e of i.children)
                                    if (Ke(e)) {
                                        t.add(Qe(e));
                                        const { modelId: i } = e.attributes;
                                        if (!this.modules.assetManager.isModelLoaded(i)) continue;
                                        const n = Qe(e);
                                        (this.animationState[n] &&
                                            this.animationByObjectId[e.id]) ||
                                            this.registerObject(e);
                                    }
                            for (const e in this.animationState)
                                t.has(e) || delete this.animationState[e];
                        }
                        resetState() {
                            (this.animationState = {}),
                                (this.animationByObjectId = {}),
                                (this.linkedIdsToObjectId = {}),
                                this.hiddenObjects.forEach((e) => {
                                    this.state.hiddenObjects.other.delete(e);
                                }),
                                (this.hiddenObjects = new Set()),
                                (this.linkedIds = {}),
                                (this.buildingIds = new Set()),
                                (this.modelIdToBuildingId = {});
                        }
                        updateMinZoom(e) {
                            e < this.minStyleZoom && (this.minStyleZoom = e);
                        }
                    }
                    var tt = i(8575);
                    class it {
                        constructor(e = null, t = {}) {
                            (this._src = null),
                                (this._glContext = null),
                                (this._texture = null),
                                (this._src = e),
                                (this.options = Object.assign({}, it.defaultOptions, t));
                        }
                        enable(e, t) {
                            const i = null != t ? t : this.options.unit;
                            return (
                                void 0 !== i && e.activeTexture(e.TEXTURE0 + i),
                                this._texture || this.prepare(e),
                                e.bindTexture(e.TEXTURE_2D, this._texture),
                                this
                            );
                        }
                        remove() {
                            return (
                                this._texture &&
                                    this._glContext &&
                                    (this._glContext.deleteTexture(this._texture),
                                    (this._glContext = null),
                                    (this._texture = null)),
                                this
                            );
                        }
                        getTexture() {
                            return this._texture;
                        }
                        subImage(e, t, i, n) {
                            var o;
                            e.bindTexture(e.TEXTURE_2D, this._texture),
                                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, this.options.flipY),
                                e.pixelStorei(
                                    e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                    this.options.premultiplyAlpha,
                                );
                            const r = this._toGlParam(e, this.options.format),
                                s = this._toGlParam(
                                    e,
                                    null !== (o = this.options.type) && void 0 !== o
                                        ? o
                                        : it.UnsignedByte,
                                );
                            return (
                                null === r ||
                                    null === s ||
                                    e.texSubImage2D(e.TEXTURE_2D, 0, i, n, r, s, t),
                                this
                            );
                        }
                        prepare(e) {
                            var t, i, n;
                            (this._glContext = e),
                                (this._texture = e.createTexture()),
                                e.bindTexture(e.TEXTURE_2D, this._texture),
                                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, this.options.flipY),
                                e.pixelStorei(
                                    e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                                    this.options.premultiplyAlpha,
                                );
                            const o = this._toGlParam(e, this.options.format),
                                r = this._toGlParam(
                                    e,
                                    null !== (t = this.options.type) && void 0 !== t
                                        ? t
                                        : it.UnsignedByte,
                                ),
                                s = this._toGlParam(e, this.options.wrapS),
                                a = this._toGlParam(e, this.options.wrapT),
                                l = this._toGlParam(
                                    e,
                                    null !== (i = this.options.magFilter) && void 0 !== i
                                        ? i
                                        : it.LinearFilter,
                                ),
                                c = this._toGlParam(
                                    e,
                                    null !== (n = this.options.minFilter) && void 0 !== n
                                        ? n
                                        : it.LinearMipMapLinearFilter,
                                );
                            return (
                                null !== o &&
                                    null !== r &&
                                    (ArrayBuffer.isView(this._src) || null === this._src
                                        ? this.options.size &&
                                          e.texImage2D(
                                              e.TEXTURE_2D,
                                              0,
                                              o,
                                              this.options.size[0],
                                              this.options.size[1],
                                              0,
                                              o,
                                              r,
                                              this._src,
                                          )
                                        : this._src &&
                                          e.texImage2D(e.TEXTURE_2D, 0, o, o, r, this._src)),
                                null !== s &&
                                    null !== a &&
                                    (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, s),
                                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)),
                                null !== l &&
                                    null !== c &&
                                    (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, l),
                                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, c)),
                                this.options.generateMipmaps &&
                                    this.options.minFilter !== it.NearestFilter &&
                                    this.options.minFilter !== it.LinearFilter &&
                                    e.generateMipmap(e.TEXTURE_2D),
                                e.bindTexture(e.TEXTURE_2D, null),
                                this
                            );
                        }
                        _toGlParam(e, t) {
                            return t === it.ClampToEdgeWrapping
                                ? e.CLAMP_TO_EDGE
                                : t === it.Repeat
                                ? e.REPEAT
                                : t === it.MirroredRepeat
                                ? e.MIRRORED_REPEAT
                                : t === it.NearestFilter
                                ? e.NEAREST
                                : t === it.NearestMipMapNearestFilter
                                ? e.NEAREST_MIPMAP_NEAREST
                                : t === it.NearestMipMapLinearFilter
                                ? e.NEAREST_MIPMAP_LINEAR
                                : t === it.LinearFilter
                                ? e.LINEAR
                                : t === it.LinearMipMapNearestFilter
                                ? e.LINEAR_MIPMAP_NEAREST
                                : t === it.LinearMipMapLinearFilter
                                ? e.LINEAR_MIPMAP_LINEAR
                                : t === it.RgbaFormat
                                ? e.RGBA
                                : t === it.AlphaFormat
                                ? e.ALPHA
                                : t === it.RgbFormat
                                ? e.RGB
                                : t === it.DepthComponentFormat
                                ? e.DEPTH_COMPONENT
                                : t === it.UnsignedByte
                                ? e.UNSIGNED_BYTE
                                : t === it.Float
                                ? e.FLOAT
                                : t === it.UnsignedInt
                                ? e.UNSIGNED_INT
                                : null;
                        }
                    }
                    (it.ClampToEdgeWrapping = 8),
                        (it.Repeat = 9),
                        (it.MirroredRepeat = 10),
                        (it.NearestFilter = 1),
                        (it.NearestMipMapNearestFilter = 2),
                        (it.NearestMipMapLinearFilter = 3),
                        (it.LinearFilter = 4),
                        (it.LinearMipMapNearestFilter = 5),
                        (it.LinearMipMapLinearFilter = 6),
                        (it.DepthComponentFormat = 7),
                        (it.RgbaFormat = 11),
                        (it.AlphaFormat = 12),
                        (it.RgbFormat = 13),
                        (it.UnsignedByte = 14),
                        (it.Float = 15),
                        (it.UnsignedInt = 16),
                        (it.defaultOptions = {
                            magFilter: it.LinearFilter,
                            minFilter: it.LinearMipMapLinearFilter,
                            wrapS: it.ClampToEdgeWrapping,
                            wrapT: it.ClampToEdgeWrapping,
                            format: it.RgbaFormat,
                            generateMipmaps: !0,
                            flipY: !0,
                            premultiplyAlpha: !0,
                            type: it.UnsignedByte,
                        });
                    class nt {
                        constructor(e = {}) {
                            (this._texture = null),
                                (this._glContext = null),
                                (this._frameBuffer = null),
                                (this._depthBuffer = null),
                                (this.options = Object.assign({}, nt.defaultOptions, e)),
                                (this._texture = new it(null, this.options));
                        }
                        bind(e) {
                            return (
                                this._frameBuffer || this._prepare(e),
                                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer),
                                this
                            );
                        }
                        unbind(e) {
                            return e.bindFramebuffer(e.FRAMEBUFFER, null), this;
                        }
                        remove() {
                            return this._unprepare(), this;
                        }
                        setSize(e) {
                            return (this.options.size = e), this._unprepare(), this;
                        }
                        getTexture() {
                            return this._texture;
                        }
                        getDepthBuffer() {
                            return this._depthBuffer;
                        }
                        _prepare(e) {
                            if (
                                ((this._glContext = e),
                                this._texture || (this._texture = new it(null, this.options)),
                                this._texture.prepare(e),
                                (this._frameBuffer = e.createFramebuffer()),
                                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer),
                                e.framebufferTexture2D(
                                    e.FRAMEBUFFER,
                                    e.COLOR_ATTACHMENT0,
                                    e.TEXTURE_2D,
                                    this._texture.getTexture(),
                                    0,
                                ),
                                this.options.depthTexture)
                            ) {
                                const t = (this._depthBuffer = new it(null, {
                                    magFilter: it.NearestFilter,
                                    minFilter: it.NearestFilter,
                                    format: it.DepthComponentFormat,
                                    size: this.options.size,
                                    premultiplyAlpha: !1,
                                    generateMipmaps: !1,
                                    type: it.UnsignedInt,
                                }));
                                t.prepare(e),
                                    e.framebufferTexture2D(
                                        e.FRAMEBUFFER,
                                        e.DEPTH_ATTACHMENT,
                                        e.TEXTURE_2D,
                                        t.getTexture(),
                                        0,
                                    );
                            } else
                                (this._depthBuffer = e.createRenderbuffer()),
                                    e.bindRenderbuffer(e.RENDERBUFFER, this._depthBuffer),
                                    e.renderbufferStorage(
                                        e.RENDERBUFFER,
                                        e.DEPTH_COMPONENT16,
                                        this.options.size[0],
                                        this.options.size[1],
                                    ),
                                    e.framebufferRenderbuffer(
                                        e.FRAMEBUFFER,
                                        e.DEPTH_ATTACHMENT,
                                        e.RENDERBUFFER,
                                        this._depthBuffer,
                                    );
                            this._checkComplete(e),
                                e.bindRenderbuffer(e.RENDERBUFFER, null),
                                e.bindFramebuffer(e.FRAMEBUFFER, null);
                        }
                        _unprepare() {
                            this._texture && (this._texture.remove(), (this._texture = null)),
                                this._glContext &&
                                    this._depthBuffer &&
                                    (this._depthBuffer instanceof it
                                        ? this._depthBuffer.remove()
                                        : this._glContext.deleteRenderbuffer(this._depthBuffer),
                                    (this._depthBuffer = null)),
                                this._glContext &&
                                    this._frameBuffer &&
                                    (this._glContext.deleteFramebuffer(this._frameBuffer),
                                    (this._frameBuffer = null));
                        }
                        _checkComplete(e) {
                            const t = e.checkFramebufferStatus(e.FRAMEBUFFER);
                            t !== e.FRAMEBUFFER_COMPLETE &&
                                (t === e.FRAMEBUFFER_UNSUPPORTED
                                    ? console.log('Framebuffer is unsupported')
                                    : t === e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT
                                    ? console.log('Framebuffer incomplete attachment')
                                    : t === e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS
                                    ? console.log('Framebuffer incomplete dimensions')
                                    : t === e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
                                    ? console.log('Framebuffer incomplete missing attachment')
                                    : console.log(`Unexpected framebuffer status: ${t}`));
                        }
                    }
                    nt.defaultOptions = Object.assign({}, it.defaultOptions, {
                        size: [0, 0],
                        generateMipmaps: !1,
                        depthTexture: !1,
                    });
                    var ot = i(878),
                        rt = i(6273);
                    const { wallMinBrightness: st, wallMaxBrightness: at } = I.floors,
                        { lightIntensity: lt } = I.fences,
                        ct = [lt, lt, lt],
                        dt = [0.05, 0.05, 0.05],
                        ht = [0.1, 0.1, 0.1],
                        ut = [1, 1, 1, 1],
                        mt = (e, t, i) => {
                            const { size: n } = i,
                                o = window.devicePixelRatio;
                            t.bind(e, { u_vec2_vpt_size: [n[0] * o, n[1] * o] });
                        },
                        ft = (e, t, i, n) => {
                            const { size: o } = i,
                                r = window.devicePixelRatio;
                            if (i.demMode) {
                                const i = n.renderer.getFramebuffer(
                                    n.demManager.getFlatFramebufferId(),
                                );
                                if (!i) return;
                                t.bind(e, {
                                    u_vec2_vpt_size: [
                                        Math.trunc(i.renderTarget.options.size[0]),
                                        Math.trunc(i.renderTarget.options.size[1]),
                                    ],
                                });
                            } else t.bind(e, { u_vec2_vpt_size: [o[0] * r, o[1] * r] });
                        },
                        pt = (e, t, i) => {
                            const n = (0, L.EO)(i.zoom);
                            t.bind(e, {
                                u_vec3_projection_scale_style_scale_dpi: [
                                    n,
                                    n,
                                    rt.$U * window.devicePixelRatio,
                                ],
                            });
                        },
                        _t = (e, t, i) => {
                            const n = (0, L.EO)(i.styleZoom);
                            t.bind(e, {
                                u_vec3_projection_scale_style_scale_dpi: [
                                    n,
                                    n,
                                    rt.$U * window.devicePixelRatio,
                                ],
                            });
                        },
                        vt = (e, t, i, n) => {
                            t.bind(e, {
                                u_float_height_factor:
                                    n.buildingHeightAnimator.getDefaultBuildingHeight(),
                            });
                        },
                        gt = (e, t, i) => {
                            t.bind(e, {
                                u_float_height_limitation:
                                    i.pitch >= i.pitchHightLimitation
                                        ? rt._9
                                        : (0, L.r9)(i.zoom, i.size) *
                                          Math.cos(i.pitch) *
                                          0.75 *
                                          rt.gt,
                                u_float_tile_height: rt._9,
                            });
                        },
                        yt = (e, t) => {
                            t.bind(e, {
                                u_float_height_limitation: rt._9,
                                u_float_tile_height: rt._9,
                            });
                        },
                        bt = (e, t, i, n) => {
                            const o = n.styleManager.getStyle(i.handyStyleId);
                            if (!o) return !1;
                            t.bind(e, {
                                u_vec3_light_direction: o.light.direction,
                                u_vec3_ambient_color: o.light.ambientColor.value,
                            });
                        },
                        wt = (e, t) => {
                            t.bind(e, { u_vec3_light_color: dt });
                        },
                        xt = (e, t) => {
                            t.bind(e, { u_vec3_light_color: ht });
                        },
                        St = (e, t) => {
                            t.bind(e, { u_vec3_light_color: ct });
                        },
                        It = (e, t) => {
                            t.bind(e, { u_float_border_width_offset: 1 / window.devicePixelRatio });
                        },
                        Mt = (e, t) => {
                            t.bind(e, { u_float_z_offset: 0 });
                        },
                        Tt = (e, t) => {
                            t.bind(e, { u_float_z_offset: -1e-5 });
                        },
                        Pt = (e, t, i) => {
                            t.bind(e, { u_float_z_offset: -5e-7 * Math.pow(2, i.styleZoom - 15) });
                        },
                        Lt = (e, t) => {
                            t.bind(e, { u_sr2d_texture: 0 });
                        },
                        kt = (e, t) => {
                            t.bind(e, { u_vec2_scale_limits: [0, rt.ax] });
                        },
                        Et = (e, t, i, n) => {
                            if (!i.enableFog) return !1;
                            const o = n.styleManager.getStyle(i.handyStyleId);
                            let r = ut,
                                s = ut;
                            if (o) {
                                const e = (0, $.jJ)(i.styleZoom, i.styleState, []);
                                (r = (0, $.m2)((0, $.zn)(o.environment.style.fogColor, e))),
                                    (s = (0, $.m2)((0, $.zn)(o.environment.style.highColor, e)));
                            }
                            t.bind(e, {
                                u_fog_color: r,
                                u_fog_high_color: s,
                                u_cam_pos: n.camera.position,
                                u_fog_limits: n.environmentManager.fogLimits,
                                u_fog_horizon_blend: n.environmentManager.fogHorizonBlend,
                            });
                        },
                        At = (e, t, i, { assetManager: n }) => {
                            n.textures.forEach((t) => t.enable(e));
                        };
                    function zt(...e) {
                        return (t, i, n, o) => {
                            e.forEach((e) => e(t, i, n, o));
                        };
                    }
                    var Ct = i(3338),
                        Ft = i(4713);
                    class Ot {
                        constructor(e, t = {}) {
                            (this._buffer = e),
                                (this.options = Object.assign({}, Ft.l.defaultOptions, t));
                        }
                        bind(e, t, i, n) {
                            this._buffer.bind(e, t, i || this.options, n);
                        }
                    }
                    var Dt = i(6263),
                        Rt = i(749),
                        jt = i(4922),
                        Bt = i(1678),
                        Nt = i(8965),
                        Ut = i(8394),
                        Zt = i(3642);
                    const Ht = (e, t) => new Xe(t, {}),
                        Gt = (e, t) => {
                            const i = new Ot(e, {
                                itemSize: 2,
                                dataType: Ft.l.UnsignedShort,
                                stride: 8,
                                offset: 0,
                                normalized: !0,
                            });
                            return new Xe(t, { a_vec2_vertex: i });
                        },
                        Vt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 8,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 8,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec2_vertex: i, a_vec2_texcoord: n });
                        },
                        Wt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 8,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 8,
                                    offset: 4,
                                    normalized: !0,
                                });
                            return new Xe(t, { a_vec2_vertex: i, a_vec4_identifier: n });
                        },
                        qt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 12,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: 12,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec2_vertex: i, a_vec4_normals: n });
                        },
                        $t = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 16,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: 16,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Float,
                                    stride: 16,
                                    offset: 8,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec2_vertex: i,
                                a_vec4_normals: n,
                                a_vec2_shift: o,
                            });
                        },
                        Xt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 12,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: 12,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 12,
                                    offset: 8,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec2_vertex: i,
                                a_vec4_normals: n,
                                a_vec4_identifier: o,
                            });
                        },
                        Yt = (e, t) => {
                            const i = 28,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                a = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                l = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 20,
                                    normalized: !1,
                                }),
                                c = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: i,
                                    offset: 24,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec2_vertex: n,
                                a_vec2_texture_widen: r,
                                a_vec2_widen: o,
                                a_float_vertex_distance: s,
                                a_float_component_distance: a,
                                a_float_object_length: l,
                                a_vec4_identifier: c,
                            });
                        },
                        Kt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 28,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 28,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 28,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 28,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 28,
                                    offset: 24,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec4_position: i,
                                a_vec2_check_offset: o,
                                a_vec2_offset: n,
                                a_vec2_texcoord: r,
                                a_vec4_tex_identifier: s,
                            });
                        },
                        Jt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 28,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 28,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 28,
                                    offset: 20,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec4_position: i,
                                a_vec2_offset: n,
                                a_vec4_identifier: o,
                            });
                        },
                        Qt = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 28,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 28,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Float,
                                    stride: 28,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Float,
                                    stride: 28,
                                    offset: 20,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec4_position: i,
                                a_vec2_offset: o,
                                a_vec2_texcoord: n,
                                a_vec2_style_zoom_limits: r,
                            });
                        },
                        ei = (e, t) => {
                            const i = Nt.j.sinks.fill.stride,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 11,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: n,
                                a_vec3_normal: o,
                                a_float_gradient: r,
                            });
                        },
                        ti = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 24,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Byte,
                                    stride: 24,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 24,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: i,
                                a_vec3_normal: n,
                                a_vec2_dem_position: o,
                            });
                        },
                        ii = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 24,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 24,
                                    offset: 12,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 24,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: i,
                                a_vec4_identifier: n,
                                a_vec2_dem_position: o,
                            });
                        },
                        ni = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 24,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 24,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 24,
                                    offset: 20,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: i,
                                a_vec4_identifier: o,
                                a_vec2_dem_position: n,
                            });
                        },
                        oi = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 20,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Byte,
                                    stride: 20,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 20,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: i,
                                a_vec3_normal: n,
                                a_vec2_dem_position: o,
                            });
                        },
                        ri = (e, t) => {
                            const i = 20,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 6,
                                    normalized: !0,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 10,
                                    normalized: !1,
                                }),
                                a = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                l = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec4_vertex: n,
                                a_vec2_normal: r,
                                a_vec2_normal_delta: s,
                                a_vec3_direction: a,
                                a_float_distance: o,
                                a_vec2_dem_position: l,
                            });
                        },
                        si = (e, t) => {
                            const i = 32,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                a = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 20,
                                    normalized: !1,
                                }),
                                l = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: i,
                                    offset: 28,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec3_position: n,
                                a_vec2_offset: o,
                                a_vec2_check_offset: r,
                                a_vec2_texcoord: s,
                                a_vec2_range: a,
                                a_vec4_tex_identifier: l,
                            });
                        },
                        ai = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 32,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 32,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 32,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 32,
                                    offset: 20,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 32,
                                    offset: 24,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec3_position: i,
                                a_vec2_offset: n,
                                a_vec2_texcoord: o,
                                a_vec2_range: r,
                                a_vec4_identifier: s,
                            });
                        },
                        li = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 16,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 16,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 16,
                                    offset: 12,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec4_position: i,
                                a_vec2_offset: n,
                                a_vec4_identifier: o,
                            });
                        },
                        ci = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 12,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: 12,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: 12,
                                    offset: 10,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec2_position: i,
                                a_vec2_direction: n,
                                a_vec2_widen_direction: o,
                            });
                        },
                        di = (e, t) => {
                            const i = Bt.X.sinks.fill.stride,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: n,
                                a_vec2_texcoord: o,
                                a_vec2_dem_position: r,
                            });
                        },
                        hi = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 8,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: 8,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec3_vertex: i, a_vec4_direction_distance: n });
                        },
                        ui = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 16,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: 16,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 16,
                                    offset: 12,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: i,
                                a_vec4_direction_distance: n,
                                a_vec2_dem_position: o,
                            });
                        },
                        mi = (e, t) => {
                            const i = 36,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 4,
                                    normalized: !0,
                                }),
                                r = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                a = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                }),
                                l = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 20,
                                    normalized: !1,
                                }),
                                c = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 24,
                                    normalized: !1,
                                }),
                                d = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 28,
                                    normalized: !1,
                                }),
                                h = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: i,
                                    offset: 32,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec2_vertex: n,
                                a_vec2_segment_end: o,
                                a_vec4_texture_widen_arrow_widen: r,
                                a_vec2_widen: s,
                                a_vec2_direction: a,
                                a_float_distance_from_start: l,
                                a_float_object_length: c,
                                a_float_type: d,
                                a_vec4_identifier: h,
                            });
                        },
                        fi = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 12,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 12,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec4_vertex: i, a_vec2_widen: n });
                        },
                        pi = (e, t) => {
                            const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 12,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: 12,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: 12,
                                    offset: 8,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec4_vertex: i,
                                a_vec2_widen: n,
                                a_vec4_identifier: o,
                            });
                        },
                        _i = (e, t) => {
                            const i = Dt.h.sinks.fill.stride,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec2_vertex: n, a_vec2_texcoord: o });
                        },
                        vi = (e, t) => {
                            const i = Rt.B.sinks.framebuffer.stride,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec2_position: n,
                                a_vec2_widen: r,
                                a_float_weight: o,
                            });
                        },
                        gi = (e, t) => {
                            const i = new Ot(e, {
                                itemSize: 2,
                                dataType: Ft.l.Float,
                                stride: 0,
                                offset: 0,
                                normalized: !1,
                            });
                            return new Xe(t, { a_vec2_position: i });
                        },
                        yi = (e, t) => new Xe(t, { a_vec2_position: e }),
                        bi = (e, t) => {
                            const i = jt._.sinks.elevation.stride,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec2_vertex: n, a_vec2_texcoord: o });
                        },
                        wi = (e, t) => {
                            const i = jt._.sinks.flatBottom.stride,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 8,
                                    normalized: !0,
                                });
                            return new Xe(t, {
                                a_vec2_vertex: n,
                                a_vec2_centroid: o,
                                a_vec2_extender: r,
                            });
                        },
                        xi = (e, t) => {
                            const i = jt._.sinks.hillshade.stride,
                                n = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 4,
                                    normalized: !1,
                                });
                            return new Xe(t, { a_vec2_vertex: n, a_vec2_texcoord: o });
                        },
                        Si = (e, t) => new Xe(t, {}),
                        Ii = (e, t) => {
                            const i = Ut.m.sinks.instances.stride,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                    instanceDivisor: 1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 8,
                                    instanceDivisor: 1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 20,
                                    instanceDivisor: 1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: i,
                                    offset: 36,
                                    normalized: !0,
                                    instanceDivisor: 1,
                                });
                            return new Xe(t, {
                                a_vec3_instance_position: n,
                                a_vec3_instance_scale: o,
                                a_vec4_instance_rotation: r,
                                a_vec4_instance_localid: s,
                            });
                        },
                        Mi = (e, t) => {
                            const i = Ut.m.sinks.instances.stride,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                    instanceDivisor: 1,
                                }),
                                o = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 8,
                                    instanceDivisor: 1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.Float,
                                    stride: i,
                                    offset: 20,
                                    instanceDivisor: 1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 4,
                                    dataType: Ft.l.UnsignedByte,
                                    stride: i,
                                    offset: 40,
                                    normalized: !0,
                                    instanceDivisor: 1,
                                });
                            return new Xe(t, {
                                a_vec3_instance_position: n,
                                a_vec3_instance_scale: o,
                                a_vec4_instance_rotation: r,
                                a_vec4_instance_localid: s,
                            });
                        },
                        Ti = (e, t) => {
                            const i = Zt._.sinks.fill.stride,
                                n = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: i,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                o = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 8,
                                    normalized: !1,
                                }),
                                r = new Ot(e, {
                                    itemSize: 3,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 12,
                                    normalized: !1,
                                }),
                                s = new Ot(e, {
                                    itemSize: 1,
                                    dataType: Ft.l.Byte,
                                    stride: i,
                                    offset: 15,
                                    normalized: !1,
                                }),
                                a = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Short,
                                    stride: i,
                                    offset: 16,
                                    normalized: !1,
                                });
                            return new Xe(t, {
                                a_vec3_vertex: n,
                                a_vec2_extender: o,
                                a_vec3_normal: r,
                                a_float_gradient: s,
                                a_vec2_dem_position: a,
                            });
                        };
                    var Pi = i(132);
                    const Li = 32,
                        ki = 1 / 0;
                    class Ei extends C.Y {
                        constructor(e, t, i, n) {
                            var o, r;
                            super('raster', e), (this.children = []), (this.identifyChildren = []);
                            const s = this;
                            this.setTileCoords(e),
                                null ===
                                    (r =
                                        null === (o = t.renderer.symbolSettingsList.dem) ||
                                        void 0 === o
                                            ? void 0
                                            : o[n]) ||
                                    void 0 === r ||
                                    r.forEach((e) => {
                                        const o = {
                                            id: (0, E.f)(),
                                            type: ot.H.Tile,
                                            symbol: 'dem',
                                            sink: n,
                                            tile: this,
                                            attributes: {
                                                layerId: Pi.he,
                                                styleId: t.map.state.handyStyleId,
                                                tileData: [],
                                            },
                                            stride: 4,
                                            rangeStart: 0,
                                            rangeEnd: 24576,
                                            attributesHash: '',
                                            layerSettings: e,
                                            vao: i[n],
                                        };
                                        e.identify
                                            ? s.identifyChildren.push(o)
                                            : e.depthTest
                                            ? s.depthTestChildren.push(o)
                                            : s.children.push(o);
                                    });
                        }
                        setTileCoords(e) {
                            const t = e[2],
                                i = e[3],
                                n = (0, G.aq)(t),
                                o = n / Li;
                            (this.coords = e),
                                (this.size = n),
                                (this.zoomLevel = t),
                                (this.detailLevel = i);
                            const r = (0, G.Oy)(e);
                            (r[0] -= o),
                                (r[1] -= o),
                                (this.bounds.min = [r[0], r[1]]),
                                (this.bounds.max = [r[0] + n, r[1] + n]),
                                $e.wA(this.modelMatrix, r, D.al(n + o, n + o, rt._9));
                        }
                    }
                    class Ai {
                        constructor(e, t) {
                            var i;
                            (this.meshTiles = new Map()),
                                (this.groundTiles = new Map()),
                                (this.destroyed = !1),
                                (this.modules = e.modules),
                                (this.maxZoom =
                                    null !== (i = null == t ? void 0 : t.maxZoom) && void 0 !== i
                                        ? i
                                        : ki);
                            const n = [];
                            for (let e = 0; e < Li; e++)
                                for (let t = 0; t < Li; t++)
                                    n.push(t, e, t + 1, e, t, e + 1),
                                        n.push(t, e + 1, t + 1, e, t + 1, e + 1);
                            const o = rt._H / Li;
                            for (let e = 0; e < n.length; e++) n[e] *= o;
                            (this.buffer = new Ft.l(new Uint16Array(n), {
                                itemSize: 2,
                                dataType: Ft.l.UnsignedShort,
                                stride: 0,
                                offset: 0,
                                normalized: !0,
                            })),
                                (this.buffer.drawType = Ft.l.StaticDraw),
                                (this.vaos = {
                                    mesh: yi(
                                        this.buffer,
                                        this.modules.renderer.getShaderProgram('demMesh'),
                                    ),
                                    ground: yi(
                                        this.buffer,
                                        this.modules.renderer.getShaderProgram('demGround'),
                                    ),
                                }),
                                this.update();
                        }
                        destroy() {
                            this.destroyed ||
                                ((this.meshTiles = new Map()),
                                (this.groundTiles = new Map()),
                                Object.values(this.vaos).forEach((e) => {
                                    e.unbind(), e.remove();
                                }),
                                this.buffer.remove(),
                                (this.destroyed = !0));
                        }
                        setMaxZoom(e = Infinity) {
                            e !== this.maxZoom && ((this.maxZoom = e), this.update());
                        }
                        update() {
                            if (this.destroyed) return;
                            const e = this.modules.map.state,
                                t = Math.trunc(e.styleZoom),
                                i = Math.min(t, Math.min(this.maxZoom, t)),
                                n = (0, G.b5)(this.modules.map.state, i, 0, i).reduce(
                                    (e, t) => (e.set((0, G.gx)(t), t), e),
                                    new Map(),
                                );
                            this.meshTiles.forEach((e, t) => {
                                n.has(t) || (this.meshTiles.delete(t), this.groundTiles.delete(t));
                            }),
                                n.forEach((e, t) => {
                                    this.meshTiles.has(t) ||
                                        (this.meshTiles.set(
                                            t,
                                            new Ei(e, this.modules, this.vaos, 'mesh'),
                                        ),
                                        this.groundTiles.set(
                                            t,
                                            new Ei(e, this.modules, this.vaos, 'ground'),
                                        ));
                                });
                        }
                        updateStyleId() {
                            this.meshTiles.forEach((e) => this.updateTileStyleId(e)),
                                this.groundTiles.forEach((e) => this.updateTileStyleId(e));
                        }
                        updateTileStyleId(e) {
                            e.children.forEach((e) => {
                                e.attributes.styleId = this.modules.map.state.handyStyleId;
                            }),
                                e.identifyChildren.forEach((e) => {
                                    e.attributes.styleId = this.modules.map.state.handyStyleId;
                                }),
                                e.depthTestChildren.forEach((e) => {
                                    e.attributes.styleId = this.modules.map.state.handyStyleId;
                                });
                        }
                    }
                    var zi = i(7123),
                        Ci = i(2398),
                        Fi = i(2618),
                        Oi = i(267);
                    const Di = new Fi.TD('main').getPacked(),
                        Ri = 64;
                    class ji {
                        constructor(e, t, i) {
                            (this.id = e),
                                (this.modules = t),
                                (this.options = i),
                                (this.type = 'dem'),
                                (this.tree = zi()),
                                (this.minElevation = 0),
                                (this.revision = 0),
                                (this.tileLoader = new Ci.U('arrayBuffer')),
                                (this.attributes = {}),
                                (this.tiles = new Map()),
                                (this.textureIndices = new Map()),
                                (this.url = (e) => {
                                    const [t, i, n] = (0, G._W)(e);
                                    return this.options.url(t, i, n);
                                });
                        }
                        abortTileFetch(e) {
                            this.tileLoader.abortRequest((0, G.gx)(e));
                        }
                        deleteTile(e) {
                            const t = (0, G.gx)(e);
                            if (this.tiles.get(t)) {
                                const i = (0, G.Sl)(e);
                                this.tree.remove(
                                    {
                                        minX: i.min[0],
                                        minY: i.min[1],
                                        maxX: i.max[0],
                                        maxY: i.max[1],
                                    },
                                    (e, i) => t === i.key,
                                ),
                                    this.updateRevision();
                            }
                            this.tiles.delete(t), this.updateMinElevation();
                        }
                        fetchTile(e) {
                            const t = (0, G.gx)(e),
                                i = [{ regionId: 0, metatileHash: -1 }];
                            if (this.tiles.has(t)) return Promise.resolve(i);
                            const n = this.url(e);
                            return this.tileLoader
                                .fetch(e, () => n)
                                .then(
                                    (n) => (
                                        n.rejected ||
                                            (this.tiles.set(
                                                t,
                                                n.data && n.data.byteLength
                                                    ? this.tileDataToFloat32Array(n.data, e)
                                                    : void 0,
                                            ),
                                            this.updateRevision()),
                                        i
                                    ),
                                    () => Promise.resolve(void 0),
                                );
                        }
                        generateTile(e, t, i, n, o, r) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const e = [],
                                    i = [],
                                    n = (0, G.gx)(t),
                                    o = this.tiles.get(n);
                                if (!o) return Promise.resolve({ results: e, transferable: i });
                                let r = this.textureIndices.get(n);
                                if (void 0 === r) {
                                    const e = (0, G.aq)(t[2]),
                                        i = (0, G.Sl)(t);
                                    this.tree.insert(
                                        Object.assign(
                                            {
                                                key: n,
                                                minX: i.min[0],
                                                minY: i.min[1],
                                                maxX: i.max[0],
                                                maxY: i.max[1],
                                                cellSize: e / Ri,
                                            },
                                            o,
                                        ),
                                    ),
                                        this.updateMinElevation();
                                    const s = this.modules.renderer.getRenderingContext(),
                                        a = new it(o.data, {
                                            size: [Ri, Ri],
                                            format: it.AlphaFormat,
                                            type: it.Float,
                                            flipY: !0,
                                            magFilter: it.LinearFilter,
                                            minFilter: it.LinearFilter,
                                        }).prepare(s);
                                    (r = this.modules.imageManager.addPreparedTexture(a)),
                                        this.textureIndices.set(n, r);
                                }
                                const s = this.modules.map.state.handyStyleId,
                                    a = 0.0078125,
                                    l = [
                                        [0, 0, 0 + a, 0 + a],
                                        [1, 0, 1 - a, 0 + a],
                                        [0, 1, 0 + a, 1 - a],
                                        [0, 1, 0 + a, 1 - a],
                                        [1, 0, 1 - a, 0 + a],
                                        [1, 1, 1 - a, 1 - a],
                                    ],
                                    c = jt._.generateElevation(
                                        this.modules.collector,
                                        l,
                                        s,
                                        Pi.he,
                                        r,
                                    );
                                return (
                                    e.push({
                                        regionId: 0,
                                        metatileHash: -1,
                                        styleId: s,
                                        collectorOutput: {
                                            data: [c],
                                            labels: [],
                                            geoIds: new Uint32Array(),
                                            floorHidingMap: [],
                                            rastersToLoad: new Float64Array(),
                                            modelsToLoad: new Int32Array(),
                                            transferable: [],
                                            identifyIds: Di,
                                        },
                                    }),
                                    Promise.resolve({ results: e, transferable: i })
                                );
                            });
                        }
                        tileDataToFloat32Array(e, t) {
                            const [i, n, o, r] = t,
                                s = new Uint8Array(e),
                                a = new Float32Array(Math.pow(Ri, 2));
                            let l = 1 / 0,
                                c = -1 / 0;
                            for (let e = 0; e < Ri; e++) {
                                const t = (0, M.projectMapToGeo)(
                                        (0, G.Oy)([i, n + 0.015625 * e, o, r]),
                                    ),
                                    d = (0, L.Xg)(t[1]);
                                for (let t = 0; t < Ri; t++) {
                                    const i = t + e * Ri,
                                        n = (s[i] + 256 * s[Math.pow(Ri, 2) + i] - 1e4) * d;
                                    (l = Math.min(n, l)), (c = Math.max(n, c)), (a[i] = n);
                                }
                            }
                            return {
                                data: a,
                                minZ: l,
                                maxZ: c,
                                bounds: { min: (0, G.Oy)(t), max: (0, G.Oy)([i + 1, n + 1, o, r]) },
                            };
                        }
                        getAttributes() {
                            return this.attributes;
                        }
                        setAttributes(e) {
                            this.attributes = e;
                        }
                        getId() {
                            return this.id;
                        }
                        destroy() {
                            const { imageManager: e } = this.modules;
                            this.tileLoader.destroy(),
                                this.tiles.clear(),
                                this.tree.clear(),
                                this.textureIndices.forEach((t) => e.deleteTexture(t)),
                                this.textureIndices.clear();
                        }
                        getElevation(e) {
                            const t = this.getElevationTile(e);
                            if (t)
                                return (function (e, t) {
                                    if (e.data) {
                                        const i = (0, fe.uZ)((t[0] - e.minX) / e.cellSize, 0, 63),
                                            n = (0, fe.uZ)((t[1] - e.minY) / e.cellSize, 0, 63),
                                            o = Math.trunc(i),
                                            r = Math.trunc(n),
                                            s = Math.min(o + 1, 63),
                                            a = Math.min(r + 1, 63),
                                            l = z.t7(
                                                [],
                                                [e.data[Bi(r) * Ri + o], e.data[Bi(a) * Ri + o]],
                                                [e.data[Bi(r) * Ri + s], e.data[Bi(a) * Ri + s]],
                                                i % 1,
                                            );
                                        return (0, fe.t7)(l[0], l[1], n % 1);
                                    }
                                })(t, e);
                        }
                        getElevationTile(e) {
                            return this.tree
                                .search({ minX: e[0], minY: e[1], maxX: e[0], maxY: e[1] })
                                .reduce((e, t) => (!e || e.cellSize > t.cellSize ? t : e), void 0);
                        }
                        getMinElevation() {
                            return this.minElevation;
                        }
                        updateMinElevation() {
                            const e = this.modules.map.state;
                            if (!e.demMode) return;
                            const t = this.modules.camera.position[2],
                                i = (0, Oi.BS)(e.tilesBounds);
                            if (void 0 !== e.elevation) {
                                const n = (e.elevation * L.C) / t + 1,
                                    o = Math.max((e.pitch / e.maxPitch) * 30, 4);
                                (0, ee.bA)(i, Math.min(n, o));
                            }
                            const n = this.tree.search({
                                minX: i.min[0],
                                minY: i.min[1],
                                maxX: i.max[0],
                                maxY: i.max[1],
                            });
                            e.styleZoom - En > 1
                                ? (this.minElevation = n.reduce((e, t) => {
                                      if (t.data) {
                                          const n = (0, ee.jV)(i, t.bounds);
                                          z.lu(n.min, n.min, t.bounds.min),
                                              z.lu(n.max, n.max, t.bounds.min),
                                              z.bA(n.min, n.min, 1 / t.cellSize),
                                              z.bA(n.max, n.max, 1 / t.cellSize);
                                          for (let i = Math.trunc(n.min[0]); i < n.max[0]; i++)
                                              for (
                                                  let o = Math.trunc(n.min[1]);
                                                  o < n.max[1];
                                                  o++
                                              ) {
                                                  const n = i + o * Ri,
                                                      r = t.data[n];
                                                  e = void 0 === e ? r : Math.min(e, r);
                                              }
                                      }
                                      return e;
                                  }, void 0))
                                : (this.minElevation = n.reduce(
                                      (e, t) => (void 0 === e ? t.minZ : Math.min(e, t.minZ)),
                                      void 0,
                                  ));
                        }
                        getRevision() {
                            return this.revision;
                        }
                        updateRevision() {
                            this.revision++;
                        }
                    }
                    function Bi(e) {
                        return 63 - e;
                    }
                    var Ni = i(314),
                        Ui = i(3698),
                        Zi = i(1245),
                        Hi = i(4874),
                        Gi = i(2539);
                    const Vi = new Float64Array(16);
                    class Wi {
                        constructor(e, t, i) {
                            (this.detailLevel = 0),
                                (this.mvpMatrix = new Float64Array(16)),
                                (this.texMatrix = new Float64Array(16)),
                                $e.JG(this.mvpMatrix, e),
                                $e.Jp(this.texMatrix, L.LX, e),
                                (this.detailLevel = i),
                                (this.viewport = [
                                    [0, 0, 0, 1],
                                    [1, 0, 0, 1],
                                    [1, 1, 0, 1],
                                    [0, 1, 0, 1],
                                ]),
                                $e.U_(Vi, this.texMatrix),
                                this.viewport.forEach((e) => {
                                    D.fF(e, e, Vi),
                                        (e[0] -= t[0]),
                                        (e[1] -= t[1]),
                                        (e[2] -= t[2]),
                                        e[2] >= 0 && (e[2] = -1),
                                        D.Fv(e, e);
                                    const i = -t[2] / e[2];
                                    (e[0] = t[0] + e[0] * i),
                                        (e[1] = t[1] + e[1] * i),
                                        (e[2] = t[2] + e[2] * i);
                                });
                        }
                    }
                    class qi {
                        constructor(e) {
                            (this.destroyed = !1), (this.modules = e.modules), (this.textures = []);
                        }
                        update() {
                            if (this.destroyed) return;
                            const {
                                    center: e,
                                    padding: t,
                                    rotation: i,
                                    size: n,
                                    viewport: o,
                                    demTilesBounds: r,
                                    zoom: s,
                                } = this.modules.map.state,
                                a = (0, Gi.hS)(r[0], r[1]),
                                l = (0, Gi.Oy)(r[2], a);
                            this.textures = [];
                            const c = (0, fe.Id)(45),
                                d = Math.min(this.modules.map.state.pitch, c),
                                h = new Hi.V({
                                    pitch: d,
                                    center: e,
                                    padding: t,
                                    rotation: i,
                                    size: n,
                                    viewport: o,
                                    zoom: s,
                                }),
                                u = (0, fe.uZ)(Math.pow(this.modules.map.state.pitch / c, 3), 0, 1),
                                [m, f] = this.modules.camera.position,
                                p = Zi.fF([], [m, f, 0, 1], h.viewProjectionMatrix),
                                _ = Math.min(p[1] / p[3] + 1, -0.5);
                            let v = Math.max(_, -1);
                            if (
                                ($e.wA(Vi, [0, -v, 0], [1 / zn[0], 1 / zn[1], 1]),
                                $e.Jp(Vi, Vi, h.viewProjectionMatrix),
                                this.textures.push(new Wi(Vi, h.position, 0)),
                                (0, Gi.Oy)(this.textures[0].viewport[2], a) >= l)
                            )
                                return !0;
                            if (_ < v) {
                                const e = Math.max(Math.abs(_ - v) / 2, 1);
                                $e.wA(Vi, [0, 2 / e + 1, 0], [1 / zn[0], zn[1] / e, 1]),
                                    $e.Jp(Vi, Vi, h.viewProjectionMatrix),
                                    this.textures.push(new Wi(Vi, h.position, 1));
                            }
                            v += 1;
                            const g = Math.pow(n[1] / 749, 2);
                            [1.4, 3.2, 12, 31].some((e, t) => {
                                (e = (e - 1) * u * g + 1),
                                    $e.wA(Vi, [0, -(v * e + 1), 0], [1 / zn[0], e / zn[1], 1]),
                                    $e.Jp(Vi, Vi, h.viewProjectionMatrix),
                                    (v += 2 / e);
                                const i = this.textures.push(new Wi(Vi, h.position, t));
                                if ((0, Gi.Oy)(this.textures[i - 1].viewport[2], a) >= l) return !0;
                            });
                        }
                        destroy() {
                            this.textures = [];
                        }
                    }
                    var $i = i(6201);
                    const Xi =
                            null === window || void 0 === window
                                ? void 0
                                : window.WebGLRenderingContext,
                        Yi = {
                            depthMask: !0,
                            depthTest: !0,
                            depthFunc: Xi ? Xi.LESS : 0,
                            cullFace: !0,
                            cullFaceMode: Xi ? Xi.BACK : 0,
                            blend: !1,
                            blendFunc: { sfactor: Xi ? Xi.ONE : 0, dfactor: Xi ? Xi.ZERO : 0 },
                            colorMask: [!0, !0, !0, !0],
                            polygonOffsetFill: !1,
                            polygonOffset: { factor: 1, units: 2 },
                        },
                        Ki = (e) => Object.assign({}, Yi, e),
                        Ji = (e, t, i) => {
                            var n,
                                o,
                                r,
                                s,
                                a,
                                l,
                                c,
                                d,
                                h,
                                u,
                                m,
                                f,
                                p,
                                _,
                                v,
                                g,
                                y,
                                b,
                                w,
                                x,
                                S,
                                I,
                                M,
                                T,
                                P,
                                L,
                                k,
                                E,
                                A;
                            e.depthMask(
                                null !==
                                    (o =
                                        null === (n = null == i ? void 0 : i.webglState) ||
                                        void 0 === n
                                            ? void 0
                                            : n.depthMask) && void 0 !== o
                                    ? o
                                    : t.depthMask,
                            ),
                                (
                                    null !==
                                        (s =
                                            null === (r = null == i ? void 0 : i.webglState) ||
                                            void 0 === r
                                                ? void 0
                                                : r.depthTest) && void 0 !== s
                                        ? s
                                        : t.depthTest
                                )
                                    ? (e.enable(e.DEPTH_TEST),
                                      e.depthFunc(
                                          null !==
                                              (l =
                                                  null ===
                                                      (a = null == i ? void 0 : i.webglState) ||
                                                  void 0 === a
                                                      ? void 0
                                                      : a.depthFunc) && void 0 !== l
                                              ? l
                                              : t.depthFunc,
                                      ))
                                    : e.disable(e.DEPTH_TEST),
                                (
                                    null !==
                                        (d =
                                            null === (c = null == i ? void 0 : i.webglState) ||
                                            void 0 === c
                                                ? void 0
                                                : c.cullFace) && void 0 !== d
                                        ? d
                                        : t.cullFace
                                )
                                    ? (e.enable(e.CULL_FACE),
                                      e.cullFace(
                                          null !==
                                              (u =
                                                  null ===
                                                      (h = null == i ? void 0 : i.webglState) ||
                                                  void 0 === h
                                                      ? void 0
                                                      : h.cullFaceMode) && void 0 !== u
                                              ? u
                                              : t.cullFaceMode,
                                      ))
                                    : e.disable(e.CULL_FACE),
                                (
                                    null !==
                                        (f =
                                            null === (m = null == i ? void 0 : i.webglState) ||
                                            void 0 === m
                                                ? void 0
                                                : m.blend) && void 0 !== f
                                        ? f
                                        : t.blend
                                )
                                    ? (e.enable(e.BLEND),
                                      e.blendFunc(
                                          null !==
                                              (v =
                                                  null ===
                                                      (_ =
                                                          null ===
                                                              (p =
                                                                  null == i
                                                                      ? void 0
                                                                      : i.webglState) ||
                                                          void 0 === p
                                                              ? void 0
                                                              : p.blendFunc) || void 0 === _
                                                      ? void 0
                                                      : _.sfactor) && void 0 !== v
                                              ? v
                                              : t.blendFunc.sfactor,
                                          null !==
                                              (b =
                                                  null ===
                                                      (y =
                                                          null ===
                                                              (g =
                                                                  null == i
                                                                      ? void 0
                                                                      : i.webglState) ||
                                                          void 0 === g
                                                              ? void 0
                                                              : g.blendFunc) || void 0 === y
                                                      ? void 0
                                                      : y.dfactor) && void 0 !== b
                                              ? b
                                              : t.blendFunc.dfactor,
                                      ))
                                    : e.disable(e.BLEND);
                            const z =
                                null !==
                                    (x =
                                        null === (w = null == i ? void 0 : i.webglState) ||
                                        void 0 === w
                                            ? void 0
                                            : w.colorMask) && void 0 !== x
                                    ? x
                                    : t.colorMask;
                            e.colorMask(z[0], z[1], z[2], z[3]),
                                (
                                    null !==
                                        (I =
                                            null === (S = null == i ? void 0 : i.webglState) ||
                                            void 0 === S
                                                ? void 0
                                                : S.polygonOffsetFill) && void 0 !== I
                                        ? I
                                        : t.polygonOffsetFill
                                )
                                    ? (e.enable(e.POLYGON_OFFSET_FILL),
                                      e.polygonOffset(
                                          null !==
                                              (P =
                                                  null ===
                                                      (T =
                                                          null ===
                                                              (M =
                                                                  null == i
                                                                      ? void 0
                                                                      : i.webglState) ||
                                                          void 0 === M
                                                              ? void 0
                                                              : M.polygonOffset) || void 0 === T
                                                      ? void 0
                                                      : T.factor) && void 0 !== P
                                              ? P
                                              : t.polygonOffset.factor,
                                          null !==
                                              (E =
                                                  null ===
                                                      (k =
                                                          null ===
                                                              (L =
                                                                  null == i
                                                                      ? void 0
                                                                      : i.webglState) ||
                                                          void 0 === L
                                                              ? void 0
                                                              : L.polygonOffset) || void 0 === k
                                                      ? void 0
                                                      : k.units) && void 0 !== E
                                              ? E
                                              : t.polygonOffset.units,
                                      ))
                                    : e.disable(e.POLYGON_OFFSET_FILL),
                                null === (A = t.customStateBinder) || void 0 === A || A.call(t, e);
                        },
                        Qi = Ki({}),
                        en = Ki({
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        tn = Ki({
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                            depthFunc: Xi.GREATER,
                            depthMask: !1,
                            cullFace: !1,
                        }),
                        nn = Ki({
                            depthMask: !1,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        on = Ki({
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                            cullFace: !1,
                        }),
                        rn = Ki({
                            depthMask: !1,
                            depthTest: !1,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        sn = Ki({ depthMask: !1, depthTest: !1, colorMask: [!0, !1, !1, !0] }),
                        an = Ki({ depthMask: !1, depthTest: !1 }),
                        ln = Ki({ depthMask: !1 }),
                        cn = Ki({ colorMask: [!1, !1, !1, !1] }),
                        dn = Ki({
                            depthFunc: Xi.EQUAL,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        hn = Ki({
                            depthMask: !1,
                            depthTest: !1,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        un = Ki({
                            depthMask: !1,
                            depthTest: !0,
                            depthFunc: Xi.LEQUAL,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        mn = Ki({
                            depthMask: !1,
                            depthTest: !0,
                            depthFunc: Xi.GREATER,
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        fn = Ki({
                            polygonOffsetFill: !0,
                            polygonOffset: { factor: 1, units: 2 },
                            blend: !0,
                            blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE_MINUS_SRC_ALPHA },
                        }),
                        pn =
                            (Ki({ cullFace: !1 }),
                            Ki({
                                depthMask: !1,
                                depthTest: !1,
                                blend: !0,
                                blendFunc: { sfactor: Xi.ONE, dfactor: Xi.ONE },
                            })),
                        _n = Ki({ depthTest: !1, cullFace: !1 });
                    function vn(e) {
                        return !gn(e);
                    }
                    function gn(e) {
                        if ('undefined' == typeof window || 'undefined' == typeof document)
                            return 'not a browser';
                        if (!Boolean(Function.prototype && Function.prototype.bind))
                            return 'insufficient Function support';
                        if (!('JSON' in window && 'parse' in JSON && 'stringify' in JSON))
                            return 'insufficient JSON support';
                        if (
                            !(function () {
                                if (!('Worker' in window && 'Blob' in window && 'URL' in window))
                                    return !1;
                                const e = new Blob([''], { type: 'text/javascript' }),
                                    t = URL.createObjectURL(e);
                                let i,
                                    n = null;
                                try {
                                    (n = new Worker(t)), (i = !0);
                                } catch (e) {
                                    i = !1;
                                }
                                n && n.terminate();
                                return URL.revokeObjectURL(t), i;
                            })()
                        )
                            return 'insufficient worker support';
                        if (!ArrayBuffer.isView) return 'insufficient ArrayBuffer support';
                        if (
                            !(function () {
                                const e = document.createElement('canvas');
                                e.width = e.height = 1;
                                const t = e.getContext('2d');
                                if (!t) return !1;
                                const i = t.getImageData(0, 0, 1, 1);
                                return i && i.width === e.width;
                            })()
                        )
                            return 'insufficient Canvas/getImageData support';
                        const t = (function (e) {
                            const t = String(e);
                            void 0 === yn[t] &&
                                (yn[t] = (function (e) {
                                    const t = bn(e);
                                    if (!t) return { ok: !1, msg: 'error on get context' };
                                    for (const e of [
                                        'OES_element_index_uint',
                                        'OES_standard_derivatives',
                                        'OES_vertex_array_object',
                                    ])
                                        if (!t.getExtension(e))
                                            return {
                                                ok: !1,
                                                msg: `${e} extension is not supported`,
                                            };
                                    let i;
                                    try {
                                        i = t.createShader(t.VERTEX_SHADER);
                                    } catch (e) {
                                        return { ok: !1, msg: 'browser block shader API' };
                                    }
                                    if (!i || t.isContextLost()) return { ok: !1 };
                                    return (
                                        t.shaderSource(i, 'void main() {}'),
                                        t.compileShader(i),
                                        { ok: !0 === t.getShaderParameter(i, t.COMPILE_STATUS) }
                                    );
                                })(e));
                            return yn[t];
                        })((e && e.failIfMajorPerformanceCaveat) || !1);
                        return t.ok
                            ? Array.prototype &&
                              Array.prototype.every &&
                              Array.prototype.filter &&
                              Array.prototype.forEach &&
                              Array.prototype.indexOf &&
                              Array.prototype.map &&
                              Array.prototype.some &&
                              Array.prototype.reduce &&
                              Array.isArray
                                ? Boolean(
                                      Object.keys &&
                                          Object.assign &&
                                          Object.create &&
                                          Object.getPrototypeOf &&
                                          Object.getOwnPropertyNames &&
                                          Object.getOwnPropertyDescriptor &&
                                          Object.defineProperty &&
                                          Object.freeze,
                                  )
                                    ? (function () {
                                          const e = document.createElement('div');
                                          return e && 'function' == typeof e.after;
                                      })()
                                        ? document.documentMode
                                            ? 'insufficient ECMAScript 6 support'
                                            : void 0
                                        : 'insufficient DOM support'
                                    : 'insufficient Object support'
                                : 'insufficient Array support'
                            : 'insufficient WebGL support' + (t.msg ? `: ${t.msg}` : '');
                    }
                    const yn = {};
                    function bn(e) {
                        const t = document.createElement('canvas'),
                            i = { antialias: !1, stencil: !0, failIfMajorPerformanceCaveat: e };
                        return (
                            'WebGLRenderingContext' in window &&
                            (t.getContext('webgl', i) || t.getContext('experimental-webgl', i))
                        );
                    }
                    let wn;
                    function xn() {
                        return (wn = void 0), Sn(), wn;
                    }
                    function Sn() {
                        const e = new Float32Array([-1, -1, 1, -1, -1, 1]),
                            t = bn(!1);
                        if (!t) return (wn = 'Failed to obtain WebGL context'), !1;
                        for (const e of [
                            'OES_element_index_uint',
                            'OES_standard_derivatives',
                            'OES_vertex_array_object',
                            'OES_texture_float',
                            'OES_texture_float_linear',
                        ])
                            if (!t.getExtension(e)) return (wn = `Absent ${e} extension`), !1;
                        const i = new nt({ size: [2, 2] });
                        i.bind(t);
                        const n = new it(new Float32Array([1, 0, 1, 0]), {
                                size: [2, 2],
                                format: it.AlphaFormat,
                                type: it.Float,
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                            }).prepare(t),
                            o = t.createShader(t.VERTEX_SHADER),
                            r = t.createShader(t.FRAGMENT_SHADER);
                        if (!o || !r || t.isContextLost())
                            return (wn = 'Cannot create shaders'), !1;
                        t.shaderSource(
                            o,
                            'attribute vec2 pos;\n    void main () {\n        gl_Position = vec4(pos, 0, 1);\n    }',
                        ),
                            t.compileShader(o),
                            t.shaderSource(
                                r,
                                'precision mediump float;\n    uniform sampler2D tex;\n    void main () {\n        gl_FragColor = vec4(texture2D(tex, vec2(0.4, 0.4)).a, 0, 0, 0);\n    }',
                            ),
                            t.compileShader(r);
                        const s = t.createProgram();
                        if (!s) return (wn = 'Cannot compile shader program'), !1;
                        t.attachShader(s, o),
                            t.attachShader(s, r),
                            t.linkProgram(s),
                            t.useProgram(s);
                        const a = t.createBuffer();
                        if (!a) return (wn = 'Cannot create buffer'), !1;
                        t.bindBuffer(t.ARRAY_BUFFER, a),
                            t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW);
                        const l = t.getAttribLocation(s, 'pos');
                        t.vertexAttribPointer(l, 2, t.FLOAT, !1, 0, 0),
                            t.enableVertexAttribArray(l),
                            n.enable(t, 0);
                        const c = t.getUniformLocation(s, 'tex');
                        t.uniform1i(c, 0), t.viewport(0, 0, 2, 2), t.drawArrays(t.TRIANGLES, 0, 3);
                        const d = new Uint8Array(4);
                        return (
                            t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, d),
                            i.unbind(t),
                            255 !== d[0]
                        );
                    }
                    var In = i(9600);
                    const Mn = (0, E.H)(),
                        Tn = (0, E.H)(),
                        Pn = (0, E.H)(),
                        Ln = (0, E.H)(),
                        kn = 64,
                        En = 12,
                        An = 0.001,
                        zn = [1.7, 1];
                    const Cn = D.Ue(),
                        Fn = new Float64Array(16);
                    class On {
                        constructor(e) {
                            (this.demTextureMatrix = new Float64Array(16)),
                                (this.demCorrectedFbVpToDemTex = new Float32Array(16)),
                                (this.demTexToCorrectedTex = new Float32Array(16)),
                                (this.correctedTexToDemTex = new Float32Array(16)),
                                (this.isDemCorrectionEnabled = !1),
                                (this.demCorrectedScale = 1),
                                (this.demFbVpMatrix = new Float64Array(16)),
                                (this.demCorrectedFbVpMatrix = new Float64Array(16)),
                                (this.demFramebufferId = Ni.z),
                                (this.correctedDemFramebufferId = Ni.z),
                                (this.flatFramebufferId = Ni.z),
                                (this.identifyFlatFramebufferId = Ni.z),
                                (this.hillshadeRampTextureId = NaN),
                                (this.hillshadeFramebufferId = Ni.z),
                                (this.groundFramebufferId = Ni.z),
                                (this.isGroundBufferValid = !1),
                                (this.lastStyleId = NaN),
                                (this.tilesRevision = 0),
                                (this.modules = e),
                                (this.enabled = !1),
                                (this.sources = []),
                                (this.sourcesRevision = []),
                                (this.tileLayers = []),
                                (this.groundBuffer = new Float32Array()),
                                (this.differ = new De([])),
                                (this.copyDemProgram =
                                    this.modules.renderer.getShaderProgram('demElevationCopy'));
                        }
                        enable() {
                            void 0 === this.isTerrainSupported && (this.isTerrainSupported = Sn()),
                                !this.enabled &&
                                    this.isTerrainSupported &&
                                    ((this.differ = new De([
                                        { path: 'center', type: 'vec2' },
                                        { path: 'zoom', type: 'number' },
                                        { path: 'size', type: 'vec2' },
                                        { path: 'rotation', type: 'number' },
                                        { path: 'pitch', type: 'number' },
                                        { path: 'demMode', type: 'boolean' },
                                        { path: 'elevation', type: 'number' },
                                        { path: 'minElevation', type: 'number' },
                                    ])),
                                    (this.demFramebufferId = this.createDemFramebuffer()),
                                    (this.correctedDemFramebufferId =
                                        this.createCorrectedDemFramebuffer()),
                                    (this.hillshadeFramebufferId =
                                        this.createHillshadeFramebuffer()),
                                    (this.flatFramebufferId = this.createFlatFramebuffer()),
                                    (this.identifyFlatFramebufferId =
                                        this.createFlatIdentifyFramebuffer()),
                                    (this.groundFramebufferId = this.createGroundFramebuffer()),
                                    (this.fullscreenBuffer = new Ft.l(
                                        new Uint16Array(
                                            [
                                                [0, 0, 0, 0],
                                                [1, 0, 1, 0],
                                                [0, 1, 0, 1],
                                                [0, 1, 0, 1],
                                                [1, 0, 1, 0],
                                                [1, 1, 1, 1],
                                            ].reduce((e, t) => {
                                                const [i, n, o, r] = t;
                                                return (
                                                    e.push(
                                                        i * rt._H,
                                                        n * rt._H,
                                                        (0, Ui.Bb)(o),
                                                        (0, Ui.Bb)(r),
                                                    ),
                                                    e
                                                );
                                            }, []),
                                        ),
                                    )),
                                    (this.hillshadeVao = xi(
                                        this.fullscreenBuffer,
                                        this.modules.renderer.getShaderProgram('demHillshade'),
                                    )),
                                    (this.copyDemVao = xi(
                                        this.fullscreenBuffer,
                                        this.copyDemProgram,
                                    )),
                                    this.addDefaultSources(),
                                    this.modules.styleManager.setFramebufferId(
                                        this.modules.map.state.handyStyleId,
                                        Pi.he,
                                        {
                                            elevation: this.demFramebufferId,
                                            hillshade: this.hillshadeFramebufferId,
                                            flatBottom: this.correctedDemFramebufferId,
                                            ground: this.groundFramebufferId,
                                        },
                                    ),
                                    this.updateRampTextureId(),
                                    (this.enabled = !0));
                        }
                        onTerrainStyleChange() {
                            this.updateRampTextureId();
                        }
                        disable() {
                            var e, t, i, n, o;
                            this.enabled &&
                                (null === (e = this.meshSource) || void 0 === e || e.destroy(),
                                (this.meshSource = void 0),
                                null === (t = this.flatMapSource) || void 0 === t || t.destroy(),
                                (this.flatMapSource = void 0),
                                this.tileLayers.forEach((e) => {
                                    this.modules.tileManager.removeTileLayer(e);
                                }),
                                (this.tileLayers = []),
                                this.sources.forEach((e) => {
                                    e.destroy();
                                }),
                                (this.sources = []),
                                (this.sourcesRevision = []),
                                this.hillshadeTile &&
                                    (this.modules.tileManager.removeObject(this.hillshadeTile),
                                    (this.hillshadeTile = void 0)),
                                null === (i = this.hillshadeVao) || void 0 === i || i.unbind(),
                                null === (n = this.hillshadeVao) || void 0 === n || n.remove(),
                                null === (o = this.fullscreenBuffer) || void 0 === o || o.remove(),
                                this.modules.styleManager.removeLayer('demo_raster_layer'),
                                this.modules.styleManager.setFramebufferId(
                                    this.modules.map.state.handyStyleId,
                                    Pi.he,
                                    {
                                        elevation: Ni.z,
                                        hillshade: Ni.z,
                                        flatBottom: Ni.z,
                                        ground: Ni.z,
                                    },
                                ),
                                this.modules.renderer.removeFramebuffer(
                                    this.hillshadeFramebufferId,
                                ),
                                this.modules.renderer.removeFramebuffer(this.demFramebufferId),
                                this.modules.renderer.removeFramebuffer(
                                    this.correctedDemFramebufferId,
                                ),
                                this.modules.renderer.removeFramebuffer(this.flatFramebufferId),
                                this.modules.renderer.removeFramebuffer(this.groundFramebufferId),
                                (this.enabled = !1));
                        }
                        update() {
                            var e, t, i, n;
                            if (!this.enabled) return;
                            const o = this.modules.map.state;
                            this.lastStyleId !== o.handyStyleId &&
                                (this.updateRampTextureId(),
                                null === (e = this.meshSource) || void 0 === e || e.updateStyleId(),
                                null === (t = this.hillshadeTile) ||
                                    void 0 === t ||
                                    t.children.forEach((e) => {
                                        e.attributes.styleId = o.handyStyleId;
                                    }),
                                this.modules.styleManager.setFramebufferId(
                                    this.modules.map.state.handyStyleId,
                                    Pi.he,
                                    {
                                        elevation: this.demFramebufferId,
                                        hillshade: this.hillshadeFramebufferId,
                                        flatBottom: this.correctedDemFramebufferId,
                                        ground: this.groundFramebufferId,
                                    },
                                ),
                                this.updateClearColor(),
                                (this.lastStyleId = o.handyStyleId));
                            const r = this.updateTilesRevision(),
                                s = this.differ.check(this.modules.map.state);
                            (r || s) && (this.isGroundBufferValid = !1),
                                s &&
                                    (this.updateMinElevation(),
                                    null === (i = this.flatMapSource) || void 0 === i || i.update(),
                                    null === (n = this.meshSource) || void 0 === n || n.update(),
                                    this.updateDemFramebufferMatrix(),
                                    (this.modules.map.state.needRerender = !0));
                        }
                        isEnabled() {
                            return this.enabled;
                        }
                        getDemFramebufferId() {
                            return this.demFramebufferId;
                        }
                        getCorrectedDemFramebufferId() {
                            return this.correctedDemFramebufferId;
                        }
                        getFlatFramebufferId() {
                            return this.flatFramebufferId;
                        }
                        getIdentifyFlatFramebufferId() {
                            return this.identifyFlatFramebufferId;
                        }
                        getHillshadeFramebufferId() {
                            return this.hillshadeFramebufferId;
                        }
                        getHillshadeRampTextureId() {
                            return this.hillshadeRampTextureId;
                        }
                        getElevation(e) {
                            if (this.enabled)
                                for (let t = this.sources.length - 1; t >= 0; t--) {
                                    const i = this.sources[t].getElevation(e);
                                    if (void 0 !== i) return i;
                                }
                        }
                        getLabelsDemKey(e) {
                            if (!this.enabled || 0 === e.length) return;
                            let t, i;
                            for (const i of e)
                                if (((t = i.labels.find((e) => e.type === $i.R2.Point)), t)) break;
                            if (t) {
                                (0, G.L7)(Cn, t.vertices, 0, (0, G.Bs)(t.tileCoords));
                                for (let e = this.sources.length - 1; e >= 0; e--) {
                                    const t = this.sources[e].getElevationTile(Cn);
                                    if (void 0 !== t) {
                                        i = t;
                                        break;
                                    }
                                }
                                return i ? i.key : void 0;
                            }
                        }
                        enrichWithElevation(e) {
                            var t;
                            if (this.enabled)
                                for (const i of e) {
                                    let e = null;
                                    for (const n of i.labels)
                                        n.type === $i.R2.Point &&
                                            (e || (e = (0, G.Bs)(n.tileCoords)),
                                            (0, G.L7)(Cn, n.vertices, 0, e),
                                            (n.demElevation =
                                                null !== (t = this.getElevation(Cn)) && void 0 !== t
                                                    ? t
                                                    : NaN));
                                }
                        }
                        getMinElevation() {
                            return this.sources.reduce((e, t) => {
                                const i = t.getMinElevation();
                                return void 0 === i ? e : void 0 === e ? i : Math.min(e, i);
                            }, void 0);
                        }
                        updateMinElevation() {
                            this.sources.forEach((e) => e.updateMinElevation());
                        }
                        getMeshTiles() {
                            return this.meshSource
                                ? Array.from(this.meshSource.meshTiles.values())
                                : [];
                        }
                        getGroundTiles() {
                            return this.meshSource
                                ? Array.from(this.meshSource.groundTiles.values())
                                : [];
                        }
                        getFlatMapTextures() {
                            return this.flatMapSource ? this.flatMapSource.textures.slice() : [];
                        }
                        clearTextureBindings() {
                            const e = this.modules.renderer.getRenderingContext();
                            e.activeTexture(e.TEXTURE0),
                                e.bindTexture(e.TEXTURE_2D, null),
                                e.activeTexture(e.TEXTURE0 + Mn),
                                e.bindTexture(e.TEXTURE_2D, null),
                                e.activeTexture(e.TEXTURE0 + Ln),
                                e.bindTexture(e.TEXTURE_2D, null),
                                e.activeTexture(e.TEXTURE0 + Tn),
                                e.bindTexture(e.TEXTURE_2D, null),
                                e.activeTexture(e.TEXTURE0 + Pn),
                                e.bindTexture(e.TEXTURE_2D, null);
                        }
                        setMeshMaxZoom(e) {
                            var t;
                            (this.meshMaxZoom = e),
                                null === (t = this.meshSource) || void 0 === t || t.setMaxZoom(e);
                        }
                        getVerticalScale() {
                            const e = this.modules.map.state,
                                t = this.modules.styleManager.getStyle(e.handyStyleId);
                            if (!t) return 0;
                            const i = t.dem.style,
                                n = (0, $.jJ)(e.styleZoom, e.styleState, []);
                            return (0, $.vn)(i.verticalScale, n);
                        }
                        getTilesRevision() {
                            return this.tilesRevision;
                        }
                        getGroundPoint(e) {
                            if (!this.enabled) return;
                            if ((this.updateGround(), !this.isGroundBufferValid)) return;
                            const t = this.modules.renderer.getFramebuffer(
                                this.groundFramebufferId,
                            );
                            if (!t) return;
                            const i = t.renderTarget.options.size;
                            if (e[0] < 0 || e[0] > i[0] - 1 || e[1] < 0 || e[1] > i[1] - 1) return;
                            const n = e[0],
                                o = 4 * ((i[1] - e[1] - 1) * i[0] + n);
                            if (0 === this.groundBuffer[o + 3]) return;
                            const [r, s] = (0, L.PA)([
                                this.groundBuffer[o],
                                this.groundBuffer[o + 1],
                            ]);
                            return [r, s, this.groundBuffer[o + 2]];
                        }
                        updateRampTextureId() {
                            const e = this.modules.styleManager.getStyle(
                                this.modules.map.state.handyStyleId,
                            );
                            if (null == e ? void 0 : e.dem) {
                                const t = (function (e, t, i) {
                                    const n = (0, $.jJ)(e.styleZoom, e.styleState, []),
                                        o = [],
                                        r = i - 1;
                                    for (let e = 0; e < i; e++) {
                                        const i = e / r,
                                            s = 256 * (0, $.UP)(t, i, n);
                                        o.push(s);
                                    }
                                    return new it(new Uint8Array(o), {
                                        size: [i, 1],
                                        format: it.AlphaFormat,
                                        magFilter: it.LinearFilter,
                                        minFilter: it.LinearFilter,
                                        wrapS: it.ClampToEdgeWrapping,
                                        wrapT: it.ClampToEdgeWrapping,
                                    });
                                })(this.modules.map.state, e.dem.style.shadingPalette, 256);
                                Number.isNaN(this.hillshadeRampTextureId)
                                    ? (this.hillshadeRampTextureId =
                                          this.modules.imageManager.addPreparedTexture(t))
                                    : this.modules.imageManager.updatePreparedTexture(
                                          this.hillshadeRampTextureId,
                                          t,
                                      );
                            }
                        }
                        updateClearColor() {
                            const e = this.modules.styleManager.getStyle(
                                this.modules.map.state.handyStyleId,
                            );
                            if (null == e ? void 0 : e.dem) {
                                const t = this.modules.renderer.getFramebuffer(
                                    this.flatFramebufferId,
                                );
                                t && (t.clearColor = (0, $.m2)(e.background.color));
                            }
                        }
                        updateGround() {
                            if (this.enabled && !this.isGroundBufferValid) {
                                const e = this.modules.renderer.getFramebuffer(
                                    this.groundFramebufferId,
                                );
                                if (!e) return;
                                const t = this.modules.renderer.getRenderingContext(),
                                    i = e.renderTarget.options.size;
                                this.validateGroundBufferSize(i),
                                    e.renderTarget.bind(t),
                                    t.readPixels(
                                        0,
                                        0,
                                        i[0],
                                        i[1],
                                        t.RGBA,
                                        t.FLOAT,
                                        this.groundBuffer,
                                    ),
                                    e.renderTarget.unbind(t),
                                    (this.isGroundBufferValid = !0);
                            }
                        }
                        addDefaultSources() {
                            var e;
                            if (!this.enabled) {
                                const t = this.modules.map.state,
                                    i = (e, i, n) =>
                                        ((e, t, i, n) => {
                                            const o = (0, T.IG)(e.tileServer, {
                                                subdomain:
                                                    e.subdomains[
                                                        Math.abs(t + i) % e.subdomains.length
                                                    ],
                                            });
                                            return `${e.tileProtocol}://${o}/v2/ald?ts=relief&x=${t}&y=${i}&z=${n}`;
                                        })(t, e, i, n);
                                this.addElevationSource({
                                    url: i,
                                    minZoom: 5,
                                    maxZoom: 8,
                                    attributes: {},
                                }),
                                    this.addElevationSource({
                                        url: i,
                                        minZoom: 9,
                                        maxZoom: En,
                                        attributes: {},
                                    }),
                                    (this.flatMapSource = new qi(this.modules.map)),
                                    (this.meshSource = new Ai(this.modules.map, {
                                        maxZoom: this.meshMaxZoom,
                                    }));
                                const n = this.hillshadeVao,
                                    o =
                                        null ===
                                            (e =
                                                this.modules.renderer.symbolSettingsList.dem
                                                    .hillshade) || void 0 === e
                                            ? void 0
                                            : e[0];
                                if (n && o) {
                                    this.hillshadeTile = new C.W(
                                        'raster',
                                        [],
                                        this.modules.renderer,
                                    );
                                    const e = {
                                        id: (0, E.f)(),
                                        type: ot.H.Tile,
                                        symbol: 'dem',
                                        sink: 'hillshade',
                                        tile: this.hillshadeTile,
                                        attributes: {
                                            layerId: Pi.he,
                                            styleId: this.modules.map.state.handyStyleId,
                                            tileData: [],
                                        },
                                        stride: jt._.sinks.hillshade.stride,
                                        rangeStart: 0,
                                        rangeEnd: 6 * jt._.sinks.hillshade.stride,
                                        attributesHash: '',
                                        layerSettings: o,
                                        vao: n,
                                    };
                                    this.hillshadeTile.children.push(e),
                                        this.modules.tileManager.addObject(this.hillshadeTile);
                                }
                            }
                        }
                        updateTilesRevision() {
                            let e = !1;
                            return (
                                this.sources.forEach((t, i) => {
                                    const n = t.getRevision();
                                    n !== this.sourcesRevision[i] &&
                                        ((this.sourcesRevision[i] = n), (e = !0));
                                }),
                                e && this.tilesRevision++,
                                e
                            );
                        }
                        addElevationSource(e) {
                            const t = new ji((0, In.Q)(), this.modules, e);
                            this.sources.push(t), this.sourcesRevision.push(t.getRevision());
                            const { minZoom: i, maxZoom: n } = e,
                                o = new Ct.I(i, n, i, n, this.modules, this.modules.map.state, t);
                            this.modules.tileManager.addTileLayer(o), this.tileLayers.push(o);
                        }
                        getDemTextureSize() {
                            const e = this.modules.map.state.size[1] * I.camera.viewportLimitRatio;
                            return Math.min(Math.ceil(Math.hypot(e, e) / rt.y4), kn);
                        }
                        createGroundFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext(),
                                t = this.modules.map.state.size,
                                i = [0, 0, 0, 0],
                                n = new nt({
                                    size: t,
                                    magFilter: it.NearestFilter,
                                    minFilter: it.NearestFilter,
                                    wrapS: it.ClampToEdgeWrapping,
                                    wrapT: it.ClampToEdgeWrapping,
                                    flipY: !0,
                                    type: it.Float,
                                });
                            return (
                                n.bind(e),
                                this.modules.renderer.clearWithColor(i),
                                n.unbind(e),
                                this.modules.renderer.addFramebuffer({
                                    clearColor: i,
                                    useDem: !0,
                                    clearDepth: !0,
                                    onResize: () => {
                                        const e = this.modules.renderer.getRenderingContext(),
                                            t = this.modules.map.state.size;
                                        n.setSize(t),
                                            n.bind(e),
                                            this.modules.renderer.clearWithColor(i),
                                            n.unbind(e);
                                    },
                                    renderTarget: n,
                                    renderIndex: 5,
                                    onRenderStart: () => {
                                        this.clearTextureBindings();
                                    },
                                    onRenderEnd: () => {},
                                })
                            );
                        }
                        createDemFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext();
                            let t = this.getDemTextureSize() * kn;
                            const i = new nt({
                                size: [t, t],
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                                wrapS: it.ClampToEdgeWrapping,
                                wrapT: it.ClampToEdgeWrapping,
                                flipY: !0,
                                type: it.Float,
                            });
                            return (
                                i.bind(e),
                                this.modules.renderer.clearWithColor([0, 0, 0, 1]),
                                i.unbind(e),
                                this.modules.renderer.addFramebuffer({
                                    clearColor: [0, 0, 0, 1],
                                    onResize: () => {
                                        const n = this.getDemTextureSize() * kn;
                                        n !== t &&
                                            ((t = n),
                                            i.setSize([t, t]),
                                            i.bind(e),
                                            this.modules.renderer.clearWithColor([0, 0, 0, 1]),
                                            i.unbind(e));
                                    },
                                    renderTarget: i,
                                    getViewProjectionMatrix: () => this.demFbVpMatrix,
                                    renderIndex: 0,
                                    onRenderStart: () => {
                                        this.clearTextureBindings();
                                    },
                                    onRenderEnd: () => {
                                        this.isDemCorrectionEnabled = !1;
                                    },
                                })
                            );
                        }
                        createCorrectedDemFramebuffer() {
                            const e = this.modules.renderer,
                                t = e.getRenderingContext(),
                                i = e.webGlExtensions;
                            let n = this.getDemTextureSize() * kn;
                            const o = new nt({
                                size: [n, n],
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                                wrapS: it.ClampToEdgeWrapping,
                                wrapT: it.ClampToEdgeWrapping,
                                flipY: !0,
                                type: it.Float,
                            });
                            return (
                                o.bind(t),
                                this.modules.renderer.clearWithColor([0, 0, 0, 1]),
                                o.unbind(t),
                                this.modules.renderer.addFramebuffer({
                                    onResize: () => {
                                        const e = this.getDemTextureSize() * kn;
                                        e !== n &&
                                            ((n = e),
                                            o.setSize([n, n]),
                                            o.bind(t),
                                            this.modules.renderer.clearWithColor([0, 0, 0, 1]),
                                            o.unbind(t));
                                    },
                                    renderTarget: o,
                                    getViewProjectionMatrix: () => this.demCorrectedFbVpMatrix,
                                    renderIndex: 1,
                                    onRenderStart: () => {
                                        var e;
                                        const n =
                                            null ===
                                                (e = this.modules.renderer.getFramebuffer(
                                                    this.demFramebufferId,
                                                )) || void 0 === e
                                                ? void 0
                                                : e.renderTarget.getTexture();
                                        if (!n || !this.copyDemVao) return;
                                        this.clearTextureBindings(),
                                            o.bind(t),
                                            t.viewport(0, 0, o.options.size[0], o.options.size[1]),
                                            Ji(t, sn);
                                        n.enable(t, 0),
                                            this.copyDemProgram.enable(t),
                                            this.copyDemProgram.bind(t, {
                                                u_mat4_mvp: L.TD,
                                                u_sr2d_texture: 0,
                                                u_mat4_dem_corrected: this.correctedTexToDemTex,
                                            }),
                                            this.copyDemVao.bind({ gl: t, extensions: i }),
                                            t.drawArrays(t.TRIANGLES, 0, 6),
                                            o.unbind(t),
                                            (this.isDemCorrectionEnabled = !0);
                                    },
                                })
                            );
                        }
                        createHillshadeFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext();
                            let t = this.getDemTextureSize() * kn;
                            const i = new nt({
                                size: [t, t],
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                                wrapS: it.ClampToEdgeWrapping,
                                wrapT: it.ClampToEdgeWrapping,
                                format: it.RgbFormat,
                                flipY: !0,
                            });
                            return this.modules.renderer.addFramebuffer({
                                clearColor: [0, 0, 0, 0],
                                onResize: () => {
                                    const n = this.getDemTextureSize() * kn;
                                    n !== t && ((t = n), i.setSize([t, t]), i.bind(e), i.unbind(e));
                                },
                                renderTarget: i,
                                getViewProjectionMatrix: () => this.demFbVpMatrix,
                                renderIndex: 2,
                                onRenderStart: () => {
                                    this.clearTextureBindings();
                                },
                                onRenderEnd: () => {
                                    e.colorMask(!0, !0, !0, !0);
                                },
                            });
                        }
                        createFlatFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext(),
                                t = window.devicePixelRatio,
                                i = this.modules.map.state.size,
                                n = new nt({
                                    size: [
                                        Math.trunc(i[0] * zn[0] * t),
                                        Math.trunc(i[1] * zn[1] * t),
                                    ],
                                    magFilter: it.LinearFilter,
                                    minFilter: it.LinearFilter,
                                    wrapS: it.ClampToEdgeWrapping,
                                    wrapT: it.ClampToEdgeWrapping,
                                });
                            return this.modules.renderer.addFramebuffer({
                                clearColor: this.modules.renderer.clearColor,
                                onResize: () => {
                                    const t = window.devicePixelRatio,
                                        i = this.modules.map.state.size;
                                    n.setSize([
                                        Math.trunc(i[0] * zn[0] * t),
                                        Math.trunc(i[1] * zn[1] * t),
                                    ]),
                                        n.bind(e),
                                        n.unbind(e);
                                },
                                renderTarget: n,
                                renderIndex: 3,
                                onRenderStart: () => {
                                    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, null);
                                },
                            });
                        }
                        createFlatIdentifyFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext(),
                                t = this.modules.map.state.size,
                                i = new nt({
                                    size: [
                                        Math.trunc(t[0] * zn[0] * I.identify.pixelDensity),
                                        Math.trunc(t[1] * zn[1] * I.identify.pixelDensity),
                                    ],
                                    magFilter: it.NearestFilter,
                                    minFilter: it.NearestFilter,
                                    wrapS: it.ClampToEdgeWrapping,
                                    wrapT: it.ClampToEdgeWrapping,
                                });
                            return this.modules.renderer.addFramebuffer({
                                clearColor: [1, 1, 1, 1],
                                onResize: () => {
                                    const t = this.modules.map.state.size;
                                    i.setSize([
                                        Math.trunc(t[0] * zn[0] * I.identify.pixelDensity),
                                        Math.trunc(t[1] * zn[1] * I.identify.pixelDensity),
                                    ]),
                                        i.bind(e),
                                        i.unbind(e);
                                },
                                renderTarget: i,
                                renderIndex: 4,
                                onRenderStart: () => {
                                    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, null);
                                },
                            });
                        }
                        updateDemFramebufferMatrix() {
                            const e = this.modules.map.state,
                                t = Math.trunc(e.styleZoom),
                                i = Math.min(t, En),
                                n = (0, G.aq)(i),
                                o = n * this.getDemTextureSize(),
                                r = n / kn,
                                s = [
                                    Math.trunc(e.center[0] / r) * r + r / 2,
                                    Math.trunc(e.center[1] / r) * r + r / 2,
                                ],
                                a = [s[0] - o / 2, s[1] - o / 2, 0];
                            $e.wA(Fn, a, [o, o, rt._9]),
                                $e.U_(this.demTextureMatrix, Fn),
                                $e.Jp(this.demFbVpMatrix, L.TD, this.demTextureMatrix),
                                (this.demCorrectedScale = Math.pow(2, t - i));
                            const l = (0, G.aq)(t) * this.getDemTextureSize(),
                                c = [s[0] - l / 2, s[1] - l / 2, 0];
                            $e.wA(Fn, c, [l, l, rt._9]),
                                $e.U_(Fn, Fn),
                                $e.Jp(this.demCorrectedFbVpMatrix, L.TD, Fn),
                                $e.xJ(Fn, [
                                    1 / this.demCorrectedScale,
                                    1 / this.demCorrectedScale,
                                    1,
                                ]),
                                $e.Jp(this.demCorrectedFbVpToDemTex, L.LX, Fn),
                                $e.xJ(Fn, [
                                    1 / this.demCorrectedScale,
                                    1 / this.demCorrectedScale,
                                    1,
                                ]),
                                $e.Jp(Fn, Fn, L.TD),
                                $e.Jp(this.correctedTexToDemTex, L.LX, Fn),
                                $e.xJ(Fn, [this.demCorrectedScale, this.demCorrectedScale, 1]),
                                $e.Jp(Fn, Fn, L.TD),
                                $e.Jp(this.demTexToCorrectedTex, L.LX, Fn);
                        }
                        validateGroundBufferSize(e) {
                            const t = e[0] * e[1] * 4;
                            this.groundBuffer.length !== t &&
                                (this.groundBuffer = new Float32Array(t));
                        }
                    }
                    function Dn(...e) {
                        return (t, i, n, o, r) => {
                            e.forEach((e) => e(t, i, n, o, r));
                        };
                    }
                    const Rn = (e, t, i, n, o, r) => {
                            var s, a, l;
                            if (!0 === r || !n.map.state.demMode) return Zn(e, t);
                            const c =
                                    null ===
                                        (s = n.renderer.getFramebuffer(
                                            n.demManager.getDemFramebufferId(),
                                        )) || void 0 === s
                                        ? void 0
                                        : s.renderTarget.getTexture(),
                                d =
                                    null ===
                                        (a = n.renderer.getFramebuffer(
                                            n.demManager.getCorrectedDemFramebufferId(),
                                        )) || void 0 === a
                                        ? void 0
                                        : a.renderTarget.getTexture(),
                                h = n.imageManager.getTexture(
                                    n.demManager.getHillshadeRampTextureId(),
                                ),
                                u = null == c ? void 0 : c.options.size,
                                m = n.styleManager.getStyle(i.handyStyleId);
                            if (!(c && d && h && m && u)) return Zn(e, t);
                            const f = {
                                    type: 'binder',
                                    styleZoom: i.styleZoom,
                                    styleState: i.styleState,
                                    tileData: [],
                                    isBehind: !1,
                                },
                                p = (0, L.v3)(
                                    (0, fe.Id)((0, $.vn)(m.dem.style.lightingDirection, f)) -
                                        i.rotation,
                                ),
                                _ = (0, $.vn)(m.dem.style.shadingIntensity, f),
                                v =
                                    L.A5 /
                                    (Math.pow(2, Math.min(Math.trunc(i.styleZoom), En)) * kn);
                            c.enable(e, Mn), h.enable(e, Pn), d.enable(e, Ln);
                            const g = n.demManager.demCorrectedScale;
                            t.bind(e, {
                                u_float_dem_scale: i.elevationScale,
                                u_float_dem_resolution: u[0],
                                u_float_dem_cell_size: v,
                                u_float_dem_light_direction: p,
                                u_float_dem_shade_intension: _,
                                u_tex_dem: Mn,
                                u_tex_corrected_dem: Ln,
                                u_tex_hillshade_ramp: Pn,
                                u_float_corrected_interval:
                                    n.demManager.isDemCorrectionEnabled && 1 !== g ? 0.5 / g : 0,
                                u_mat4_dem_corrected: n.demManager.demTexToCorrectedTex,
                                u_float_map_center_elevation:
                                    null !== (l = i.elevation) && void 0 !== l ? l : 0,
                            }),
                                o.setFlags({ demUniformsBound: !0 });
                        },
                        jn = (e, t, i, n) => {
                            const { renderer: o } = n,
                                { labelingTextureBuffer: r } = o,
                                s = r.getDepthBuffer();
                            if (!(s instanceof it)) return !1;
                            const a = r.getTexture();
                            if (!a) return !1;
                            a.enable(e, Ns),
                                s.enable(e, Us),
                                t.bind(e, { u_color_tex_labeling: Ns, u_depth_tex_labeling: Us });
                        },
                        Bn = (e, t, i) => {
                            const n = (rt.Jv - 0.5) / 2,
                                { size: o } = i;
                            t.bind(e, { u_vec2_depth_test_half_point_size: [n / o[0], n / o[1]] });
                        },
                        Nn = (e, t, i) => {
                            const { labelingDepthTestDisabled: n } = i;
                            t.bind(e, { u_bool_depth_test_disable: n });
                        },
                        Un = (e, t) => (t.bind(e, { u_float_dem_shade_intension: 0 }), !0),
                        Zn = (e, t) => (t.bind(e, { u_float_dem_scale: 0 }), !0),
                        Hn = Dn(bt, gt, Rn),
                        Gn = Dn(bt, Rn),
                        Vn = Dn(gt, mt, Rn),
                        Wn = Dn(bt, mt, gt, Rn),
                        qn = Dn(Lt, vt),
                        $n = Dn(mt, pt, kt, It),
                        Xn = Dn(
                            mt,
                            pt,
                            (e, t) => {
                                t.bind(e, { u_vec4_border_color: [0, 0, 0, 0] });
                            },
                            (e, t) => {
                                t.bind(e, { u_vec4_space_color: [0, 0, 0, 0] });
                            },
                        ),
                        Yn = Dn(
                            mt,
                            _t,
                            (e, t, i) => {
                                t.bind(e, { u_float_rounding_factor: i.stillness });
                            },
                            vt,
                            Rn,
                            jn,
                            Bn,
                            Nn,
                        ),
                        Kn = Dn(mt, _t, vt, Rn),
                        Jn = Dn(Lt, vt, mt, Rn, jn, Bn, Nn),
                        Qn = mt,
                        eo = Dn(mt, pt, kt, It),
                        to = Rn;
                    var io = i(7840),
                        no = i(5071),
                        oo = i(7464);
                    const ro = new Float32Array(16),
                        so = new Float32Array(16);
                    function ao(e, t) {
                        return 0 === t ? 1 : 1 === t ? e.labelingOpacity : 1 - e.labelingOpacity;
                    }
                    const lo = () => !0,
                        co = (e, t, i, n, o, r, s) => {
                            const a = (0, $.zn)(r.style.color, lr(i, o));
                            return Zi.JG(s.value, a.value), !0;
                        },
                        ho = (e, t, i, n, o, r, s) => {
                            let a;
                            switch (o.attributes.side) {
                                case Nt.z.top:
                                    a = r.style.topColor;
                                    break;
                                case Nt.z.side:
                                    a = r.style.sideColor;
                                    break;
                                case Nt.z.bottom:
                                    a = r.style.bottomColor;
                            }
                            return Zi.JG(s.value, (0, $.zn)(a, lr(i, o)).value), !0;
                        },
                        uo = (e, t, i, n, o, r, s) => {
                            const a = (0, $.jJ)(
                                    i.styleZoom,
                                    i.styleState,
                                    o.attributes.tileData,
                                    Boolean(o.layerSettings.isOverlappedObject),
                                ),
                                l = (0, $.zn)(r.style.color, a);
                            return Zi.JG(s.value, l.value), !0;
                        },
                        mo = (e, t, i, n, o, r, s) => {
                            const a = (0, $.zn)(r.style.topColor, lr(i, o));
                            return Zi.JG(s.value, a.value), !0;
                        },
                        fo = (e, t, i, n, o, r, s) => {
                            const a = (0, $.zn)(r.style.sideColor, lr(i, o));
                            return Zi.JG(s.value, a.value), !0;
                        },
                        po = (e, t, i, n, o, r, s) => {
                            const a = (0, $.qv)(r.style.sideColor, lr(i, o));
                            if (a) {
                                Zi.JG(s.value, a.values[0].value);
                                for (let e = 0; e < a.values.length; e++) {
                                    const t = a.values[e],
                                        i = (0, $.m2)(t);
                                    Zi.bA(i, i, o.tile.readiness),
                                        (so[e] = a.steps[e]),
                                        (so[4 + 4 * e] = i[0]),
                                        (so[5 + 4 * e] = i[1]),
                                        (so[6 + 4 * e] = i[2]),
                                        (so[7 + 4 * e] = i[3]);
                                }
                                (so[2] = a.values.length), t.bind(e, { u_mat4_gradient: so });
                            } else t.bind(e, { u_mat4_gradient: ro });
                            return !0;
                        },
                        _o = (e, t, i, n, o, r, s) => {
                            const a = (0, $.zn)(r.style.strokeColor, lr(i, o));
                            return Zi.JG(s.value, a.value), !0;
                        },
                        vo = (e, t, i, n, o, r, s) => {
                            const a = (0, $.zn)(r.style.strokeColor2, lr(i, o));
                            return Zi.JG(s.value, a.value), !0;
                        },
                        go = (e, t, i, n, o, r, s) => (
                            void 0 === o.attributes.id ||
                                (s.value[3] *= n.modelLayer.getOpacity(o.attributes.id, r.minzoom)),
                            !0
                        ),
                        yo = (e, t, i, { modelLayer: n, gltfAnimator: o }, r, s, a) => {
                            if (void 0 === r.attributes.hiddenObjectId) return !0;
                            if (n.hasModel(r.attributes.hiddenObjectId)) {
                                const e = n.getVisibleModelData(r.attributes.hiddenObjectId);
                                if (!e) return !0;
                                const t = 1 - e.opacity;
                                if (t < 0.5) return !1;
                                a.value[3] *= t;
                            } else if (o.hasModelFor(r.attributes.hiddenObjectId)) {
                                if (!o.isAnimating(r.attributes.hiddenObjectId)) return !1;
                                const e =
                                    1 -
                                    2 *
                                        o.getModelOpacityForLinkedObject(
                                            r.attributes.hiddenObjectId,
                                        );
                                if (e < 0.5) return !1;
                                a.value[3] *= e;
                            }
                            return !0;
                        },
                        bo = (e, t) => (t.bind(e, { u_float_opacity: 1 }), !0),
                        wo = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.textureOpacity, s);
                            return t.bind(e, { u_float_texture_opacity: o.tile.readiness * a }), !0;
                        },
                        xo = (e, t, i, n, o, r, s) => {
                            const a = lr(i, o),
                                l = (0, $.zn)(r.style.strokeColor, a).value,
                                c = (0, $.vn)(r.style.strokeWidth, a);
                            return (
                                Zi.fS(s.value, l) &&
                                    1 === s.value[3] &&
                                    c <= 1 &&
                                    (s.value[3] *= i.stillness),
                                !0
                            );
                        },
                        So = (e, t, i, n, o, r, s) => {
                            const a = lr(i, o),
                                l = (0, $.zn)(r.style.topColor, a).value,
                                c = (0, $.vn)(r.style.strokeWidth, a);
                            return (
                                Zi.fS(s.value, l) &&
                                    1 === s.value[3] &&
                                    c <= 1 &&
                                    (s.value[3] *= i.stillness),
                                !0
                            );
                        },
                        Io = (e, t, i, n, o, r, s) => ((s.value[3] *= i.stillness), !0),
                        Mo = (e, t, i, n, o, r, s) => {
                            const a = (0, $.m2)(s);
                            return (
                                Zi.bA(a, a, o.tile.readiness),
                                0 !== s.value[3] && (t.bind(e, { u_vec4_color: a }), !0)
                            );
                        },
                        To = (e, t, i, n, o, r, s) => {
                            const a = (0, $.m2)(s);
                            return t.bind(e, { u_vec4_color: a }), !0;
                        },
                        Po = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.width, lr(i, o));
                            return (
                                0 !== s &&
                                (t.bind(e, { u_float_width: s * window.devicePixelRatio }), !0)
                            );
                        },
                        Lo = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.shadingValue, lr(i, o));
                            return t.bind(e, { u_float_shading: s }), !0;
                        },
                        ko = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.strokeWidth, lr(i, o));
                            return (
                                0 !== s &&
                                (t.bind(e, { u_float_width: s * window.devicePixelRatio }), !0)
                            );
                        },
                        Eo = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.strokeWidth, s);
                            if (0 === a) return !1;
                            const l = (0, $.vn)(r.style.width, s) + 2 * a;
                            return t.bind(e, { u_float_width: l * window.devicePixelRatio }), !0;
                        },
                        Ao = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.strokeWidth2, s);
                            if (0 === a) return !1;
                            const l =
                                (0, $.vn)(r.style.width, s) +
                                2 * (0, $.vn)(r.style.strokeWidth, s) +
                                2 * a;
                            return t.bind(e, { u_float_width: l * window.devicePixelRatio }), !0;
                        },
                        zo = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a =
                                    (0, $.vn)(r.style.width, s) +
                                    2 * (0, $.vn)(r.style.strokeWidth, s) +
                                    2 * (0, $.vn)(r.style.strokeWidth2, s);
                            return (
                                0 !== a &&
                                (t.bind(e, { u_float_width: a * window.devicePixelRatio }), !0)
                            );
                        },
                        Co = (e, t, i, n, o, r) => {
                            const s = lr(i, o);
                            return (0, $.vn)(r.style.iconWidth, s) > 0;
                        },
                        Fo = (e, t, i, n, o, r) => (
                            t.bind(e, {
                                u_float_shift:
                                    (0, $.vn)(r.style.shift, lr(i, o)) * window.devicePixelRatio,
                            }),
                            !0
                        ),
                        Oo = (e, t, i, n, o) => 0 !== ao(i, o.attributes.animDirection),
                        Do = (e, t, i, n, o, r) => {
                            const s = lr(i, o);
                            return (
                                (0, $.vn)(r.style.iconOpacity, s) *
                                    ao(i, o.attributes.animDirection) !=
                                0
                            );
                        },
                        Ro = (e, t, i, n, o, r) => {
                            const s = ao(i, o.attributes.animDirection);
                            if (0 === s) return !1;
                            const a = (0, $.jJ)(
                                    i.styleZoom,
                                    i.styleState,
                                    o.attributes.tileData,
                                    !1,
                                ),
                                l = r.style.iconOpacity,
                                c = (0, $.vn)(l, a);
                            a.isBehind = !0;
                            const d = (0, $.vn)(l, a);
                            return t.bind(e, { u_vec2_opacity: [s * c, s * d] }), !0;
                        },
                        jo = (e, t, i, n, o) => {
                            const r = ao(i, o.attributes.animDirection);
                            return 0 !== r && (t.bind(e, { u_float_opacity: r }), !0);
                        },
                        Bo = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.iconRotation, lr(i, o));
                            return t.bind(e, { u_vec2_rotation: [Math.cos(s), Math.sin(s)] }), !0;
                        },
                        No = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.opacity, lr(i, o));
                            return t.bind(e, { u_float_opacity: o.tile.readiness * s }), !0;
                        },
                        Uo = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.opacity, lr(i, o));
                            return t.bind(e, { u_float_opacity: s }), !0;
                        },
                        Zo = (e, t, i, { threeJsSceneManager: n }, o) =>
                            void 0 === o.attributes.hiddenObjectId ||
                            (!i.hiddenObjects.other.has(o.attributes.hiddenObjectId) &&
                                !(null == n
                                    ? void 0
                                    : n.hasDisplayedBuilding(o.attributes.hiddenObjectId))),
                        Ho = (e, t, i, { floorManager: n }, o) =>
                            void 0 === o.attributes.hiddenObjectId ||
                            !n.hasDisplayedFloorBuilding(o.attributes.hiddenObjectId),
                        Go = (e, t, i, { modelLayer: n }, o) => {
                            if (void 0 === o.attributes.hiddenObjectId) return !0;
                            if (!n.hasModel(o.attributes.hiddenObjectId)) return !0;
                            const r = n.getVisibleModelData(o.attributes.hiddenObjectId);
                            return !r || 1 !== r.opacity;
                        },
                        Vo = (e, t, i, n, o) => (
                            t.bind(e, { u_sr2d_texture: o.attributes.atlasIndex }), !0
                        ),
                        Wo = (e, t, i, n, o) => {
                            const { range: r, fontIndex: s, styleId: a } = o.attributes,
                                l = n.styleManager.getStyle(a);
                            if (!l) return !1;
                            const c = l.fonts[s],
                                d = n.assetManager.getFontTextureByName(c, r);
                            return void 0 !== d && (d.enable(e), !0);
                        },
                        qo = (e, t, i, { imageManager: n }, o) => {
                            const r = n.getTexture(o.attributes.textureIndex);
                            return !!r && (r.enable(e, 0), t.bind(e, { u_sr2d_texture: 0 }), !0);
                        },
                        $o = (e, t, i, { imageManager: n }, o) => {
                            const r = n.getTexture(o.attributes.rampTextureIndex);
                            return (
                                void 0 !== r &&
                                (r.enable(e, 1), t.bind(e, { u_sr2d_ramp_texture: 1 }), !0)
                            );
                        },
                        Xo = (e, t, i, n, o, r) => {
                            const { tile: s } = o,
                                a = (0, $.zn)(r.style.gapColor, lr(i, o));
                            if (!a) return !0;
                            const l = (0, $.m2)((0, $.zn)(a, lr(i, o)));
                            return (
                                Zi.bA(l, l, s.readiness), t.bind(e, { u_vec4_space_color: l }), !0
                            );
                        },
                        Yo = (e, t, i, n, o, r) => {
                            const { styleZoom: s } = i,
                                a = lr(i, o),
                                { tile: l } = o,
                                c = (0, $.m2)((0, $.zn)(r.style.color, a));
                            Zi.bA(c, c, l.readiness), (a.styleZoom = Math.floor(s));
                            const d = Math.pow(2, (0, fe.vO)(s)),
                                h = (0, $.vn)(r.style.dashLength, a) * d,
                                u = (0, $.vn)(r.style.gapLength, a) * d;
                            return (
                                t.bind(e, {
                                    u_vec4_dash_color: c,
                                    u_vec2_scaler_params: [0, rt.ax],
                                    u_float_dash_length: (0, L.Qn)(h, l.size),
                                    u_float_dash2_length: (0, L.Qn)(h, l.size),
                                    u_float_space_length: (0, L.Qn)(u, l.size),
                                }),
                                !0
                            );
                        },
                        Ko = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.tipWidth, s),
                                l = (0, $.vn)(r.style.tipHeight, s),
                                c = a,
                                d = z.al(-c, -0);
                            z.Fv(d, d);
                            const h = z.al(a, l);
                            return (
                                z.Fv(h, h),
                                t.bind(e, {
                                    u_vec2_wing_normal: d,
                                    u_vec2_tip_normal: h,
                                    u_float_tip_height_multiplier: l,
                                    u_float_wing_height_multiplier: 0,
                                    u_float_wing_width_multiplier: c,
                                    u_float_size_factor: (0, L.Qn)(rt.gt, o.tile.size) / 2,
                                }),
                                !0
                            );
                        },
                        Jo = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.lineLength, s),
                                l = (0, $.vn)(r.style.lineWidth, s);
                            return (
                                t.bind(e, {
                                    u_float_length: a,
                                    u_float_width: l,
                                    u_float_border_width: 0,
                                }),
                                !0
                            );
                        },
                        Qo = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                { tile: a, attributes: l } = o,
                                c = l.isLongArrow,
                                d = o.tile.dynamicObject;
                            let h = 0,
                                u = 1;
                            d && (c ? (u = d.growPosition) : (h = d.bouncePosition));
                            let m = 0;
                            return (
                                'appearance' === r.style.animation.type &&
                                    (m = (0, $.vn)(r.style.animation.tipMovementAmplitude, s)),
                                t.bind(e, {
                                    u_float_width_zpt: (0, $.vn)(r.style.lineWidth, s),
                                    u_float_border_width_zpt: (0, $.vn)(r.style.strokeWidth, s),
                                    u_float_tip_movement_amplitude: (0, L.Qn)(m, a.size),
                                    u_float_vertex_shift: h,
                                    u_float_relative_end_position: u,
                                }),
                                !0
                            );
                        },
                        er = (e, t, i, { modelLayer: n }, o) => {
                            const { texture: r, id: s } = o.attributes;
                            if (void 0 === s) return !1;
                            const a = n.getTexture(s, r);
                            return (
                                void 0 !== a &&
                                (a.enable(e, 0), t.bind(e, { u_sr2d_texture: 0 }), !0)
                            );
                        };
                    let tr;
                    const ir = (e, t, i, { assetManager: n, floorManager: o }, r) => {
                            var s, a;
                            const l = n.getModel(r.attributes.modelId);
                            return l
                                ? (!(null ===
                                      (a =
                                          null === (s = r.meta) || void 0 === s
                                              ? void 0
                                              : s.linkedIds) || void 0 === a
                                      ? void 0
                                      : a.length) ||
                                      !o.hasDisplayedFloorBuilding(r.meta.linkedIds)) &&
                                      !i.hiddenObjects.gltfModel.has(r.attributes.buildingId) &&
                                      ((tr = l), !0)
                                : ((tr = void 0), !1);
                        },
                        nr = (e, t, i, n, o) => {
                            if (!tr) return !1;
                            const r = o.attributes.colorTexture;
                            if (void 0 === r) return !1;
                            const s = tr.textures[r];
                            if (!s) return !1;
                            s.enable(e, 0);
                            const a = { u_sr2d_texture_0: 0, u_int_has_ao_texture: 0 },
                                l = o.attributes.aoTexture,
                                c = void 0 !== l ? tr.textures[l] : null;
                            return (
                                c &&
                                    (c.enable(e, 1),
                                    (a.u_ao_texture = 1),
                                    (a.u_int_has_ao_texture = 1)),
                                t.bind(e, a),
                                !0
                            );
                        },
                        or = (e, t, i, { gltfAnimator: n }, o, r, s) => {
                            const a = n.getModelOpacity(o, r.minzoom);
                            return 0 !== a && ((s.value[3] *= a), !0);
                        },
                        rr = (e, t, i, n, o, r) => {
                            if (void 0 === o.attributes.id) return !0;
                            const s = n.modelLayer.getOpacity(o.attributes.id, r.minzoom),
                                a = 1 === n.modelLayer.getBuildingHeight(o.attributes.id) ? 1 : s;
                            return t.bind(e, { u_float_height_factor: a }), !0;
                        },
                        sr = (e, t, i, n, o, r) => {
                            const s = lr(i, o),
                                a = (0, $.vn)(r.style.height, s);
                            return t.bind(e, { u_float_height_factor: (0, G.VW)(a) }), !0;
                        },
                        ar = (e, t, i, n, o, r) => {
                            let s = n.buildingHeightAnimator.getBuildingHeight(r.minzoom);
                            return (
                                n.map.state.demMode && (s = An + 0.999 * s),
                                o.attributes.hiddenObjectId &&
                                    n.modelLayer.setBuildingHeight(o.attributes.hiddenObjectId, s),
                                t.bind(e, { u_float_height_factor: s }),
                                !0
                            );
                        };
                    function lr(e, t) {
                        return (0, $.jJ)(e.styleZoom, e.styleState, t.attributes.tileData);
                    }
                    const cr = (e, t, i, n, o, r) => {
                        const {
                                tile: { purpose: s, detailLevel: a },
                            } = o,
                            { styleZoom: l } = i;
                        switch (s) {
                            case 'zenith':
                            case 'traffic':
                            case 'geojson':
                                const e =
                                    a <
                                    (function (e) {
                                        switch (e) {
                                            case 'zenith':
                                                return I.tiles.maxDetailLevel;
                                            case 'traffic':
                                                return I.traffic.maxDetailLevel;
                                            case 'geojson':
                                                return no.rR;
                                        }
                                    })(s)
                                        ? (0, fe.uZ)(l, a, a + 0.99999)
                                        : l;
                                return r.minzoom <= e && e < r.maxzoom;
                            case 'dynamicObject':
                                return r.minzoom <= l && l <= r.maxzoom;
                            default:
                                return r.minzoom <= l && l < r.maxzoom;
                        }
                    };
                    const dr = (e, t, i, n, o) => {
                            const { styleZoom: r } = i,
                                { tile: s } = o;
                            return !('zenith' === s.purpose && r <= I.tiles.maxUniverseZoom);
                        },
                        hr = (e, t, i, n, o, r) => {
                            const { styleZoom: s } = i;
                            return s >= r.minzoom && s < r.maxzoom;
                        },
                        ur = (e, t, i, n, o, r) => {
                            const { tile: s } = o,
                                a = (0, $.vn)(r.style.width, lr(i, o));
                            return (
                                0 !== a &&
                                (t.bind(e, {
                                    u_float_width: ((0, L.Qn)(a, s.size) / 2) * rt.gt,
                                    u_float_width_offset:
                                        (0, L.Qn)(rt.gt / window.devicePixelRatio, s.size) / 2,
                                }),
                                !0)
                            );
                        },
                        mr = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.radius, lr(i, o));
                            return (
                                !(s <= 0) &&
                                (t.bind(e, { u_float_radius: s * window.devicePixelRatio }), !0)
                            );
                        },
                        fr = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.intensity, lr(i, o));
                            return t.bind(e, { u_float_intensity: s }), !0;
                        },
                        pr = (e, t, i, n, o, r) => {
                            const s = lr(i, o);
                            let a = (0, $.vn)(r.style.textFontSize, s);
                            if ('point' === o.symbol) {
                                const e = o.attributes.labelIndex;
                                e === io.bR.Second && r.style.textFontSize2
                                    ? (a = (0, $.vn)(r.style.textFontSize2, s))
                                    : e === io.bR.Icon &&
                                      r.style.iconTextFontSize &&
                                      (a = (0, $.vn)(r.style.iconTextFontSize, s));
                            }
                            return (
                                t.bind(e, {
                                    u_float_scale: (a * window.devicePixelRatio) / I.fonts.baseSize,
                                }),
                                !0
                            );
                        },
                        _r = (e, t, i, n, o, r) => {
                            var s, a;
                            const l = r.style;
                            if ('point' === o.symbol) {
                                switch (o.attributes.labelIndex) {
                                    case io.bR.Second:
                                        return (
                                            (null !== (s = l.textHaloWidth2) && void 0 !== s
                                                ? s
                                                : 0) > 0 && !!l.textHaloColor2
                                        );
                                    case io.bR.Icon:
                                        return (
                                            (null !== (a = l.iconTextHaloWidth) && void 0 !== a
                                                ? a
                                                : 0) > 0 && !!l.iconTextHaloColor
                                        );
                                    case io.bR.First:
                                }
                            }
                            return l.textHaloWidth > 0 && !!l.textHaloColor;
                        },
                        vr = (e, t, i, n, o, r) =>
                            yr(
                                e,
                                t,
                                i,
                                o,
                                r.style.textFontSize,
                                r.style.textColor,
                                r.style.textHaloWidth,
                                r.style.textHaloColor,
                                o.layerSettings.uniformSet,
                            ),
                        gr = (e, t, i, n, o, r) => {
                            const { layerSettings: s } = o,
                                { uniformSet: a } = s,
                                l = o.attributes.labelIndex,
                                c = r.style;
                            let {
                                textFontSize: d,
                                textHaloWidth: h,
                                textColor: u,
                                textHaloColor: m,
                            } = c;
                            switch (l) {
                                case io.bR.Icon:
                                    (d = c.iconTextFontSize),
                                        (h = c.iconTextHaloWidth),
                                        (u = c.iconTextColor),
                                        (m = c.iconTextHaloColor);
                                    break;
                                case io.bR.Second:
                                    (d = c.textFontSize2),
                                        (h = c.textHaloWidth2),
                                        (u = c.textColor2),
                                        (m = c.textHaloColor2);
                            }
                            return br(e, t, i, o, d, u, h, m, a);
                        },
                        yr = (e, t, i, n, o, r, s, a, l) => {
                            const c = (0, $.jJ)(
                                    i.styleZoom,
                                    i.styleState,
                                    n.attributes.tileData,
                                    Boolean(n.layerSettings.isOverlappedObject),
                                ),
                                d = (0, $.vn)(o, c) / I.fonts.baseSize,
                                h = d * window.devicePixelRatio,
                                u = I.fonts.gamma / h,
                                m = 'fontHalo' === l ? (6 - (0, $.vn)(s, c) / d) / 8 : 0.75;
                            let f;
                            if ('fontHalo' === l) {
                                if (!a) return !1;
                                f = (0, $.m2)((0, $.zn)(a, c));
                            } else f = (0, $.m2)((0, $.zn)(r, c));
                            return (
                                t.bind(e, { u_float_buffer: m, u_float_gamma: u, u_vec4_color: f }),
                                !0
                            );
                        },
                        br = (e, t, i, n, o, r, s, a, l) => {
                            const c = (0, $.jJ)(
                                    i.styleZoom,
                                    i.styleState,
                                    n.attributes.tileData,
                                    !1,
                                ),
                                d = (0, $.vn)(o, c) / I.fonts.baseSize,
                                h = d * window.devicePixelRatio,
                                u = I.fonts.gamma / h,
                                m = 'fontHalo' === l ? (6 - (0, $.vn)(s, c) / d) / 8 : 0.75;
                            let f, p;
                            if ('fontHalo' === l) {
                                if (!a) return !1;
                                (f = (0, $.m2)((0, $.zn)(a, c))),
                                    (c.isBehind = !0),
                                    (p = (0, $.m2)((0, $.zn)(a, c)));
                            } else
                                (f = (0, $.m2)((0, $.zn)(r, c))),
                                    (c.isBehind = !0),
                                    (p = (0, $.m2)((0, $.zn)(r, c)));
                            return (
                                t.bind(e, {
                                    u_float_buffer: m,
                                    u_float_gamma: u,
                                    u_vec4_color: f,
                                    u_vec4_hidden_color: p,
                                }),
                                !0
                            );
                        },
                        wr = (e, t, i, n, o) => {
                            const { attributes: r } = o,
                                { offsetX: s, offsetY: a } = r,
                                l = window.devicePixelRatio;
                            return t.bind(e, { u_vec2_offset: [s * l, a * l] }), !0;
                        },
                        xr = (e, t, i) => (t.bind(e, { u_float_style_zoom: i.styleZoom }), !0),
                        Sr = (e, t, i, n, o) => {
                            const { tile: r } = o,
                                { zoom: s } = i,
                                a = rt.y4 * Math.pow(2, s - r.zoomLevel) * window.devicePixelRatio;
                            return t.bind(e, { u_float_tile_to_pixel_ratio: rt.gt / a }), !0;
                        },
                        Ir = (e, t, i, { demManager: n, renderer: o, map: r }) => {
                            if (!r.state.demMode) return !1;
                            const s = n.getFlatFramebufferId(),
                                a = o.getFramebuffer(s);
                            if (!a) return !1;
                            const l = a.renderTarget.getTexture();
                            return l && l.enable(e, 0), t.bind(e, { u_flat_tex: 0 }), !0;
                        },
                        Mr = (e, t, i, { demManager: n, renderer: o, map: r }) => {
                            if (!r.state.demMode) return !1;
                            const s = n.getIdentifyFlatFramebufferId(),
                                a = o.getFramebuffer(s);
                            if (!a) return !1;
                            const l = a.renderTarget.getTexture();
                            return l && l.enable(e, 0), t.bind(e, { u_flat_tex: 0 }), !0;
                        },
                        Tr = (e, t, i, { demManager: n, renderer: o, map: r }) => {
                            if (!r.state.demMode) return !1;
                            const s = n.getHillshadeFramebufferId(),
                                a = o.getFramebuffer(s);
                            if (!a) return !1;
                            const l = a.renderTarget.getTexture();
                            return l && l.enable(e, Tn), t.bind(e, { u_hillshade_tex: Tn }), !0;
                        },
                        Pr = (e, t, i, n) => {
                            var o;
                            const r = n.demManager.getDemFramebufferId(),
                                s =
                                    null === (o = n.renderer.getFramebuffer(r)) || void 0 === o
                                        ? void 0
                                        : o.renderTarget.getTexture();
                            return (
                                !!s &&
                                (s.enable(e, 0),
                                t.bind(e, {
                                    u_tex_dem: 0,
                                    u_mat4_dem_corrected: n.demManager.demCorrectedFbVpToDemTex,
                                }),
                                !0)
                            );
                        },
                        Lr = (e, t, i, n, o, r) => {
                            const s = (0, $.vn)(r.style.elevation, lr(i, o));
                            return t.bind(e, { u_bool_skip_height_factor: Boolean(s) }), !0;
                        },
                        kr = (e, t, i, n, o, r) => {
                            let s = n.buildingHeightAnimator.getBuildingHeight(r.minzoom);
                            return (
                                n.map.state.demMode && (s = An + 0.999 * s),
                                t.bind(e, { u_float_height_factor: s }),
                                !0
                            );
                        },
                        Er = (e, t, i, n, o) => {
                            var r;
                            return (
                                t.bind(e, {
                                    u_float_height_delta:
                                        (null !== (r = o.attributes.heightDelta) && void 0 !== r
                                            ? r
                                            : 0) / rt._H,
                                }),
                                !0
                            );
                        },
                        Ar = (e, t, i, n, o) => (
                            t.bind(e, { u_float_tile_size: (0, G.aq)(o.tile.zoomLevel) }), !0
                        ),
                        zr = (e, t, i, n) => {
                            var o;
                            const r = n.renderer.getMapMeshFramebufferId(),
                                s =
                                    null === (o = n.renderer.getFramebuffer(r)) || void 0 === o
                                        ? void 0
                                        : o.renderTarget.getTexture();
                            return (
                                !!s &&
                                (s.enable(e, 0),
                                t.bind(e, { u_sampler_map_tex: 0, u_float_tex_scale: Bs }),
                                !0)
                            );
                        };
                    function Cr(...e) {
                        const t = (0, oo.lK)([0, 0, 0, 0]);
                        return (i, n, o, r, s, a) => {
                            for (let l = 0; l < e.length; l++) {
                                if (!e[l](i, n, o, r, s, a, t, null)) return !1;
                            }
                            return !0;
                        };
                    }
                    var Fr = i(7486);
                    const Or = new Float32Array(16);
                    function Dr(...e) {
                        return (t, i, n, o, r, s, a, l) => {
                            for (const c of e) {
                                if (!c(t, i, n, o, r, s, a, l)) return !1;
                            }
                            return !0;
                        };
                    }
                    const Rr = () => !0,
                        jr = (e, t, i, n, o) => (t.bind(e, { u_mat4_mvp: o.tile.mvpMatrix }), !0),
                        Br = (e, t, i, n, o) => (
                            $e.JG(Or, o.tile.modelMatrix), t.bind(e, { u_mat4_model: Or }), !0
                        );
                    function Nr(e, t) {
                        return (0, $.jJ)(e.styleZoom, e.styleState, t.attributes.tileData);
                    }
                    const Ur = (e, t, i, { styleManager: n }, o, r, s, a) => {
                            var l;
                            const c = Nr(i, o),
                                d = (0, $.Q9)(a.style.textureImage, c),
                                h = n.getStyle(o.attributes.styleId);
                            if (!h) return t.bind(e, { u_int_is_textured: 0 }), !0;
                            const u =
                                null === (l = h.rasterSets.byKey[(0, oo.FD)(d)]) || void 0 === l
                                    ? void 0
                                    : l.rasters;
                            if (!u) return t.bind(e, { u_int_is_textured: 0 }), !0;
                            const m = a.style.textureSize,
                                [f, p] = Array.isArray(m) ? m : [m, m];
                            if (f <= 0 || p <= 0) return t.bind(e, { u_int_is_textured: 0 }), !0;
                            const _ = (0, Fr.Bl)(u, f * window.devicePixelRatio, !0);
                            if (void 0 === _) return t.bind(e, { u_int_is_textured: 0 }), !0;
                            const { tile: v } = o,
                                { zoom: g } = i,
                                y = u[_],
                                b =
                                    rt.y4 *
                                    Math.pow(2, Math.round(g) - v.zoomLevel) *
                                    window.devicePixelRatio,
                                w = ((v.coords[0] * b) % y.w) / y.w,
                                x = ((v.coords[1] * b) % y.h) / y.h,
                                S = b / y.w,
                                M = b / y.h;
                            return (
                                t.bind(e, {
                                    u_int_is_textured: 1,
                                    u_float_texture_params: [w, x, S, M],
                                    u_sr2d_texture: y.atlasIndex,
                                    u_float_sprite_texture_coords: [
                                        (y.x + 0.5) / I.atlasSize[0],
                                        (y.y + y.h - 1) / I.atlasSize[1],
                                        (y.x + y.w - 1) / I.atlasSize[0],
                                        (y.y + 0.5) / I.atlasSize[1],
                                    ],
                                }),
                                !0
                            );
                        },
                        Zr = (e, t, i, { styleManager: n }, o, r, s, a) => {
                            var l;
                            const c = Nr(i, o),
                                d = (0, $.Q9)(a.style.textureImage, c),
                                h = n.getStyle(o.attributes.styleId);
                            if (!h) return !1;
                            const u =
                                null === (l = h.rasterSets.byKey[(0, oo.FD)(d)]) || void 0 === l
                                    ? void 0
                                    : l.rasters;
                            if (!u) return !1;
                            const m = a.style.textureSize,
                                [f, p] = Array.isArray(m) ? m : [m, m];
                            if (f <= 0 || p <= 0) return !1;
                            const _ = (0, Fr.Bl)(u, f * window.devicePixelRatio, !0);
                            if (void 0 === _) return !1;
                            const v = u[_];
                            return (
                                t.bind(e, {
                                    u_sr2d_texture: v.atlasIndex,
                                    u_float_sprite_texture_coords: [
                                        (v.x + 0.5) / I.atlasSize[0],
                                        (v.y + v.h - 1) / I.atlasSize[1],
                                        (v.x + v.w - 1) / I.atlasSize[0],
                                        (v.y + 0.5) / I.atlasSize[1],
                                    ],
                                }),
                                !0
                            );
                        },
                        Hr = (e, t, i, n, o, r) => {
                            if (null === r) return !1;
                            const s = r.linked;
                            if (!s) return !1;
                            const a = s[o.id];
                            return (
                                !!a &&
                                (t.bind(e, {
                                    u_mat4_instance: a.transformMatrix,
                                    u_mat4_mvp: r.tile.mvpMatrix,
                                }),
                                !0)
                            );
                        },
                        Gr = (e, t, i, n, o, r) => {
                            if (null === r) return !1;
                            const s = r.linked;
                            if (!s) return !1;
                            return (
                                !!s[o.id] &&
                                ($e.JG(Or, r.tile.modelMatrix), t.bind(e, { u_mat4_model: Or }), !0)
                            );
                        };
                    class Vr {
                        constructor(e) {
                            (this.gl = e),
                                (this.ext = e.getExtension('EXT_disjoint_timer_query')),
                                (this.queries = []);
                        }
                        addTimer() {
                            if (!this.ext) return;
                            const e = this.ext.createQueryEXT();
                            this.queries.push(e),
                                this.ext.beginQueryEXT(this.ext.TIME_ELAPSED_EXT, e);
                        }
                        stopTimer() {
                            this.ext &&
                                this.queries.length &&
                                this.ext.endQueryEXT(this.ext.TIME_ELAPSED_EXT);
                        }
                        tryToGetFirstTimerValue() {
                            if (!this.ext) return;
                            const e = this.queries[0];
                            if (!e) return;
                            const t = this.ext,
                                i = t.getQueryObjectEXT(e, t.QUERY_RESULT_AVAILABLE_EXT),
                                n = this.gl.getParameter(t.GPU_DISJOINT_EXT);
                            if (!i || n) return;
                            const o = t.getQueryObjectEXT(e, t.QUERY_RESULT_EXT);
                            return t.deleteQueryEXT(e), this.queries.shift(), Number(o);
                        }
                    }
                    class Wr {
                        constructor(e) {
                            (this._enable = !1),
                                (this.name = e.name),
                                (this.index = e.index),
                                (this.location = void 0 !== e.location ? e.location : -1);
                        }
                        bindLocation(e, t) {
                            return (
                                -1 !== this.location &&
                                    !0 !== this.index &&
                                    e.bindAttribLocation(t, this.location, this.name),
                                this
                            );
                        }
                        getLocation(e, t) {
                            return (
                                -1 === this.location &&
                                    !0 !== this.index &&
                                    (this.location = e.getAttribLocation(t, this.name)),
                                this
                            );
                        }
                        bind(e, t) {
                            return (
                                this._enable ||
                                    !0 === this.index ||
                                    (e.enableVertexAttribArray(this.location), (this._enable = !0)),
                                t.bind(e, this.location),
                                this
                            );
                        }
                        disable(e) {
                            return (
                                this._enable &&
                                    !0 !== this.index &&
                                    (e.disableVertexAttribArray(this.location),
                                    (this._enable = !1)),
                                this
                            );
                        }
                    }
                    class qr {
                        constructor(e) {
                            (this.location = null), (this.name = e.name), (this.type = e.type);
                        }
                        getLocation(e, t) {
                            return (this.location = e.getUniformLocation(t, this.name)), this;
                        }
                        bind(e, t) {
                            const i = this.type;
                            return (
                                'mat2' === i
                                    ? e.uniformMatrix2fv(this.location, !1, t)
                                    : 'mat3' === i
                                    ? e.uniformMatrix3fv(this.location, !1, t)
                                    : 'mat4' === i
                                    ? e.uniformMatrix4fv(this.location, !1, t)
                                    : '2f' === i
                                    ? e.uniform2f(this.location, t[0], t[1])
                                    : '3f' === i
                                    ? e.uniform3f(this.location, t[0], t[1], t[2])
                                    : '4f' === i
                                    ? e.uniform4f(this.location, t[0], t[1], t[2], t[3])
                                    : '2i' === i
                                    ? e.uniform2i(this.location, t[0], t[1])
                                    : '3i' === i
                                    ? e.uniform3i(this.location, t[0], t[1], t[2])
                                    : '4i' === i
                                    ? e.uniform4i(this.location, t[0], t[1], t[2], t[3])
                                    : e['uniform' + i](this.location, t),
                                this
                            );
                        }
                    }
                    class $r {
                        constructor(e) {
                            (this.uniforms = {}),
                                (this.attributes = {}),
                                (this._webglProgram = null),
                                (this._linked = !1),
                                (this._located = !1),
                                (this._error = !1),
                                (e = e || {}),
                                (this._vertexShader = e.vertex),
                                (this._fragmentShader = e.fragment),
                                (e.uniforms = e.uniforms || []),
                                e.uniforms.forEach((e) => {
                                    this.uniforms[e.name] = new qr(e);
                                }),
                                (e.attributes = e.attributes || []),
                                e.attributes.forEach((e) => {
                                    this.attributes[e.name] = new Wr(e);
                                });
                        }
                        enable(e, t) {
                            return this._error
                                ? this
                                : (this.link(e, t),
                                  this.locate(e),
                                  this._error || e.useProgram(this._webglProgram),
                                  this);
                        }
                        bind(e, t, i) {
                            if (this._error) return this;
                            if (t) for (const i in t) this.uniforms[i].bind(e, t[i]);
                            if (i) for (const t in i) this.attributes[t].bind(e, i[t]);
                            return this;
                        }
                        disable(e) {
                            if (this._error) return this;
                            for (const t in this.attributes) this.attributes[t].disable(e);
                            return this;
                        }
                        link(e, t) {
                            if (this._linked || this._error) return this;
                            try {
                                if (((this._webglProgram = e.createProgram()), !this._webglProgram))
                                    throw new Error('Failed to create shader program');
                                const i = this._vertexShader.get(e, t),
                                    n = this._fragmentShader.get(e, t);
                                i && e.attachShader(this._webglProgram, i),
                                    n && e.attachShader(this._webglProgram, n);
                                for (const t in this.attributes)
                                    this.attributes[t].bindLocation(e, this._webglProgram);
                                if (
                                    (e.linkProgram(this._webglProgram),
                                    !e.getProgramParameter(this._webglProgram, e.LINK_STATUS))
                                )
                                    throw new Error(
                                        e.getProgramInfoLog(this._webglProgram) ||
                                            "Couldn't get shader program Info Log",
                                    );
                                this._linked = !0;
                            } catch (e) {
                                throw ((this._error = !0), e);
                            }
                            return this;
                        }
                        locate(e) {
                            if (this._located || this._error || !this._webglProgram) return this;
                            for (const t in this.attributes)
                                this.attributes[t].getLocation(e, this._webglProgram);
                            for (const t in this.uniforms)
                                this.uniforms[t].getLocation(e, this._webglProgram);
                            return (this._located = !0), this;
                        }
                    }
                    const Xr =
                            '\nvec4 apply_opacity(const vec4 color, const float opacity)\n{\nreturn color * opacity;\n}\n',
                        Yr = {
                            prelude:
                                '#ifdef WEBGL2\n#define varying in\n#define attribute in\n#define texture2D texture\n#define gl_FragColor fragColor\nout vec4 gl_FragColor;\n#endif\n',
                            affine_step:
                                '\nfloat affine_step(const float edge0, const float edge1, const float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0., 1.);\n}\n',
                            apply_opacity: Xr,
                            color: 'varying vec4 v_vec4_color;\nvoid main()\n{\n    gl_FragColor = apply_fog(v_vec4_color);\n}\n',
                            gradient:
                                'varying mat4 v_mat4_gradient;\nvarying vec4 v_vec4_color;\nvarying float v_float_height_gradient;\nvoid main()\n{\nvec4 color = v_vec4_color;\nif (v_mat4_gradient[0][2] != 0.) {\ncolor = mix(v_mat4_gradient[1], v_mat4_gradient[2], smoothstep(v_mat4_gradient[0][0], v_mat4_gradient[0][1], v_float_height_gradient));\n}\ngl_FragColor = apply_fog(color);\n}',
                            line: 'varying vec4 v_vec4_color;\nvarying float v_float_distance;\nvarying float v_float_height_gradient;\nvarying mat4 v_mat4_gradient;\nvoid main()\n{ \n    vec4 color = v_vec4_color;\n    if (v_mat4_gradient[0][2] != 0.) {\n        color = mix(v_mat4_gradient[1], v_mat4_gradient[2], smoothstep(v_mat4_gradient[0][0], v_mat4_gradient[0][1], v_float_height_gradient));\n    }\n    color *= (1. - abs(v_float_distance * gl_FragCoord.w));\n    gl_FragColor = apply_fog(color);\n}\n',
                            lowp_float: 'precision lowp float;\n',
                            mediump_float: 'precision mediump float;\n',
                            highp_float: 'precision highp float;\n',
                            pointsprite:
                                'uniform sampler2D u_sr2d_texture;\nuniform vec2 u_vec2_opacity;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_behind_factor;\nvoid main()\n{\n    vec4 color = texture2D(u_sr2d_texture, v_vec2_texcoord);\n    float opacity = mix(u_vec2_opacity[1], u_vec2_opacity[0], v_float_behind_factor);\n    gl_FragColor = apply_opacity(color, opacity);\n}\n',
                            striped_line:
                                'varying vec4 v_vec4_dash_color;\nvarying vec4 v_vec4_space_color;\nvarying vec4 v_vec4_border_color;\nvarying vec2 v_vec2_circle;\nvarying float v_float_width;\nvarying float v_float_part_color_swap_threshold;\nvarying float v_float_distance_in_parts;\nvec4 distance_func_smooth(in vec4 main_color, in vec4 border_color, in vec2 circle)\n{\n    float circle_length = length(circle);\n    float distance = circle_length - v_float_width;\n    mat2 derivatives = mat2(dFdx(v_vec2_circle), dFdy(v_vec2_circle));\n    \n    \n    \n    vec2 circle_dx = derivatives[0];\n    vec2 circle_dy = derivatives[1];\n    \n    float distance_dx = dot(v_vec2_circle, circle_dx);\n    float distance_dy = dot(v_vec2_circle, circle_dy);\n    \n    float derivative_denominator = circle_length;\n    float width = max(abs(distance_dx), abs(distance_dy));\n    vec4 from_main_to_border = mix(\n        main_color,\n        border_color,\n        affine_step(-width, 0., distance * derivative_denominator));\n    vec4 from_color_to_fade = mix(\n        from_main_to_border,\n        vec4(0.),\n        affine_step(0., +width, distance * derivative_denominator));\n    return from_color_to_fade;\n}\nfloat calculate_segment_color_factor(in float distance_in_parts, in float threshold)\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    float color_factor = abs(fract(distance_in_parts + 0.5 - 0.5 * threshold) - 0.5);\n    \n    float parts_affine_step_width = fwidth(distance_in_parts);\n    \n    float smoothed_color_factor = affine_step(\n        0.5 * threshold - 0.5 * parts_affine_step_width,\n        0.5 * threshold + 0.5 * parts_affine_step_width,\n        color_factor);\n    return smoothed_color_factor;\n}\nvoid main()\n{\n    vec4 current_segment_color = mix(\n        v_vec4_dash_color,\n        v_vec4_space_color,\n        calculate_segment_color_factor(\n            v_float_distance_in_parts,\n            v_float_part_color_swap_threshold));\n    \n    vec4 final_border_color = (1.0 - v_vec4_border_color.a) * current_segment_color + v_vec4_border_color;\n    vec4 color = distance_func_smooth(current_segment_color, final_border_color, v_vec2_circle);\n    gl_FragColor = apply_fog(color);\n}\n',
                            label: 'uniform sampler2D u_sr2d_texture;\nuniform float u_float_buffer;\nuniform float u_float_gamma;\nuniform vec4 u_vec4_color;\nuniform vec4 u_vec4_hidden_color;\nuniform float u_float_opacity;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_behind_factor;\nvoid main() {\n    float dist = texture2D(u_sr2d_texture, v_vec2_texcoord).a;\n    float alpha = smoothstep(\n        u_float_buffer - u_float_gamma,\n        u_float_buffer + u_float_gamma,\n        dist\n    );\n    vec4 color = mix(u_vec4_hidden_color, u_vec4_color, v_float_behind_factor);\n    gl_FragColor = apply_opacity(color * alpha, u_float_opacity);\n}\n',
                            label_directional:
                                'uniform sampler2D u_sr2d_texture;\nuniform float u_float_buffer;\nuniform float u_float_gamma;\nuniform vec4 u_vec4_color;\nuniform float u_float_opacity;\nvarying vec2 v_vec2_texcoord;\nvoid main() {\n    float dist = texture2D(u_sr2d_texture, v_vec2_texcoord).a;\n    float alpha = smoothstep(\n        u_float_buffer - u_float_gamma,\n        u_float_buffer + u_float_gamma,\n        dist\n    );\n    gl_FragColor = apply_opacity(u_vec4_color * alpha, u_float_opacity);\n}\n',
                            one_way_line:
                                'uniform vec2 u_vec2_wing_normal;\nuniform vec2 u_vec2_tip_normal;\nuniform float u_float_width;\nuniform float u_float_length;\nuniform vec2 u_vec2_vpt_size;\nuniform float u_float_tip_height_multiplier;\nuniform float u_float_wing_height_multiplier;\nvarying vec4 v_vec4_color;\nvarying vec4 v_vec4_border_color;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_border_width;\nvarying float v_float_zpt_to_texcoord_factor;\nvarying float v_float_outer_width;\nvarying float v_float_opacity;\nfloat one_way_line_distance(const ArrowDistances ad)\n{\n    return max(max(max(ad.top_tip_cut, ad.bottom_tip_cut), max(ad.top_left_wing, ad.top_right_wing)), min(ad.line, min(ad.bottom_left_wing, ad.bottom_right_wing)));\n}\nvoid main()\n{\n    mat2 derivatives = mat2(dFdx(v_vec2_texcoord), dFdy(v_vec2_texcoord));\n    ArrowDistanceParameters arrow_parameters = calculate_arrow_distance_parameters(\n        u_vec2_wing_normal,\n        u_vec2_tip_normal,\n        u_float_width * v_float_zpt_to_texcoord_factor,\n        u_float_length * v_float_zpt_to_texcoord_factor,\n        u_float_tip_height_multiplier,\n        u_float_wing_height_multiplier);\n    \n    float border_clipping = (abs(v_vec2_texcoord.y) - v_float_outer_width) / max(abs(derivatives[0].y), abs(derivatives[1].y));\n    float fill_factor = affine_step(-1., 0., one_way_line_distance(calculate_arrow_distances(arrow_parameters, v_vec2_texcoord, 0., derivatives)));\n    float border_factor = max(border_clipping, affine_step(0., 1., one_way_line_distance(calculate_arrow_distances(arrow_parameters, v_vec2_texcoord, v_float_border_width, derivatives))));\ngl_FragColor = apply_opacity(mix(mix(v_vec4_color, v_vec4_border_color, fill_factor), vec4(0.), border_factor), v_float_opacity);\n}\n',
                            color_identify:
                                'varying vec4 v_vec4_identifier;\nvoid main()\n{\n    gl_FragColor = v_vec4_identifier;\n}\n',
                            pointsprite_identify:
                                'uniform sampler2D u_sr2d_texture;\nvarying vec2 v_vec2_texcoord;\nvarying vec4 v_vec4_identifier;\nvoid main()\n{\n    vec4 color = texture2D(u_sr2d_texture, v_vec2_texcoord);\n    if (color.a < 0.3) {\n        discard;\n    } else {\n        gl_FragColor = v_vec4_identifier;\n    }\n}\n',
                            zbm_model:
                                'uniform sampler2D u_sr2d_texture;\nuniform vec4 u_vec4_color;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    vec4 color = texture2D(u_sr2d_texture, v_vec2_texcoord) * u_vec4_color;\n    gl_FragColor = apply_fog(color);\n}\n',
                            gltf_model:
                                'uniform sampler2D u_sr2d_texture_0;\nuniform vec4 u_vec4_color;\nuniform int u_int_has_ao_texture;\nuniform sampler2D u_ao_texture;\nvarying vec2 v_vec2_texcoord_color;\nvarying vec2 v_vec2_texcoord_ao;\nvoid main()\n{\n    vec4 tex_color = texture2D(u_sr2d_texture_0, v_vec2_texcoord_color);\n    \n    \n    if (u_int_has_ao_texture == 1) {\n        \n        \n        vec4 ao_tex_color = texture2D(u_ao_texture, v_vec2_texcoord_ao);\n        tex_color *= ao_tex_color;\n    }\n    gl_FragColor = apply_fog(tex_color * u_vec4_color);\n}',
                            simple_line:
                                'uniform vec4 u_vec4_color;\nvarying float v_float_distance;\nvarying float v_float_distance_offset;\nvoid main()\n{\n    vec4 color = u_vec4_color * clamp(\n        1. + v_float_distance_offset - abs(v_float_distance * gl_FragCoord.w),\n        0.,\n        1.);\n    gl_FragColor = apply_fog(color);\n}\n',
                            enable_standard_derivatives:
                                '#ifdef WEBGL1\n#extension GL_OES_standard_derivatives: enable\n#endif\n',
                            arrow_functions:
                                'struct ArrowDistanceParameters\n{\n    vec2 wing_normal;\n    vec2 tip_normal;\n    vec2 mirrored_wing_normal;\n    vec2 mirrored_tip_normal;\n    float width;\n    float full_length;\n    float arrow_height;\n};\nArrowDistanceParameters calculate_arrow_distance_parameters(\n    const vec2 wing_normal,\n    const vec2 tip_normal,\n    const float width_zpt,\n    const float length_zpt,\n    const float tip_height_multiplier,\n    const float wing_height_multiplier)\n{\n    vec2 mirrored_wing_normal = vec2(wing_normal.x, -wing_normal.y);\n    vec2 mirrored_tip_normal = vec2(tip_normal.x, -tip_normal.y);\n    float width = 0.5 * width_zpt;\n    float length = 0.5 * length_zpt;\n    float arrow_height = width_zpt * (tip_height_multiplier - wing_height_multiplier);\n    return ArrowDistanceParameters(\n        wing_normal,\n        tip_normal,\n        mirrored_wing_normal,\n        mirrored_tip_normal,\n        width,\n        length,\n        arrow_height);\n}\nstruct ArrowDistances\n{\n    float top_tip_cut;\n    float bottom_tip_cut;\n    float line;\n    float bottom_left_wing;\n    float bottom_right_wing;\n    float top_left_wing;\n    float top_right_wing;\n};\nArrowDistances calculate_arrow_distances(\n    const ArrowDistanceParameters arrow_parameters,\n    const vec2 texcoord,\n    const float offset,\n    const mat2 derivatives)\n{\n    float derivatives_x_multiplier = 1. / max(abs(derivatives[0].x), abs(derivatives[1].x));\n    float dt = ( texcoord.x - arrow_parameters.full_length - offset) * derivatives_x_multiplier;\n    float d0 = (-texcoord.x - arrow_parameters.full_length - offset) * derivatives_x_multiplier;\n    float d1 = (abs(texcoord.y) - arrow_parameters.width - offset) / max(abs(derivatives[0].y), abs(derivatives[1].y));\n    float d2 = (dot(texcoord - vec2(arrow_parameters.full_length - arrow_parameters.arrow_height, 0.), arrow_parameters.wing_normal) - offset) / max(abs(dot(derivatives[0], arrow_parameters.wing_normal)), abs(dot(derivatives[1], arrow_parameters.wing_normal)));\n    float d3 = (dot(texcoord - vec2(arrow_parameters.full_length - arrow_parameters.arrow_height, 0.), arrow_parameters.mirrored_wing_normal) - offset) / max(abs(dot(derivatives[0], arrow_parameters.mirrored_wing_normal)), abs(dot(derivatives[1], arrow_parameters.mirrored_wing_normal)));\n    float d4 = (dot(texcoord - vec2(arrow_parameters.full_length, 0.), arrow_parameters.tip_normal) - offset) / max(abs(dot(derivatives[0], arrow_parameters.tip_normal)), abs(dot(derivatives[1], arrow_parameters.tip_normal)));\n    float d5 = (dot(texcoord - vec2(arrow_parameters.full_length, 0.), arrow_parameters.mirrored_tip_normal) - offset) / max(abs(dot(derivatives[0], arrow_parameters.mirrored_tip_normal)), abs(dot(derivatives[1], arrow_parameters.mirrored_tip_normal)));\n    return ArrowDistances(dt, d0, d1, d2, d3, d4, d5);\n}\n',
                            circle_functions:
                                '\nconst float g_distance_precision_limit = 1e-4;\nstruct CircleDistance\n{\n    float distance;\n    float width;\n};\nCircleDistance circle_color_distance(\n    const mat2 derivatives,\n    const vec2 circle,\n    const float circle_width)\n{\n    float circle_length = length(circle);\n    float distance = circle_length - circle_width;\n    \n    \n    \n    vec2 circle_dx = derivatives[0];\n    vec2 circle_dy = derivatives[1];\n    \n    float distance_dx = dot(circle, circle_dx);\n    float distance_dy = dot(circle, circle_dy);\n    \n    float derivative_denominator = circle_length;\n    float width = max(abs(distance_dx), abs(distance_dy));\n    return CircleDistance(\n        distance * derivative_denominator,\n        width);\n}\nvec4 distance_to_color(\n    const float fill_distance,\n    const float border_distance,\n    const vec4 fill_color,\n    const vec4 border_color)\n{\n    float fill_factor = affine_step(-1., 0., fill_distance);\n    float border_factor = affine_step(0., 1., border_distance);\n    return\n        mix(mix(fill_color, border_color, fill_factor), vec4(.0), border_factor);\n}\nvec4 distance_to_color(\n    const CircleDistance circle_distance,\n    const vec4 fill_color)\n{\n    \n    \n    float fill_factor = circle_distance.distance < g_distance_precision_limit\n        ? 0.\n        : affine_step(0., circle_distance.width, circle_distance.distance);\n    return mix(fill_color, vec4(0.), fill_factor);\n}\n',
                            arrow_line:
                                'uniform vec2 u_vec2_wing_normal;\nuniform vec2 u_vec2_tip_normal;\nuniform float u_float_tip_height_multiplier;\nuniform float u_float_wing_height_multiplier;\nvarying vec2 v_vec2_line_type_arrow_tail;\nvarying vec4 v_vec4_arrow_width_length_border_outer;\nvarying vec4 v_vec4_texcoord_arrow_line;\nvarying vec4 v_vec4_distance_vertex_hiding;\nvarying vec4 v_vec4_color;\nvarying vec4 v_vec4_border_color;\nconst float g_type_arrow = 1.;\nconst float g_type_start_border = 2.;\nbool lookalike(const float a, const float b)\n{\n    return abs(a - b) < 1e-4;\n}\nfloat filter_border(const float start, const float value)\n{\n    return step(start, value) * 2. - 1.;\n}\nfloat arrow_distance(\n    const ArrowDistanceParameters arrow_parameters,\n    const vec2 texcoord,\n    const float offset,\n    const mat2 derivatives,\n    const float line_distance,\n    const float line_distance_no_offset)\n{\n    ArrowDistances ad = calculate_arrow_distances(arrow_parameters, texcoord, offset, derivatives);\n    float derivatives_x_multiplier = 1. / max(abs(derivatives[0].x), abs(derivatives[1].x));\n    \n    \n    float intersection_point = arrow_parameters.full_length - arrow_parameters.arrow_height - arrow_parameters.width * u_vec2_wing_normal.y / u_vec2_wing_normal.x;\n    float tail_arrow_intersection = filter_border(-1., (texcoord.x - intersection_point) * derivatives_x_multiplier);\n    \n    float tail_hide_part = v_vec2_line_type_arrow_tail.y;\n    float tail_hide_mask = (-texcoord.x - tail_hide_part) * derivatives_x_multiplier;\n    float clipped_tail = max(tail_hide_mask, max(line_distance, max(ad.top_left_wing, ad.top_right_wing)));\n    float line_without_offset = filter_border(0., line_distance_no_offset);\n    float wings_with_tail = max(min(min(ad.bottom_left_wing, ad.bottom_right_wing), line_without_offset), max(ad.top_left_wing, ad.top_right_wing));\n    return (v_vec4_distance_vertex_hiding.x < v_vec4_distance_vertex_hiding.y)\n        ? max(ad.top_tip_cut, max(-max(tail_arrow_intersection, line_without_offset), wings_with_tail))\n        : max(ad.top_tip_cut, min(clipped_tail, max(-max(tail_arrow_intersection, line_without_offset), wings_with_tail)));\n}\nvec4 distance_to_arrow_line_color(\n    const float fill_distance,\n    const float border_distance)\n{\n    return distance_to_color(fill_distance, border_distance, v_vec4_color, v_vec4_border_color);\n}\nvec4 arrow_color(\n    const vec2 texcoord,\n    const ArrowDistanceParameters arrow_parameters,\n    const float line_fill_distance,\n    const float line_border_distance)\n{\n    mat2 derivatives = mat2(dFdx(texcoord), dFdy(texcoord));\n    \n    float border_clipping = (abs(texcoord.y) - v_vec4_arrow_width_length_border_outer.w) / max(abs(derivatives[0].y), abs(derivatives[1].y));\n    float arrow_border_distance = arrow_distance(\n        arrow_parameters,\n        texcoord,\n        v_vec4_arrow_width_length_border_outer.z,\n        derivatives,\n        line_border_distance,\n        line_fill_distance);\n    float border_factor = max(border_clipping, affine_step(0., 1., arrow_border_distance));\n    return distance_to_arrow_line_color(\n        arrow_distance(arrow_parameters, texcoord, 0., derivatives, line_fill_distance, line_fill_distance),\n        border_factor);\n}\nfloat line_start_distance(\n    const vec2 texcoord,\n    const float offset,\n    const mat2 derivatives,\n    const float line_distance)\n{\n    float tail_hide_part = v_vec2_line_type_arrow_tail.y;\n    float d0 = (-texcoord.x - offset) / max(abs(derivatives[0].x), abs(derivatives[1].x));\n    float dh = (texcoord.x - tail_hide_part) / max(abs(derivatives[0].x), abs(derivatives[1].x));\n    return max(d0, max(line_distance, dh));\n}\nvec4 line_color(const float line_fill_distance, const float line_border_distance)\n{\n    float type = v_vec2_line_type_arrow_tail.x;\n    float fill_distance = line_fill_distance;\n    float border_distance = line_border_distance;\n    if (lookalike(type, g_type_start_border))\n    {\n        vec2 texcoord = v_vec4_texcoord_arrow_line.xy;\n        mat2 derivatives = mat2(dFdx(texcoord), dFdy(texcoord));\n        fill_distance = line_start_distance(texcoord, 0., derivatives, line_fill_distance);\n        border_distance = line_start_distance(texcoord, v_vec4_arrow_width_length_border_outer.z, derivatives, line_border_distance);\n    }\n    return distance_to_arrow_line_color(fill_distance, border_distance);\n}\nvec4 arrow_line_color()\n{\n    if (lookalike(min(v_vec4_distance_vertex_hiding.y, 1.), 1.)\n        || lookalike(v_vec4_distance_vertex_hiding.w, 1.)\n        || !lookalike(v_vec2_line_type_arrow_tail.x, g_type_arrow) && (v_vec4_distance_vertex_hiding.x < v_vec4_distance_vertex_hiding.y || v_vec4_distance_vertex_hiding.x > v_vec4_distance_vertex_hiding.z))\n    {\n        discard;\n    }\n    ArrowDistanceParameters arrow_parameters = calculate_arrow_distance_parameters(\n        u_vec2_wing_normal,\n        u_vec2_tip_normal,\n        v_vec4_arrow_width_length_border_outer.x,\n        v_vec4_arrow_width_length_border_outer.y,\n        u_float_tip_height_multiplier,\n        u_float_wing_height_multiplier);\n    float line_width = arrow_parameters.width;\n    float line_border = v_vec4_arrow_width_length_border_outer.z;\n    \n    vec2 line_texcoord = v_vec4_texcoord_arrow_line.zw;\n    mat2 line_derivatives = mat2(dFdx(line_texcoord), dFdy(line_texcoord));\n    CircleDistance circle_fill_distance = circle_color_distance(line_derivatives, line_texcoord, line_width);\n    CircleDistance circle_border_distance = circle_color_distance(line_derivatives, line_texcoord, line_width + line_border);\n    float line_fill_distance = affine_step(-1., 0., circle_fill_distance.distance / circle_fill_distance.width) - 1.;\n    float line_border_distance = affine_step(0., circle_border_distance.width, circle_border_distance.distance);\n    return lookalike(v_vec2_line_type_arrow_tail.x, g_type_arrow)\n        ? arrow_color(v_vec4_texcoord_arrow_line.xy, arrow_parameters, line_fill_distance, line_border_distance)\n        : line_color(line_fill_distance, line_border_distance);\n}\nvoid main()\n{\n    gl_FragColor = arrow_line_color();\n}\n',
                            arrow_line_identify:
                                '\nvarying vec2 v_vec2_line_type_arrow_tail;\nvarying vec4 v_vec4_distance_vertex_hiding;\nvarying vec4 v_vec4_identifier;\nconst float g_type_arrow = 1.;\nbool lookalike(const float a, const float b)\n{\n    return abs(a - b) < 1e-5;\n}\nvoid main()\n{\n    if (lookalike(min(v_vec4_distance_vertex_hiding.y, 1.), 1.)\n        || lookalike(v_vec4_distance_vertex_hiding.w, 1.)\n        || !lookalike(v_vec2_line_type_arrow_tail.x, g_type_arrow) && (v_vec4_distance_vertex_hiding.x < v_vec4_distance_vertex_hiding.y || v_vec4_distance_vertex_hiding.x > v_vec4_distance_vertex_hiding.z))\n    {\n        discard;\n    }\n    gl_FragColor = v_vec4_identifier;\n}\n',
                            circle_marker:
                                'uniform vec4 u_vec4_color;\nvarying vec2 v_vec2_circle;\nvarying float v_float_width;\nvoid main() {\n    float center_distance = dot(v_vec2_circle, v_vec2_circle);\n    gl_FragColor = u_vec4_color * affine_step(1.0, 1.0 - 4.0 / v_float_width, center_distance);\n}\n',
                            road: 'uniform vec4 u_vec4_color;\nvarying vec2 v_vec2_normal;\nvarying float v_float_half_width;\nvoid main()\n{\n    \n    float opacity = 1.0 - affine_step(\n        v_float_half_width - length(fwidth(v_vec2_normal)),\n        v_float_half_width,\n        length(v_vec2_normal)\n    );\n    vec4 color = apply_fog(u_vec4_color);\n    gl_FragColor = color * opacity;\n}\n',
                            road_identify:
                                'varying vec4 v_vec4_identifier;\nvarying vec2 v_vec2_normal;\nvarying float v_float_half_width;\nvoid main()\n{\n    if (dot(v_vec2_normal, v_vec2_normal) > v_float_half_width * v_float_half_width) {\n        discard;\n    }\n    gl_FragColor = v_vec4_identifier;\n}\n',
                            rect: 'uniform vec4 u_vec4_color;\nvoid main()\n{\n    gl_FragColor = u_vec4_color;\n}\n',
                            rect_with_texture:
                                'uniform sampler2D u_sr2d_texture;\nuniform float u_float_opacity;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    vec4 color = texture2D(u_sr2d_texture, v_vec2_texcoord);\n    gl_FragColor = apply_opacity(color, u_float_opacity);\n}\n',
                            heatmap:
                                'uniform highp float u_float_intensity;\nvarying float v_float_weight;\nvarying vec2 v_vec2_extrude;\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n    float d = -0.5 * 3.0 * 3.0 * dot(v_vec2_extrude, v_vec2_extrude);\n    float val = v_float_weight * u_float_intensity * GAUSS_COEF * exp(d);\n    gl_FragColor = vec4(val, 1.0, 1.0, 1.0);\n}\n',
                            heatmap_texture:
                                'uniform sampler2D u_sr2d_texture;\nuniform sampler2D u_sr2d_ramp_texture;\nuniform float u_float_opacity;\nvarying vec2 v_vec2_position;\nvoid main() {\n    float t = texture2D(u_sr2d_texture, v_vec2_position).r;\n    vec4 color = texture2D(u_sr2d_ramp_texture, vec2(t, 0.5));\n    gl_FragColor = color * u_float_opacity;\n}\n',
                            dem_mesh:
                                '\nuniform sampler2D u_flat_tex;\nuniform sampler2D u_hillshade_tex;\nuniform sampler2D u_tex_hillshade_ramp;\nuniform float u_float_dem_shade_intension;\nvarying vec3 v_vec3_texcoord;\nvarying vec2 hs_tex_pos;\nconst float M_PI = 3.1415926535897932384626433832795;\nconst float zenith = 45. * M_PI / 180.;\nconst float HILLSHADE_OFFSET = cos(zenith) - 0.5;\nvoid main()\n{\n    \n    if (v_vec3_texcoord.z == 0.) {\n        discard;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    if (v_vec3_texcoord.x < 0. || v_vec3_texcoord.x > 1. || v_vec3_texcoord.y < 0. || v_vec3_texcoord.y > 1.) {\n        discard;\n    } else {\n        vec4 flatMapColor = texture2D(u_flat_tex, v_vec3_texcoord.xy);\n        \n        if (u_float_dem_shade_intension > 0.) {\n            float shade_raw = texture2D(u_hillshade_tex, hs_tex_pos).x;\n            float shade_value = texture2D(u_tex_hillshade_ramp, vec2(shade_raw, 0.5)).a;\n            float base = 1. - u_float_dem_shade_intension;\n            gl_FragColor.a = flatMapColor.a;\n            gl_FragColor.rgb = (flatMapColor.rgb * base) + (flatMapColor.rgb * 2. * u_float_dem_shade_intension * (shade_value - HILLSHADE_OFFSET));\n        } else {\n            gl_FragColor = flatMapColor;\n        }\n        gl_FragColor = apply_fog(gl_FragColor);\n    }\n}\n',
                            dem_ground:
                                'varying vec4 v_vec4_coords;\nvoid main()\n{\n    gl_FragColor = v_vec4_coords;\n}\n',
                            dem_elevation:
                                'uniform sampler2D u_sr2d_texture;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n  vec4 color = texture2D(u_sr2d_texture, v_vec2_texcoord);\n  gl_FragColor = vec4(color.a, 0, 0, 1);\n}\n',
                            dem_elevation_copy:
                                'uniform sampler2D u_sr2d_texture;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n  gl_FragColor = texture2D(u_sr2d_texture, v_vec2_texcoord);\n}\n',
                            dem_hillshade:
                                '\nuniform sampler2D u_tex_dem;\nconst float DEM_INVALID_VALUE = -9999.;\nuniform float u_float_dem_resolution;\nuniform float u_float_dem_cell_size;\nuniform float u_float_dem_light_direction;\nuniform float u_float_dem_scale;\nconst float M_PI = 3.1415926535897932384626433832795;\nconst float zenith = 45. * M_PI / 180.;\nvarying vec2 v_vec2_texcoord;\nmat3 get_kernel(vec2 pos, float step, float defval) {\n    mat3 kernel;\n    for (int x = 0; x < 3; x++) {\n        vec3 col;\n        for (int y = 0; y < 3; y++) {\n            col[y] = texture2D(u_tex_dem, vec2(pos.x + float(x - 1) * step, pos.y + float(y - 1) * step)).r;\n            if (col[y] == DEM_INVALID_VALUE) {\n                col[y] = defval;\n            }\n        }\n        kernel[x] = col;\n    }\n    return kernel;\n}\nfloat calc_aspect(mat3 kernel) {\n    float dzdx = ((kernel[2].z + 2.0 * kernel[2].y + kernel[2].x) - (kernel[0].z + 2.0 * kernel[0].y + kernel[0].x)) / 8.;\n    float dzdy = ((kernel[0].x + 2.0 * kernel[1].x + kernel[2].x) - (kernel[0].z + 2.0 * kernel[1].z + kernel[2].z)) / 8.;\n    \n    if (dzdx == 0. && dzdy == 0.) {\n        return 0.;\n    }\n    return atan(-dzdx, dzdy);\n}\nfloat calc_slope(mat3 kernel, float cell_size) {\n    float dzdx = ((kernel[2].z + 2. * kernel[2].y + kernel[2].x) - (kernel[0].z + 2. * kernel[0].y + kernel[0].x)) / (8. * cell_size);\n    float dzdy = ((kernel[0].x + 2. * kernel[1].x + kernel[2].x) - (kernel[0].z + 2. * kernel[1].z + kernel[2].z)) / (8. * cell_size);\n    float rise_run = sqrt(dzdx * dzdx + dzdy * dzdy);\n    return atan(rise_run);\n}\nfloat dem_hillshade(const vec2 tex_pos)\n{\n    \n    float tex_step = 1. / u_float_dem_resolution;\n    \n    if (u_float_dem_scale == 0.) {\n        return 0.;\n    }\n    \n    vec4 e = texture2D(u_tex_dem, tex_pos);\n    if (e.a == 0. || e.r == DEM_INVALID_VALUE) {\n        \n        return 0.;\n    }\n    mat3 kernel = get_kernel(tex_pos.xy, tex_step, e.r);\n    float aspect = calc_aspect(kernel);\n    float slope = calc_slope(kernel, u_float_dem_cell_size);\n    float azimuth = u_float_dem_light_direction;\n    \n    \n    \n    return (cos(zenith) * cos(slope)) +\n             (sin(zenith) * sin(slope) * cos(azimuth - aspect));\n}\nvoid main() {\n    gl_FragColor = vec4(dem_hillshade(v_vec2_texcoord), 0, 0, 1);\n}\n',
                            dem_flat_bottom:
                                'varying vec4 v_vec4_color;\nvoid main()\n{\n    gl_FragColor = v_vec4_color;\n}\n',
                            mesh: 'uniform sampler2D u_sampler2d_texture;\nuniform float u_float_opacity;\nuniform float u_float_shading;\nvarying vec4 v_vec4_color;\nvarying vec3 v_vec3_light_factor;\nvarying vec2 v_vec2_tex_coord;\nvarying float v_float_gradient;\nvoid main()\n{   \n    float gradient = 1. - u_float_shading * smoothstep(0., 1., abs(v_float_gradient));\n    \n    \n    if (v_vec2_tex_coord.x != -1.) {\n        \n        vec4 color = texture2D(u_sampler2d_texture, v_vec2_tex_coord);\n        gl_FragColor = apply_opacity(vec4(color.rgb * gradient * v_vec3_light_factor, color.a), u_float_opacity);\n    } else {\n        gl_FragColor = v_vec4_color;\n        gl_FragColor.rgb *= gradient;\n    }\n}\n',
                            textured_color:
                                'uniform sampler2D u_sr2d_texture;\nuniform float u_float_texture_opacity;\nuniform vec4 u_float_texture_params;\nuniform vec4 u_float_sprite_texture_coords;\nuniform int u_int_is_textured;\nvarying vec4 v_vec4_color;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    if (u_int_is_textured == 0) {\n        gl_FragColor = apply_fog(v_vec4_color);\n        return;\n    }\n    vec2 texcoord = fract(v_vec2_texcoord * u_float_texture_params.zw + u_float_texture_params.xy);\n    vec2 spritecoord = mix(u_float_sprite_texture_coords.xy, u_float_sprite_texture_coords.zw, texcoord);\n    vec4 color = texture2D(u_sr2d_texture, spritecoord);\n    vec4 texcolor = apply_opacity(color, u_float_texture_opacity);\n    gl_FragColor = apply_fog(texcolor + v_vec4_color * (1. - texcolor.a));\n}\n',
                            road_point_mark:
                                'uniform vec4 u_vec4_color;\nuniform sampler2D u_sr2d_texture;\nuniform vec4 u_float_sprite_texture_coords;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    vec2 spritecoord = mix(u_float_sprite_texture_coords.xy, u_float_sprite_texture_coords.zw, v_vec2_texcoord);\n    vec4 color = texture2D(u_sr2d_texture, spritecoord) * u_vec4_color;\n    gl_FragColor = apply_fog(color);\n}\n',
                            map_mesh:
                                'uniform sampler2D u_sampler_map_tex;\nuniform float u_float_tex_scale;\nuniform float u_float_shading;\nvarying vec4 v_tex_coord;\nvarying vec3 v_ambient_light;\nvarying float v_float_gradient;\nvoid main()\n{\nvec2 coord = v_tex_coord.xy / v_tex_coord.w;\ncoord.y = coord.y * (1. / u_float_tex_scale) + (1. / u_float_tex_scale);\ncoord = (coord / 2.) + vec2(0.5, 0.5);\nif (coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.) {\ngl_FragColor = vec4(1, 1, 1, 1);\n} else {\ngl_FragColor = texture2D(u_sampler_map_tex, coord);\ngl_FragColor.rgb *= 1. - u_float_shading * smoothstep(0.85, 1., abs(v_float_gradient));\ngl_FragColor.rgb *= v_ambient_light;\n}\n}',
                            fog: '\n#define LINEAR 0\n#define EXP 1\n#define FOG_EQUATION (LINEAR)\n#define EPSILON (0.0001)\n#ifdef FOG\nuniform vec3 u_fog_color;\nuniform vec3 u_fog_high_color;\nuniform vec2 u_fog_limits;\nuniform float u_fog_horizon_blend;\n#endif\n#if defined(FOG) || defined(SKY)\nvarying vec3 v_world_pos;\n#endif\n#ifdef FOG\nfloat fog_horizon_blending(vec3 camera_dir) {\n    float t = max(0.0, -camera_dir.z / u_fog_horizon_blend);\n    \n    return exp(-3.0 * t * t);\n}\nfloat fog_exponential(float t) {\n    const float decay = 6.0;\n    float falloff = 1.0 - min(1.0, exp(-decay * t));\n    \n    falloff *= falloff * falloff;\n    \n    return min(1.0, 1.00747 * falloff);\n}\nfloat fog_depth(float depth) {\n    float start = u_fog_limits.x;\n    float end = u_fog_limits.y;\n    float range = end - start;\n    float fac = (depth - start) / range;\n#if (FOG_EQUATION == LINEAR)\n    \n    fac = clamp(fac, 0.0, 1.0);\n#elif (FOG_EQUATION == EXP)\n    fac = fog_exponential(fac);\n#endif\n    return fac;\n}\nvec3 apply_fog_internal(vec3 color) {\n    float depth = length(v_world_pos);\n    float fac = fog_depth(depth);\n    vec3 dir = v_world_pos / depth;\n    fac *= fog_horizon_blending(dir);\n    vec3 fog_color = mix(u_fog_color, u_fog_high_color, clamp(dir.z / u_fog_horizon_blend, 0.0, 1.0));\n    return mix(color, fog_color, fac);\n}\n#endif \nvec4 apply_fog(vec4 color) {\n#ifdef FOG\n    float alpha = EPSILON + color.a;\n    color.rgb = apply_fog_internal(color.rgb / alpha) * alpha;\n#endif\n    return color;\n}\nvec4 apply_fog_sky(vec4 color) {\n#ifdef FOG\n    float alpha = EPSILON + color.a;\n    float depth = length(v_world_pos);\n    vec3 dir = v_world_pos / depth;\n    \n    float fac = max(dir.z, 0.0) / u_fog_horizon_blend;\n    fac = exp(-3.0 * fac * fac);\n    vec3 fog_color = mix(u_fog_color, u_fog_high_color, clamp(dir.z / u_fog_horizon_blend, 0.0, 1.0));\n    color.rgb = mix(color.rgb / alpha, fog_color, fac) * alpha;\n#endif\n    return color;\n}',
                            sky: 'uniform vec4 u_vec4_color;\n#define SKY_ALPHA_HORIZON_BLEND (6.0)\nvoid make_bottom_transparent(inout vec4 color) {\n#ifdef SKY\n    float depth = length(v_world_pos);\n    vec3 dir = v_world_pos / depth;\n    float alpha = clamp(1.0 + SKY_ALPHA_HORIZON_BLEND * dir.z, 0.0, 1.0);\n    color *= alpha;\n#endif\n}\nvoid main() {\n    vec4 color = u_vec4_color;\n    make_bottom_transparent(color);\n    color = apply_fog_sky(color);\n    gl_FragColor = vec4(color);\n}\n',
                        },
                        Kr = {
                            prelude:
                                '#ifdef WEBGL2\n#define varying out\n#define attribute in\n#define texture2D texture\n#endif\n',
                            apply_height_factor:
                                'vec4 apply_z_limitation(vec4 vertex, float tile_height, float height_limitation)\n{\n    \n    vertex.z = min(vertex.z, height_limitation / tile_height);\n    return vertex;\n}\nvec4 apply_height_factor(const vec3 vertex, const float height_factor)\n{\n    vec3 result_vertex = vertex;\n    result_vertex.z *= height_factor;\n    return vec4(result_vertex, 1.0);\n}\n',
                            apply_opacity: Xr,
                            color: 'uniform vec4 u_vec4_color;\nuniform float u_float_opacity;\nattribute vec2 a_vec2_vertex;\nvarying vec4 v_vec4_color;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    v_vec4_color = apply_opacity(u_vec4_color, u_float_opacity);\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n    calc_world_pos(a_vec2_vertex);\n    \n    \n    \n    \n    \n    \n    v_vec2_texcoord = fract(abs((a_vec2_vertex - 0.25) * 2.));\n}\n',
                            road_point_mark:
                                'attribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texcoord;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n    calc_world_pos(a_vec2_vertex);\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            diffuse:
                                'uniform vec3 u_vec3_light_direction;\nuniform vec3 u_vec3_light_color;\nuniform vec3 u_vec3_ambient_color;\nuniform vec4 u_vec4_color;\nuniform mat4 u_mat4_gradient;\nuniform float u_float_height_limitation;\nuniform float u_float_tile_height;\nuniform float u_float_height_factor;\nuniform float u_float_opacity;\nattribute vec3 a_vec3_vertex;\nattribute vec3 a_vec3_normal;\nattribute vec2 a_vec2_dem_position;\nvarying float v_float_height_gradient;\nvarying vec4 v_vec4_color;\nvarying mat4 v_mat4_gradient;\nconst float g_wall_offset_isometric = .001;\nconst float g_wall_offset_perspective = 8.;\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        v_vec4_color = vec4(0, 0, 0, 0);\n        return;\n    }\n    \n    \n    vec3 v_vec3_ambient_light = (u_vec3_ambient_color + u_vec3_light_color * abs(dot(u_vec3_light_direction, normalize_s08(a_vec3_normal))));\n    \n    v_vec4_color = apply_opacity(\n        vec4(\n            u_vec4_color.rgb * v_vec3_ambient_light,\n            u_vec4_color.a),\n        u_float_opacity);\n    \n    if (u_mat4_gradient[0][2] !=0.)\n    {\n        \n        if (a_vec3_vertex.z > 0.0)\n        {\n            v_float_height_gradient = 1.;\n        } else {\n            v_float_height_gradient = 0.;\n        }\n        v_mat4_gradient = mat4(u_mat4_gradient);\n        v_mat4_gradient[1] = apply_opacity(\n            vec4(\n                u_mat4_gradient[1].rgb * v_vec3_ambient_light,\n                u_mat4_gradient[1].a),\n            u_float_opacity);    \n        v_mat4_gradient[2] = apply_opacity(\n            vec4(\n                u_mat4_gradient[2].rgb * v_vec3_ambient_light,\n                u_mat4_gradient[2].a),\n            u_float_opacity);\n    }\n    vec4 vertex_hf = apply_height_factor(a_vec3_vertex, u_float_height_factor);\n    vertex_hf.z += height;\n    vertex_hf = apply_z_limitation(vertex_hf, u_float_tile_height, u_float_height_limitation);\n    \n    vertex_hf.z = max(vertex_hf.z, height);\n    gl_Position = u_mat4_mvp * vertex_hf;\n    \n    \n    \n    if (normalize_s08(a_vec3_normal).z < .5)\n    {\n        \n        if ((u_mat4_mvp[0][3] == 0.) && (u_mat4_mvp[1][3] == 0.) && (u_mat4_mvp[2][3] == 0.))\n        {\n            gl_Position.z += g_wall_offset_isometric;\n        }\n        else\n        {\n            \n            \n            \n            if (height == 0.) {\n                gl_Position.z += g_wall_offset_perspective;\n            } else {\n                gl_Position.z += g_wall_offset_isometric;\n            }\n        }\n    }\n    calc_world_pos(vertex_hf);\n}\n',
                            line: 'uniform vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_light_direction;\nuniform vec3 u_vec3_light_color;\nuniform vec3 u_vec3_ambient_color;\nuniform vec4 u_vec4_color;\nuniform float u_float_height_limitation;\nuniform float u_float_tile_height;\nuniform float u_float_height_factor;\nuniform float u_float_opacity;\nuniform mat4 u_mat4_gradient;\nattribute vec4 a_vec4_vertex;\nattribute vec2 a_vec2_normal;\nattribute vec2 a_vec2_normal_delta;\nattribute vec3 a_vec3_direction;\nattribute float a_float_distance;\nattribute vec2 a_vec2_dem_position;\nvarying vec4 v_vec4_color;\nvarying float v_float_distance;\nvarying float v_float_height_gradient;\nvarying mat4 v_mat4_gradient;\nconst float g_shift_pixels = 1.;\nconst float g_min_denominator = 1e-4;\nconst float g_w_factor = 1e-6;\nvec2 multiply_complex(vec2 lhs, vec2 rhs)\n{\n    return vec2(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);\n}\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec2 half_viewport = u_vec2_vpt_size / vec2(2.);\n    \n    if (a_vec4_vertex.z > 0.0)\n    {\n        v_float_height_gradient = 1.;\n    } else {\n        v_float_height_gradient = 0.;\n    }\n    \n    vec4 clip_space_direction = u_mat4_mvp * vec4(normalize_s08(vec3(a_vec3_direction.xy, a_vec3_direction.z + height)), 0.);\n    vec4 vertex_hf = apply_height_factor(a_vec4_vertex.xyz, u_float_height_factor);\n    vertex_hf.z += height;\n    vertex_hf = apply_z_limitation(vertex_hf, u_float_tile_height, u_float_height_limitation);\n    \n    vertex_hf.z = max(vertex_hf.z, height);\n    vec4 clip_space_vertex = u_mat4_mvp * vertex_hf;\n    vec2 screen_space_direction = (clip_space_direction.xy * clip_space_vertex.w - clip_space_vertex.xy * clip_space_direction.w) * half_viewport;\n    vec2 screen_space_perp = vec2(-screen_space_direction.y, screen_space_direction.x);\n    float denominator = max(g_min_denominator, length(screen_space_perp));\n    vec2 bevel_normal = normalize_s08(a_vec2_normal);\n    vec2 normal_delta = normalize_s08(a_vec2_normal_delta);\n    vec4 clip_space_bevel_normal = u_mat4_mvp * vec4(bevel_normal, 0., 0.);\n    vec2 screen_space_bevel_normal = (clip_space_bevel_normal.xy * clip_space_vertex.w - clip_space_vertex.xy * clip_space_bevel_normal.w) * half_viewport;\n    float bevel_denominator = max(g_min_denominator, length(screen_space_bevel_normal));\n    \n    float normal_factor = -dot(screen_space_bevel_normal, screen_space_perp) / denominator / bevel_denominator;\n    vec2 wall_normal = multiply_complex(bevel_normal, vec2(normal_delta.x, sign(normal_factor) * normal_delta.y));\n    float bevel_diffuse = abs(dot(u_vec3_light_direction.xy, bevel_normal));\n    float wall_diffuse = abs(dot(u_vec3_light_direction.xy, wall_normal));\n    float diffuse = mix(bevel_diffuse, wall_diffuse, abs(normal_factor));\n    gl_Position = g_w_factor * (clip_space_vertex + vec4(screen_space_perp / half_viewport, 0., 0.) * g_shift_pixels * a_float_distance / denominator * clip_space_vertex.w);\n    \n    vec3 v_vec3_ambient_light = u_vec3_ambient_color + u_vec3_light_color * diffuse;\n    v_vec4_color = vec4(u_vec4_color.rgb * v_vec3_ambient_light, u_vec4_color.a);\n    if (u_mat4_gradient[0][2] !=0.)\n    {\n        v_mat4_gradient = mat4(u_mat4_gradient);\n        v_mat4_gradient[1] = vec4(u_mat4_gradient[1].rgb * v_vec3_ambient_light, u_mat4_gradient[1].a);  \n        v_mat4_gradient[2] = vec4(u_mat4_gradient[2].rgb * v_vec3_ambient_light, u_mat4_gradient[2].a);  \n    }\n    v_float_distance = a_float_distance * gl_Position.w;\n    calc_world_pos(apply_height_factor(a_vec4_vertex.xyz, u_float_height_factor).xyz);\n}\n',
                            packed_attributes:
                                '\nvec2 normalize_s08(vec2 value)\n{\n    return value * (1. / 127.);\n}\nvec3 normalize_s08(vec3 value)\n{\n    return value * (1. / 127.);\n}\nfloat normalize_s16(float value)\n{\n    return value * (1. / 32767.);\n}\nvec2 normalize_s16(vec2 value)\n{\n    return value * (1. / 32767.);\n}\nvec3 normalize_s16(vec3 value)\n{\n    return value * (1. / 32767.);\n}\nvec2 unpack_widen(vec2 widen_packed)\n{\n    \n    return normalize_s08(widen_packed) * sqrt(2.);\n}\nvec2 unpack_texcoord(vec2 texcoord)\n{\n    return texcoord * (1. / 32768.);\n}\nvec2 unpack_model_texcoord(vec2 texcoord)\n{\n    const float min_value = -3.0;\n    const float max_value = 5.0;\n    return texcoord * (max_value - min_value) / 65536.0 + min_value;\n}\n',
                            pixel_offset:
                                '\nconst float g_min_denominator = 1e-7;\nconst float g_max_factor = 10000.;\nfloat calculate_multiplication_factor(\n    vec2 half_viewport,\n    \n    vec4 clip_space_widen,\n    vec4 clip_space_widen_perp,\n    \n    vec4 clip_space_vertex,\n    float shift_pixels)\n{\n    float limited_factor = 0.;\n    {\n        \n        vec2 screen_space_widen = (clip_space_widen.xy * clip_space_vertex.w - clip_space_vertex.xy * clip_space_widen.w) * half_viewport;\n        vec2 screen_space_widen_perp = (clip_space_widen_perp.xy * clip_space_vertex.w - clip_space_vertex.xy * clip_space_widen_perp.w) * half_viewport;\n        \n        vec2 perp = vec2(screen_space_widen_perp.y, -screen_space_widen_perp.x);\n        \n        float perp_length = length(perp);\n        vec4 v = clip_space_vertex;\n        vec4 n = clip_space_widen;\n        float denominator = dot(perp, screen_space_widen) / shift_pixels - n.w * v.w * perp_length;\n        if (abs(denominator) > g_min_denominator)\n        {\n            float factor = v.w * v.w * perp_length / denominator;\n            limited_factor = sign(factor) * min(g_max_factor, abs(factor));\n        }\n    }\n    return limited_factor;\n}\n',
                            pointsprite:
                                'uniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform float u_float_height_factor;\nuniform float u_float_rounding_factor;\nuniform vec2 u_vec2_rotation; \nuniform bool u_bool_skip_height_factor;\nuniform vec2 u_vec2_vpt_size;\nattribute vec3 a_vec3_position;\nattribute vec2 a_vec2_offset;\nattribute vec2 a_vec2_check_offset;\nattribute vec2 a_vec2_texcoord;\nattribute vec2 a_vec2_range;\nattribute vec2 a_vec2_rescale;\nattribute vec4 a_vec4_tex_identifier;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_behind_factor;\nvoid main()\n{\n    float height = dem_height(a_vec3_position.xy);\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    mat2 rotation_matrix = mat2(\n        u_vec2_rotation.x, -u_vec2_rotation.y,\n        u_vec2_rotation.y, u_vec2_rotation.x\n    );\n    vec2 inv_half_size = 2.0 / u_vec2_vpt_size;\n    vec4 anchor;\n    \n    \n    \n    if (u_bool_skip_height_factor == true) {\n        anchor = vec4(a_vec3_position, 1.0);\n    } else {\n        anchor = apply_height_factor(a_vec3_position, u_float_height_factor);\n    }\n    anchor.z += height;\n    anchor = u_mat4_mvp * anchor;\n    vec2 offset = rescale(rotation_matrix * a_vec2_offset, a_vec2_rescale, a_vec2_range, u_vec3_projection_scale_style_scale_dpi.y);\n    vec2 pos_2d = anchor.xy + overlay_transform(offset, inv_half_size) * anchor.w;\n    vec2 corner = make_position(pos_2d, anchor.w, inv_half_size, u_float_rounding_factor);\n    v_float_behind_factor = depth_test(anchor.xy / anchor.w + a_vec2_check_offset / u_vec2_vpt_size, anchor.z / anchor.w, a_vec4_tex_identifier);\n    gl_Position = vec4(corner, anchor.z, clipw(anchor.w, a_vec2_range, u_vec3_projection_scale_style_scale_dpi.y));\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            point_anchor:
                                'attribute vec4 a_vec4_position;\nattribute vec2 a_vec2_offset;\nattribute vec4 a_vec4_identifier;\nuniform vec2 u_vec2_offset;\nuniform vec2 u_vec2_vpt_size;\nvarying vec4 v_vec4_identifier;\nvoid main() {\n    float height = dem_height(a_vec4_position.xy);\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec4 ndcPosition = u_mat4_mvp * vec4(a_vec4_position.xy, a_vec4_position.z + height, a_vec4_position.w);\n    ndcPosition.xyz = ndcPosition.xyz / ndcPosition.w;\n    ndcPosition.w = 1.0;\n    ndcPosition.xy += (a_vec2_offset + u_vec2_offset) / u_vec2_vpt_size * 2.0;\n    gl_Position = ndcPosition;\n    v_vec4_identifier = a_vec4_identifier;\n}\n',
                            precision_constants:
                                '\nconst float g_circle_scale_precision_factor = 1e8;\n',
                            striped_line:
                                'uniform vec4 u_vec4_dash_color;\nuniform vec4 u_vec4_space_color;\nuniform vec4 u_vec4_border_color;\nuniform mediump vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform float u_float_width;\nuniform float u_float_width_offset;\nuniform vec2 u_vec2_scaler_params;\nuniform float u_float_dash_length;\nuniform float u_float_space_length;\nuniform float u_float_dash2_length;\nuniform float u_float_opacity;\nattribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texture_widen;\nattribute vec2 a_vec2_widen;\nattribute float a_float_vertex_distance;\nattribute float a_float_component_distance;\nattribute float a_float_object_length;\nvarying vec4 v_vec4_dash_color;\nvarying vec4 v_vec4_space_color;\nvarying vec4 v_vec4_border_color;\nvarying vec2 v_vec2_circle;\nvarying float v_float_width;\nvarying float v_float_part_color_swap_threshold;\nvarying float v_float_distance_in_parts;\nconst float g_shift_pixels = 2.;\nconst float g_w_factor = 1e-7;\nPolylineDistance decode_line_distance()\n{\n    return PolylineDistance(\n        a_float_vertex_distance,\n        a_float_component_distance,\n        a_float_object_length);\n}\nStripedLineInParams decode_line_params(const Scale scale)\n{\n    float width = calculate_final_width(scale, u_float_width, u_float_width_offset);\n    float dash_length  = scale.calculation * u_float_dash_length;\n    float space_length = scale.calculation * u_float_space_length;\n    float dash2_length = scale.calculation * u_float_dash2_length;\n    return StripedLineInParams(\n        dash_length,\n        space_length,\n        dash2_length,\n        width);\n}\nvoid main()\n{\n    Scale scale = calculate_scale(u_vec3_projection_scale_style_scale_dpi, u_vec2_scaler_params);\n    StripedLineInParams params = decode_line_params(scale);\n    vec2 widen = unpack_widen(a_vec2_widen);\n    vec2 widen_perp = vec2(-widen.y, widen.x);\n    \n    vec4 clip_space_widen = u_mat4_mvp * vec4(widen, 0., 0.);\n    vec4 clip_space_widen_perp = u_mat4_mvp * vec4(widen_perp, 0., 0.);\n    \n    vec4 clip_space_vertex = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0) + clip_space_widen * params.line_width;\n    vec2 half_viewport = 0.5 * u_vec2_vpt_size;\n    \n    float limited_factor = calculate_multiplication_factor(\n        half_viewport,\n        clip_space_widen,\n        clip_space_widen_perp,\n        clip_space_vertex,\n        g_shift_pixels);\n    PolylineDistance distance_decoded = decode_line_distance();\n    StripedLineOutParams output_params;\n    calculate_line_params(distance_decoded, params, output_params);\n    \n    \n    vec2 texture_widen_with_shift_sign = unpack_widen(a_vec2_texture_widen);\n    float shift_sign = sign(dot(widen, texture_widen_with_shift_sign));\n    vec2 texture_widen = shift_sign * texture_widen_with_shift_sign;\n    vec2 texture_widen_perp = vec2(-texture_widen.y, texture_widen.x);\n    float distance_shift = shift_sign * abs(dot(widen, texture_widen_perp)) * params.line_width;\n    float circle_factor = g_circle_scale_precision_factor / scale.calculation;\n    v_vec2_circle = texture_widen * (params.line_width + limited_factor) * circle_factor;\n    v_float_width = params.line_width * circle_factor;\n    v_float_part_color_swap_threshold = output_params.part_color_swap_threshold;\n    v_float_distance_in_parts = output_params.distance_in_parts;\n    v_vec4_dash_color = apply_opacity(u_vec4_dash_color, u_float_opacity);\n    v_vec4_space_color = apply_opacity(u_vec4_space_color, u_float_opacity);\n    v_vec4_border_color = apply_opacity(u_vec4_border_color, u_float_opacity);\n    gl_Position = (clip_space_vertex + clip_space_widen * limited_factor) * g_w_factor;\n    calc_world_pos(a_vec2_vertex);\n}\n',
                            striped_line_identify:
                                'uniform vec4 u_vec4_dash_color;\nuniform vec4 u_vec4_space_color;\nuniform vec4 u_vec4_border_color;\nuniform mediump vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform float u_float_width;\nuniform float u_float_width_offset;\nuniform vec2 u_vec2_scaler_params;\nuniform float u_float_dash_length;\nuniform float u_float_space_length;\nuniform float u_float_dash2_length;\nuniform float u_float_opacity;\nattribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texture_widen;\nattribute vec2 a_vec2_widen;\nattribute float a_float_vertex_distance;\nattribute float a_float_component_distance;\nattribute float a_float_object_length;\nattribute vec4 a_vec4_identifier;\nvarying vec4 v_vec4_identifier;\nvarying vec4 v_vec4_dash_color;\nvarying vec4 v_vec4_space_color;\nvarying vec4 v_vec4_border_color;\nvarying vec2 v_vec2_circle;\nvarying float v_float_width;\nvarying float v_float_part_color_swap_threshold;\nvarying float v_float_distance_in_parts;\nconst float g_shift_pixels = 2.;\nconst float g_w_factor = 1e-7;\nPolylineDistance decode_line_distance()\n{\n    return PolylineDistance(\n        a_float_vertex_distance,\n        a_float_component_distance,\n        a_float_object_length);\n}\nStripedLineInParams decode_line_params(const Scale scale)\n{\n    float width = calculate_final_width(scale, u_float_width, u_float_width_offset);\n    float dash_length  = scale.calculation * u_float_dash_length;\n    float space_length = scale.calculation * u_float_space_length;\n    float dash2_length = scale.calculation * u_float_dash2_length;\n    return StripedLineInParams(\n        dash_length,\n        space_length,\n        dash2_length,\n        width);\n}\nvoid main()\n{\n    Scale scale = calculate_scale(u_vec3_projection_scale_style_scale_dpi, u_vec2_scaler_params);\n    StripedLineInParams params = decode_line_params(scale);\n    vec2 widen = unpack_widen(a_vec2_widen);\n    vec2 widen_perp = vec2(-widen.y, widen.x);\n    \n    vec4 clip_space_widen = u_mat4_mvp * vec4(widen, 0., 0.);\n    vec4 clip_space_widen_perp = u_mat4_mvp * vec4(widen_perp, 0., 0.);\n    \n    vec4 clip_space_vertex = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0) + clip_space_widen * params.line_width;\n    vec2 half_viewport = 0.5 * u_vec2_vpt_size;\n    \n    float limited_factor = calculate_multiplication_factor(\n        half_viewport,\n        clip_space_widen,\n        clip_space_widen_perp,\n        clip_space_vertex,\n        g_shift_pixels);\n    PolylineDistance distance_decoded = decode_line_distance();\n    StripedLineOutParams output_params;\n    calculate_line_params(distance_decoded, params, output_params);\n    \n    \n    vec2 texture_widen_with_shift_sign = unpack_widen(a_vec2_texture_widen);\n    float shift_sign = sign(dot(widen, texture_widen_with_shift_sign));\n    vec2 texture_widen = shift_sign * texture_widen_with_shift_sign;\n    vec2 texture_widen_perp = vec2(-texture_widen.y, texture_widen.x);\n    float distance_shift = shift_sign * abs(dot(widen, texture_widen_perp)) * params.line_width;\n    float circle_factor = g_circle_scale_precision_factor / scale.calculation;\n    v_vec2_circle = texture_widen * (params.line_width + limited_factor) * circle_factor;\n    v_float_width = params.line_width * circle_factor;\n    v_float_part_color_swap_threshold = output_params.part_color_swap_threshold;\n    v_float_distance_in_parts = output_params.distance_in_parts;\n    v_vec4_dash_color = apply_opacity(u_vec4_dash_color, u_float_opacity);\n    v_vec4_space_color = apply_opacity(u_vec4_space_color, u_float_opacity);\n    v_vec4_border_color = apply_opacity(u_vec4_border_color, u_float_opacity);\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        gl_Position = (clip_space_vertex + clip_space_widen * limited_factor) * g_w_factor;\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            striped_line_functions:
                                'struct PolylineDistance\n{\n    \n    float vertex_distance_from_start;\n    \n    float segment_distance_from_start;\n    \n    float total_length;\n};\nstruct StripedLineInParams\n{\n    float dash_length;\n    float space_length;\n    float dash2_length;\n    float line_width;\n};\nstruct StripedLineOutParams\n{\n    \n    float part_color_swap_threshold;\n    float distance_in_parts;\n};\nvoid calculate_line_params(in PolylineDistance polyline_distance, in StripedLineInParams striped_line_params, out StripedLineOutParams line_params)\n{\n    \n    float requested_part_length =\n        striped_line_params.dash_length\n        + striped_line_params.space_length;\n    \n    float space2_length = requested_part_length - striped_line_params.dash2_length;\n    \n    float min_part_length =\n        requested_part_length\n        - 0.5 * min(striped_line_params.space_length, space2_length);\n    \n    float part_count = max(\n        floor(polyline_distance.total_length / requested_part_length + 0.5),\n        1.0);\n    \n    float part_length = polyline_distance.total_length / part_count;\n    \n    float dash_length = (part_length / requested_part_length) * striped_line_params.dash2_length;\n    float part_color_swap_threshold;\n    if (polyline_distance.total_length < min_part_length)\n    {\n        \n        dash_length = part_length;\n        part_color_swap_threshold = 1.0;\n    }\n    else\n    {\n        \n        part_color_swap_threshold = dash_length / part_length;\n    }\n    \n    \n    float segment_start = fract((polyline_distance.segment_distance_from_start + 0.5 * dash_length) / part_length);\n    float vertex_normalized_distance = segment_start + polyline_distance.vertex_distance_from_start / part_length;\n    line_params = StripedLineOutParams(\n        part_color_swap_threshold,\n        vertex_normalized_distance);\n}\n',
                            label_fixed_anchor:
                                'attribute vec4 a_vec4_position;\nattribute vec2 a_vec2_offset;\nattribute vec2 a_vec2_texcoord;\nattribute vec2 a_vec2_check_offset;\nattribute vec4 a_vec4_tex_identifier;\nuniform vec2 u_vec2_offset;\nuniform float u_float_scale;\nuniform float u_float_height_factor;\nuniform bool u_bool_skip_height_factor;\nuniform vec2 u_vec2_vpt_size;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_behind_factor;\nvoid main() {\n    float height = dem_height(a_vec4_position.xy);\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec4 ndcPosition;\n    \n    \n    \n    if (u_bool_skip_height_factor == true) {\n        ndcPosition = vec4(a_vec4_position.xyz, 1.0);\n    } else {\n        ndcPosition = apply_height_factor(a_vec4_position.xyz, u_float_height_factor);\n    }\n    ndcPosition.z += height;\n    ndcPosition = u_mat4_mvp * ndcPosition;\n    ndcPosition.xyz = ndcPosition.xyz / ndcPosition.w;\n    ndcPosition.w = 1.0;\n    v_float_behind_factor = depth_test(ndcPosition.xy + a_vec2_check_offset / u_vec2_vpt_size, ndcPosition.z, a_vec4_tex_identifier);\n    ndcPosition.xy += (a_vec2_offset * u_float_scale + u_vec2_offset) / u_vec2_vpt_size * 2.0;\n    gl_Position = ndcPosition;\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            label_fixed_anchor_identify:
                                'attribute vec4 a_vec4_position;\nattribute vec2 a_vec2_offset;\nattribute vec4 a_vec4_identifier;\nuniform vec2 u_vec2_offset;\nuniform vec2 u_vec2_vpt_size;\nuniform float u_float_scale;\nvarying vec4 v_vec4_identifier;\nvoid main() {\n    float height = dem_height(a_vec4_position.xy);\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        vec4 ndcPosition = u_mat4_mvp * vec4(a_vec4_position.xy, a_vec4_position.z + height, a_vec4_position.w);\n        ndcPosition.xyz = ndcPosition.xyz / ndcPosition.w;\n        ndcPosition.w = 1.0;\n        ndcPosition.xy += (a_vec2_offset * u_float_scale + u_vec2_offset) / u_vec2_vpt_size * 2.0;\n        gl_Position = ndcPosition;\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            label_directional:
                                'attribute vec4 a_vec4_position;\nattribute vec2 a_vec2_offset;\nattribute vec2 a_vec2_texcoord;\nattribute vec2 a_vec2_style_zoom_limits;\nuniform float u_float_style_zoom;\nuniform float u_float_scale;\nuniform float u_float_tile_to_pixel_ratio;\nvarying vec2 v_vec2_texcoord;\nfloat clipw(const float w, const vec2 range, const float zoom) {\n    return w * (step(range.x, zoom) - step(range.y, zoom));\n}\nvoid main() {\n    vec4 newPosition = a_vec4_position;\n    newPosition.xy += a_vec2_offset * u_float_scale * u_float_tile_to_pixel_ratio;\n    newPosition = u_mat4_mvp * newPosition;\n    gl_Position = vec4(newPosition.xyz, clipw(newPosition.w, a_vec2_style_zoom_limits, u_float_style_zoom));\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            one_way_line:
                                'uniform vec4 u_vec4_color;\nuniform vec4 u_vec4_border_color;\nuniform mediump vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform vec2 u_vec2_scale_limits;\nuniform float u_float_border_width;\nuniform float u_float_border_width_offset;\nuniform float u_float_size_factor;\nuniform mediump float u_float_width;\nuniform mediump float u_float_length;\nuniform float u_float_wing_width_multiplier;\nuniform float u_float_opacity;\nattribute vec2 a_vec2_position;\nattribute vec2 a_vec2_direction;\nattribute vec2 a_vec2_widen_direction;\nvarying vec4 v_vec4_color;\nvarying vec4 v_vec4_border_color;\nvarying vec2 v_vec2_texcoord;\nvarying float v_float_border_width;\nvarying float v_float_zpt_to_texcoord_factor;\nvarying float v_float_outer_width;\nvarying float v_float_opacity;\nconst float g_shift_pixels = 2.;\nconst float g_w_factor = 1e-7;\nvoid main()\n{\n    float style_scale_clamped = clamp(u_vec3_projection_scale_style_scale_dpi.y, u_vec2_scale_limits.x, u_vec2_scale_limits.y);\n    float scale_ratio = u_vec3_projection_scale_style_scale_dpi.x / u_vec3_projection_scale_style_scale_dpi.y;\n    float calculation_scale = style_scale_clamped * scale_ratio;\n    ArrowParameters arrow_parameters = calculate_arrow_parameters(\n        calculation_scale,\n        u_float_width,\n        u_float_border_width,\n        u_float_length,\n        u_float_wing_width_multiplier,\n        u_float_size_factor);\n    v_float_zpt_to_texcoord_factor = arrow_parameters.zpt_to_texcoord_factor;\n    v_float_outer_width = arrow_parameters.outer_width;\n    vec2 direction = normalize_s08(a_vec2_direction);\n    vec2 untransformed_widen = a_vec2_widen_direction * arrow_parameters.widen_size;\n    vec2 widen = multiply_complex(untransformed_widen * arrow_parameters.final_size, direction);\n    \n    float shift_pixels = g_shift_pixels * sqrt(2.) / min(abs(untransformed_widen.x), abs(untransformed_widen.y));\n    VertexShiftParameters shift_parameters = calculate_vertex_shift_parameters(\n        u_mat4_mvp,\n        u_vec2_vpt_size,\n        a_vec2_position,\n        widen,\n        shift_pixels);\n    \n    \n    gl_Position = shift_parameters.clip_space_vertex / arrow_parameters.final_size * g_w_factor;\n    v_vec2_texcoord = untransformed_widen * (1. + shift_parameters.limited_factor);\n    \n    float border_width = u_float_border_width * v_float_zpt_to_texcoord_factor;\n    float border_width_offset = u_float_border_width_offset * v_float_zpt_to_texcoord_factor;\n    v_float_border_width = max(0., border_width - u_vec3_projection_scale_style_scale_dpi.y / style_scale_clamped * border_width_offset);\n    v_vec4_color = apply_opacity(u_vec4_color, u_float_opacity);\n    v_vec4_border_color = apply_opacity(u_vec4_border_color, u_float_opacity);\n    v_float_opacity = u_float_opacity;\n    calc_world_pos(a_vec2_position);\n}\n',
                            round_position:
                                '\nvec4 round_position(const vec4 position, const vec2 half_viewport)\n{\n    if (\n        position.w < 0.\n        || position.x < -position.w\n        || position.x > position.w\n        || position.y < -position.w\n        || position.y > position.w\n        || position.z < -position.w\n        || position.z > position.w)\n    {\n        return position;\n    }\n    else\n    {\n        \n        return vec4(\n            sign(position.xy) * floor(abs(position.xy) * half_viewport / position.w + .5)\n                * position.w / half_viewport,\n            position.zw);\n    }\n}\n',
                            color_identify:
                                'uniform vec2 u_vec2_vpt_size;\nattribute vec2 a_vec2_vertex;\nattribute vec4 a_vec4_identifier;\nvarying vec4 v_vec4_identifier;\nvoid main()\n{\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        gl_Position = round_position(u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.), .5 * u_vec2_vpt_size);\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            zbm_model_identify:
                                'uniform vec2 u_vec2_vpt_size;\nattribute vec3 a_vec3_vertex;\nattribute vec4 a_vec4_identifier;\nattribute vec2 a_vec2_dem_position;\nvarying vec4 v_vec4_identifier;\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        gl_Position = round_position(u_mat4_mvp * vec4(a_vec3_vertex.xy, a_vec3_vertex.z + height, 1.), .5 * u_vec2_vpt_size);\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            pointsprite_identify:
                                'uniform vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform float u_float_height_factor;\nuniform vec2 u_vec2_rotation; \nuniform bool u_bool_skip_height_factor;\nattribute vec3 a_vec3_position;\nattribute vec2 a_vec2_offset;\nattribute vec2 a_vec2_texcoord;\nattribute vec2 a_vec2_range;\nattribute vec2 a_vec2_rescale;\nattribute vec4 a_vec4_identifier;\nvarying vec2 v_vec2_texcoord;\nvarying vec4 v_vec4_identifier;\nvoid main()\n{\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        float height = dem_height(a_vec3_position.xy);\n        \n        if (height == DEM_INVALID_VALUE) {\n            gl_Position = vec4(0, 0, 0, 0);\n            return;\n        }\n        mat2 rotation_matrix = mat2(\n            u_vec2_rotation.x, -u_vec2_rotation.y,\n            u_vec2_rotation.y, u_vec2_rotation.x\n        );\n        vec2 inv_half_size = 2.0 / u_vec2_vpt_size;\n        vec4 anchor;\n        \n        \n        \n        if (u_bool_skip_height_factor == true) {\n            anchor = vec4(a_vec3_position, 1.0);\n        } else {\n            anchor = apply_height_factor(a_vec3_position, u_float_height_factor);\n        }\n        anchor.z += height;\n        anchor = u_mat4_mvp * anchor;\n        vec2 offset = rescale(rotation_matrix * a_vec2_offset, a_vec2_rescale, a_vec2_range, u_vec3_projection_scale_style_scale_dpi.y);\n        vec2 pos_2d = anchor.xy + overlay_transform(offset, inv_half_size) * anchor.w;\n        vec2 corner = make_position(pos_2d, anchor.w, inv_half_size, 1.0);\n        gl_Position = vec4(corner, anchor.z, clipw(anchor.w, a_vec2_range, u_vec3_projection_scale_style_scale_dpi.y));\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n    v_vec4_identifier = a_vec4_identifier;\n}\n',
                            zbm_model:
                                'uniform float u_float_height_factor;\nattribute vec3 a_vec3_vertex;\nattribute vec2 a_vec2_texcoord;\nattribute vec2 a_vec2_dem_position;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    v_vec2_texcoord = unpack_model_texcoord(a_vec2_texcoord);\n    vec4 vh = apply_height_factor(a_vec3_vertex, u_float_height_factor);\n    vh.z += height;\n    calc_world_pos(vh);\n    gl_Position = u_mat4_mvp * vh;\n}\n',
                            gltf_model:
                                'uniform mat4 u_mat4_instance;\nattribute vec3 position;\nattribute vec2 normal;\nattribute vec2 tangent;\nattribute vec3 a_vec3_instance_position;\nattribute vec3 a_vec3_instance_scale;\nattribute vec4 a_vec4_instance_rotation;\nattribute vec4 a_vec4_instance_localid;\nattribute vec2 texcoord_color;\nattribute vec2 texcoord_ao;\nvarying vec4 v_vec4_identifier;\nvarying vec2 v_vec2_texcoord_color;\nvarying vec2 v_vec2_texcoord_ao;\nvoid calc_texcoords() {\n    v_vec2_texcoord_color = texcoord_color;\n    v_vec2_texcoord_ao = texcoord_ao;\n}\nvec3 rotate(vec4 q, vec3 v) {\n    return v + cross(2.0 * q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvoid main()\n{\n    float height = dem_height(a_vec3_instance_position.xy);\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    v_vec4_identifier = a_vec4_instance_localid;\n    calc_texcoords();\n    vec4 vh = vec4(a_vec3_instance_position, 1.);\n    vh.z += height;\n    vec4 vertex = vec4(rotate(a_vec4_instance_rotation, position) * a_vec3_instance_scale, 1.);\n    vertex = u_mat4_instance * vertex;\n    vh.xyz += vertex.xyz;\n    calc_world_pos(vh);\n    gl_Position = u_mat4_mvp * vh;\n}\n',
                            simple_line:
                                'uniform vec2 u_vec2_vpt_size;\nuniform float u_float_width;\nuniform float u_float_height_factor;\nuniform float u_float_height_limitation;\nuniform float u_float_tile_height;\nuniform float u_float_z_offset;\nattribute vec3 a_vec3_vertex;\nattribute vec4 a_vec4_direction_distance;\nattribute vec2 a_vec2_dem_position;\nvarying float v_float_distance;\nvarying float v_float_distance_offset;\nconst float g_smooth_width = 1.;\nconst float g_min_denominator = 1e-4;\nconst float g_w_factor = 1e-6;\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    float shift_pixels = 0.5 * max(u_float_width - 1., 0.);\n    float shift_pixels_added = shift_pixels + g_smooth_width;\n    vec3 direction = a_vec4_direction_distance.xyz;\n    float distance = a_vec4_direction_distance.w;\n    vec2 half_viewport = u_vec2_vpt_size / vec2(2.);\n    \n    \n    vec4 clip_space_direction = normalize(u_mat4_mvp * vec4(normalize_s08(direction), 0.));\n    vec4 clip_space_vertex = apply_height_factor(a_vec3_vertex, u_float_height_factor);\n    clip_space_vertex.z += height;\n    clip_space_vertex = apply_z_limitation(\n        clip_space_vertex,\n        u_float_tile_height, u_float_height_limitation\n    );\n    \n    clip_space_vertex.z = max(clip_space_vertex.z, height);\n    clip_space_vertex = u_mat4_mvp * clip_space_vertex;\n    vec2 screen_space_direction =\n        (clip_space_direction.xy * clip_space_vertex.w - clip_space_vertex.xy * clip_space_direction.w) * half_viewport;\n    vec2 screen_space_perp = vec2(-screen_space_direction.y, screen_space_direction.x);\n    float denominator = max(g_min_denominator, length(screen_space_perp));\n    gl_Position = g_w_factor * (clip_space_vertex + vec4(screen_space_perp / half_viewport, 0., 0.)\n        * distance * shift_pixels_added / denominator * clip_space_vertex.w);\n    gl_Position.z += u_float_z_offset;\n    v_float_distance = shift_pixels_added * distance * gl_Position.w;\n    v_float_distance_offset = shift_pixels;\n    calc_world_pos(a_vec3_vertex);\n}\n',
                            arrow_line_entrance:
                                'uniform vec4 u_vec4_color;\nuniform vec4 u_vec4_border_color;\nuniform mediump vec2 u_vec2_vpt_size;\nuniform vec3 u_vec3_projection_scale_style_scale_dpi;\nuniform vec2 u_vec2_scale_limits;\nuniform float u_float_width_zpt;\nuniform float u_float_wing_width_multiplier;\nuniform float u_float_border_width_zpt;\nuniform float u_float_size_factor;\nuniform float u_float_border_width_offset;\nuniform float u_float_tip_height_multiplier;\nuniform float u_float_relative_end_position;\nuniform float u_float_tip_movement_amplitude;\nuniform float u_float_vertex_shift; \nuniform float u_float_opacity;\nattribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_segment_end;\nattribute vec4 a_vec4_texture_widen_arrow_widen;\nattribute vec2 a_vec2_widen;\nattribute vec2 a_vec2_direction; \nattribute float a_float_distance_from_start;\nattribute float a_float_object_length;\nattribute float a_float_type;\nattribute vec4 a_vec4_identifier; \nvarying vec2 v_vec2_line_type_arrow_tail;\nvarying vec4 v_vec4_arrow_width_length_border_outer;\nvarying vec4 v_vec4_texcoord_arrow_line;\nvarying vec4 v_vec4_distance_vertex_hiding;\nvarying vec4 v_vec4_identifier;\nvarying vec4 v_vec4_color;\nvarying vec4 v_vec4_border_color;\nconst float g_w_factor = 1e-7;\nconst float g_type_line = 0.;\nconst float g_type_arrow = 1.;\nconst float g_type_start_border = 2.;\nconst float g_type_line_ending = 3.;\nconst float g_type_line_cut = 4.;\nconst float g_shift_pixels = 2.;\nconst float g_line_overlapping_part = .2;\nstruct ArrowLineViewParameters\n{\n    float vertex_type;\n    float width_zpt;\n    float border_width_zpt;\n    float border_width_offset;\n    float arrow_segment_length_zpt;\n    float wing_width_multiplier;\n    float size_factor;\n    vec2 vertex_position;\n    vec2 vertex_widen;\n    vec2 line_texture_widen;\n    vec2 arrow_texture_widen;\n    vec2 segment_direction;\n    float segment_length;\n    float distance_to_end;\n};\nstruct DistanceShiftParameters\n{\n    float shift;\n    bool invisible;\n};\nvec2 perp(const vec2 vector)\n{\n    return vec2(-vector.y, vector.x);\n}\nvec2 vertex_shift(const Scale scale)\n{\n    return u_float_vertex_shift * u_float_tip_movement_amplitude * normalize_s08(a_vec2_direction) * scale.calculation;\n}\nvec2 arrow_shift(const ArrowLineViewParameters view)\n{\n    \n    \n    \n    return view.segment_direction * view.distance_to_end;\n}\nfloat erase_length_end()\n{\n    return clamp(u_float_relative_end_position, 0., 1.) * a_float_object_length;\n}\nvoid set_texcoord_varyings(const vec2 arrow_texcoord, const vec2 line_texcoord)\n{\n    v_vec4_texcoord_arrow_line = vec4(arrow_texcoord, line_texcoord);\n}\nvoid set_arrow_varyings(\n    const float arrow_width,\n    const float arrow_length,\n    const float arrow_border,\n    const float arrow_outer_width,\n    const float arrow_tail_hide_part)\n{\n    v_vec4_arrow_width_length_border_outer = vec4(\n        arrow_width,\n        arrow_length,\n        arrow_border,\n        arrow_outer_width);\n    v_vec2_line_type_arrow_tail = vec2(\n        a_float_type,\n        arrow_tail_hide_part);\n}\nDistanceShiftParameters calculate_entrance_arrow_distances(\n    const ArrowLineViewParameters view,\n    const float signed_distance_shift,\n    const float arrow_final_size,\n    const float entrance_arrow_distance_shift)\n{\n    DistanceShiftParameters line_distance_parameters = DistanceShiftParameters(\n        signed_distance_shift + entrance_arrow_distance_shift,\n        false);\n    if (a_float_type == g_type_arrow)\n    {\n        \n        \n        bool outside_of_current_segment = view.distance_to_end > view.segment_length + entrance_arrow_distance_shift;\n        \n        bool inside_end_hide = a_float_distance_from_start + entrance_arrow_distance_shift > erase_length_end();\n        return DistanceShiftParameters(\n            \n            line_distance_parameters.shift + view.distance_to_end,\n            outside_of_current_segment || inside_end_hide\n        );\n    }\n    else\n    {\n        return line_distance_parameters;\n    }\n}\nvoid set_distance_varyings(\n    const ArrowLineViewParameters view,\n    const float arrow_final_size,\n    const float signed_shift_distance)\n{\n    float entrance_arrow_distance_shift = arrow_final_size * (2. - g_line_overlapping_part);\n    DistanceShiftParameters distance_shift_parameters = calculate_entrance_arrow_distances(\n        view,\n        signed_shift_distance,\n        arrow_final_size,\n        entrance_arrow_distance_shift);\n    v_vec4_distance_vertex_hiding =\n        vec4(\n            a_float_distance_from_start + distance_shift_parameters.shift,\n            0.,\n            erase_length_end(),\n            distance_shift_parameters.invisible\n                ? a_float_object_length\n                : 0.\n        ) / a_float_object_length;\n}\nArrowLineViewParameters decode_arrow_line_view_parameters()\n{\n    float width_zpt = u_float_width_zpt;\n    float border_width_zpt = u_float_border_width_zpt;\n    float arrow_segment_length_zpt = width_zpt * u_float_tip_height_multiplier + border_width_zpt;\n    float vertex_type = a_float_type;\n    \n    vec2 segment_direction = (vertex_type == g_type_line_ending || vertex_type == g_type_line_cut)\n        ? normalize(a_vec2_vertex - a_vec2_segment_end)\n        : normalize(a_vec2_segment_end - a_vec2_vertex);\n    float segment_length = length(a_vec2_segment_end - a_vec2_vertex);\n    float distance_to_end = erase_length_end() - a_float_distance_from_start;\n    return ArrowLineViewParameters(\n        vertex_type,\n        width_zpt,\n        border_width_zpt,\n        u_float_border_width_offset,\n        arrow_segment_length_zpt,\n        u_float_wing_width_multiplier,\n        u_float_size_factor,\n        a_vec2_vertex,\n        unpack_widen(a_vec2_widen),\n        unpack_widen(a_vec4_texture_widen_arrow_widen.xy),\n        unpack_widen(a_vec4_texture_widen_arrow_widen.zw),\n        segment_direction,\n        segment_length,\n        distance_to_end);\n}\nvec4 process_arrow_line_vertex(const Scale scale, const mat4 mvp, const vec2 vpt_size)\n{\n    ArrowLineViewParameters view = decode_arrow_line_view_parameters();\n    \n    ArrowParameters arrow_parameters = calculate_arrow_parameters(\n        scale.calculation,\n        view.width_zpt,\n        view.border_width_zpt,\n        view.arrow_segment_length_zpt,\n        view.wing_width_multiplier,\n        view.size_factor);\n    vec2 vertex_widen = view.vertex_widen;\n    vec2 texture_widen_with_sign = view.line_texture_widen;\n    \n    \n    float shift_sign = sign(dot(vertex_widen, texture_widen_with_sign));\n    vec2 line_texture_widen = shift_sign * texture_widen_with_sign;\n    \n    float line_final_size = (view.width_zpt + 2. * view.border_width_zpt) * view.size_factor * scale.calculation;\n    float final_size = (view.vertex_type == g_type_arrow)\n        ? arrow_parameters.final_size\n        : line_final_size;\n    \n    \n    \n    \n    vec2 line_texture_widen_perp = perp(line_texture_widen);\n    float shift_distance = abs(dot(vertex_widen, line_texture_widen_perp)) * final_size;\n    vec2 shift_direction = line_texture_widen_perp * sign(dot(vertex_widen, line_texture_widen_perp));\n    vec2 line_vertex_shift = vertex_widen * final_size - shift_direction * max(0., shift_distance - .5 * view.segment_length);\n    \n    vec2 arrow_vertex_widen = vertex_widen * arrow_parameters.final_size;\n    vec2 scene_vertex_shift = (view.vertex_type == g_type_arrow)\n        ? arrow_vertex_widen\n        : line_vertex_shift;\n    vec2 arrow_position_shift = (view.vertex_type == g_type_arrow)\n        ? arrow_shift(view)\n        : vec2(0.);\n    \n    float shift_pixels = g_shift_pixels * sqrt(2.);\n    VertexShiftParameters line_shift_parameters = calculate_vertex_shift_parameters(\n        mvp,\n        vpt_size,\n        view.vertex_position + (vertex_shift(scale) + arrow_position_shift),\n        scene_vertex_shift,\n        shift_pixels);\n    float arrow_line_texcoord_scale = line_final_size / arrow_parameters.final_size;\n    float line_texcoord_scale = (view.vertex_type != g_type_arrow)\n        ? arrow_line_texcoord_scale\n        : 1.;\n    vec2 line_texcoord = line_texture_widen * (1. + line_shift_parameters.limited_factor) * line_texcoord_scale;\n    \n    float arrow_texcoord_scale = (view.vertex_type == g_type_start_border)\n        ? arrow_line_texcoord_scale\n        : 1.;\n    vec2 arrow_texcoord = view.arrow_texture_widen * (1. + line_shift_parameters.limited_factor) * arrow_texcoord_scale;\n    set_texcoord_varyings(arrow_texcoord, line_texcoord);\n    float arrow_width = view.width_zpt * arrow_parameters.zpt_to_texcoord_factor;\n    float arrow_length = view.arrow_segment_length_zpt * arrow_parameters.zpt_to_texcoord_factor;\n    \n    float texcoord_border_width = view.border_width_zpt * arrow_parameters.zpt_to_texcoord_factor;\n    float border_width_texcoord_offset = view.border_width_offset * arrow_parameters.zpt_to_texcoord_factor;\n    float arrow_border = max(0., texcoord_border_width - scale.style / scale.style_clamped * border_width_texcoord_offset);\n    \n    float tail_shift_direction = (view.vertex_type == g_type_line_ending || view.vertex_type == g_type_start_border) ? 1. : -1.;\n    float tail_hide_shift = dot(arrow_vertex_widen, tail_shift_direction * view.segment_direction);\n    float arrow_tail_hide_part = (view.distance_to_end - tail_hide_shift) * arrow_parameters.zpt_to_texcoord_factor / view.size_factor;\n    set_arrow_varyings(\n        arrow_width,\n        arrow_length,\n        arrow_border,\n        arrow_parameters.outer_width,\n        arrow_tail_hide_part);\n    set_distance_varyings(\n        view,\n        arrow_parameters.final_size,\n        shift_sign * shift_distance);\n    \n    \n    return line_shift_parameters.clip_space_vertex / final_size;\n}\nvoid main()\n{\n    v_vec4_identifier = a_vec4_identifier; \n    Scale scale = calculate_scale(u_vec3_projection_scale_style_scale_dpi, u_vec2_scale_limits);\n    vec4 processed_vertex = process_arrow_line_vertex(scale, u_mat4_mvp, u_vec2_vpt_size);\n    gl_Position = processed_vertex * g_w_factor;\n    v_vec4_color = apply_opacity(u_vec4_color, u_float_opacity);\n    v_vec4_border_color = apply_opacity(u_vec4_border_color, u_float_opacity);\n}\n',
                            diffuse_identify:
                                'uniform vec2 u_vec2_vpt_size;\nuniform float u_float_height_limitation;\nuniform float u_float_tile_height;\nuniform float u_float_height_factor;\nattribute vec3 a_vec3_vertex;\nattribute vec4 a_vec4_identifier;\nattribute vec2 a_vec2_dem_position;\nvarying vec4 v_vec4_identifier;\nvoid main()\n{\n    float height = dem_height(unpack_dem_position(a_vec2_dem_position));\n    \n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = vec4(0, 0, 0, 0);\n        return;\n    }\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        vec4 vertex_hf = apply_height_factor(a_vec3_vertex, u_float_height_factor);\n        vertex_hf.z += height;\n        vertex_hf = apply_z_limitation(vertex_hf, u_float_tile_height, u_float_height_limitation);\n        \n        vertex_hf.z = max(vertex_hf.z, height);\n        gl_Position = round_position(\n            u_mat4_mvp * vertex_hf,\n            .5 * u_vec2_vpt_size);\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            calculate_scale:
                                'struct Scale\n{\n    float projection;\n    float style;\n    float style_clamped;\n    float calculation;\n};\nScale calculate_scale(const vec3 projection_scale_style_scale_dpi, const vec2 scale_limits)\n{\n    float style_scale_clamped = clamp(projection_scale_style_scale_dpi.y, scale_limits.x, scale_limits.y);\n    float scale_ratio = projection_scale_style_scale_dpi.x / projection_scale_style_scale_dpi.y;\n    float calculation_scale = style_scale_clamped * scale_ratio;\n    return Scale(\n        projection_scale_style_scale_dpi.x,\n        projection_scale_style_scale_dpi.y,\n        style_scale_clamped,\n        calculation_scale);\n}\nconst float g_min_scale_factor = 1e-2;\nconst float g_max_scale_factor = 1e2;\nconst float g_base_scale_numerator = 1e2;\nfloat normalize_scale_to_tile(const float scale, const float tile_size)\n{\n    return clamp(\n        (scale - g_min_scale_factor) / (tile_size - g_min_scale_factor),\n        g_min_scale_factor,\n        g_max_scale_factor);\n}\n',
                            line_width:
                                'float calculate_final_width(\n    const Scale scale,\n    const float width,\n    const float width_offset)\n{\n    \n    float final_width = max(0., scale.calculation * width - scale.projection * width_offset);\n    return final_width;\n}\n',
                            arrow_functions:
                                '\nvec2 multiply_complex(const vec2 lhs, const vec2 rhs)\n{\n    return vec2(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);\n}\nstruct ArrowParameters\n{\n    float zpt_to_texcoord_factor;\n    float final_size;\n    float outer_width;\n    vec2 widen_size;\n};\nArrowParameters calculate_arrow_parameters(\n    const float calculation_scale,\n    const float width_zpt,\n    const float border_width_zpt,\n    const float segment_length_zpt,\n    const float wing_width_multiplier,\n    const float size_factor)\n{\n    float quad_width = 2.0 * border_width_zpt + 2.0 * wing_width_multiplier * width_zpt;\n    float quad_height = 2.0 * border_width_zpt + segment_length_zpt;\n    float max_quad_dimension = max(quad_width, quad_height);\n    float zpt_to_texcoord_factor = 2.0 / max_quad_dimension;\n    float final_size = calculation_scale * size_factor * max_quad_dimension;\n    vec2 widen_size = 0.5 * vec2(quad_height, quad_width) * zpt_to_texcoord_factor;\n    float outer_width = (width_zpt * wing_width_multiplier + border_width_zpt) * zpt_to_texcoord_factor;\n    return ArrowParameters(\n        zpt_to_texcoord_factor,\n        final_size,\n        outer_width,\n        widen_size);\n}\nstruct VertexShiftParameters\n{\n    vec4 clip_space_vertex;\n    float limited_factor;\n};\nVertexShiftParameters calculate_vertex_shift_parameters(\n    const mat4 mvp,\n    const vec2 vpt_size,\n    const vec2 vertex,\n    const vec2 widen,\n    const float shift_pixels)\n{\n    vec2 widen_perp = vec2(-widen.y, widen.x);\n    \n    vec4 clip_space_widen = mvp * vec4(widen, 0., 0.);\n    vec4 clip_space_widen_perp = mvp * vec4(widen_perp, 0., 0.);\n    vec2 half_viewport = vpt_size / 2.;\n    \n    vec4 clip_space_vertex = mvp * vec4(vertex, 0.0, 1.0) + clip_space_widen;\n    \n    float limited_factor = calculate_multiplication_factor(\n        half_viewport,\n        clip_space_widen,\n        clip_space_widen_perp,\n        clip_space_vertex,\n        shift_pixels);\n    return VertexShiftParameters(\n        clip_space_vertex + clip_space_widen * limited_factor,\n        limited_factor);\n}\n',
                            circle_marker:
                                'attribute vec4 a_vec4_vertex;\nattribute vec2 a_vec2_widen;\nuniform vec2 u_vec2_vpt_size;\nuniform float u_float_width;\nvarying vec2 v_vec2_circle;\nvarying float v_float_width;\nvoid main() {\n    vec4 clip_space_position = u_mat4_mvp * a_vec4_vertex;\n    vec4 ndc_position = clip_space_position / clip_space_position.w;\n    ndc_position.xy += a_vec2_widen * u_float_width / u_vec2_vpt_size;\n    gl_Position = ndc_position;\n    v_vec2_circle = a_vec2_widen;\n    v_float_width = u_float_width;\n}\n',
                            circle_marker_identify:
                                'attribute vec4 a_vec4_vertex;\nattribute vec2 a_vec2_widen;\nattribute vec4 a_vec4_identifier;\nuniform vec2 u_vec2_vpt_size;\nuniform float u_float_width;\nvarying vec2 v_vec2_circle;\nvarying vec4 v_vec4_identifier;\nvoid main() {\n    v_vec2_circle = a_vec2_widen;\n    v_vec4_identifier = a_vec4_identifier;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier)\n    {\n        vec4 clip_space_position = u_mat4_mvp * a_vec4_vertex;\n        vec4 ndc_position = clip_space_position / clip_space_position.w;\n        ndc_position.xy += a_vec2_widen * u_float_width / u_vec2_vpt_size;\n        gl_Position = ndc_position;\n    }\n    else\n    {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n}\n',
                            raster_functions:
                                '\nfloat unpack_scale(float value)\n{\n    return exp(abs(value) / 256.) * sign(value);\n}\nfloat unpack_positive_value(float value)\n{\n    return exp(value / 256.);\n}\nvec2 make_position(const vec2 position, const float w, const vec2 inv_half_size, const float rounding_factor)\n{\n    vec2 non_rounded_position = (position + w) / (w * inv_half_size);\n    vec2 rounded_position = floor(non_rounded_position + 0.5);\n    vec2 rounding_delta = rounded_position - non_rounded_position;\n    vec2 pixel_coord = non_rounded_position + rounding_factor * rounding_delta - 0.5;\n    return (pixel_coord * inv_half_size) * w - w;\n}\nvec2 overlay_transform(const vec2 position, const vec2 inv_half_size)\n{\n    \n    \n    return position * inv_half_size;\n}\nfloat clipw(const float w, const vec2 range, const float scale)\n{\n    return w * (step(unpack_scale(range.x), scale) - step(unpack_positive_value(range.y), scale));\n}\nvec2 rescale(const vec2 corner, const vec2 rescale, const vec2 scale_range, const float style_scale)\n{\n    \n    \n    if (scale_range.x < 0.)\n    {\n        float default_scale_denominator = unpack_positive_value(rescale.x);\n        float rescale_coeff = unpack_positive_value(rescale.y);\n        float min_scale = unpack_positive_value(-scale_range.x);\n        float stretch_exponent = floor(0.5 + log2(\n            max(1., 1. + rescale_coeff * (1. / max(min_scale, style_scale) - default_scale_denominator))));\n        return corner.xy * exp2(stretch_exponent);\n    }\n    return corner;\n}\n',
                            road: 'attribute vec2 a_vec2_vertex;\nattribute vec4 a_vec4_normals;\nattribute vec2 a_vec2_shift;\nuniform float u_float_width;\nuniform float u_float_tile_to_pixel_ratio;\nuniform float u_float_shift;\nvarying vec2 v_vec2_normal;\nvarying float v_float_half_width;\nconst float g_w_factor = 1e-6;\nconst float normal_unpack_multiplier = 0.011135539861205473;\nvoid main()\n{\n    \n    float half_width = 0.5 * (u_float_width + 1.0);\n    \n    vec4 normals = a_vec4_normals * normal_unpack_multiplier * half_width;\n    vec2 extender = normals.xy;\n    vec2 normal = normals.zw;\n    vec2 shift = a_vec2_shift * u_float_shift;\n    \n    vec4 shifted_vertex = vec4(a_vec2_vertex + (shift + extender) * u_float_tile_to_pixel_ratio, 0.0, 1.0);\n    gl_Position = g_w_factor * u_mat4_mvp * shifted_vertex;\n    v_vec2_normal = normal;\n    v_float_half_width = half_width;\n    calc_world_pos(shifted_vertex);\n}\n',
                            road_identify:
                                'attribute vec2 a_vec2_vertex;\nattribute vec4 a_vec4_normals;\nattribute vec4 a_vec4_identifier;\nuniform float u_float_width;\nuniform float u_float_tile_to_pixel_ratio;\nvarying vec2 v_vec2_normal;\nvarying vec4 v_vec4_identifier;\nvarying float v_float_half_width;\nconst float g_w_factor = 1e-6;\nconst float normal_unpack_multiplier = 0.011135539861205473;\nvoid main()\n{\n    \n    float half_width = 0.5 * (u_float_width + 1.0);\n    \n    vec4 normals = a_vec4_normals * normal_unpack_multiplier * half_width;\n    vec2 extender = normals.xy;\n    vec2 normal = normals.zw;\n    if (vec4(1., 1., 1., 1.) != a_vec4_identifier) {\n        \n        vec4 shifted_vertex = vec4(a_vec2_vertex + extender * u_float_tile_to_pixel_ratio, 0.0, 1.0);\n        gl_Position = g_w_factor * u_mat4_mvp * shifted_vertex;\n    } else {\n        gl_Position = vec4(1., 1., 1., 1.);\n    }\n    v_vec2_normal = normal;\n    v_vec4_identifier = a_vec4_identifier;\n    v_float_half_width = half_width;\n}\n',
                            rect: 'attribute vec2 a_vec2_vertex;\nvoid main()\n{\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n}\n',
                            rect_with_texture:
                                'attribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texcoord;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            heatmap:
                                'attribute vec2 a_vec2_position;\nattribute vec2 a_vec2_widen;\nattribute float a_float_weight;\nvarying vec2 v_vec2_extrude;\nvarying float v_float_weight;\nuniform float u_float_radius;\nuniform float u_float_intensity;\nuniform float u_float_tile_to_pixel_ratio;\nconst highp float ZERO = 1.0 / 255.0 / 16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n    float S = sqrt(-2.0 * log(ZERO / a_float_weight / u_float_intensity / GAUSS_COEF)) / 3.0;\n    v_vec2_extrude = S * a_vec2_widen;\n    v_float_weight = a_float_weight;\n    vec2 pos = a_vec2_position + a_vec2_widen * u_float_radius * u_float_tile_to_pixel_ratio;\n    gl_Position = u_mat4_mvp * vec4(pos, 0.0, 1.0);\n}\n',
                            heatmap_texture:
                                'attribute vec2 a_vec2_position;\nvarying vec2 v_vec2_position;\nvoid main() {\n    gl_Position = vec4(a_vec2_position, 0.0, 1.0);\n    v_vec2_position = clamp(a_vec2_position, vec2(0,0), vec2(1,1));\n}\n',
                            dem_mesh:
                                'uniform mat4 u_mat4_flat_map_mvp;\nattribute vec2 a_vec2_position;\nvarying vec3 v_vec3_texcoord;\nvarying vec2 hs_tex_pos;\nvoid main()\n{\n    vec4 coords = u_mat4_mvp * vec4(a_vec2_position, 0.0, 1.0);\n    vec4 tex_pos = u_mat4_dem_mvp * vec4(a_vec2_position, 0.0, 1.0);\n    float height = dem_height_direct(tex_pos.xy / tex_pos.w);\n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = coords;\n        v_vec3_texcoord = vec3(a_vec2_position, 0);\n    } else {\n        gl_Position = u_mat4_mvp * vec4(a_vec2_position, height, 1.0);\n        vec4 flat_coord = u_mat4_flat_map_mvp * vec4(a_vec2_position, 0.0, 1.0);\n        v_vec3_texcoord = vec3(flat_coord.xy / flat_coord.w, 1);\n        hs_tex_pos = tex_pos.xy;\n    }\n    calc_world_pos(vec4(a_vec2_position, height, 1.0));\n}\n',
                            dem_ground:
                                'uniform mat4 u_mat4_model;\nattribute vec2 a_vec2_position;\nvarying vec4 v_vec4_coords;\nvoid main()\n{\n    vec4 coords = u_mat4_mvp * vec4(a_vec2_position, 0.0, 1.0);\n    vec4 tex_pos = u_mat4_dem_mvp * vec4(a_vec2_position, 0.0, 1.0);\n    float height = dem_height_direct(tex_pos.xy / tex_pos.w);\n    if (height == DEM_INVALID_VALUE) {\n        gl_Position = coords;\n        v_vec4_coords = vec4(0);\n    } else {\n        gl_Position = u_mat4_mvp * vec4(a_vec2_position, height, 1.0);\n        v_vec4_coords = u_mat4_model * vec4(a_vec2_position, 0, 1.0);\n        \n        v_vec4_coords[2] = height / (u_float_dem_scale * u_float_vertical_scale) + u_float_map_center_elevation;\n    }\n}\n',
                            dem: '\nuniform sampler2D u_tex_dem;\nuniform sampler2D u_tex_corrected_dem;\nuniform float u_float_corrected_interval;\nuniform mat4 u_mat4_dem_corrected;\nuniform mat4 u_mat4_dem_mvp;\nuniform float u_float_dem_scale;\nuniform float u_float_map_center_elevation;\nuniform float u_float_vertical_scale;\nconst float DEM_INVALID_VALUE = -9999.;\nconst float UNPACK_CENTROID = 8. / 65535.;\nfloat dem_height_direct(const vec2 tex_pos) {\n    \n    if (u_float_dem_scale == 0.) {\n        return 0.;\n    }\n    vec4 elevation;\n    \n    if (u_float_corrected_interval == 0.) {\n        elevation = texture2D(u_tex_dem, tex_pos);\n    }\n    else {\n        vec2 test_tex_pos = abs(tex_pos - vec2(0.5, 0.5));\n        if (test_tex_pos.x < u_float_corrected_interval && test_tex_pos.y < u_float_corrected_interval) {\n            elevation = texture2D(u_tex_corrected_dem, (u_mat4_dem_corrected * vec4(tex_pos, 0, 1)).xy);\n        } else {\n            elevation = texture2D(u_tex_dem, tex_pos);\n        }\n    }\n    \n    if (elevation.a == 0.) {\n        \n        return DEM_INVALID_VALUE;\n    } else {\n        \n        return u_float_dem_scale * u_float_vertical_scale * (elevation.r - u_float_map_center_elevation);\n    }\n}\nfloat dem_height(const vec2 coords) {\n    \n    if (u_float_dem_scale == 0.) {\n        return 0.;\n    }\n    vec4 tex_pos = u_mat4_dem_mvp * vec4(coords, 0.0, 1.0);\n    return dem_height_direct(tex_pos.xy);\n}\nvec2 unpack_dem_position(const vec2 pos) {\n    return pos * UNPACK_CENTROID;\n}\n',
                            dem_elevation:
                                'attribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texcoord;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            dem_elevation_copy:
                                'uniform mat4 u_mat4_dem_corrected;\nattribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texcoord;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex, 0.0, 1.0);\n    v_vec2_texcoord = (u_mat4_dem_corrected * vec4(unpack_texcoord(a_vec2_texcoord), 0, 1)).xy;\n}\n',
                            dem_hillshade:
                                'attribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_texcoord;\nvarying vec2 v_vec2_texcoord;\nvoid main()\n{\n    gl_Position = vec4((a_vec2_vertex * 2. - vec2(1, 1)), 0.0, 1.0);\n    v_vec2_texcoord = unpack_texcoord(a_vec2_texcoord);\n}\n',
                            mvp_mat: 'uniform mat4 u_mat4_mvp;\n',
                            dem_flat_bottom:
                                'attribute vec2 a_vec2_vertex;\nattribute vec2 a_vec2_centroid;\nattribute vec2 a_vec2_extender;\nvarying vec4 v_vec4_color;\nvoid main()\n{\n    vec4 tex_pos = u_mat4_dem_corrected * u_mat4_mvp * vec4(unpack_dem_position(a_vec2_centroid), 0.0, 1.0);\n    v_vec4_color = texture2D(u_tex_dem, tex_pos.xy);\n    gl_Position = u_mat4_mvp * vec4(a_vec2_vertex + a_vec2_extender * 1./64., 0.0, 1.0);\n}\n',
                            mesh: 'uniform vec3 u_vec3_light_direction;\nuniform vec3 u_vec3_light_color;\nuniform vec3 u_vec3_ambient_color;\nuniform vec4 u_vec4_color;\nuniform float u_float_height_factor;\nuniform mediump float u_float_opacity;\nattribute vec3 a_vec3_vertex;\nattribute vec3 a_vec3_normal;\nattribute float a_float_gradient;\nattribute vec2 a_vec2_tex_coord;\nvarying vec4 v_vec4_color;\nvarying vec3 v_vec3_light_factor;\nvarying vec2 v_vec2_tex_coord;\nvarying float v_float_gradient;\nvoid main()\n{\n    vec4 vec3_pos = apply_height_factor(a_vec3_vertex, u_float_height_factor);\n    gl_Position = u_mat4_mvp * vec4(vec3_pos.xyz, 1);\n    v_float_gradient = a_float_gradient;\n    \n    \n    v_vec3_light_factor = u_vec3_ambient_color + u_vec3_light_color * abs(dot(u_vec3_light_direction, normalize_s08(a_vec3_normal)));\n    \n    \n    if (u_vec4_color.a > 0.) {\n        v_vec4_color =  apply_opacity(vec4(u_vec4_color.rgb * v_vec3_light_factor, u_vec4_color.a), u_float_opacity);\n        \n        v_vec2_tex_coord = vec2(-1, 0);\n    } else {\n        v_vec4_color = u_vec4_color;\n        v_vec2_tex_coord = a_vec2_tex_coord;\n    }\n}\n',
                            map_mesh:
                                'attribute vec3 a_vec3_vertex;\nattribute vec2 a_vec2_extender;\nattribute vec3 a_vec3_normal;\nattribute float a_float_gradient;\nattribute vec2 a_vec2_dem_position;\nuniform float u_float_tile_size;\nuniform float u_float_height_delta;\nuniform float u_float_height_factor;\nuniform vec3 u_vec3_light_direction;\nuniform vec3 u_vec3_light_color;\nuniform vec3 u_vec3_ambient_color;\nvarying vec4 v_tex_coord;\nvarying vec3 v_ambient_light;\nvarying float v_float_gradient;\nvoid main()\n{\n    v_tex_coord = u_mat4_mvp * vec4(a_vec3_vertex.xy, 0, 1.0);\n    v_float_gradient = a_float_gradient;\n    v_ambient_light = u_vec3_ambient_color + u_vec3_light_color * abs(dot(u_vec3_light_direction, normalize_s08(a_vec3_normal)));\n    gl_Position = u_mat4_mvp * vec4(a_vec3_vertex.xy, (a_vec3_vertex.z - u_float_height_delta) * u_float_height_factor, 1.0);\n}',
                            fog: '#ifdef FOG\nuniform mat4 u_mat4_model;\nuniform vec3 u_cam_pos;\n#endif\n#ifdef SKY\nuniform mat4 u_mat4_view_transposed;\nuniform mat4 u_mat4_proj_inverted;\n#endif\n#if defined(FOG) || defined(SKY)\nvarying vec3 v_world_pos;\n#endif\nvoid calc_world_pos(vec4 pos) {\n#ifdef FOG\n    v_world_pos = (u_mat4_model * pos).xyz - u_cam_pos;\n#endif\n}\nvoid calc_world_pos(vec3 pos) {\n#ifdef FOG\n    calc_world_pos(vec4(pos, 1.0));\n#endif\n}\nvoid calc_world_pos(vec2 pos) {\n#ifdef FOG\n    calc_world_pos(vec4(pos, 0.0, 1.0));\n#endif\n}\nvoid calc_world_pos_sky(vec4 pos) {\n#ifdef SKY\n    v_world_pos = mat3(u_mat4_view_transposed) * (u_mat4_proj_inverted * pos).xyz;\n#endif\n}',
                            sky: 'attribute vec2 a_vec2_vertex;\nvoid main()\n{\n    gl_Position = vec4(a_vec2_vertex, 1.0, 1.0);\n    calc_world_pos_sky(gl_Position);\n}\n',
                            depth_test:
                                'uniform sampler2D u_depth_tex_labeling;\nuniform sampler2D u_color_tex_labeling;\nuniform vec2 u_vec2_depth_test_half_point_size;\nuniform bool u_bool_depth_test_disable;\nfloat color_test(const vec2 pos, const vec4 color)\n{\n    vec2 halfPointSize = u_vec2_depth_test_half_point_size;\n    float result = 0.;\n    \n    if (texture2D(u_color_tex_labeling, (vec2(pos.x - halfPointSize.x, pos.y + halfPointSize.y) + 1.) / 2.) == color) {\n        result++;\n    }\n    if (texture2D(u_color_tex_labeling, (pos + halfPointSize + 1.) / 2.) == color) {\n        result++;\n    }\n    if (texture2D(u_color_tex_labeling, (pos - halfPointSize + 1.) / 2.) == color) {\n        result++;\n    }\n    if (texture2D(u_color_tex_labeling, (vec2(pos.x + halfPointSize.x, pos.y - halfPointSize.y) + 1.) / 2.) == color) {\n        result++;\n    }\n    \n    return step(3., result);\n}\nfloat depth_test(const vec2 pos, const float depth, const vec4 color)\n{\n    if (u_bool_depth_test_disable == true) {\n        return 1.;\n    }\n    float colorCheck = color_test(pos, color);\n    if (colorCheck == 1.) {\n        return 1.;\n    }\n    float d = (depth + 1.) / 2.;\n    float delta = 0.001;\n    float texDepth = texture2D(u_depth_tex_labeling, (pos + 1.) / 2.).r;\n    if (d <= texDepth) {\n        return 1.;\n    }\n    if (d - texDepth > delta) {\n        return 0.;\n    }\n    return 1. - (d - texDepth) / delta;\n}\n',
                        },
                        Jr = {
                            color: ['prelude', 'mvp_mat', 'apply_opacity', 'fog', 'color'],
                            diffuse: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'apply_opacity',
                                'fog',
                                'diffuse',
                            ],
                            line: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'apply_opacity',
                                'fog',
                                'line',
                            ],
                            pointSprite: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'raster_functions',
                                'depth_test',
                                'pointsprite',
                            ],
                            pointAnchor: ['prelude', 'mvp_mat', 'dem', 'point_anchor'],
                            labelPoint: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'depth_test',
                                'label_fixed_anchor',
                            ],
                            labelPointIdentify: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'label_fixed_anchor_identify',
                            ],
                            labelLine: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'label_directional',
                            ],
                            stripedLine: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'pixel_offset',
                                'calculate_scale',
                                'line_width',
                                'apply_opacity',
                                'precision_constants',
                                'striped_line_functions',
                                'fog',
                                'striped_line',
                            ],
                            stripedLineIdentify: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'pixel_offset',
                                'calculate_scale',
                                'line_width',
                                'apply_opacity',
                                'precision_constants',
                                'striped_line_functions',
                                'striped_line_identify',
                            ],
                            oneWayLine: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'pixel_offset',
                                'arrow_functions',
                                'apply_opacity',
                                'fog',
                                'one_way_line',
                            ],
                            colorIdentify: [
                                'prelude',
                                'mvp_mat',
                                'round_position',
                                'color_identify',
                            ],
                            zbmModelIdentify: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'round_position',
                                'zbm_model_identify',
                            ],
                            buildingIdentify: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'round_position',
                                'apply_height_factor',
                                'diffuse_identify',
                            ],
                            pointSpriteIdentify: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'raster_functions',
                                'pointsprite_identify',
                            ],
                            zbmModel: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'fog',
                                'zbm_model',
                            ],
                            gltfModel: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'fog',
                                'gltf_model',
                            ],
                            simpleLine: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'fog',
                                'simple_line',
                            ],
                            entranceArrow: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'pixel_offset',
                                'arrow_functions',
                                'calculate_scale',
                                'apply_opacity',
                                'arrow_line_entrance',
                            ],
                            circleMarker: ['prelude', 'mvp_mat', 'circle_marker'],
                            circleMarkerIdentify: ['prelude', 'mvp_mat', 'circle_marker_identify'],
                            rect: ['prelude', 'mvp_mat', 'fog', 'rect'],
                            road: ['prelude', 'mvp_mat', 'fog', 'road'],
                            roadIdentify: ['prelude', 'mvp_mat', 'road_identify'],
                            rectWithTexture: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'apply_opacity',
                                'raster_functions',
                                'fog',
                                'rect_with_texture',
                            ],
                            roadPointMark: [
                                'prelude',
                                'mvp_mat',
                                'apply_opacity',
                                'packed_attributes',
                                'fog',
                                'road_point_mark',
                            ],
                            heatmap: ['prelude', 'mvp_mat', 'heatmap'],
                            heatmapTexture: ['prelude', 'heatmap_texture'],
                            demMesh: ['prelude', 'mvp_mat', 'dem', 'fog', 'dem_mesh'],
                            demGround: ['prelude', 'mvp_mat', 'dem', 'dem_ground'],
                            demElevation: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'dem_elevation',
                            ],
                            demElevationCopy: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'dem_elevation_copy',
                            ],
                            demHillshade: [
                                'prelude',
                                'mvp_mat',
                                'packed_attributes',
                                'dem_hillshade',
                            ],
                            demFlatBottom: ['prelude', 'mvp_mat', 'dem', 'dem_flat_bottom'],
                            mesh: [
                                'prelude',
                                'mvp_mat',
                                'dem',
                                'packed_attributes',
                                'apply_height_factor',
                                'apply_opacity',
                                'fog',
                                'mesh',
                            ],
                            mapMesh: ['prelude', 'mvp_mat', 'dem', 'packed_attributes', 'map_mesh'],
                            sky: ['prelude', 'fog', 'sky'],
                        },
                        Qr = {
                            color: ['lowp_float', 'prelude', 'fog', 'color'],
                            gradient: ['lowp_float', 'prelude', 'fog', 'gradient'],
                            texturedColor: [
                                'mediump_float',
                                'prelude',
                                'apply_opacity',
                                'fog',
                                'textured_color',
                            ],
                            roadPointMark: [
                                'mediump_float',
                                'prelude',
                                'apply_opacity',
                                'fog',
                                'road_point_mark',
                            ],
                            line: ['mediump_float', 'prelude', 'fog', 'line'],
                            pointSprite: [
                                'mediump_float',
                                'prelude',
                                'apply_opacity',
                                'pointsprite',
                            ],
                            zbmModel: ['lowp_float', 'prelude', 'fog', 'zbm_model'],
                            label: ['mediump_float', 'prelude', 'apply_opacity', 'label'],
                            labelLine: [
                                'mediump_float',
                                'prelude',
                                'apply_opacity',
                                'label_directional',
                            ],
                            stripedLine: [
                                'enable_standard_derivatives',
                                'mediump_float',
                                'prelude',
                                'affine_step',
                                'fog',
                                'striped_line',
                            ],
                            oneWayLine: [
                                'enable_standard_derivatives',
                                'mediump_float',
                                'prelude',
                                'affine_step',
                                'apply_opacity',
                                'arrow_functions',
                                'fog',
                                'one_way_line',
                            ],
                            colorIdentify: ['lowp_float', 'prelude', 'color_identify'],
                            pointSpriteIdentify: [
                                'mediump_float',
                                'prelude',
                                'pointsprite_identify',
                            ],
                            gltfModel: ['lowp_float', 'prelude', 'fog', 'gltf_model'],
                            simpleLine: ['lowp_float', 'prelude', 'fog', 'simple_line'],
                            entranceArrow: [
                                'enable_standard_derivatives',
                                'highp_float',
                                'prelude',
                                'affine_step',
                                'arrow_functions',
                                'circle_functions',
                                'arrow_line',
                            ],
                            entranceArrowIdentify: ['lowp_float', 'prelude', 'arrow_line_identify'],
                            circleMarker: [
                                'mediump_float',
                                'prelude',
                                'affine_step',
                                'circle_marker',
                            ],
                            rect: ['lowp_float', 'prelude', 'fog', 'rect'],
                            road: [
                                'enable_standard_derivatives',
                                'mediump_float',
                                'prelude',
                                'affine_step',
                                'fog',
                                'road',
                            ],
                            roadIdentify: [
                                'enable_standard_derivatives',
                                'lowp_float',
                                'prelude',
                                'road_identify',
                            ],
                            rectWithTexture: [
                                'mediump_float',
                                'prelude',
                                'apply_opacity',
                                'fog',
                                'rect_with_texture',
                            ],
                            heatmap: ['mediump_float', 'prelude', 'heatmap'],
                            heatmapTexture: ['mediump_float', 'prelude', 'heatmap_texture'],
                            demMesh: ['mediump_float', 'prelude', 'fog', 'dem_mesh'],
                            demGround: ['mediump_float', 'prelude', 'dem_ground'],
                            demElevation: ['mediump_float', 'prelude', 'dem_elevation'],
                            demElevationCopy: ['mediump_float', 'prelude', 'dem_elevation_copy'],
                            demHillshade: ['lowp_float', 'prelude', 'dem_hillshade'],
                            demFlatBottom: ['mediump_float', 'prelude', 'dem_flat_bottom'],
                            mesh: ['mediump_float', 'prelude', 'apply_opacity', 'fog', 'mesh'],
                            mapMesh: ['mediump_float', 'prelude', 'map_mesh'],
                            sky: ['mediump_float', 'prelude', 'fog', 'sky'],
                        };
                    class es {
                        constructor(e, t, i = []) {
                            (this.shader = null),
                                (this.type = 'vertex' === e ? es.Vertex : es.Fragment),
                                (this.sourceCode = t),
                                (this.defines = i);
                        }
                        get(e, t) {
                            return this.shader || this.compile(e, t), this.shader;
                        }
                        remove(e) {
                            this.shader && e.deleteShader(this.shader);
                        }
                        getCode() {
                            return this.assembleShaderText().slice();
                        }
                        compile(e, t) {
                            const i = this.type === es.Vertex ? e.VERTEX_SHADER : e.FRAGMENT_SHADER,
                                n = (this.shader = e.createShader(i));
                            if (!n || e.isContextLost())
                                throw new Error(
                                    `[2gl] Failed to create shader. Shader is null: ${String(
                                        !n,
                                    )}. Context is lost: ${String(e.isContextLost())}`,
                                );
                            t && this.combineDefintions(t);
                            const o = this.assembleShaderText();
                            if (
                                (e.shaderSource(n, o),
                                e.compileShader(n),
                                !e.getShaderParameter(n, e.COMPILE_STATUS))
                            ) {
                                const t = e.getShaderInfoLog(n),
                                    i = (o || '').split('\n');
                                throw new Error(
                                    t
                                        ? t.replace(
                                              /^ERROR:\s*(\d+):(\d+):\s*(.*?)\n/,
                                              function (e, t, n, o) {
                                                  const r = i[Number(n) - 1];
                                                  return r
                                                      ? `ERROR ${t}:${n}: ${o}\nErroneous line: <<${r}>>\n`
                                                      : e;
                                              },
                                          )
                                        : 'Unknown shader compilation error',
                                );
                            }
                        }
                        combineDefintions(e) {
                            for (const { type: t, value: i } of e) {
                                const e = this.defines.find((e) => e.type === t);
                                e ? (e.value = i) : this.defines.push({ type: t, value: i });
                            }
                        }
                        assembleShaderText() {
                            const e = this.sourceCode,
                                t = this.defines.map((e) =>
                                    void 0 !== e.value
                                        ? '#define ' + e.type + ' ' + e.value
                                        : '#define ' + e.type,
                                ),
                                i = Array.isArray(e) ? e : [e || ''];
                            let n = !0;
                            for (const e of i)
                                n && -1 !== e.indexOf('#version') ? t.unshift(e) : t.push(e),
                                    (n = !1);
                            return t.join('\n');
                        }
                    }
                    (es.Vertex = 1), (es.Fragment = 2);
                    const ts = {},
                        is = {};
                    for (const e in Jr) {
                        const t = Jr[e].map((e) => Kr[e]);
                        is[e] = t;
                    }
                    for (const e in Qr) {
                        const t = Qr[e].map((e) => Yr[e]);
                        ts[e] = t;
                    }
                    function ns(e) {
                        const t = 2 === Hs.webglVersion ? ['#version 300 es'] : [],
                            i = [{ type: `WEBGL${Hs.webglVersion}`, value: '' }];
                        return new es('vertex', t.concat(is[e]), i);
                    }
                    function os(e) {
                        const t = 2 === Hs.webglVersion ? ['#version 300 es'] : [],
                            i = [{ type: `WEBGL${Hs.webglVersion}`, value: '' }];
                        return new es('fragment', t.concat(ts[e]), i);
                    }
                    const rs = { name: 'u_mat4_mvp', type: 'mat4' },
                        ss = [
                            { name: 'u_tex_dem', type: '1i' },
                            { name: 'u_tex_corrected_dem', type: '1i' },
                            { name: 'u_float_corrected_interval', type: '1f' },
                            { name: 'u_mat4_dem_corrected', type: 'mat4' },
                            { name: 'u_tex_hillshade_ramp', type: '1i' },
                            { name: 'u_mat4_dem_mvp', type: 'mat4' },
                            { name: 'u_float_dem_scale', type: '1f' },
                            { name: 'u_float_vertical_scale', type: '1f' },
                            { name: 'u_float_dem_resolution', type: '1f' },
                            { name: 'u_float_dem_cell_size', type: '1f' },
                            { name: 'u_float_dem_light_direction', type: '1f' },
                            { name: 'u_float_dem_shade_intension', type: '1f' },
                            { name: 'u_float_map_center_elevation', type: '1f' },
                        ],
                        as = [
                            { name: 'u_vec3_light_direction', type: '3fv' },
                            { name: 'u_vec3_light_color', type: '3fv' },
                            { name: 'u_vec3_ambient_color', type: '3fv' },
                        ],
                        ls = { name: 'u_float_shading', type: '1f' },
                        cs = [
                            { name: 'u_fog_color', type: '3f' },
                            { name: 'u_fog_high_color', type: '3f' },
                            { name: 'u_fog_limits', type: '2f' },
                            { name: 'u_fog_horizon_blend', type: '1f' },
                            { name: 'u_mat4_model', type: 'mat4' },
                            { name: 'u_cam_pos', type: '3f' },
                            { name: 'u_mat4_proj_inverted', type: 'mat4' },
                            { name: 'u_mat4_view_transposed', type: 'mat4' },
                        ];
                    var ds = i(412),
                        hs = i(309);
                    const us = (e, t, i, n, o) => {
                            i.length > 0 &&
                                Number.isNaN(e.metrics.firstcontent) &&
                                (e.metrics.firstcontent = performance.now() - e.metrics.start),
                                Ls(i, n, o),
                                Is(i, e).forEach((i) => ms(e, t, i, n));
                        },
                        ms = (e, t, i, n) => {
                            Ts(t.styleManager, i, e).forEach((i) => {
                                bs(t.styleManager, i[0]) ? fs(e, t, i, n) : ps(e, t, i, n);
                            });
                        },
                        fs = (e, t, i, n) => {
                            const o = bs(t.styleManager, i[0]);
                            if (!o) return;
                            const r = (i, s) => {
                                s >= o.orderBy.length
                                    ? ps(e, t, i, n)
                                    : ks(o.orderBy[s], i, e).forEach((e, t) => r(e, t + 1));
                            };
                            r(i, 0);
                        },
                        ps = (e, t, i, n) => {
                            const o = i;
                            o.sort((e, t) => e.tile.zoomLevel - t.tile.zoomLevel),
                                Ms(t.styleManager, o, e).forEach((i) => _s(e, t, i, n));
                        },
                        _s = (e, t, i, n) => {
                            Ps(i, e).forEach((i) => vs(e, t, i, n));
                        },
                        vs = (e, t, i, n) => {
                            const o = t.styleManager.getStyle(i[0].attributes.styleId);
                            let r;
                            o && (r = o.layersById[i[0].attributes.layerId]);
                            const s = r && r.selectedIdx;
                            void 0 !== s &&
                                i.sort((e, t) => {
                                    var i, n;
                                    return (
                                        Number(
                                            null !== (i = e.attributes.tileData[s]) && void 0 !== i
                                                ? i
                                                : 0,
                                        ) -
                                        Number(
                                            null !== (n = t.attributes.tileData[s]) && void 0 !== n
                                                ? n
                                                : 0,
                                        )
                                    );
                                }),
                                Es(i, e).forEach((i) => gs(e, t, i, n));
                        },
                        gs = (e, t, i, n) => {
                            var o;
                            const r = i[0];
                            if ((null == r ? void 0 : r.type) === ot.H.Custom) {
                                const e = Cs(t.styleManager, r);
                                if (!e) return;
                                n.useCustomLayerState(e),
                                    t.styleManager.callCustomLayerRender(r.attributes.layerId);
                            } else if ('gltfModel' === r.symbol && 'anchor' === r.sink)
                                null === (o = t.threeJsSceneManager) || void 0 === o || o.render();
                            else {
                                const o = i;
                                n.useProgram(o),
                                    As(o, e).forEach((i) => {
                                        ys(e, t, i, n);
                                    });
                            }
                        },
                        ys = (e, t, i, n) => {
                            const o = i[0],
                                r = Cs(t.styleManager, o);
                            r &&
                                (n.useState(i, r),
                                zs(i, e).forEach((i) => {
                                    n.drawSymbol(i, r, e, t);
                                }));
                        };
                    function bs(e, t) {
                        const i = e.getStyle(t.attributes.styleId);
                        if (!i) return;
                        const n = i.layersById[t.attributes.layerId];
                        if (!n) return;
                        if (void 0 === n.groupId) return;
                        const o = i.groupsById[n.groupId];
                        if (!o || 'group' === o.type) return o;
                        (0, hs.cM)(`Expecting layer with type 'group' but got '${o.type}'`);
                    }
                    const ws = (e, t) => Number(e) - Number(t),
                        xs = (e) => (t, i) => {
                            const n = {};
                            for (let o = 0; o < t.length; o++) {
                                const r = t[o],
                                    s = e(r, i),
                                    a = n[s];
                                void 0 === a ? (n[s] = [r]) : a.push(r);
                            }
                            const o = Object.keys(n);
                            o.sort(ws);
                            const r = [];
                            for (let e = 0; e < o.length; e++) r.push(n[o[e]]);
                            return r;
                        },
                        Ss = (e) => (t, i) => {
                            const n = new Map();
                            for (let o = 0; o < t.length; o++) {
                                const r = t[o],
                                    s = e(r, i);
                                n.has(s) ? n.get(s).push(r) : n.set(s, [r]);
                            }
                            return n;
                        },
                        Is = xs((e) => {
                            const { styleId: t } = e.attributes;
                            return t === V.jf ? 1 : -t;
                        }),
                        Ms = (e, t, i) =>
                            xs((t) =>
                                ((e, t, i) => {
                                    const n = e.getStyle(t);
                                    if (!n)
                                        return (
                                            (0, hs.cM)(
                                                `Cannot get style with id=${t} for renderIndex`,
                                            ),
                                            NaN
                                        );
                                    const o = n.layersById[i];
                                    return o ? o.groupIndex || 0 : NaN;
                                })(e, t.attributes.styleId, t.attributes.layerId),
                            )(t, i),
                        Ts = (e, t, i) =>
                            xs((t) =>
                                ((e, t, i) => {
                                    const n = e.getStyle(t);
                                    if (!n)
                                        return (
                                            (0, hs.cM)(
                                                `Cannot get style with id=${t} for renderIndex`,
                                            ),
                                            NaN
                                        );
                                    const o = n.layersById[i];
                                    return o ? o.renderIndex : NaN;
                                })(e, t.attributes.styleId, t.attributes.layerId),
                            )(t, i),
                        Ps = xs((e) => e.layerSettings.subRenderIndex || 0),
                        Ls = (e, t, i) => {
                            const n = new Set();
                            e.forEach((e) => {
                                if (e.type === ot.H.Custom) return;
                                const o = e.layerSettings.programName;
                                n.has(e.layerSettings.programName) ||
                                    (n.add(o), t.setProgramBinder(e, i));
                            });
                        },
                        ks = (e, t, i) =>
                            xs((t, i) => {
                                const n = (0, $.jJ)(
                                    i.styleZoom,
                                    i.styleState,
                                    t.attributes.tileData,
                                );
                                return (0, $.vn)(e, n, 0);
                            })(t, i),
                        Es = Ss((e) => e.layerSettings.programName),
                        As = Ss((e) => e.layerSettings.webglState),
                        zs = Ss((e) => e.sink + '_' + e.attributesHash + '_' + e.tile.readiness);
                    function Cs(e, t) {
                        const i = e.getStyle(t.attributes.styleId);
                        if (i) return i.layersById[t.attributes.layerId];
                    }
                    const Fs = (e, t, i) => {
                            const n = t.renderer.getRenderingContext(),
                                o = { demUniformsBound: !1 };
                            let r = null;
                            const s = t.renderer.commonShaderDefines,
                                a = {
                                    drawSymbol: (e, t, i, s) => {
                                        const l = e[0];
                                        'mapMesh' === l.symbol && 'overpass' === t.type
                                            ? (a.renderLevelTexture(l, t, !1),
                                              a.useProgram(e),
                                              a.useState(e),
                                              Os(e, t, i, s, a, o.demUniformsBound, null),
                                              a.renderLevelTexture(l, t, !0),
                                              a.useProgram(e),
                                              a.useState(e),
                                              Ji(n, tn, t),
                                              Os(e, t, i, s, a, o.demUniformsBound, null))
                                            : Os(e, t, i, s, a, o.demUniformsBound, r);
                                    },
                                    useProgram: (i) => {
                                        const { layerBinder: o, programName: r } =
                                                i[0].layerSettings,
                                            a = t.renderer.getShaderProgram(r);
                                        a.enable(n, s), null == o || o(n, a, e, t);
                                    },
                                    setProgramBinder: (i, r) => {
                                        if (
                                            ((o.demUniformsBound = !1),
                                            i.layerSettings.programBinder)
                                        ) {
                                            const o = t.renderer.getShaderProgram(
                                                i.layerSettings.programName,
                                            );
                                            o.enable(n, s),
                                                i.layerSettings.programBinder(n, o, e, t, a, r);
                                        }
                                    },
                                    useState: (e, t) => {
                                        Ji(n, e[0].layerSettings.webglState, t);
                                    },
                                    useCustomLayerState: (e) => {
                                        Ji(n, _n, e);
                                    },
                                    useInstanceObject: (e) => {
                                        r = e;
                                    },
                                    setFlags: (e) => {
                                        Object.assign(o, e);
                                    },
                                    renderLevelTexture: (o, r, s) => {
                                        const { viewport: l, size: c } = e,
                                            d = window.devicePixelRatio,
                                            h = t.renderer.getMapMeshFramebufferId(),
                                            u = t.renderer.getFramebuffer(h);
                                        if (!u) return;
                                        if (
                                            (n.activeTexture(n.TEXTURE0),
                                            n.bindTexture(n.TEXTURE_2D, null),
                                            u.renderTarget.bind(n),
                                            n.viewport(
                                                0,
                                                0,
                                                u.renderTarget.options.size[0],
                                                u.renderTarget.options.size[1],
                                            ),
                                            s)
                                        )
                                            n.depthMask(!0),
                                                n.clearDepth(-1),
                                                n.clearColor(0, 0, 0, 0),
                                                n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT);
                                        else {
                                            const i = (0, $.jJ)(
                                                    e.styleZoom,
                                                    e.styleState,
                                                    o.attributes.tileData,
                                                ),
                                                n = (0, $.zn)(r.style.clearColor, i).value;
                                            t.renderer.clearWithColor(
                                                [n[0] / 255, n[1] / 255, n[2] / 255, n[3] / 255],
                                                !0,
                                            );
                                        }
                                        const m = o.attributes.meshLevel,
                                            f = null == i ? void 0 : i[m];
                                        if (f) {
                                            f.tileObjects.forEach((e) => {
                                                var i, n;
                                                e.updateMvpMatrix(
                                                    null !==
                                                        (n =
                                                            null ===
                                                                (i = u.getViewProjectionMatrix) ||
                                                            void 0 === i
                                                                ? void 0
                                                                : i.call(u)) && void 0 !== n
                                                        ? n
                                                        : t.camera.viewProjectionMatrix,
                                                    void 0,
                                                );
                                            });
                                            const i = s
                                                ? f.objects.filter((e) => {
                                                      var i;
                                                      if (e.type !== ot.H.Custom) {
                                                          if (e.layerSettings.webglState.depthTest)
                                                              return !0;
                                                          const n = t.styleManager.getStyleLayer(
                                                              e.attributes.styleId,
                                                              e.attributes.layerId,
                                                          );
                                                          if (n)
                                                              return (
                                                                  !0 ===
                                                                  (null === (i = n.webglState) ||
                                                                  void 0 === i
                                                                      ? void 0
                                                                      : i.depthTest)
                                                              );
                                                      }
                                                      return !1;
                                                  })
                                                : f.objects;
                                            us(e, t, i, a, !0),
                                                f.tileObjects.forEach((e) => {
                                                    e.updateMvpMatrix(
                                                        t.camera.viewProjectionMatrix,
                                                        void 0,
                                                    );
                                                });
                                        }
                                        u.renderTarget.unbind(n),
                                            n.viewport(
                                                l.left * d,
                                                l.bottom * d,
                                                c[0] * d,
                                                c[1] * d,
                                            );
                                    },
                                };
                            return a;
                        },
                        Os = (e, t, i, n, o, r, s) => {
                            const a = n.renderer.getRenderingContext(),
                                l = e[0];
                            let c = !0;
                            if (s) {
                                const { objectBinder: e, programName: o } = s.layerSettings,
                                    r = n.renderer.getShaderProgram(o);
                                c = c && e(a, r, i, n, s, t);
                            }
                            const {
                                    objectBinder: d,
                                    programName: h,
                                    zoomBinder: u,
                                } = l.layerSettings,
                                m = n.renderer.getShaderProgram(h);
                            (c = c && d(a, m, i, n, l, t)),
                                c &&
                                    (u
                                        ? Rs(e, i).forEach((e) => {
                                              u(a, m, i, n, e[0], t),
                                                  e.forEach((e) => Ds(e, n, m, i, o, a, r, t, s));
                                          })
                                        : e.forEach((e) => Ds(e, n, m, i, o, a, r, t, s)));
                        },
                        Ds = (e, t, i, n, o, r, s, a, l) => {
                            var c;
                            const d = t.renderer.webGlExtensions,
                                h = d.ANGLE_instanced_arrays,
                                u = !(r instanceof WebGLRenderingContext) || h;
                            if (Ke(e))
                                return u
                                    ? void (function (e, t, i, n, o) {
                                          const r =
                                                  ((a = e),
                                                  'instances' === a.sink
                                                      ? a.attributes.modelId
                                                      : NaN),
                                              { assetManager: s } = t;
                                          var a;
                                          if (Number.isNaN(r)) return;
                                          const l = s.getModel(r);
                                          if (void 0 === l) return;
                                          const c = l.objects;
                                          if (0 === c.length) return;
                                          n.useInstanceObject(e);
                                          for (const r of c) {
                                              let s = r.children;
                                              e.layerSettings.identify
                                                  ? (s = r.identifyChildren)
                                                  : e.layerSettings.depthTest &&
                                                    (s = r.depthTestChildren);
                                              for (const t of s)
                                                  (t.attributes.styleId = e.attributes.styleId),
                                                      (t.attributes.layerId = e.attributes.layerId);
                                              us(i, t, s, n, !o);
                                          }
                                          n.useInstanceObject(null);
                                      })(e, t, n, o, s)
                                    : void (0, hs.cM)(
                                          'Instancing is not supported. Cannot draw instanced objects.',
                                      );
                            let m;
                            l &&
                                (l.linked || (l.linked = []),
                                l.linked[e.id] || Ye(l, e, a),
                                (m = l.linked[e.id]));
                            if (!e.layerSettings.tileBinder(r, i, n, t, e, l, s, a)) return;
                            if (s) {
                                const t = null != l ? l : e;
                                i.bind(r, {
                                    u_mat4_dem_mvp: t.tile.demMatrix,
                                    u_float_vertical_scale: L.C / t.tile.modelMatrix[10],
                                });
                            }
                            m
                                ? m.vao.bind({ gl: r, extensions: d })
                                : e.vao.bind({ gl: r, extensions: d });
                            const f = e.rangeStart / e.stride,
                                p = (e.rangeEnd - e.rangeStart) / e.stride,
                                _ = null !== (c = e.drawMode) && void 0 !== c ? c : rt.Fg,
                                v = l ? (l.rangeEnd - l.rangeStart) / l.stride : 0,
                                g = e.vao.getElementsGLType(r);
                            null !== g
                                ? v
                                    ? (function (e, t, i, n, o, r, s) {
                                          if (e instanceof WebGLRenderingContext) {
                                              if (!s) return;
                                              s.drawElementsInstancedANGLE(t, i, n, o, r);
                                          } else e.drawElementsInstanced(t, i, n, o, r);
                                      })(r, _, p, g, f, v, h)
                                    : r.drawElements(_, p, g, f)
                                : v
                                ? (function (e, t, i, n, o, r) {
                                      if (e instanceof WebGLRenderingContext) {
                                          if (!r) return;
                                          r.drawArraysInstancedANGLE(t, i, n, o);
                                      } else e.drawArraysInstanced(t, i, n, o);
                                  })(r, _, f, p, v, h)
                                : r.drawArrays(_, f, p),
                                !n.collectStats ||
                                    e.layerSettings.identify ||
                                    e.layerSettings.depthTest ||
                                    (n.stats.drawCount++, (n.stats.vertexCount += p * v));
                        };
                    const Rs = xs((e) => e.tile.zoomLevel),
                        js = new Float32Array(16),
                        Bs = 2,
                        Ns = (0, E.H)(),
                        Us = (0, E.H)(),
                        Zs = new Float64Array(16);
                    class Hs extends class {
                        constructor(e) {
                            if (
                                ((this.webGlExtensions = {}),
                                (this._canvasElement = null),
                                (this._size = [1, 1]),
                                'canvas' in (e = e || {}))
                            ) {
                                this._canvasElement =
                                    'string' == typeof e.canvas
                                        ? document.getElementById(e.canvas)
                                        : e.canvas;
                                const t = {
                                    antialias: void 0 === e.antialias || e.antialias,
                                    stencil: void 0 !== e.stencil && e.stencil,
                                    failIfMajorPerformanceCaveat:
                                        void 0 !== e.failIfMajorPerformanceCaveat &&
                                        e.failIfMajorPerformanceCaveat,
                                    preserveDrawingBuffer:
                                        void 0 !== e.preserveDrawingBuffer &&
                                        e.preserveDrawingBuffer,
                                };
                                this._gl =
                                    2 === e.version
                                        ? this._canvasElement.getContext('webgl2', t)
                                        : this._canvasElement.getContext('webgl', t) ||
                                          this._canvasElement.getContext('experimental-webgl', t);
                            } else this._gl = e.gl;
                            (this._pixelRatio = e.pixelRatio || 1),
                                (this.clearColor = e.clearColor || [1, 1, 1, 1]),
                                (this.webGlExtensions = {});
                        }
                        setPixelRatio(e) {
                            return (this._pixelRatio = e), this;
                        }
                        getPixelRatio() {
                            return this._pixelRatio;
                        }
                        setSize(e, t) {
                            return (
                                (this._size = [e * this._pixelRatio, t * this._pixelRatio]),
                                this._canvasElement &&
                                    ((this._canvasElement.width = this._size[0]),
                                    (this._canvasElement.height = this._size[1]),
                                    (this._canvasElement.style.width = `${e}px`),
                                    (this._canvasElement.style.height = `${t}px`)),
                                this.setViewport(),
                                this
                            );
                        }
                        setViewport(e, t) {
                            return (
                                void 0 !== e && void 0 !== t
                                    ? this._gl.viewport(0, 0, e, t)
                                    : this._gl.viewport(0, 0, this._size[0], this._size[1]),
                                this
                            );
                        }
                        getSize() {
                            return this._size;
                        }
                        addExtension(e) {
                            return (this.webGlExtensions[e] = this._gl.getExtension(e)), this;
                        }
                    } {
                        constructor(e, t) {
                            const i = t.layout.canvas,
                                n = {
                                    antialias: !1,
                                    failIfMajorPerformanceCaveat: !1,
                                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                                },
                                o = e.webglVersion;
                            let r = null;
                            if (
                                (2 === o &&
                                    ((r = i.getContext('webgl2', n)), (Hs.webglVersion = 2)),
                                (null !== r && 1 !== o) ||
                                    ((r =
                                        i.getContext('webgl', n) ||
                                        i.getContext('experimental-webgl', n)),
                                    (Hs.webglVersion = 1)),
                                null === r ||
                                    !(
                                        r instanceof WebGLRenderingContext ||
                                        r instanceof WebGL2RenderingContext
                                    ))
                            )
                                throw new Error('Failed to obtain WebGL context');
                            super({
                                gl: r,
                                clearColor: (0, $.m2)((0, ds.MV)(e.defaultBackgroundColor)),
                            }),
                                (this.framebuffers = []),
                                (this.lastRenderedFramebuffers = []),
                                (this.mapMeshMvpMatrix = new Float64Array(16)),
                                (this.trackContextLost = (e) => {
                                    e.preventDefault(),
                                        this.modules.map.destroy(),
                                        ze({
                                            eventAction: 'WebGlContext',
                                            eventLabel: 'webglcontextlost',
                                        }),
                                        ze({
                                            eventCategory: 'WebGlContext',
                                            eventAction: 'webglcontextlost',
                                            eventLabel: e.statusMessage || '',
                                        });
                                }),
                                (this.state = e),
                                (this.modules = t),
                                (this.identifyBuffer = new nt({
                                    minFilter: it.NearestFilter,
                                    magFilter: it.NearestFilter,
                                })),
                                (this.labelingTextureBuffer = new nt({
                                    size: [
                                        Math.ceil(this.state.size[0] * window.devicePixelRatio),
                                        Math.ceil(this.state.size[1] * window.devicePixelRatio),
                                    ],
                                    magFilter: it.NearestFilter,
                                    minFilter: it.NearestFilter,
                                    depthTexture: !0,
                                })),
                                (this.commonShaderDefines =
                                    this.prepareExternalShaderDefinitions(e)),
                                (this.shaderPrograms = {
                                    diffuse: new $r({
                                        vertex: ns('diffuse'),
                                        fragment: os('color'),
                                        uniforms: [
                                            rs,
                                            ...as,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_height_limitation', type: '1f' },
                                            { name: 'u_float_tile_height', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            ...ss,
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec3_normal', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    gradientDiffuse: new $r({
                                        vertex: ns('diffuse'),
                                        fragment: os('gradient'),
                                        uniforms: [
                                            rs,
                                            ...as,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_height_limitation', type: '1f' },
                                            { name: 'u_float_tile_height', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            { name: 'u_mat4_gradient', type: 'mat4' },
                                            ...ss,
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec3_normal', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    labelLine: new $r({
                                        vertex: ns('labelLine'),
                                        fragment: os('labelLine'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_float_tile_to_pixel_ratio', type: '1f' },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_buffer', type: '1f' },
                                            { name: 'u_float_gamma', type: '1f' },
                                            { name: 'u_float_scale', type: '1f' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_style_zoom', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec2_texcoord', location: 2 },
                                            { name: 'a_vec2_style_zoom_limits', location: 3 },
                                        ],
                                    }),
                                    labelPoint: new $r({
                                        vertex: ns('labelPoint'),
                                        fragment: os('label'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_buffer', type: '1f' },
                                            { name: 'u_float_gamma', type: '1f' },
                                            { name: 'u_float_scale', type: '1f' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_vec4_hidden_color', type: '4fv' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            { name: 'u_vec2_offset', type: '2f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_depth_tex_labeling', type: '1i' },
                                            { name: 'u_color_tex_labeling', type: '1i' },
                                            {
                                                name: 'u_vec2_depth_test_half_point_size',
                                                type: '2f',
                                            },
                                            { name: 'u_bool_skip_height_factor', type: '1i' },
                                            { name: 'u_bool_depth_test_disable', type: '1i' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec2_texcoord', location: 2 },
                                            { name: 'a_vec2_check_offset', location: 3 },
                                            { name: 'a_vec4_tex_identifier', location: 4 },
                                        ],
                                    }),
                                    labelPointIdentify: new $r({
                                        vertex: ns('labelPointIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            { name: 'u_float_scale', type: '1f' },
                                            { name: 'u_vec2_offset', type: '2f' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec4_identifier', location: 2 },
                                        ],
                                    }),
                                    line: new $r({
                                        vertex: ns('line'),
                                        fragment: os('line'),
                                        uniforms: [
                                            rs,
                                            ...as,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_height_limitation', type: '1f' },
                                            { name: 'u_float_tile_height', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            { name: 'u_mat4_gradient', type: 'mat4' },
                                            ...ss,
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_vertex', location: 0 },
                                            { name: 'a_vec2_normal', location: 1 },
                                            { name: 'a_vec2_normal_delta', location: 2 },
                                            { name: 'a_vec3_direction', location: 3 },
                                            { name: 'a_float_distance', location: 4 },
                                            { name: 'a_vec2_dem_position', location: 5 },
                                        ],
                                    }),
                                    pointSprite: new $r({
                                        vertex: ns('pointSprite'),
                                        fragment: os('pointSprite'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_rounding_factor', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_vec2_opacity', type: '2f' },
                                            { name: 'u_vec2_rotation', type: '2fv' },
                                            { name: 'u_depth_tex_labeling', type: '1i' },
                                            { name: 'u_color_tex_labeling', type: '1i' },
                                            {
                                                name: 'u_vec2_depth_test_half_point_size',
                                                type: '2f',
                                            },
                                            { name: 'u_bool_skip_height_factor', type: '1i' },
                                            { name: 'u_bool_depth_test_disable', type: '1i' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec2_check_offset', location: 2 },
                                            { name: 'a_vec2_texcoord', location: 3 },
                                            { name: 'a_vec2_range', location: 4 },
                                            { name: 'a_vec2_rescale', location: 5 },
                                            { name: 'a_vec4_tex_identifier', location: 6 },
                                        ],
                                    }),
                                    pointSpriteIdentify: new $r({
                                        vertex: ns('pointSpriteIdentify'),
                                        fragment: os('pointSpriteIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_vec2_rotation', type: '2fv' },
                                            { name: 'u_bool_skip_height_factor', type: '1i' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec2_texcoord', location: 2 },
                                            { name: 'a_vec2_range', location: 3 },
                                            { name: 'a_vec2_rescale', location: 4 },
                                            { name: 'a_vec4_identifier', location: 5 },
                                        ],
                                    }),
                                    pointDepthTest: new $r({
                                        vertex: ns('pointAnchor'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            { name: 'u_vec2_offset', type: '2f' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_position', location: 0 },
                                            { name: 'a_vec2_offset', location: 1 },
                                            { name: 'a_vec4_identifier', location: 2 },
                                        ],
                                    }),
                                    stripedLine: new $r({
                                        vertex: ns('stripedLine'),
                                        fragment: os('stripedLine'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_vec2_scaler_params', type: '2fv' },
                                            { name: 'u_float_dash_length', type: '1f' },
                                            { name: 'u_float_space_length', type: '1f' },
                                            { name: 'u_float_dash2_length', type: '1f' },
                                            { name: 'u_vec4_dash_color', type: '4fv' },
                                            { name: 'u_vec4_space_color', type: '4fv' },
                                            { name: 'u_vec4_border_color', type: '4fv' },
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_width_offset', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texture_widen', location: 1 },
                                            { name: 'a_vec2_widen', location: 2 },
                                            { name: 'a_float_vertex_distance', location: 3 },
                                            { name: 'a_float_component_distance', location: 4 },
                                            { name: 'a_float_object_length', location: 5 },
                                            { name: 'a_vec4_identifier', location: 6 },
                                        ],
                                    }),
                                    stripedLineIdentify: new $r({
                                        vertex: ns('stripedLineIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_vec2_scaler_params', type: '2fv' },
                                            { name: 'u_float_dash_length', type: '1f' },
                                            { name: 'u_float_space_length', type: '1f' },
                                            { name: 'u_float_dash2_length', type: '1f' },
                                            { name: 'u_vec4_dash_color', type: '4fv' },
                                            { name: 'u_vec4_space_color', type: '4fv' },
                                            { name: 'u_vec4_border_color', type: '4fv' },
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_width_offset', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texture_widen', location: 1 },
                                            { name: 'a_vec2_widen', location: 2 },
                                            { name: 'a_float_vertex_distance', location: 3 },
                                            { name: 'a_float_component_distance', location: 4 },
                                            { name: 'a_float_object_length', location: 5 },
                                            { name: 'a_vec4_identifier', location: 6 },
                                        ],
                                    }),
                                    vtxColor: new $r({
                                        vertex: ns('color'),
                                        fragment: os('texturedColor'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_texture_opacity', type: '1f' },
                                            { name: 'u_float_texture_params', type: '4fv' },
                                            { name: 'u_float_sprite_texture_coords', type: '4fv' },
                                            { name: 'u_int_is_textured', type: '1i' },
                                            ...cs,
                                        ],
                                        attributes: [{ name: 'a_vec2_vertex', location: 0 }],
                                    }),
                                    vtxColorIdentify: new $r({
                                        vertex: ns('colorIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [rs, { name: 'u_vec2_vpt_size', type: '2fv' }],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec4_identifier', location: 1 },
                                        ],
                                    }),
                                    roadPointMark: new $r({
                                        vertex: ns('roadPointMark'),
                                        fragment: os('roadPointMark'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_sprite_texture_coords', type: '4fv' },
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                        ],
                                    }),
                                    zbmModelIdentify: new $r({
                                        vertex: ns('zbmModelIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec4_identifier', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    buildingIdentify: new $r({
                                        vertex: ns('buildingIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            { name: 'u_float_height_limitation', type: '1f' },
                                            { name: 'u_float_tile_height', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec4_identifier', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    oneWayLine: new $r({
                                        vertex: ns('oneWayLine'),
                                        fragment: os('oneWayLine'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_vec4_color', type: '4f' },
                                            { name: 'u_vec4_border_color', type: '4f' },
                                            { name: 'u_vec2_wing_normal', type: '2f' },
                                            { name: 'u_vec2_tip_normal', type: '2f' },
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_length', type: '1f' },
                                            { name: 'u_float_border_width', type: '1f' },
                                            { name: 'u_float_border_width_offset', type: '1f' },
                                            { name: 'u_float_size_factor', type: '1f' },
                                            { name: 'u_vec2_scale_limits', type: '2fv' },
                                            { name: 'u_float_tip_height_multiplier', type: '1f' },
                                            { name: 'u_float_wing_height_multiplier', type: '1f' },
                                            { name: 'u_float_wing_width_multiplier', type: '1f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_position', location: 0 },
                                            { name: 'a_vec2_direction', location: 1 },
                                            { name: 'a_vec2_widen_direction', location: 2 },
                                        ],
                                    }),
                                    zbmModel: new $r({
                                        vertex: ns('zbmModel'),
                                        fragment: os('zbmModel'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            ...ss,
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    gltfModel: new $r({
                                        vertex: ns('gltfModel'),
                                        fragment: os('gltfModel'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_mat4_instance', type: 'mat4' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_sr2d_texture_0', type: '1i' },
                                            { name: 'u_ao_texture', type: '1i' },
                                            { name: 'u_int_has_ao_texture', type: '1i' },
                                            { name: 'u_float_identify', type: '1f' },
                                            ...cs,
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'position', location: 0 },
                                            { name: 'normal', location: 1 },
                                            { name: 'tangent', location: 2 },
                                            { name: 'a_vec3_instance_position', location: 3 },
                                            { name: 'a_vec3_instance_scale', location: 4 },
                                            { name: 'a_vec4_instance_rotation', location: 5 },
                                            { name: 'a_vec4_instance_localid', location: 6 },
                                            { name: 'texcoord_color', location: 7 },
                                            { name: 'texcoord_ao', location: 8 },
                                        ],
                                    }),
                                    gltfModelIdentify: new $r({
                                        vertex: ns('gltfModel'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_mat4_instance', type: 'mat4' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_sr2d_texture_0', type: '1i' },
                                            { name: 'u_float_identify', type: '1f' },
                                            ...cs,
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'position', location: 0 },
                                            { name: 'normal', location: 1 },
                                            { name: 'tangent', location: 2 },
                                            { name: 'a_vec3_instance_position', location: 3 },
                                            { name: 'a_vec3_instance_scale', location: 4 },
                                            { name: 'a_vec4_instance_rotation', location: 5 },
                                            { name: 'a_vec4_instance_localid', location: 6 },
                                        ],
                                    }),
                                    simpleLine: new $r({
                                        vertex: ns('simpleLine'),
                                        fragment: os('simpleLine'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_height_limitation', type: '1f' },
                                            { name: 'u_float_tile_height', type: '1f' },
                                            { name: 'u_float_z_offset', type: '1f' },
                                            ...cs,
                                            ...ss,
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec4_direction_distance', location: 1 },
                                            { name: 'a_vec2_dem_position', location: 2 },
                                        ],
                                    }),
                                    road: new $r({
                                        vertex: ns('road'),
                                        fragment: os('road'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_tile_to_pixel_ratio', type: '1f' },
                                            { name: 'u_float_shift', type: '1f' },
                                            ...cs,
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec4_normals', location: 1 },
                                            { name: 'a_vec2_shift', location: 2 },
                                        ],
                                    }),
                                    roadIdentify: new $r({
                                        vertex: ns('roadIdentify'),
                                        fragment: os('roadIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_float_width', type: '1f' },
                                            { name: 'u_float_tile_to_pixel_ratio', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec4_normals', location: 1 },
                                            { name: 'a_vec4_identifier', location: 2 },
                                        ],
                                    }),
                                    entrance: new $r({
                                        vertex: ns('entranceArrow'),
                                        fragment: os('entranceArrow'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_vec2_scale_limits', type: '2fv' },
                                            { name: 'u_vec4_color', type: '4f' },
                                            { name: 'u_vec4_border_color', type: '4f' },
                                            { name: 'u_vec2_wing_normal', type: '2f' },
                                            { name: 'u_vec2_tip_normal', type: '2f' },
                                            { name: 'u_float_width_zpt', type: '1f' },
                                            { name: 'u_float_tip_height_multiplier', type: '1f' },
                                            { name: 'u_float_wing_width_multiplier', type: '1f' },
                                            { name: 'u_float_wing_height_multiplier', type: '1f' },
                                            { name: 'u_float_border_width_zpt', type: '1f' },
                                            { name: 'u_float_size_factor', type: '1f' },
                                            { name: 'u_float_border_width_offset', type: '1f' },
                                            { name: 'u_float_total_line_length', type: '1f' },
                                            { name: 'u_float_relative_end_position', type: '1f' },
                                            { name: 'u_float_vertex_shift', type: '1f' },
                                            { name: 'u_float_tip_movement_amplitude', type: '1f' },
                                            { name: 'u_vec2_bounce_direction', type: '2f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_segment_end', location: 1 },
                                            {
                                                name: 'a_vec4_texture_widen_arrow_widen',
                                                location: 2,
                                            },
                                            { name: 'a_vec2_widen', location: 3 },
                                            { name: 'a_vec2_direction', location: 4 },
                                            { name: 'a_float_distance_from_start', location: 5 },
                                            { name: 'a_float_object_length', location: 6 },
                                            { name: 'a_float_type', location: 7 },
                                            { name: 'a_vec4_identifier', location: 8 },
                                        ],
                                    }),
                                    entranceIdentify: new $r({
                                        vertex: ns('entranceArrow'),
                                        fragment: os('entranceArrowIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2f' },
                                            {
                                                name: 'u_vec3_projection_scale_style_scale_dpi',
                                                type: '3fv',
                                            },
                                            { name: 'u_vec2_scale_limits', type: '2fv' },
                                            { name: 'u_vec4_color', type: '4f' },
                                            { name: 'u_vec4_border_color', type: '4f' },
                                            { name: 'u_vec2_wing_normal', type: '2f' },
                                            { name: 'u_vec2_tip_normal', type: '2f' },
                                            { name: 'u_float_width_zpt', type: '1f' },
                                            { name: 'u_float_tip_height_multiplier', type: '1f' },
                                            { name: 'u_float_wing_width_multiplier', type: '1f' },
                                            { name: 'u_float_wing_height_multiplier', type: '1f' },
                                            { name: 'u_float_border_width_zpt', type: '1f' },
                                            { name: 'u_float_size_factor', type: '1f' },
                                            { name: 'u_float_border_width_offset', type: '1f' },
                                            { name: 'u_float_total_line_length', type: '1f' },
                                            { name: 'u_float_relative_end_position', type: '1f' },
                                            { name: 'u_float_vertex_shift', type: '1f' },
                                            { name: 'u_float_tip_movement_amplitude', type: '1f' },
                                            { name: 'u_vec2_bounce_direction', type: '2f' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_segment_end', location: 1 },
                                            {
                                                name: 'a_vec4_texture_widen_arrow_widen',
                                                location: 2,
                                            },
                                            { name: 'a_vec2_widen', location: 3 },
                                            { name: 'a_vec2_direction', location: 4 },
                                            { name: 'a_float_distance_from_start', location: 5 },
                                            { name: 'a_float_object_length', location: 6 },
                                            { name: 'a_float_type', location: 7 },
                                            { name: 'a_vec4_identifier', location: 8 },
                                        ],
                                    }),
                                    circleMarker: new $r({
                                        vertex: ns('circleMarker'),
                                        fragment: os('circleMarker'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_width', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_vertex', location: 0 },
                                            { name: 'a_vec2_widen', location: 1 },
                                        ],
                                    }),
                                    rect: new $r({
                                        vertex: ns('rect'),
                                        fragment: os('rect'),
                                        uniforms: [rs, { name: 'u_vec4_color', type: '4fv' }],
                                        attributes: [{ name: 'a_vec2_vertex', location: 0 }],
                                    }),
                                    rectWithTexture: new $r({
                                        vertex: ns('rectWithTexture'),
                                        fragment: os('rectWithTexture'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                        ],
                                    }),
                                    circleMarkerIdentify: new $r({
                                        vertex: ns('circleMarkerIdentify'),
                                        fragment: os('colorIdentify'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_vec2_vpt_size', type: '2fv' },
                                            { name: 'u_float_width', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec4_vertex', location: 0 },
                                            { name: 'a_vec2_widen', location: 1 },
                                            { name: 'a_vec4_identifier', location: 2 },
                                        ],
                                    }),
                                    heatmap: new $r({
                                        vertex: ns('heatmap'),
                                        fragment: os('heatmap'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_float_radius', type: '1f' },
                                            { name: 'u_float_intensity', type: '1f' },
                                            { name: 'u_float_tile_to_pixel_ratio', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_position', location: 0 },
                                            { name: 'a_vec2_widen', location: 1 },
                                            { name: 'a_float_weight', location: 2 },
                                        ],
                                    }),
                                    heatmapTexture: new $r({
                                        vertex: ns('heatmapTexture'),
                                        fragment: os('heatmapTexture'),
                                        uniforms: [
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_sr2d_ramp_texture', type: '1i' },
                                            { name: 'u_float_opacity', type: '1f' },
                                        ],
                                        attributes: [{ name: 'a_vec2_position', location: 0 }],
                                    }),
                                    demMesh: new $r({
                                        vertex: ns('demMesh'),
                                        fragment: os('demMesh'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_mat4_flat_map_mvp', type: 'mat4' },
                                            { name: 'u_flat_tex', type: '1i' },
                                            { name: 'u_hillshade_tex', type: '1i' },
                                            ...ss,
                                            ...cs,
                                        ],
                                        attributes: [{ name: 'a_vec2_position', location: 0 }],
                                    }),
                                    demGround: new $r({
                                        vertex: ns('demGround'),
                                        fragment: os('demGround'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_mat4_model', type: 'mat4' },
                                            ...ss,
                                        ],
                                        attributes: [{ name: 'a_vec2_position', location: 0 }],
                                    }),
                                    demElevation: new $r({
                                        vertex: ns('demElevation'),
                                        fragment: os('demElevation'),
                                        uniforms: [rs, { name: 'u_sr2d_texture', type: '1i' }],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                        ],
                                    }),
                                    demElevationCopy: new $r({
                                        vertex: ns('demElevationCopy'),
                                        fragment: os('demElevationCopy'),
                                        uniforms: [
                                            rs,
                                            { name: 'u_sr2d_texture', type: '1i' },
                                            { name: 'u_mat4_dem_corrected', type: 'mat4' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                        ],
                                    }),
                                    demHillshade: new $r({
                                        vertex: ns('demHillshade'),
                                        fragment: os('demHillshade'),
                                        uniforms: [
                                            ...ss,
                                            rs,
                                            { name: 'u_sr2d_texture', type: '1i' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_texcoord', location: 1 },
                                        ],
                                    }),
                                    demFlatBottom: new $r({
                                        vertex: ns('demFlatBottom'),
                                        fragment: os('demFlatBottom'),
                                        uniforms: [rs, ...ss],
                                        attributes: [
                                            { name: 'a_vec2_vertex', location: 0 },
                                            { name: 'a_vec2_centroid', location: 1 },
                                            { name: 'a_vec2_extender', location: 2 },
                                        ],
                                    }),
                                    mesh: new $r({
                                        vertex: ns('mesh'),
                                        fragment: os('mesh'),
                                        uniforms: [
                                            rs,
                                            ...ss,
                                            ...as,
                                            ls,
                                            { name: 'u_sampler2d_texture', type: '1i' },
                                            { name: 'u_float_opacity', type: '1f' },
                                            { name: 'u_vec4_color', type: '4fv' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec3_normal', location: 1 },
                                            { name: 'a_float_gradient', location: 2 },
                                            { name: 'a_vec2_tex_coord', location: 3 },
                                        ],
                                    }),
                                    mapMesh: new $r({
                                        vertex: ns('mapMesh'),
                                        fragment: os('mapMesh'),
                                        uniforms: [
                                            rs,
                                            ...ss,
                                            ...as,
                                            ls,
                                            { name: 'u_float_tile_size', type: '1f' },
                                            { name: 'u_sampler_map_tex', type: '1i' },
                                            { name: 'u_float_tex_scale', type: '1f' },
                                            { name: 'u_float_height_factor', type: '1f' },
                                            { name: 'u_float_height_delta', type: '1f' },
                                        ],
                                        attributes: [
                                            { name: 'a_vec3_vertex', location: 0 },
                                            { name: 'a_vec2_extender', location: 1 },
                                            { name: 'a_vec3_normal', location: 2 },
                                            { name: 'a_float_gradient', location: 3 },
                                            { name: 'a_vec2_dem_position', location: 4 },
                                        ],
                                    }),
                                    sky: new $r({
                                        vertex: ns('sky'),
                                        fragment: os('sky'),
                                        uniforms: [...cs, { name: 'u_vec4_color', type: '4f' }],
                                        attributes: [{ name: 'a_vec2_vertex', location: 0 }],
                                    }),
                                }),
                                t.map.once('idle', () =>
                                    (function (e, t, i) {
                                        if (window.requestIdleCallback)
                                            for (const n in e) {
                                                const o = e[n];
                                                window.requestIdleCallback(() => {
                                                    t.isContextLost() ||
                                                        (o.link(t, i),
                                                        setTimeout(() => {
                                                            window.requestIdleCallback(() => {
                                                                t.isContextLost() || o.locate(t);
                                                            });
                                                        }, 2e3));
                                                });
                                            }
                                    })(this.shaderPrograms, this._gl, this.commonShaderDefines),
                                ),
                                (this.symbolSettingsList = {
                                    line: {
                                        solid: [
                                            {
                                                programName: 'road',
                                                vaoCreator: qt,
                                                webglState: rn,
                                                layerBinder: Et,
                                                objectBinder: Cr(Fo, cr, co, Mo, Po),
                                                zoomBinder: Sr,
                                                tileBinder: Dr(Br, jr),
                                            },
                                            {
                                                identify: !0,
                                                programName: 'roadIdentify',
                                                vaoCreator: Xt,
                                                webglState: ln,
                                                objectBinder: Cr(cr, Po),
                                                zoomBinder: Sr,
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    polygon: {
                                        fill: [
                                            {
                                                programName: 'vtxColor',
                                                vaoCreator: Gt,
                                                webglState: rn,
                                                layerBinder: zt(At, Et),
                                                objectBinder: Cr(cr, Ho, Zo, co, Mo, bo, wo),
                                                tileBinder: Dr(Ur, jr, Br),
                                            },
                                            {
                                                identify: !0,
                                                programName: 'vtxColorIdentify',
                                                vaoCreator: Wt,
                                                webglState: an,
                                                programBinder: ft,
                                                objectBinder: Cr(cr, Ho, Zo),
                                                tileBinder: jr,
                                            },
                                        ],
                                        stroke: [
                                            {
                                                programName: 'simpleLine',
                                                vaoCreator: hi,
                                                webglState: rn,
                                                programBinder: to,
                                                layerBinder: zt(ft, yt, Mt, Et),
                                                objectBinder: Cr(dr, cr, Ho, Zo, _o, xo, Mo, ko),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 1,
                                            },
                                        ],
                                    },
                                    roadPointMark: {
                                        fill: [
                                            {
                                                programName: 'roadPointMark',
                                                vaoCreator: Vt,
                                                webglState: rn,
                                                layerBinder: zt(At, Et),
                                                objectBinder: Cr(cr, co, Mo),
                                                tileBinder: Dr(Zr, jr, Br),
                                            },
                                        ],
                                    },
                                    mesh: {
                                        fill: [
                                            {
                                                programName: 'mesh',
                                                vaoCreator: ei,
                                                webglState: en,
                                                layerBinder: xt,
                                                programBinder: Gn,
                                                objectBinder: Cr(cr, ho, To, bo, kr, Lo),
                                                tileBinder: jr,
                                            },
                                        ],
                                        stroke: [
                                            {
                                                programName: 'simpleLine',
                                                vaoCreator: ui,
                                                webglState: nn,
                                                programBinder: to,
                                                layerBinder: zt(mt, yt, Pt),
                                                objectBinder: Cr(cr, _o, xo, Mo, ko, kr),
                                                tileBinder: jr,
                                                subRenderIndex: 1,
                                            },
                                        ],
                                    },
                                    polygonExtrusion: {
                                        sideFill: [
                                            {
                                                programName: 'diffuse',
                                                vaoCreator: ti,
                                                webglState: cn,
                                                tileBinder: Dr(Br, jr),
                                                layerBinder: zt(wt, Et),
                                                programBinder: Hn,
                                                objectBinder: Cr(cr, Ho, Zo, fo, yo, Mo, ar, bo),
                                            },
                                            {
                                                programName: 'gradientDiffuse',
                                                vaoCreator: ti,
                                                webglState: dn,
                                                layerBinder: zt(wt, Et),
                                                programBinder: Hn,
                                                objectBinder: Cr(
                                                    cr,
                                                    Ho,
                                                    Zo,
                                                    fo,
                                                    po,
                                                    yo,
                                                    Mo,
                                                    ar,
                                                    bo,
                                                ),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 1,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'buildingIdentify',
                                                vaoCreator: ii,
                                                webglState: Qi,
                                                programBinder: Vn,
                                                objectBinder: Cr(cr, Ho, Zo, Go, ar),
                                                tileBinder: jr,
                                            },
                                            {
                                                depthTest: !0,
                                                programName: 'buildingIdentify',
                                                vaoCreator: ni,
                                                webglState: Qi,
                                                programBinder: Vn,
                                                objectBinder: Cr(cr, Ho, Zo, Go, ar),
                                                tileBinder: jr,
                                            },
                                        ],
                                        topFill: [
                                            {
                                                programName: 'diffuse',
                                                vaoCreator: ti,
                                                webglState: cn,
                                                layerBinder: zt(Et, wt),
                                                programBinder: Hn,
                                                objectBinder: Cr(cr, Ho, Zo, mo, yo, Mo, ar, bo),
                                                tileBinder: Dr(Br, jr),
                                            },
                                            {
                                                programName: 'diffuse',
                                                vaoCreator: ti,
                                                webglState: dn,
                                                layerBinder: zt(Et, wt),
                                                programBinder: Hn,
                                                objectBinder: Cr(cr, Ho, Zo, mo, yo, Mo, ar, bo),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 1,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'buildingIdentify',
                                                vaoCreator: ii,
                                                webglState: Qi,
                                                programBinder: Vn,
                                                objectBinder: Cr(cr, Ho, Zo, Go, ar),
                                                tileBinder: jr,
                                            },
                                            {
                                                depthTest: !0,
                                                programName: 'buildingIdentify',
                                                vaoCreator: ni,
                                                webglState: Qi,
                                                programBinder: Vn,
                                                objectBinder: Cr(cr, Ho, Zo, Go, ar),
                                                tileBinder: jr,
                                            },
                                        ],
                                        sideStroke: [
                                            {
                                                programName: 'line',
                                                vaoCreator: ri,
                                                webglState: nn,
                                                programBinder: Wn,
                                                layerBinder: zt(Et, wt),
                                                objectBinder: Cr(
                                                    cr,
                                                    Ho,
                                                    Zo,
                                                    fo,
                                                    po,
                                                    Io,
                                                    yo,
                                                    Mo,
                                                    ar,
                                                    bo,
                                                ),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 3,
                                            },
                                        ],
                                        topStroke: [
                                            {
                                                programName: 'simpleLine',
                                                vaoCreator: ui,
                                                webglState: nn,
                                                programBinder: to,
                                                layerBinder: zt(mt, gt, Tt, Et),
                                                objectBinder: Cr(
                                                    cr,
                                                    Ho,
                                                    Zo,
                                                    _o,
                                                    So,
                                                    yo,
                                                    Mo,
                                                    ko,
                                                    ar,
                                                ),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 4,
                                            },
                                        ],
                                    },
                                    labelLine: {
                                        raster: [
                                            {
                                                programName: 'labelLine',
                                                vaoCreator: Qt,
                                                webglState: un,
                                                programBinder: qn,
                                                objectBinder: Cr(hr, _r, jo, Wo, pr, vr, xr),
                                                tileBinder: jr,
                                                zoomBinder: Sr,
                                                uniformSet: 'fontHalo',
                                            },
                                            {
                                                programName: 'labelLine',
                                                vaoCreator: Qt,
                                                webglState: mn,
                                                programBinder: qn,
                                                objectBinder: Cr(hr, _r, jo, Wo, pr, vr, xr),
                                                tileBinder: jr,
                                                zoomBinder: Sr,
                                                uniformSet: 'fontHalo',
                                                isOverlappedObject: !0,
                                            },
                                            {
                                                programName: 'labelLine',
                                                vaoCreator: Qt,
                                                webglState: un,
                                                programBinder: qn,
                                                objectBinder: Cr(hr, jo, Wo, pr, vr, xr),
                                                zoomBinder: Sr,
                                                tileBinder: jr,
                                                uniformSet: 'fontFill',
                                                subRenderIndex: 1,
                                            },
                                            {
                                                programName: 'labelLine',
                                                vaoCreator: Qt,
                                                webglState: mn,
                                                programBinder: qn,
                                                objectBinder: Cr(hr, jo, Wo, pr, vr, xr),
                                                zoomBinder: Sr,
                                                tileBinder: jr,
                                                uniformSet: 'fontFill',
                                                subRenderIndex: 1,
                                                isOverlappedObject: !0,
                                            },
                                        ],
                                    },
                                    dashedLine: {
                                        stroke: [
                                            {
                                                programName: 'stripedLine',
                                                vaoCreator: Yt,
                                                webglState: rn,
                                                layerBinder: Et,
                                                programBinder: Xn,
                                                objectBinder: Cr(cr, Yo, ur, Xo, bo),
                                                tileBinder: Dr(Br, jr),
                                            },
                                            {
                                                identify: !0,
                                                programName: 'stripedLineIdentify',
                                                vaoCreator: Yt,
                                                webglState: ln,
                                                programBinder: Xn,
                                                objectBinder: Cr(cr, Yo, ur, bo, Xo),
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    oneWayLine: {
                                        raster: [
                                            {
                                                programName: 'oneWayLine',
                                                vaoCreator: ci,
                                                webglState: un,
                                                programBinder: $n,
                                                objectBinder: Cr(hr, jo, uo, Mo, Ko, Jo),
                                                tileBinder: jr,
                                            },
                                            {
                                                programName: 'oneWayLine',
                                                vaoCreator: ci,
                                                webglState: mn,
                                                programBinder: $n,
                                                objectBinder: Cr(hr, jo, uo, Mo, Ko, Jo),
                                                tileBinder: jr,
                                                isOverlappedObject: !0,
                                            },
                                        ],
                                    },
                                    point: {
                                        raster: [
                                            {
                                                programName: 'pointSprite',
                                                vaoCreator: si,
                                                webglState: hn,
                                                programBinder: Yn,
                                                layerBinder: At,
                                                objectBinder: Cr(hr, Co, Ro, Vo, Bo, Lr),
                                                tileBinder: jr,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'pointSpriteIdentify',
                                                vaoCreator: ai,
                                                webglState: an,
                                                programBinder: Kn,
                                                layerBinder: At,
                                                objectBinder: Cr(hr, Co, Do, Vo, Bo, Lr),
                                                tileBinder: jr,
                                            },
                                        ],
                                        text: [
                                            {
                                                programName: 'labelPoint',
                                                vaoCreator: Kt,
                                                webglState: hn,
                                                programBinder: Jn,
                                                objectBinder: Cr(hr, _r, jo, Wo, pr, gr, wr, Lr),
                                                tileBinder: jr,
                                                uniformSet: 'fontHalo',
                                                subRenderIndex: 1,
                                            },
                                            {
                                                programName: 'labelPoint',
                                                vaoCreator: Kt,
                                                webglState: hn,
                                                programBinder: Jn,
                                                objectBinder: Cr(hr, jo, Wo, pr, gr, wr, Lr),
                                                tileBinder: jr,
                                                uniformSet: 'fontFill',
                                                subRenderIndex: 2,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'labelPointIdentify',
                                                vaoCreator: Jt,
                                                webglState: an,
                                                programBinder: Dn(mt, Rn),
                                                objectBinder: Cr(hr, Oo, pr, wr),
                                                tileBinder: jr,
                                                subRenderIndex: 1,
                                            },
                                        ],
                                        labelingTexture: [
                                            {
                                                depthTest: !0,
                                                programName: 'pointDepthTest',
                                                vaoCreator: li,
                                                webglState: ln,
                                                programBinder: Dn(mt, Rn),
                                                objectBinder: Cr(hr, wr),
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    buildingModel: {
                                        fill: [
                                            {
                                                programName: 'zbmModel',
                                                vaoCreator: di,
                                                webglState: fn,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(cr, co, go, Mo, rr, er),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 2,
                                            },
                                            {
                                                programName: 'zbmModelIdentify',
                                                vaoCreator: ii,
                                                webglState: Qi,
                                                programBinder: mt,
                                                objectBinder: Cr(cr),
                                                tileBinder: jr,
                                                subRenderIndex: 2,
                                                identify: !0,
                                            },
                                            {
                                                programName: 'zbmModelIdentify',
                                                vaoCreator: ni,
                                                webglState: Qi,
                                                programBinder: mt,
                                                objectBinder: Cr(cr),
                                                tileBinder: jr,
                                                depthTest: !0,
                                            },
                                        ],
                                        stroke: [
                                            {
                                                programName: 'simpleLine',
                                                vaoCreator: ui,
                                                webglState: nn,
                                                programBinder: to,
                                                layerBinder: zt(mt, yt, Mt, Et),
                                                objectBinder: Cr(cr, _o, go, Mo, ko, rr),
                                                tileBinder: Dr(jr, Br),
                                                subRenderIndex: 5,
                                            },
                                        ],
                                    },
                                    shiftedLine: {
                                        solid: [
                                            {
                                                programName: 'road',
                                                layerBinder: Et,
                                                vaoCreator: $t,
                                                webglState: rn,
                                                objectBinder: Cr(cr, co, Mo, Po, Fo),
                                                tileBinder: Dr(Br, jr),
                                                zoomBinder: Sr,
                                            },
                                        ],
                                    },
                                    circle: {
                                        fill: [
                                            {
                                                programName: 'circleMarker',
                                                vaoCreator: fi,
                                                webglState: rn,
                                                programBinder: Qn,
                                                objectBinder: Cr(cr, co, Mo, Po),
                                                tileBinder: jr,
                                                subRenderIndex: 2,
                                            },
                                            {
                                                programName: 'circleMarker',
                                                vaoCreator: fi,
                                                webglState: rn,
                                                programBinder: Qn,
                                                objectBinder: Cr(cr, _o, Mo, Eo),
                                                tileBinder: jr,
                                                subRenderIndex: 1,
                                            },
                                            {
                                                programName: 'circleMarker',
                                                vaoCreator: fi,
                                                webglState: rn,
                                                programBinder: Qn,
                                                objectBinder: Cr(cr, vo, Mo, Ao),
                                                tileBinder: jr,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'circleMarkerIdentify',
                                                vaoCreator: pi,
                                                webglState: an,
                                                programBinder: Qn,
                                                objectBinder: Cr(cr, zo),
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    arrow: {
                                        stroke: [
                                            {
                                                programName: 'entrance',
                                                vaoCreator: mi,
                                                webglState: rn,
                                                programBinder: eo,
                                                objectBinder: Cr(cr, co, Mo, Ko, Qo, bo),
                                                tileBinder: jr,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'entranceIdentify',
                                                vaoCreator: mi,
                                                webglState: an,
                                                programBinder: eo,
                                                objectBinder: Cr(cr, Ko, Qo, bo),
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    lineExtrusion: {
                                        fill: [
                                            {
                                                programName: 'gradientDiffuse',
                                                vaoCreator: oi,
                                                webglState: on,
                                                layerBinder: zt(St, Et),
                                                programBinder: Hn,
                                                objectBinder: Cr(cr, sr, fo, po, Mo, bo),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 9,
                                            },
                                        ],
                                        sideStroke: [
                                            {
                                                programName: 'line',
                                                vaoCreator: ri,
                                                webglState: nn,
                                                programBinder: Wn,
                                                layerBinder: zt(Et, St),
                                                objectBinder: Cr(cr, sr, fo, po, Io, Mo, bo),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 10,
                                            },
                                        ],
                                        topStroke: [
                                            {
                                                programName: 'simpleLine',
                                                vaoCreator: ui,
                                                webglState: nn,
                                                programBinder: to,
                                                layerBinder: zt(mt, gt, Mt, Et),
                                                objectBinder: Cr(cr, sr, _o, Mo, ko),
                                                tileBinder: Dr(Br, jr),
                                                subRenderIndex: 11,
                                            },
                                        ],
                                    },
                                    gltfModel: {
                                        anchor: [
                                            {
                                                programName: 'gltfModel',
                                                vaoCreator: Si,
                                                webglState: fn,
                                                programBinder: Rn,
                                                objectBinder: Cr(cr, co, Mo),
                                                tileBinder: Rr,
                                            },
                                        ],
                                        instances: [
                                            {
                                                programName: 'gltfModel',
                                                vaoCreator: Ii,
                                                webglState: fn,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(cr, co, or, Mo, ir),
                                                tileBinder: Br,
                                            },
                                            {
                                                identify: !0,
                                                programName: 'gltfModel',
                                                vaoCreator: Ii,
                                                webglState: Qi,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(cr),
                                                tileBinder: Br,
                                            },
                                            {
                                                depthTest: !0,
                                                programName: 'gltfModel',
                                                vaoCreator: Mi,
                                                webglState: Qi,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(cr),
                                                tileBinder: Br,
                                            },
                                        ],
                                        fill: [
                                            {
                                                programName: 'gltfModel',
                                                vaoCreator: Ht,
                                                layerBinder: Et,
                                                webglState: fn,
                                                programBinder: Rn,
                                                objectBinder: Cr(nr),
                                                tileBinder: Dr(Hr, Gr),
                                            },
                                            {
                                                identify: !0,
                                                programName: 'gltfModelIdentify',
                                                vaoCreator: Ht,
                                                webglState: Qi,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(),
                                                tileBinder: Hr,
                                            },
                                            {
                                                depthTest: !0,
                                                programName: 'gltfModelIdentify',
                                                vaoCreator: Ht,
                                                webglState: Qi,
                                                layerBinder: Et,
                                                programBinder: Rn,
                                                objectBinder: Cr(),
                                                tileBinder: Hr,
                                            },
                                        ],
                                    },
                                    raster: {
                                        fill: [
                                            {
                                                programName: 'rectWithTexture',
                                                vaoCreator: _i,
                                                webglState: rn,
                                                objectBinder: Cr(cr, qo, No),
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    heatmap: {
                                        framebuffer: [
                                            {
                                                programName: 'heatmap',
                                                vaoCreator: vi,
                                                webglState: pn,
                                                objectBinder: Cr(cr, mr, fr),
                                                zoomBinder: Sr,
                                                tileBinder: jr,
                                            },
                                        ],
                                        fill: [
                                            {
                                                programName: 'heatmapTexture',
                                                vaoCreator: gi,
                                                webglState: rn,
                                                objectBinder: Cr(cr, qo, $o, Uo),
                                                tileBinder: Rr,
                                                subRenderIndex: 1,
                                            },
                                        ],
                                    },
                                    dem: {
                                        mesh: [
                                            {
                                                programName: 'demMesh',
                                                vaoCreator: yi,
                                                programBinder: Rn,
                                                layerBinder: Et,
                                                webglState: Qi,
                                                objectBinder: Cr(Ir, Tr),
                                                tileBinder: Dr(jr, Br),
                                            },
                                            {
                                                identify: !0,
                                                programName: 'demMesh',
                                                vaoCreator: yi,
                                                programBinder: Dn(Rn, Un),
                                                webglState: Qi,
                                                objectBinder: Cr(Mr),
                                                tileBinder: jr,
                                            },
                                        ],
                                        ground: [
                                            {
                                                programName: 'demGround',
                                                vaoCreator: yi,
                                                programBinder: Rn,
                                                tileBinder: Dr(jr, Br),
                                                webglState: Qi,
                                                objectBinder: lo,
                                            },
                                        ],
                                        elevation: [
                                            {
                                                programName: 'demElevation',
                                                vaoCreator: bi,
                                                webglState: sn,
                                                objectBinder: Cr(qo),
                                                tileBinder: jr,
                                            },
                                        ],
                                        hillshade: [
                                            {
                                                programName: 'demHillshade',
                                                vaoCreator: xi,
                                                webglState: sn,
                                                programBinder: Rn,
                                                objectBinder: Cr(),
                                                tileBinder: jr,
                                            },
                                        ],
                                        flatBottom: [
                                            {
                                                programName: 'demFlatBottom',
                                                vaoCreator: wi,
                                                webglState: sn,
                                                objectBinder: Pr,
                                                tileBinder: jr,
                                            },
                                        ],
                                    },
                                    mapMesh: {
                                        fill: [
                                            {
                                                programName: 'mapMesh',
                                                vaoCreator: Ti,
                                                webglState: en,
                                                layerBinder: xt,
                                                zoomBinder: Cr(Ar),
                                                programBinder: Gn,
                                                objectBinder: Cr(zr, kr, Er, Lo),
                                                tileBinder: jr,
                                                subRenderIndex: 0,
                                            },
                                        ],
                                    },
                                }),
                                this.addExtension('OES_vertex_array_object')
                                    .addExtension('OES_element_index_uint')
                                    .addExtension('OES_standard_derivatives')
                                    .addExtension('OES_texture_float')
                                    .addExtension('OES_texture_float_linear')
                                    .addExtension('ANGLE_instanced_arrays')
                                    .addExtension('WEBGL_depth_texture'),
                                this.setPixelRatio(window.devicePixelRatio).setSize(
                                    t.layout.mapContainer.clientWidth,
                                    t.layout.mapContainer.clientHeight,
                                ),
                                e.collectStats && (this.timers = new Vr(this._gl)),
                                t.layout.canvas.addEventListener(
                                    'webglcontextlost',
                                    this.trackContextLost,
                                );
                        }
                        setClearColor(e) {
                            return (
                                (this.clearColor = (0, $.m2)(e)),
                                (this.state.needRerender = !0),
                                this
                            );
                        }
                        setSize(e, t) {
                            return (
                                this.modules.layout.setCanvasSize(e, t),
                                this.framebuffers.forEach((e) => {
                                    e && e.onResize();
                                }),
                                this.updateIdentifySize(),
                                this.updateLabelingTextureBufferSize(),
                                this
                            );
                        }
                        updateIdentifySize() {
                            const e = window.devicePixelRatio,
                                { size: t } = this.state;
                            return (
                                this.identifyBuffer.setSize([
                                    Math.ceil(t[0] * I.identify.pixelDensity * e),
                                    Math.ceil(t[1] * I.identify.pixelDensity * e),
                                ]),
                                this
                            );
                        }
                        updateLabelingTextureBufferSize() {
                            const e = window.devicePixelRatio,
                                { size: t } = this.state;
                            return (
                                this.labelingTextureBuffer.setSize([
                                    Math.ceil(t[0] * e),
                                    Math.ceil(t[1] * e),
                                ]),
                                this
                            );
                        }
                        clear(e = !0) {
                            return this.clearWithColor(this.clearColor, e), this;
                        }
                        clearWithColor(e, t = !0) {
                            const i = this._gl,
                                n =
                                    !0 === t
                                        ? i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT
                                        : i.COLOR_BUFFER_BIT;
                            i.depthMask(t),
                                i.clearDepth(1),
                                i.clearColor(e[0], e[1], e[2], e[3]),
                                i.clear(n);
                        }
                        renderTileObjects(e) {
                            this.state.collectStats && this.timers && this.timers.addTimer();
                            const t = this.groupObjectsByFramebuffer(e, !1),
                                i = Fs(this.state, this.modules, t.levels);
                            if (
                                (this.lastRenderedFramebuffers.forEach((e) => {
                                    t.groups.some((t) => t.framebuffer === e) ||
                                        this.clearFramebuffer(e);
                                }),
                                (this.lastRenderedFramebuffers = []),
                                t.groups.forEach(
                                    ({ objects: e, tileObjects: n, framebuffer: o }) => {
                                        var r, s, a, l;
                                        const c =
                                            this.modules.map.state.demMode &&
                                            (void 0 === o || !0 === o.useDem);
                                        if (o)
                                            null === (r = o.onRenderStart) ||
                                                void 0 === r ||
                                                r.call(o),
                                                this.lastRenderedFramebuffers.push(o),
                                                o.renderTarget.bind(this._gl),
                                                this._gl.viewport(
                                                    0,
                                                    0,
                                                    o.renderTarget.options.size[0],
                                                    o.renderTarget.options.size[1],
                                                ),
                                                o.clearColor &&
                                                    this.clearWithColor(
                                                        o.clearColor,
                                                        !!o.clearDepth,
                                                    );
                                        else {
                                            const { size: e, viewport: n } = this.state,
                                                o = window.devicePixelRatio;
                                            this._gl.viewport(
                                                n.left * o,
                                                n.bottom * o,
                                                e[0] * o,
                                                e[1] * o,
                                            ),
                                                this.clear(!0),
                                                this.modules.environmentManager.renderSky(this._gl),
                                                c &&
                                                    t.flatObjectsGroup &&
                                                    this.renderDemMesh(i, t.flatObjectsGroup);
                                        }
                                        const d =
                                                null !==
                                                    (a =
                                                        null ===
                                                            (s =
                                                                null == o
                                                                    ? void 0
                                                                    : o.getViewProjectionMatrix) ||
                                                        void 0 === s
                                                            ? void 0
                                                            : s.call(o)) && void 0 !== a
                                                    ? a
                                                    : this.modules.camera.viewProjectionMatrix,
                                            h = c
                                                ? this.modules.demManager.demTextureMatrix
                                                : void 0;
                                        n.forEach((e) => {
                                            e.updateMvpMatrix(d, h);
                                        }),
                                            us(this.state, this.modules, e, i),
                                            null == o || o.renderTarget.unbind(this._gl),
                                            null === (l = null == o ? void 0 : o.onRenderEnd) ||
                                                void 0 === l ||
                                                l.call(o);
                                    },
                                ),
                                this.state.collectStats && this.timers)
                            ) {
                                this.timers.stopTimer();
                                const e = this.timers.tryToGetFirstTimerValue();
                                e && this.modules.map.emit('gpuRenderTime', e);
                            }
                            return this;
                        }
                        renderLabelingTexture(e) {
                            if (
                                ((this.state.labelingDepthTestDisabled = !0),
                                this.state.styleZoom < 15)
                            )
                                return;
                            const t = this._gl,
                                i = [],
                                n = Fs(this.state, this.modules),
                                o = e.filter((e) => e.depthTestChildren[0]);
                            o.forEach((e) => {
                                e.updateMvpMatrix(this.modules.camera.viewProjectionMatrix, void 0);
                            }),
                                o.forEach((e) => {
                                    i.push(...e.depthTestChildren);
                                }),
                                (this.state.labelingDepthTestDisabled = !1),
                                this.labelingTextureBuffer.bind(t),
                                this.clearWithColor([1, 1, 1, 1]),
                                t.viewport(
                                    0,
                                    0,
                                    this.labelingTextureBuffer.options.size[0],
                                    this.labelingTextureBuffer.options.size[1],
                                ),
                                us(this.state, this.modules, i, n),
                                this.labelingTextureBuffer.unbind(t);
                        }
                        renderIdentify(e) {
                            const t = this._gl,
                                i = this.groupObjectsByFramebuffer(e, !0),
                                n = Fs(this.state, this.modules, i.levels);
                            i.groups.forEach(({ objects: e, tileObjects: o, framebuffer: r }) => {
                                var s, a, l;
                                const c = void 0 === r && this.modules.map.state.demMode,
                                    d = r ? r.renderTarget : this.identifyBuffer;
                                d.bind(t),
                                    this.clearIdentify(),
                                    c &&
                                        i.flatObjectsGroup &&
                                        this.renderDemMesh(n, i.flatObjectsGroup, !0),
                                    d.bind(t),
                                    t.viewport(0, 0, d.options.size[0], d.options.size[1]);
                                const h =
                                        null !==
                                            (a =
                                                null ===
                                                    (s =
                                                        null == r
                                                            ? void 0
                                                            : r.getViewProjectionMatrix) ||
                                                void 0 === s
                                                    ? void 0
                                                    : s.call(r)) && void 0 !== a
                                            ? a
                                            : this.modules.camera.viewProjectionMatrix,
                                    u = c ? this.modules.demManager.demTextureMatrix : void 0;
                                o.forEach((e) => {
                                    e.updateMvpMatrix(h, u);
                                }),
                                    us(this.state, this.modules, e, n),
                                    d.unbind(t),
                                    null == r || r.renderTarget.unbind(this._gl),
                                    null === (l = null == r ? void 0 : r.onRenderEnd) ||
                                        void 0 === l ||
                                        l.call(r);
                            }),
                                (this.state.needRerender = !0);
                        }
                        readIdentifyPixels() {
                            const e = this._gl,
                                t = this.identifyBuffer.options.size,
                                i = new Uint8Array(t[0] * t[1] * 4);
                            return (
                                this.identifyBuffer.bind(e),
                                e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, i),
                                this.identifyBuffer.unbind(e),
                                i
                            );
                        }
                        getRenderingContext() {
                            return this._gl;
                        }
                        getShaderProgram(e) {
                            return this.shaderPrograms[e];
                        }
                        destroy() {
                            (this.lastRenderedFramebuffers = []),
                                this.framebuffers.forEach((e) => {
                                    null == e || e.renderTarget.remove();
                                }),
                                this.modules.layout.canvas.removeEventListener(
                                    'webglcontextlost',
                                    this.trackContextLost,
                                );
                            const e = this._gl.getExtension('WEBGL_lose_context');
                            e && e.loseContext(),
                                this.modules.layout.destroy(),
                                (this.mapMeshFramebufferId = void 0);
                        }
                        addFramebuffer(e) {
                            return this.framebuffers.push(e), this.framebuffers.length - 1;
                        }
                        getFramebuffer(e) {
                            if (e !== Ni.z) return this.framebuffers[e];
                        }
                        removeFramebuffer(e) {
                            var t;
                            null === (t = this.framebuffers[e]) ||
                                void 0 === t ||
                                t.renderTarget.remove(),
                                (this.framebuffers[e] = void 0);
                        }
                        renderDemMesh(e, t, i = !1) {
                            const { framebuffer: n, tiles: o } = t;
                            if (!n) return;
                            let r = this.modules.demManager.getFlatMapTextures();
                            if ((i && (r = r.filter((e) => 0 === e.detailLevel)), !r.length))
                                return;
                            const s = this.modules.demManager.getMeshTiles();
                            if (!s.length) return;
                            const a = s[0],
                                l = (i ? a.identifyChildren : a.children)[0],
                                c = this.state.handyStyleId,
                                d = this.modules.styleManager.getStyleLayer(c, Pi.he);
                            if (!d) return;
                            const { size: h, viewport: u } = this.state,
                                m = window.devicePixelRatio,
                                {
                                    programBinder: f,
                                    layerBinder: p,
                                    programName: _,
                                } = l.layerSettings,
                                v = this.modules.renderer.getShaderProgram(_),
                                g = [];
                            o.forEach((e, t) => {
                                g.push({ objects: e, tile: t });
                            }),
                                r.forEach((t) => {
                                    var o, r;
                                    const a = g
                                        .filter((e) => (0, Oi.M4)(t.viewport, e.tile.bounds))
                                        .reduce((e, i) => {
                                            i.tile.updateMvpMatrix(
                                                t.mvpMatrix,
                                                this.modules.demManager.demTextureMatrix,
                                            );
                                            const n =
                                                0 === t.detailLevel
                                                    ? i.objects
                                                    : i.objects.filter((e) => {
                                                          if (e.type === ot.H.Custom) return !1;
                                                          const t =
                                                              this.modules.styleManager.getStyleLayer(
                                                                  e.attributes.styleId,
                                                                  e.attributes.layerId,
                                                              );
                                                          return !(!t || !0 === t.farLimit);
                                                      });
                                            return e.concat(n);
                                        }, []);
                                    if (
                                        (null === (o = n.onRenderStart) ||
                                            void 0 === o ||
                                            o.call(n),
                                        n.renderTarget.bind(this._gl),
                                        this._gl.viewport(
                                            0,
                                            0,
                                            n.renderTarget.options.size[0],
                                            n.renderTarget.options.size[1],
                                        ),
                                        n.clearColor && this.clearWithColor(n.clearColor, !1),
                                        us(this.state, this.modules, a, e, !0),
                                        n.renderTarget.unbind(this._gl),
                                        null === (r = n.onRenderEnd) || void 0 === r || r.call(n),
                                        i)
                                    ) {
                                        this.identifyBuffer.bind(this._gl);
                                        const e = this.identifyBuffer.options.size;
                                        this._gl.viewport(0, 0, e[0], e[1]);
                                    } else
                                        this._gl.viewport(
                                            u.left * m,
                                            u.bottom * m,
                                            h[0] * m,
                                            h[1] * m,
                                        );
                                    v.enable(this._gl),
                                        null == f || f(this._gl, v, this.state, this.modules, e),
                                        null == p || p(this._gl, v, this.state, this.modules),
                                        e.useState([l], d),
                                        s.forEach((n) => {
                                            if ((0, Oi.M4)(t.viewport, n.bounds)) {
                                                $e.Jp(js, t.texMatrix, n.modelMatrix),
                                                    v.bind(this._gl, { u_mat4_flat_map_mvp: js }),
                                                    n.updateMvpMatrix(
                                                        this.modules.camera.viewProjectionMatrix,
                                                        this.modules.demManager.demTextureMatrix,
                                                    );
                                                const o = i ? n.identifyChildren : n.children;
                                                e.drawSymbol(o, d, this.state, this.modules);
                                            }
                                        }),
                                        i && this.identifyBuffer.unbind(this._gl);
                                });
                        }
                        getMapMeshFramebufferId() {
                            return (
                                void 0 === this.mapMeshFramebufferId &&
                                    (this.mapMeshFramebufferId = this.createMapMeshFramebuffer()),
                                this.mapMeshFramebufferId
                            );
                        }
                        clearIdentify() {
                            const e = this._gl;
                            e.depthMask(!0),
                                e.clearColor(1, 1, 1, 1),
                                e.clear(
                                    e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT,
                                ),
                                e.clearDepth(1),
                                e.clearStencil(0);
                        }
                        clearFramebuffer(e) {
                            e.clearColor &&
                                (e.renderTarget.bind(this._gl),
                                this._gl.viewport(
                                    0,
                                    0,
                                    e.renderTarget.options.size[0],
                                    e.renderTarget.options.size[1],
                                ),
                                this.clearWithColor(e.clearColor, !1),
                                e.renderTarget.unbind(this._gl));
                        }
                        groupObjectsByFramebuffer(e, t) {
                            const i = this.modules.demManager,
                                n = {},
                                o = { framebuffer: void 0, objects: [], tileObjects: new Set() },
                                r = {},
                                s = t ? i.getIdentifyFlatFramebufferId() : i.getFlatFramebufferId();
                            let a;
                            if (this.modules.map.state.demMode) {
                                const e = this.getFramebuffer(s);
                                e && (a = { framebuffer: e, tiles: new Map() });
                            }
                            t ||
                                o.objects.push(
                                    ...this.modules.styleManager.getCustomSceneObjects(),
                                ),
                                e.forEach((e) => {
                                    (t ? e.identifyChildren : e.children).forEach((t) => {
                                        var i;
                                        const s = this.modules.styleManager.getFramebufferId(
                                                t.attributes.styleId,
                                                t.attributes.layerId,
                                            ),
                                            l = s ? s[t.sink] : void 0;
                                        if (l !== Ni.z) {
                                            if (void 0 === l) {
                                                const n = t.attributes.drawLevel;
                                                return this.state.immersiveLevel.drawLevels && n
                                                    ? (r[n] ||
                                                          (r[n] = {
                                                              objects: [],
                                                              tileObjects: new Set(),
                                                          }),
                                                      r[n].objects.push(t),
                                                      void r[n].tileObjects.add(e))
                                                    : void (!this.modules.map.state.demMode ||
                                                      ((c = t.symbol),
                                                      (d = t.sink),
                                                      ('dem' === c && 'mesh' === d) ||
                                                          'mapMesh' === c ||
                                                          'point' === c ||
                                                          'polygonExtrusion' === c ||
                                                          'lineExtrusion' === c ||
                                                          'buildingModel' === c ||
                                                          'gltfModel' === c)
                                                          ? (o.objects.push(t),
                                                            o.tileObjects.add(e))
                                                          : (null == a ? void 0 : a.tiles.has(e))
                                                          ? null ===
                                                                (i =
                                                                    null == a
                                                                        ? void 0
                                                                        : a.tiles.get(e)) ||
                                                            void 0 === i ||
                                                            i.push(t)
                                                          : null == a || a.tiles.set(e, [t]));
                                            }
                                            var c, d;
                                            n[l] ||
                                                (n[l] = {
                                                    framebuffer: this.getFramebuffer(l),
                                                    objects: [],
                                                    tileObjects: new Set(),
                                                }),
                                                n[l].objects.push(t),
                                                n[l].tileObjects.add(e);
                                        }
                                    });
                                });
                            const l = Object.values(n).filter((e) => !!e.framebuffer);
                            return (
                                l.sort((e, t) => {
                                    var i, n, o, r;
                                    return (
                                        (null !==
                                            (n =
                                                null === (i = e.framebuffer) || void 0 === i
                                                    ? void 0
                                                    : i.renderIndex) && void 0 !== n
                                            ? n
                                            : 0) -
                                        (null !==
                                            (r =
                                                null === (o = t.framebuffer) || void 0 === o
                                                    ? void 0
                                                    : o.renderIndex) && void 0 !== r
                                            ? r
                                            : 0)
                                    );
                                }),
                                l.push(o),
                                { flatObjectsGroup: a, groups: l, levels: r }
                            );
                        }
                        createMapMeshFramebuffer() {
                            const e = this.modules.renderer.getRenderingContext(),
                                t = window.devicePixelRatio,
                                i = this.modules.map.state.size,
                                n = new nt({
                                    size: [Math.trunc(i[0] * t), Math.trunc(i[1] * t * Bs)],
                                    magFilter: it.LinearFilter,
                                    minFilter: it.LinearFilter,
                                    wrapS: it.ClampToEdgeWrapping,
                                    wrapT: it.ClampToEdgeWrapping,
                                });
                            return this.modules.renderer.addFramebuffer({
                                getViewProjectionMatrix: () => (
                                    $e.wA(Zs, [0, 1 / Bs, 0], [1, 1 / Bs, 1]),
                                    $e.Jp(
                                        this.mapMeshMvpMatrix,
                                        Zs,
                                        this.modules.camera.viewProjectionMatrix,
                                    ),
                                    this.mapMeshMvpMatrix
                                ),
                                onResize: () => {
                                    const t = window.devicePixelRatio,
                                        i = this.modules.map.state.size;
                                    n.setSize([Math.trunc(i[0] * t), Math.trunc(i[1] * t * Bs)]),
                                        n.bind(e),
                                        n.unbind(e);
                                },
                                renderTarget: n,
                            });
                        }
                        prepareExternalShaderDefinitions(e) {
                            const t = [];
                            return e.enableFog && t.push({ type: 'FOG', value: '' }), t;
                        }
                    }
                    Hs.webglVersion = NaN;
                    var Gs = i(1375);
                    class Vs {
                        constructor(e, t) {
                            (this.isIdle = () => 0 === this.searchQueue.size),
                                (this.state = e),
                                (this.modules = t),
                                (this.identifyData = []),
                                (this.needsUpdate = !1),
                                (this.forceUpdate = !1),
                                (this.searchQueue = new Map()),
                                (this.stateDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                ])),
                                (this.debouncedFillCache = (0, He.D)(() => {
                                    this.needsUpdate = !0;
                                }, I.identify.cacheDebounceTime));
                        }
                        resetCache() {
                            (this.colorBuffer = void 0), this.debouncedFillCache();
                        }
                        search(e, t, i = !1) {
                            return (
                                void 0 === this.colorBuffer && i && (this.needsUpdate = !0),
                                (this.forceUpdate = i),
                                new Promise((i) => {
                                    this.searchQueue.set(e, { point: t, resolve: i });
                                })
                            );
                        }
                        searchSync(e) {
                            return this.searchHigherPriority(e);
                        }
                        update() {
                            this.stateDiffer.check(this.state) &&
                                (this.resetCache(),
                                this.searchQueue.size > 0 && this.searchQueue.clear()),
                                this.needsUpdate &&
                                    (this.forceUpdate ||
                                        (this.modules.tileManager.isIdle() &&
                                            this.modules.labeler.isIdle() &&
                                            this.modules.layers.entranceAnimationFinished() &&
                                            this.modules.modelLayer.isIdle() &&
                                            !this.modules.buildingHeightAnimator.isAnimating() &&
                                            this.modules.assetManager.isIdle())) &&
                                    (this.fillCache(),
                                    (this.needsUpdate = !1),
                                    (this.forceUpdate = !1)),
                                void 0 !== this.colorBuffer &&
                                    this.searchQueue.size > 0 &&
                                    (this.searchQueue.forEach((e) => {
                                        e.resolve(this.searchHigherPriority(e.point));
                                    }),
                                    this.searchQueue.clear());
                        }
                        searchHigherPriority(e) {
                            const { viewport: t } = this.state,
                                i = z.al(e[0] - t.left, e[1] - t.top),
                                n = this.state.identifyPickDistance * window.devicePixelRatio;
                            let o,
                                r = 1 / 0,
                                s = !1;
                            const a = z.Ue();
                            for (a[0] = i[0] - n; a[0] < i[0] + n; a[0]++)
                                for (a[1] = i[1] - n; a[1] < i[1] + n; a[1]++) {
                                    const e = this.searchPointInCache(a);
                                    if (!e) continue;
                                    const t = void 0 !== e.dynamicObjectId;
                                    if (s && !t) continue;
                                    const n = z.TE(i, a);
                                    (!o ||
                                        (!s && t) ||
                                        e.phase > o.phase ||
                                        (e.phase === o.phase && n < r)) &&
                                        ((o = e), (r = n), t && (s = !0));
                                }
                            return o;
                        }
                        searchPointInCache(e) {
                            if (void 0 === this.colorBuffer) return;
                            const t = I.identify.pixelDensity * window.devicePixelRatio,
                                i = this.modules.renderer.identifyBuffer.options.size,
                                n = this.state.size;
                            if (e[0] < 0 || e[0] > n[0] - 1 || e[1] < 0 || e[1] > n[1] - 1) return;
                            const o = Math.floor(e[0] * t),
                                r = 4 * ((i[1] - 1 - Math.floor(e[1] * t)) * i[0] + o),
                                s =
                                    ((this.colorBuffer[r + 3] << 24) |
                                        (this.colorBuffer[r + 2] << 16) |
                                        (this.colorBuffer[r + 1] << 8) |
                                        this.colorBuffer[r]) >>>
                                    0;
                            return this.indexToIdentifierResponse(s);
                        }
                        fillCache() {
                            const e = this.modules.tileManager.getTileObjects();
                            this.modules.renderer.renderIdentify(e),
                                (this.colorBuffer = this.modules.renderer.readIdentifyPixels());
                            const t = this.state.metrics;
                            Number.isNaN(t.interactive) &&
                                (t.interactive = performance.now() - t.start),
                                (this.identifyData =
                                    this.modules.tileManager.getDisplayedIdentifyData()),
                                this.modules.modelLayer
                                    .getDisplayedIdentifyData()
                                    .forEach((e) => this.identifyData.push(e)),
                                this.modules.floorManager
                                    .getDisplayedIdentifyData()
                                    .forEach((e) => this.identifyData.push(e));
                            const i = this.modules.personalPoiManager.getIdentifyDataChunk();
                            void 0 !== i && this.identifyData.push(i),
                                this.modules.layers.getDynamicObjectLayers().forEach((e) => {
                                    e.getIdentifyData().forEach((e) => this.identifyData.push(e));
                                });
                        }
                        indexToIdentifierResponse(e) {
                            var t, i, n;
                            for (let o = 0; o < this.identifyData.length; o++) {
                                const r = this.identifyData[o],
                                    {
                                        dynamicObjectId: s,
                                        ids: a,
                                        metatileHash: l,
                                        sourceId: c,
                                        tileKey: d,
                                    } = r,
                                    {
                                        startIndex: h,
                                        endIndex: u,
                                        idBuffer: m,
                                        floorIdBuffer: f,
                                        phaseBuffer: p,
                                        sublayerBuffer: _,
                                        styleIdBuffer: v,
                                        layerIdBuffer: g,
                                        instanceIdBuffer: y,
                                        objectClassBuffer: b,
                                        centerBuffer: w,
                                        strings: x,
                                    } = a;
                                if (e < h || e > u) continue;
                                const S = e - h,
                                    I = new Uint32Array(m, 4 * S * 2, 2),
                                    M = new Uint32Array(_)[S],
                                    T = new Uint8Array(y)[S],
                                    P = new Uint32Array(b)[S];
                                let L,
                                    k,
                                    E = '';
                                const A = new Uint32Array(f, 4 * S * 2, 2);
                                (A[0] === Fi.gl && A[1] === Fi.gl) || (k = (0, O.Ru)(A[0], A[1]));
                                const z = this.modules.assetManager.getMetatile(l);
                                if (z) {
                                    (null === (t = z.reverseDictionaries.db_sublayer) ||
                                    void 0 === t
                                        ? void 0
                                        : t[M]) && (L = z.reverseDictionaries.db_sublayer[M]);
                                    const o = x[e];
                                    E =
                                        void 0 !== o
                                            ? o.objectClass
                                            : null !==
                                                  (n =
                                                      null ===
                                                          (i =
                                                              null == z
                                                                  ? void 0
                                                                  : z.reverseDictionaries
                                                                        .db_object_class) ||
                                                      void 0 === i
                                                          ? void 0
                                                          : i[P]) && void 0 !== n
                                            ? n
                                            : '';
                                }
                                const C = new Uint16Array(v)[S],
                                    F = new Uint32Array(g)[S],
                                    D = this.modules.styleManager.getStyleLayer(C, F);
                                if (
                                    !D ||
                                    'custom' === D.type ||
                                    ('gltfModel' === D.type && D.style.useThreeJs)
                                )
                                    return;
                                const R = new Int32Array(
                                    w,
                                    S * Int32Array.BYTES_PER_ELEMENT * 2,
                                    2,
                                );
                                return {
                                    id: (0, O.Ru)(I[0], I[1]),
                                    floorId: k,
                                    phase: new Float32Array(p)[S],
                                    dynamicObjectId: s,
                                    sourceId: c,
                                    tileKey: d,
                                    sublayer: L,
                                    symbol: D.type,
                                    instanceId: T,
                                    objectClass: E,
                                    center:
                                        R[0] !== rt.Cd || R[1] !== rt.Cd ? [R[0], R[1]] : void 0,
                                };
                            }
                        }
                    }
                    var Ws = i(6479);
                    function qs(e, t, i) {
                        const n = document.createElement('img');
                        return (
                            (n.width = t),
                            (n.height = i),
                            new Promise((t) => {
                                (n.onload = () => t(n)),
                                    (n.src = `data:image/svg+xml;base64,${btoa(e)}`);
                            })
                        );
                    }
                    function $s(e, t = 'image/png') {
                        const i = new Blob([e], { type: t }),
                            n = URL.createObjectURL(i),
                            o = document.createElement('img');
                        return new Promise((t) => {
                            (o.onload = () => {
                                URL.revokeObjectURL(n), t(o);
                            }),
                                0 === e.byteLength
                                    ? (o.src =
                                          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=')
                                    : (o.src = n);
                        });
                    }
                    function Xs(e, t) {
                        if (t[0] === e.width && t[1] === e.height) return e;
                        const i = document.createElement('canvas'),
                            n = i.getContext('2d');
                        return (
                            (i.width = t[0]),
                            (i.height = t[1]),
                            (n.shadowColor = 'transparent'),
                            (n.shadowBlur = 0),
                            n.drawImage(e, 0, 0, t[0], t[1]),
                            i
                        );
                    }
                    var Ys = i(3487),
                        Ks = i(4576),
                        Js = i(4847);
                    class Qs extends Js.g {
                        constructor(e) {
                            super(),
                                (this.sync = (e) => {
                                    const { dictionaries: t, reverseDictionaries: i } = e;
                                    (this.dictionaries = t), (this.reverseDictionaries = i);
                                }),
                                e.set('syncMetatile', this.sync);
                        }
                    }
                    var ea = i(2627),
                        ta = i(7966),
                        ia = i(1284);
                    function na(e) {
                        const t = new ia.x();
                        let i;
                        for (const n of e.layers)
                            void 0 !== n.groupId && i && n.groupId === i.groupId
                                ? (n.renderIndex = i.renderIndex)
                                : (n.renderIndex = t.getIndex()),
                                (i = n);
                        for (const t in e.groupsById) {
                            const i = e.groupsById[t];
                            i && i.layers[0] && (i.renderIndex = i.layers[0].renderIndex);
                        }
                    }
                    var oa = i(199);
                    function ra(e, t, i) {
                        const {
                            map: { state: n },
                            collector: o,
                            imageManager: r,
                            renderer: s,
                            tileManager: a,
                        } = i;
                        let l;
                        try {
                            l = (function (e, t, i) {
                                const n = (0, $.jJ)(e.styleZoom, e.styleState, []),
                                    o = t.style.color,
                                    r = [];
                                if (
                                    ((s = o.argument),
                                    'object' != typeof s || 'heatmap-density' !== s.type)
                                )
                                    throw new Error(
                                        `Heatmap color must be interpolate expression with 'heatmap-density' argument in layer ${t.id}`,
                                    );
                                var s;
                                const a = i - 1;
                                for (let e = 0; e < i; e++) {
                                    const t = e / a,
                                        i = (0, $.o4)(o, t, n);
                                    r.push(...i.value);
                                }
                                return new it(new Uint8Array(r), { size: [i, 1] });
                            })(n, e, 256);
                        } catch (e) {
                            return void console.error(e);
                        }
                        const c = r.addPreparedTexture(l),
                            d = s.getRenderingContext(),
                            { downscale: h } = e.style,
                            { size: u } = n,
                            m = new nt({
                                size: [
                                    Math.ceil((u[0] * window.devicePixelRatio) / h),
                                    Math.ceil((u[1] * window.devicePixelRatio) / h),
                                ],
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                                wrapS: it.ClampToEdgeWrapping,
                                wrapT: it.ClampToEdgeWrapping,
                            }),
                            f = m.getTexture();
                        if (!f)
                            return void console.error(
                                "Can't init HeatMap Layer. Missing FrameBuffer texture",
                            );
                        const p = r.addPreparedTexture(f),
                            _ = s.addFramebuffer({
                                renderTarget: m,
                                clearColor: [0, 0, 0, 0],
                                onResize: () => {
                                    m.setSize([
                                        Math.ceil((n.size[0] * window.devicePixelRatio) / h),
                                        Math.ceil((n.size[1] * window.devicePixelRatio) / h),
                                    ]),
                                        m.bind(d),
                                        m.unbind(d);
                                    const e = m.getTexture();
                                    e && r.updatePreparedTexture(p, e);
                                },
                            });
                        (0, H.XI)({
                            collector: o,
                            generator: Rt.B.generateTexture,
                            args: [t, e, p, c],
                        });
                        const v = o.getAccumulatedData(),
                            g = new C.W('dynamicObject', v.data, s);
                        return (
                            a.addObject(g),
                            o.reset(),
                            (e.framebufferId = { framebuffer: _ }),
                            (e) => {
                                a.removeObject(g),
                                    g.clean(e),
                                    r.deleteTexture(p),
                                    r.deleteTexture(c),
                                    s.removeFramebuffer(_);
                            }
                        );
                    }
                    class sa {
                        constructor(e) {
                            (this.modules = e),
                                (this.customLayers = new Map()),
                                (this.styleIndex = 1),
                                (this.handyStylesMap = new Map()),
                                (this.waitingStyleRequests = new Map()),
                                (this.onRemoveLayerHooks = new Map());
                        }
                        createStyle(e, t, i, n) {
                            const { state: o } = this.modules.map;
                            if (!Number.isNaN(o.handyStyleId)) {
                                const e = this.getStyle(o.handyStyleId);
                                e &&
                                    (e.layers.forEach((e) => {
                                        const t = this.onRemoveLayerHooks.get(e.innerId);
                                        t && t(o);
                                    }),
                                    this.onRemoveLayerHooks.clear());
                            }
                            const r = this.styleIndex++,
                                s = (0, W.Cp)(e, r, i, n);
                            (0, ta.As)(s, t), this.handyStylesMap.set(s.id, s);
                            const a = this.waitingStyleRequests.get(r);
                            return (
                                a && a.resolve(s),
                                this.modules.workers.parser.syncStyle(s),
                                this.modules.workers.labeling.syncStyle(s),
                                s.layers.forEach((e) => this.initHandyLayer(r, e)),
                                s
                            );
                        }
                        addLayer(e, t) {
                            const i = this.getStyle(this.modules.map.state.handyStyleId);
                            if (!i)
                                return void console.error(
                                    'Cannot add layer before map style was completely set. Please use "styleload" event.',
                                );
                            const n = (0, W.ys)(e);
                            n &&
                                (!(function (e, t, i) {
                                    var n;
                                    if (void 0 === e.id)
                                        throw new Error('The layer id must be set.');
                                    if (t.layerIdToInnerId[e.id])
                                        throw new Error(
                                            `The layer with id ${e.id} already exists in the map style.`,
                                        );
                                    let o = -1;
                                    if (i) {
                                        const r = Object.values(t.groupsById).find(
                                            (e) => e && e.id === i,
                                        );
                                        if (r)
                                            o = t.layers.findIndex((e) => e.groupId === r.innerId);
                                        else {
                                            o = t.layers.findIndex((e) => e.id === i);
                                            const r =
                                                null === (n = t.layers[o]) || void 0 === n
                                                    ? void 0
                                                    : n.groupId;
                                            if (void 0 !== r && 'group' === e.type)
                                                throw new Error(
                                                    `Group layer with id ${e.id} can't be added before layer with id ${i} in group with innerId ${r}. Layer groups doesn't support nesting.`,
                                                );
                                        }
                                    } else o = t.layers.length;
                                    if (-1 === o)
                                        throw new Error(
                                            `The layer with beforeId ${i} doesn't exist in the map style.`,
                                        );
                                    let r = [];
                                    if ('group' !== e.type) {
                                        r = [e];
                                        const i = o !== t.layers.length ? t.layers[o] : void 0;
                                        if (i && void 0 !== i.groupId) {
                                            const n = t.groupsById[i.groupId];
                                            if (!n)
                                                return void (0, hs.cM)(
                                                    `   id ${i.id}     groupId ${i.groupId}   id   c id ${t.id}`,
                                                );
                                            const o = n.layers.findIndex((e) => e.id === i.id);
                                            if (-1 === o)
                                                return void (0, hs.cM)(
                                                    `  id ${i.id}  groupId ${i.groupId}     c id ${t.id}`,
                                                );
                                            (e.groupId = n.innerId),
                                                n.layers.splice(o, 0, e),
                                                n.layers.forEach((e, t) => (e.groupIndex = t));
                                        }
                                    } else
                                        (t.groupsById[e.innerId] = e),
                                            (t.layerIdToInnerId[e.id] = e.innerId),
                                            (r = e.layers);
                                    t.revision++,
                                        t.layers.splice(o, 0, ...r),
                                        r.forEach((e) => {
                                            if (
                                                ((t.layersById[e.innerId] = e),
                                                (t.layerIdToInnerId[e.id] = e.innerId),
                                                'point' === e.type ||
                                                    'polygon' === e.type ||
                                                    'roadPointMark' === e.type)
                                            ) {
                                                const i = Math.max(
                                                        0,
                                                        ...Object.keys(t.rasterSets.byIndex).map(
                                                            (e) => Number(e),
                                                        ),
                                                    ),
                                                    n = new ia.x(i + 1);
                                                (0, W.z8)(e, n).forEach((e) => {
                                                    t.rasterSets.byKey[e.key] ||
                                                        ((t.rasterSets.byIndex[e.index] = e),
                                                        (t.rasterSets.byKey[e.key] = e));
                                                });
                                            }
                                        }),
                                        na(t);
                                })(n, i, t),
                                'custom' === e.type && 'custom' === n.type
                                    ? this.initCustomLayer(i.id, n, e.render, e.onRemove, e.onAdd)
                                    : this.initHandyLayer(i.id, n),
                                this.modules.workers.parser.syncStyle(i),
                                this.modules.workers.labeling.syncStyle(i));
                        }
                        setTerrainStyle(e) {
                            const t = this.getStyle(this.modules.map.state.handyStyleId);
                            t &&
                                ((t.dem = (0, W.vR)(e)),
                                this.modules.demManager.onTerrainStyleChange(),
                                (this.modules.map.state.needRerender = !0));
                        }
                        addIcon(e, t) {
                            const i = this.getStyle(this.modules.map.state.handyStyleId);
                            if (!i)
                                return (
                                    console.error(
                                        'Cannot add icons before map style was completely set. Please use "styleload" event.',
                                    ),
                                    !1
                                );
                            const n = i.layers.filter(
                                    (t) =>
                                        'point' === t.type &&
                                        void 0 !== t.style.iconImage &&
                                        (0, $.EG)(t.style.iconImage).some((t) => t === e),
                                ),
                                o = i.layers.filter(
                                    (t) =>
                                        ('polygon' === t.type || 'roadPointMark' === t.type) &&
                                        Boolean(t.style.textureImage) &&
                                        (0, $.EG)(t.style.textureImage).some((t) => t === e),
                                );
                            if (Boolean(i.icons[e]))
                                return (
                                    console.error(`The icon with the name ${e} already exists.`), !1
                                );
                            const r = Math.max(
                                    0,
                                    ...Object.keys(i.rasterSets.byIndex).map((e) => Number(e)),
                                ),
                                s = new ia.x(r + 1);
                            return (
                                [...n, ...o].forEach((t) => {
                                    const { imageType: n, anchor: o } = (0, W.Jn)(t),
                                        r = (0, W.Wy)(e, n, s, o);
                                    (i.rasterSets.byIndex[r.index] = r),
                                        (i.rasterSets.byKey[r.key] = r);
                                }),
                                (i.icons[e] = t),
                                i.revision++,
                                this.modules.workers.parser.syncStyle(i),
                                this.modules.workers.labeling.syncStyle(i),
                                !0
                            );
                        }
                        removeIcon(e) {
                            const t = this.getStyle(this.modules.map.state.handyStyleId);
                            if (!t)
                                return (
                                    console.error(
                                        'Cannot remove icons before map style was completely set. Please use "styleload" event.',
                                    ),
                                    !1
                                );
                            delete t.icons[e];
                            let i = !1;
                            return (
                                t.layers
                                    .filter(
                                        (e) =>
                                            ('point' === e.type && Boolean(e.style.iconImage)) ||
                                            ('polygon' === e.type &&
                                                Boolean(e.style.textureImage)) ||
                                            ('roadPointMark' === e.type &&
                                                Boolean(e.style.textureImage)),
                                    )
                                    .forEach((n) => {
                                        const { image: o, imageType: r, anchor: s } = (0, W.Jn)(n);
                                        (0, $.EG)(o).forEach((n) => {
                                            if (n === e) {
                                                const e =
                                                        'icon' === r
                                                            ? (0, oo.PR)(n, s[0], s[1])
                                                            : (0, oo.FD)(n),
                                                    o = t.rasterSets.byKey[e];
                                                o &&
                                                    (this.modules.assetManager.removeRasterSet(
                                                        o,
                                                        t.id,
                                                    ),
                                                    (i = !0));
                                            }
                                        });
                                    }),
                                !!i &&
                                    (t.revision++,
                                    this.modules.workers.parser.syncStyle(t),
                                    this.modules.workers.labeling.syncStyle(t),
                                    !0)
                            );
                        }
                        addModel(e, t) {
                            const i = this.getStyle(this.modules.map.state.handyStyleId);
                            if (!i)
                                return (
                                    console.error(
                                        'Cannot add models before map style was completely set. Please use "styleload" event.',
                                    ),
                                    !1
                                );
                            return void 0 !== i.modelIndex[e]
                                ? (console.error(`The model with the name ${e} already exists.`),
                                  !1)
                                : (i.models.push(t),
                                  (i.modelIndex[e] = i.models.length - 1),
                                  i.revision++,
                                  this.modules.workers.parser.syncStyle(i),
                                  this.modules.workers.labeling.syncStyle(i),
                                  !0);
                        }
                        removeLayer(e) {
                            const t = this.getStyle(this.modules.map.state.handyStyleId);
                            t
                                ? oa.T.some((t) => t.id === e) ||
                                  (!(function (e, t, i) {
                                      const n = t.layerIdToInnerId[e];
                                      if (void 0 === n) return;
                                      t.revision++;
                                      let o = [];
                                      const r = t.groupsById[n];
                                      if (r) {
                                          if (
                                              ((o = r.layers),
                                              delete t.groupsById[n],
                                              delete t.layerIdToInnerId[r.id],
                                              0 === o.length)
                                          )
                                              return;
                                      } else {
                                          const i = t.layersById[n];
                                          if (!i)
                                              return void (0, hs.cM)(
                                                  `  id ${e}      ,       c id ${t.id}`,
                                              );
                                          if (void 0 !== i.groupId && void 0 !== i.groupIndex) {
                                              const e = t.groupsById[i.groupId];
                                              e &&
                                                  (e.layers.splice(i.groupIndex, 1),
                                                  e.layers.forEach((e, t) => (e.groupIndex = t)));
                                          }
                                          o = [i];
                                      }
                                      const s = t.layers.findIndex((e) => e.id === o[0].id);
                                      -1 !== s &&
                                          (o.forEach((e) => {
                                              const {
                                                      styleManager: n,
                                                      map: { state: o },
                                                  } = i,
                                                  r = n.getRemoveLayerHook(e.innerId);
                                              r && (r(o), n.clearRemoveLayerHook(e.innerId)),
                                                  delete t.layersById[e.innerId],
                                                  delete t.layerIdToInnerId[e.id];
                                          }),
                                          t.layers.splice(s, o.length),
                                          na(t));
                                  })(e, t, this.modules),
                                  this.modules.workers.parser.syncStyle(t),
                                  this.modules.workers.labeling.syncStyle(t))
                                : console.error(
                                      'Cannot remove layer before map style was completely set. Please use "styleload" event.',
                                  );
                        }
                        setDynamicStyle(e) {
                            this.handyStylesMap.set(V.jf, e),
                                this.modules.workers.parser.syncStyle(e),
                                this.modules.workers.labeling.syncStyle(e);
                        }
                        getStyle(e) {
                            return this.handyStylesMap.get(e);
                        }
                        getStyleLayer(e, t) {
                            var i;
                            return null === (i = this.handyStylesMap.get(e)) || void 0 === i
                                ? void 0
                                : i.layersById[t];
                        }
                        getStyleRevision(e) {
                            var t;
                            return (
                                (null === (t = this.getStyle(e)) || void 0 === t
                                    ? void 0
                                    : t.revision) || 0
                            );
                        }
                        setFramebufferId(e, t, i) {
                            var n;
                            const o =
                                null === (n = this.handyStylesMap.get(e)) || void 0 === n
                                    ? void 0
                                    : n.layersById[t];
                            o && (o.framebufferId = i);
                        }
                        getFramebufferId(e, t) {
                            var i, n;
                            return null ===
                                (n =
                                    null === (i = this.handyStylesMap.get(e)) || void 0 === i
                                        ? void 0
                                        : i.layersById[t]) || void 0 === n
                                ? void 0
                                : n.framebufferId;
                        }
                        waitForStyle(e) {
                            const t = this.handyStylesMap.get(e);
                            if (t) return Promise.resolve(t);
                            const i = this.waitingStyleRequests.get(e);
                            if (i) return i.promise;
                            const n = { resolve: void 0, promise: void 0 };
                            return (
                                (n.promise = new Promise((e) => {
                                    n.resolve = e;
                                })),
                                this.waitingStyleRequests.set(e, n),
                                n.promise
                            );
                        }
                        addRemoveLayerHook(e, t) {
                            this.onRemoveLayerHooks.set(e, t);
                        }
                        getRemoveLayerHook(e) {
                            return this.onRemoveLayerHooks.get(e);
                        }
                        clearRemoveLayerHook(e) {
                            this.onRemoveLayerHooks.delete(e);
                        }
                        callCustomLayerRender(e) {
                            const t = this.customLayers.get(e);
                            t && t.renderFunction(this.modules.renderer.getRenderingContext());
                        }
                        getCustomSceneObjects() {
                            const e = [];
                            return this.customLayers.forEach((t) => e.push(t.sceneObject)), e;
                        }
                        initHandyLayer(e, t) {
                            let i;
                            switch (t.type) {
                                case 'group':
                                    return void t.layers.forEach((t) => this.initHandyLayer(e, t));
                                case 'heatmap':
                                    i = ra(t, e, this.modules);
                            }
                            i && this.modules.styleManager.addRemoveLayerHook(t.innerId, i);
                        }
                        initCustomLayer(e, t, i, n, o) {
                            const r = {
                                sceneObject: {
                                    type: ot.H.Custom,
                                    attributes: { styleId: e, layerId: t.innerId, tileData: [] },
                                    tile: { zoomLevel: 0 },
                                    layerSettings: {},
                                },
                                layer: t,
                                renderFunction: i,
                            };
                            null == o || o(),
                                this.customLayers.set(t.innerId, r),
                                this.modules.styleManager.addRemoveLayerHook(t.innerId, () => {
                                    null == n || n(), this.customLayers.delete(t.innerId);
                                });
                        }
                    }
                    var aa = i(4619);
                    const la = new Set([
                        'position',
                        'texcoord_0',
                        'texcoord_1',
                        'texcoord_2',
                        'texcoord_3',
                        'normal',
                        'tangent',
                    ]);
                    class ca extends C.Y {
                        constructor() {
                            super('model', [0, 0, 0, 0]),
                                (this.children = []),
                                (this.identifyChildren = []),
                                (this.depthTestChildren = []);
                        }
                        setTileCoords(e) {
                            throw new Error(
                                'GLTF tile object does not support setting coordinates',
                            );
                        }
                    }
                    function da(e, t, i) {
                        return ha(e, i.scenes[i.scene].nodes, i, [], t), e;
                    }
                    function ha(e, t, i, n, o) {
                        var r, s, a;
                        if (!t) return;
                        const l = o.symbolSettingsList.gltfModel.fill;
                        if (l && 0 !== l.length)
                            for (const c of t) {
                                const t = i.nodes[c];
                                if (
                                    (t.matrix && n.push(t.matrix),
                                    t.translation && t.rotation && t.scale)
                                ) {
                                    const e = $e.Ue();
                                    $e.Iw(e, t.rotation, t.translation, t.scale), n.push(e);
                                }
                                if (void 0 !== t.mesh) {
                                    const c = i.meshes[t.mesh],
                                        d = new ca();
                                    (d.modelMatrix = fa(n)), e.objects.push(d);
                                    for (const t of c.primitives) {
                                        const n = {};
                                        let c,
                                            h = 0;
                                        for (const o in t.attributes) {
                                            const a = o.toLowerCase();
                                            if (!la.has(a)) {
                                                0;
                                                continue;
                                            }
                                            const l = t.attributes[o],
                                                c = i.accessors[l];
                                            if (void 0 === c.bufferView) continue;
                                            const d = i.bufferViews[c.bufferView];
                                            if (void 0 === d) continue;
                                            const u = ma(e, i, c.bufferView, c.componentType);
                                            u &&
                                                ((n[o.toLowerCase()] = new Ot(u, {
                                                    itemSize: pa(c.type),
                                                    dataType: va(c.componentType),
                                                    stride:
                                                        null !== (r = d.byteStride) && void 0 !== r
                                                            ? r
                                                            : 0,
                                                    offset:
                                                        null !== (s = c.byteOffset) && void 0 !== s
                                                            ? s
                                                            : 0,
                                                    normalized: !!c.normalized,
                                                })),
                                                0 === h && (h = c.count));
                                        }
                                        if (void 0 !== t.indices) {
                                            const n = i.accessors[t.indices];
                                            if (void 0 === n.bufferView) continue;
                                            if (
                                                ((c = ma(e, i, n.bufferView, n.componentType, !0)),
                                                !c)
                                            )
                                                continue;
                                            h = n.count;
                                        }
                                        if (void 0 === t.material) continue;
                                        const u = i.materials[t.material];
                                        if (!u) continue;
                                        if (void 0 === u.pbrMetallicRoughness) continue;
                                        const m = {
                                                styleId: NaN,
                                                layerId: NaN,
                                                colorTexture: NaN,
                                                aoTexture: NaN,
                                                tileData: [],
                                            },
                                            f = {},
                                            p = u.pbrMetallicRoughness.baseColorTexture;
                                        if (void 0 === p) continue;
                                        (f.texcoord_color = `texcoord_${
                                            null !== (a = p.texCoord) && void 0 !== a ? a : 0
                                        }`),
                                            ua(e, i, p),
                                            (m.colorTexture = p.index);
                                        const _ = u.occlusionTexture;
                                        if (_) {
                                            ua(e, i, _), (m.aoTexture = _.index);
                                            const t =
                                                'number' == typeof _.texCoord ? _.texCoord : 0;
                                            f.texcoord_ao = `texcoord_${t}`;
                                        }
                                        const v = o.getShaderProgram('gltfModel'),
                                            g = new Xe(v, n, c);
                                        g.setAttributesAliases(f);
                                        for (const e of l) {
                                            let i = d.children;
                                            e.identify
                                                ? (i = d.identifyChildren)
                                                : e.depthTest && (i = d.depthTestChildren),
                                                i.push({
                                                    id: (0, E.f)(),
                                                    type: ot.H.Tile,
                                                    layerSettings: e,
                                                    stride: 1,
                                                    rangeStart: 0,
                                                    rangeEnd: h,
                                                    attributes: m,
                                                    attributesHash: JSON.stringify(m),
                                                    drawMode: t.mode,
                                                    vao: g,
                                                    tile: d,
                                                    symbol: 'gltfModel',
                                                    sink: 'fill',
                                                });
                                        }
                                    }
                                }
                                t.children && ha(e, t.children, i, n, o);
                            }
                    }
                    function ua(e, t, i) {
                        var n;
                        const o = null !== (n = i.index) && void 0 !== n ? n : 0,
                            r = t.textures[o];
                        if (!r || void 0 === r.source || void 0 === r.sampler) return;
                        const s = t.images[r.source],
                            a = t.samplers[r.sampler];
                        if (!a || !s) return;
                        const l = { flipY: !1 };
                        a.magFilter && (l.magFilter = ga(a.magFilter)),
                            a.minFilter && (l.minFilter = ga(a.minFilter)),
                            a.wrapS && (l.wrapS = ga(a.wrapS)),
                            a.wrapT && (l.wrapT = ga(a.wrapT)),
                            void 0 !== i.texCoord && (l.texcoord = i.texCoord),
                            s.image || !s.bufferView
                                ? (e.textures[o] = new it(s.image, l))
                                : (function (e, t) {
                                      return (0, S.mG)(this, void 0, void 0, function* () {
                                          if (!t.bufferView) return !1;
                                          const i = e.bufferViews[t.bufferView];
                                          if (void 0 === i) return !1;
                                          const n = e.buffers[i.buffer].buffer;
                                          return (
                                              !!n &&
                                              $s(
                                                  new Uint8Array(n, i.byteOffset, i.byteLength),
                                                  t.mimeType,
                                              )
                                          );
                                      });
                                  })(t, s).then((t) => {
                                      t && ((s.image = t), (e.textures[o] = new it(s.image, l)));
                                  });
                    }
                    function ma(e, t, i, n, o = !1) {
                        const r = t.bufferViews[i];
                        if (void 0 !== r) {
                            if (!e.buffers[i]) {
                                const s = t.buffers[r.buffer].buffer;
                                if (!s) return;
                                const a = new DataView(
                                        (function (e) {
                                            if (e instanceof ArrayBuffer) return e;
                                            return e.buffer;
                                        })(s),
                                        r.byteOffset,
                                        r.byteLength,
                                    ),
                                    l = new Ft.l(a, { dataType: va(n) });
                                (l.type = o ? Ft.l.ElementArrayBuffer : Ft.l.ArrayBuffer),
                                    (e.buffers[i] = l);
                            }
                            return e.buffers[i];
                        }
                    }
                    function fa(e) {
                        if (0 === e.length) return $e.Ue();
                        const t = $e.d9(e[0]);
                        for (let i = 1; i < e.length; i++) $e.dC(t, t, e[i]);
                        return t;
                    }
                    function pa(e) {
                        switch (e[0]) {
                            case 'S':
                                return 1;
                            case 'V':
                                return Number(e[3]);
                            case 'M':
                                return Math.pow(Number(e[3]), 2);
                        }
                        return (
                            console.error(
                                `Failed to determine channels count from accessor type = ${e}`,
                            ),
                            0
                        );
                    }
                    const _a = window.WebGLRenderingContext;
                    function va(e) {
                        if (void 0 === e) return;
                        const t = {
                            [_a.UNSIGNED_BYTE]: Ft.l.UnsignedByte,
                            [_a.UNSIGNED_SHORT]: Ft.l.UnsignedShort,
                            [_a.UNSIGNED_INT]: Ft.l.UnsignedInt,
                            [_a.BYTE]: Ft.l.Byte,
                            [_a.SHORT]: Ft.l.Short,
                            [_a.INT]: Ft.l.Int,
                            [_a.FLOAT]: Ft.l.Float,
                        }[e];
                        return void 0 === t
                            ? (console.error(`Cannot translate ${e} gltf componentType`), NaN)
                            : t;
                    }
                    function ga(e) {
                        if (void 0 === e) return;
                        const t = {
                            [_a.CLAMP_TO_EDGE]: it.ClampToEdgeWrapping,
                            [_a.REPEAT]: it.Repeat,
                            [_a.MIRRORED_REPEAT]: it.MirroredRepeat,
                            [_a.NEAREST]: it.NearestFilter,
                            [_a.NEAREST_MIPMAP_NEAREST]: it.NearestMipMapNearestFilter,
                            [_a.NEAREST_MIPMAP_LINEAR]: it.NearestMipMapLinearFilter,
                            [_a.LINEAR]: it.LinearFilter,
                            [_a.LINEAR_MIPMAP_NEAREST]: it.LinearMipMapNearestFilter,
                            [_a.LINEAR_MIPMAP_LINEAR]: it.LinearMipMapLinearFilter,
                            [_a.RGBA]: it.RgbaFormat,
                            [_a.ALPHA]: it.AlphaFormat,
                            [_a.RGB]: it.RgbFormat,
                            [_a.UNSIGNED_BYTE]: it.UnsignedByte,
                            [_a.FLOAT]: it.Float,
                        }[e];
                        return void 0 === t
                            ? (console.error(`Failed to translate texture parameter ${e}`), NaN)
                            : t;
                    }
                    class ya {
                        constructor(e, t) {
                            (this.loadFont = (e, t) => {
                                let i = this.requestFontRanges.get(e, t);
                                return (
                                    i ||
                                        ((i = this.createLoadFontRequest(e, t)),
                                        this.requestFontRanges.set(e, t, i)),
                                    i
                                );
                            }),
                                (this.state = e),
                                (this.modules = t),
                                (this.requestedMetatiles = new Set()),
                                (this.metatiles = {}),
                                (this.loadedRasters = {}),
                                (this.failedRasters = {}),
                                (this.requestedRasters = {}),
                                (this.requestedSvgs = {}),
                                (this.disableIconCache = e.disableIconCache),
                                (this.textures = []),
                                (this.fontGlyphs = {}),
                                (this.fontTextures = new Ys.c()),
                                (this.requestFontRanges = new Ys.c()),
                                (this.pendingFontRanges = 0),
                                (this.loadedFontRanges = 0),
                                (this.models = {}),
                                (this.visibleBuildingIds = new Set()),
                                (this.metatileLoader = (e, t, i) => {
                                    const n = (0, P.GG)(t);
                                    fetch(e)
                                        .then((e) => {
                                            if (!e.ok)
                                                throw new Error(`Failed to load metatile "${n}"`);
                                            return e.json();
                                        })
                                        .then((e) => this.setMetatile(t, i, e))
                                        .catch((e) => console.error(e));
                                });
                            const { fnRegistry: i } = this.modules.workers;
                            i.set('addNewRasterSets', (e, t) => {
                                const i = this.modules.styleManager.getStyle(e);
                                if (!i)
                                    return void console.error(
                                        `Not found style ${e} in AssetManager#addNewRasterSets`,
                                    );
                                const { rasterSets: n } = i;
                                t.forEach((e) => {
                                    (n.byIndex[e.index] = e), (n.byKey[e.key] = e);
                                });
                            }),
                                i.set('loadFont', this.loadFont),
                                this.setPreparedMetatile(-1, P.nF),
                                this.setPreparedMetatile(rt.L2, (0, aa.X4)()),
                                (this.metatiles[rt.DL] = new Qs(i));
                        }
                        loadMetatile(e, t, i) {
                            this.requestedMetatiles.has(t) ||
                                (this.requestedMetatiles.add(t), this.metatileLoader(e, t, i));
                        }
                        setMetatile(e, t, i) {
                            (0, ea.lG)(i), (i.tileProps = i.tileProps.map(ea.dx));
                            const n = (0, P.ev)(i);
                            this.setPreparedMetatile(e, n),
                                void 0 === this.projectMetatileMetadata &&
                                    (this.projectMetatileMetadata = {
                                        regionId: t,
                                        metatileHash: e,
                                    });
                        }
                        setPreparedMetatile(e, t) {
                            (this.metatiles[e] = t), this.modules.workers.parser.setMetatile(e, t);
                        }
                        prepareRasters(e, t, i) {
                            var n, o;
                            const r = this.modules.styleManager.getStyle(e);
                            if (!r)
                                return void console.error(
                                    `Not found style ${e} in AssetManager#prepareRasters`,
                                );
                            const { rasterSets: s } = r,
                                a = this.modules.renderer.getRenderingContext(),
                                l = t.length / 7;
                            for (let e = 0; e < l; e++) {
                                const l = t[7 * e],
                                    c = t[7 * e + 1],
                                    d = t[7 * e + 6],
                                    h = t[7 * e + 2],
                                    u = t[7 * e + 3],
                                    m = t[7 * e + 4],
                                    f = t[7 * e + 5],
                                    p = s.byIndex[l];
                                if (p.isSvg) {
                                    const e = {
                                        rasterIndex: c,
                                        rasterSetIndex: l,
                                        x: h,
                                        y: u,
                                        w: m,
                                        h: f,
                                        anchorX: p.anchorX,
                                        anchorY: p.anchorY,
                                        atlasIndex: d,
                                        isPacked: !0,
                                    };
                                    (p.rasters[c] = e),
                                        null ===
                                            (o =
                                                null === (n = this.requestedSvgs[r.id]) ||
                                                void 0 === n
                                                    ? void 0
                                                    : n[l]) ||
                                            void 0 === o ||
                                            o.then((t) => {
                                                const i = this.textures[e.atlasIndex];
                                                qs(t, e.w, e.h).then((t) => {
                                                    i.subImage(a, t, e.x, e.y),
                                                        (this.state.needRerender = !0);
                                                });
                                            });
                                } else {
                                    const e = p.rasters[c];
                                    (e.x = h), (e.y = u), (e.atlasIndex = d), (e.isPacked = !0);
                                }
                                void 0 === this.textures[d] &&
                                    (this.textures[d] = new it(void 0, {
                                        size: I.atlasSize,
                                        flipY: !1,
                                        premultiplyAlpha: !Ee || !p.isSvg,
                                        unit: d,
                                        magFilter: it.LinearFilter,
                                        minFilter: it.LinearFilter,
                                    }).prepare(this.modules.renderer.getRenderingContext()));
                                const _ = this.textures[d],
                                    v = i && i[e];
                                void 0 === v ||
                                    (_.subImage(a, v, h, u), (this.state.needRerender = !0));
                            }
                            this.modules.workers.labeling.updatePackingInfo(e, t);
                        }
                        loadRasters(e) {
                            const t = e.length / 3;
                            for (let i = 0; i < t; i++) {
                                const t = e[3 * i],
                                    n = e[3 * i + 1],
                                    o = e[3 * i + 2],
                                    r = (n << 16) | o,
                                    s = this.modules.styleManager.getStyle(t);
                                if (!s) {
                                    console.error(
                                        `Not found style ${t} in AssetManager#loadRasters`,
                                    );
                                    continue;
                                }
                                if (
                                    (this.loadedRasters[t] ||
                                        ((this.loadedRasters[t] = new Set()),
                                        (this.failedRasters[t] = new Set()),
                                        (this.requestedRasters[t] = new Set())),
                                    this.requestedRasters[t].has(r))
                                )
                                    continue;
                                const { rasterSets: a } = s,
                                    l = a.byIndex[n];
                                !1 !== l.rasters[o].isPacked
                                    ? (this.requestedRasters[t].add(r),
                                      l.isSvg ? this.loadSvg(r, s, n) : this.loadPng(r, s, n, o))
                                    : console.error(`Try to load not packed raster ${l.key}`);
                            }
                        }
                        removeRasterSet(e, t) {
                            const { key: i, index: n, rasters: o } = e;
                            delete this.requestedSvgs[t][n],
                                o.forEach(({ rasterSetIndex: e, rasterIndex: i }) => {
                                    var n, o, r;
                                    const s = (e << 16) | i;
                                    null === (n = this.loadedRasters[t]) ||
                                        void 0 === n ||
                                        n.delete(s),
                                        null === (o = this.failedRasters[t]) ||
                                            void 0 === o ||
                                            o.delete(s),
                                        null === (r = this.requestedRasters[t]) ||
                                            void 0 === r ||
                                            r.delete(s);
                                }),
                                (e.rasters.length = 0);
                            const r = this.modules.styleManager.getStyle(t);
                            r && (delete r.rasterSets.byIndex[n], delete r.rasterSets.byKey[i]);
                        }
                        getMetatile(e) {
                            return this.metatiles[e];
                        }
                        getProjectMetadata() {
                            return this.projectMetatileMetadata;
                        }
                        getFontGlyphs(e) {
                            return this.fontGlyphs[e] || {};
                        }
                        getFontTextureByName(e, t) {
                            return this.fontTextures.get(e, t);
                        }
                        isIdle() {
                            let e = 0,
                                t = 0;
                            for (const i in this.requestedRasters)
                                (e += this.requestedRasters[i].size),
                                    (t += this.loadedRasters[i].size + this.failedRasters[i].size);
                            return (
                                e === t &&
                                this.pendingFontRanges === this.loadedFontRanges &&
                                this.allModelsLoaded()
                            );
                        }
                        dangerouslySetMetatiles(e) {
                            this.metatiles = e;
                        }
                        dangerouslySetRasters(e, t) {
                            (this.loadedRasters = e), (this.failedRasters = t);
                        }
                        addModel(e) {
                            const t = this.getModelUniqueKey(e);
                            void 0 === this.models[t] &&
                                ((this.models[t] = {
                                    buffers: [],
                                    objects: [],
                                    textures: [],
                                    loaded: !1,
                                }),
                                this.modules.workers.parser
                                    .loadModel(this.state.handyStyleId, e)
                                    .then((e) => {
                                        if ('ok' === e.type) {
                                            if (!e.result) return;
                                            da(this.models[t], this.modules.renderer, e.result),
                                                (this.state.needRerender = !0);
                                        } else (0, hs.$z)(e);
                                    })
                                    .finally(() => {
                                        this.models[t].loaded = !0;
                                    }));
                        }
                        getModel(e) {
                            return this.models[this.getModelUniqueKey(e)];
                        }
                        allModelsLoaded() {
                            for (const e in this.models) if (!this.models[e].loaded) return !1;
                            return !0;
                        }
                        isModelLoaded(e) {
                            const t = this.models[this.getModelUniqueKey(e)];
                            return t && t.objects.length > 0;
                        }
                        invalidateUsedModels() {
                            const e = new Set(),
                                t = this.modules.tileManager.getTileObjects();
                            for (const i of t)
                                for (const t of i.children) {
                                    if ('gltfModel' !== t.symbol) continue;
                                    const i = t.attributes.modelId;
                                    if (void 0 === i) continue;
                                    const n = this.getModel(i);
                                    n ? e.add(n) : this.addModel(i);
                                }
                            for (const t in this.models) {
                                const i = this.models[t];
                                !e.has(i) &&
                                    i.buffers.length > 0 &&
                                    (i.objects.forEach((e) => e.clean(this.state)),
                                    delete this.models[t]);
                            }
                        }
                        getModelUniqueKey(e) {
                            return e > 0 ? `${this.state.handyStyleId},${e}` : String(e);
                        }
                        createLoadFontRequest(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                this.pendingFontRanges += 1;
                                const i = Number.isNaN(this.state.handyStyleId)
                                    ? 1
                                    : this.state.handyStyleId;
                                try {
                                    const n = yield this.modules.styleManager.waitForStyle(i),
                                        o = yield fetch((0, ta.fb)(e, t, n))
                                            .then((e) => {
                                                if (!e.ok) throw new Error();
                                                return e;
                                            })
                                            .catch(
                                                () => (
                                                    console.error(
                                                        `Could not load font ${e} for range ${t} fallback to the default font ${rt.Uo}`,
                                                    ),
                                                    fetch((0, ta.fb)(rt.Uo, t, n)).then((e) => {
                                                        if (!e.ok)
                                                            throw new Error(
                                                                `Could not load default font ${rt.Uo} for range ${t}`,
                                                            );
                                                        return e;
                                                    })
                                                ),
                                            )
                                            .then((e) => e.arrayBuffer()),
                                        r = (0, Ks.Xq)(o);
                                    return (
                                        this.prepareFontAtlas(e, t, r),
                                        this.modules.workers.labeling.appendFont(e, r.glyphData),
                                        (this.loadedFontRanges += 1),
                                        this.modules.workers.labeling.markFontAsLoaded(e, t)
                                    );
                                } catch (i) {
                                    return (
                                        console.error(i),
                                        (this.loadedFontRanges += 1),
                                        this.modules.workers.labeling.markFontAsLoaded(e, t)
                                    );
                                }
                            });
                        }
                        prepareFontAtlas(e, t, i) {
                            const { bitmap: n, width: o, height: r, glyphData: s } = i;
                            this.fontGlyphs[e] || (this.fontGlyphs[e] = {});
                            for (const t in s) this.fontGlyphs[e][t] = s[t];
                            const a = new it(new Uint8Array(n), {
                                size: [o, r],
                                magFilter: it.LinearFilter,
                                minFilter: it.LinearFilter,
                                format: it.AlphaFormat,
                                premultiplyAlpha: !1,
                                flipY: !1,
                                unit: 0,
                            });
                            this.fontTextures.set(e, t, a), (this.state.needLabeling = !0);
                        }
                        loadPng(e, t, i, n) {
                            const o = this.modules.renderer.getRenderingContext(),
                                { rasterSets: r } = t,
                                s = r.byIndex[i],
                                a = s.rasters[n],
                                l = this.textures[a.atlasIndex];
                            let c = '';
                            if (s.type === Ws.f.Unique) {
                                const e = (0, O.Ak)(s.id);
                                c = s.url
                                    ? s.url.replace(
                                          'image',
                                          `image_${a.w.toString()}x${a.h.toString()}`,
                                      )
                                    : (0, T.Gr)('dynamicPoi', {
                                          host: this.state.tileServer,
                                          tileSet: this.state.tileSet,
                                          protocol: this.state.tileProtocol,
                                          subdomain: (0, T.Sy)(this.state.subdomains, e),
                                          id: e,
                                          width: a.w.toString(),
                                          height: a.h.toString(),
                                          regionId: String(s.regionId),
                                      });
                            } else if (s.type === Ws.f.Static) {
                                const i = t.icons[s.name];
                                if (!i)
                                    return (
                                        console.error(
                                            'There is no appropriate icon config in the style',
                                        ),
                                        void this.failedRasters[t.id].add(e)
                                    );
                                c = (0, ta.bX)(i.url, t, (0, T.Sy)(this.state.subdomains, s.name));
                            }
                            this.modules.workers.parser.prepareAtlas(c).then((i) => {
                                i
                                    ? (i.isBitmap
                                          ? (l.subImage(o, i.data[0], a.x, a.y),
                                            (this.state.needRerender = !0))
                                          : $s(i.data[0]).then((e) => {
                                                l.subImage(o, e, a.x, a.y),
                                                    (this.state.needRerender = !0);
                                            }),
                                      this.loadedRasters[t.id].add(e))
                                    : this.failedRasters[t.id].add(e);
                            });
                        }
                        loadSvg(e, t, i) {
                            const n = this.modules.renderer.getRenderingContext(),
                                o = t.rasterSets.byIndex[i];
                            if (!t.iconBaseUrl)
                                return (
                                    console.error('Attempt to load svg without existing style'),
                                    void this.failedRasters[t.id].add(e)
                                );
                            const r = t.icons[o.name];
                            if (!r)
                                return (
                                    console.error(
                                        'There is no appropriate icon config in the style',
                                    ),
                                    void this.failedRasters[t.id].add(e)
                                );
                            const s = (0, ta.bX)(
                                r.url,
                                t,
                                (0, T.Sy)(this.state.subdomains, o.name),
                            );
                            this.requestedSvgs[t.id] || (this.requestedSvgs[t.id] = {});
                            let a = this.requestedSvgs[t.id][i];
                            (a && !this.disableIconCache) ||
                                (a = this.requestedSvgs[t.id][i] =
                                    fetch(s, {
                                        cache: this.disableIconCache ? 'no-cache' : 'default',
                                    }).then((e) => {
                                        if (!e.ok) throw new Error('Not 2xx response');
                                        return e.text();
                                    })),
                                a
                                    .then((i) => {
                                        for (const e of o.rasters) {
                                            if (e.w <= 0 || e.h <= 0) continue;
                                            const t = this.textures[e.atlasIndex];
                                            qs(i, e.w, e.h).then((i) => {
                                                t.subImage(n, i, e.x, e.y),
                                                    (this.state.needRerender = !0);
                                            });
                                        }
                                        this.loadedRasters[t.id].add(e);
                                    })
                                    .catch((i) => {
                                        console.error(i), this.failedRasters[t.id].add(e);
                                    });
                        }
                    }
                    var ba = i(3429);
                    class wa {
                        constructor(e, t, i, n, o, r, s, a) {
                            (this.modules = e),
                                (this.mapState = t),
                                (this.cache = i),
                                (this.maxStyleZoom = -1 / 0),
                                (this.minStyleZoom = 1 / 0),
                                (this.ready = !1),
                                (this.useful = !1),
                                (this.status = 'initial'),
                                (this.model = n),
                                (this.key = o),
                                (this.selectedIds = r),
                                (this.styleId = s),
                                (this.styleRevision = a),
                                (this.modelRevision = n.revision),
                                (this.objects = []);
                        }
                        update() {
                            switch (this.status) {
                                case 'initial':
                                    this.useful && (this.loadModel(), (this.status = 'generating'));
                                    break;
                                case 'generating':
                                    if (
                                        this.useful &&
                                        this.processResponse &&
                                        this.model.texturesLoaded
                                    ) {
                                        const {
                                            objects: { data: e },
                                        } = this.processResponse;
                                        (this.objects = (function (e, t) {
                                            var i, n;
                                            const o = new C.W('model', e, t),
                                                r = [],
                                                s = xa(
                                                    null !==
                                                        (n =
                                                            null !== (i = o.children[0]) &&
                                                            void 0 !== i
                                                                ? i
                                                                : o.identifyChildren[0]) &&
                                                        void 0 !== n
                                                        ? n
                                                        : o.depthTestChildren[0],
                                                );
                                            s &&
                                                [
                                                    'children',
                                                    'identifyChildren',
                                                    'depthTestChildren',
                                                ].forEach((e) => {
                                                    $e.JG(o.modelMatrix, s);
                                                    let i = o[e].length;
                                                    for (; i--; ) {
                                                        const n = o[e][i],
                                                            s = xa(n);
                                                        if (!s) continue;
                                                        if ($e.I6(o.modelMatrix, s)) continue;
                                                        let a = r.find((e) =>
                                                            $e.I6(e.modelMatrix, s),
                                                        );
                                                        a ||
                                                            ((a = new C.W('model', [], t)),
                                                            $e.JG(a.modelMatrix, s),
                                                            r.push(a)),
                                                            a[e].push(n),
                                                            (n.tile = a),
                                                            o[e].splice(i, 1);
                                                    }
                                                });
                                            return [o, ...r];
                                        })(e, this.modules.renderer)),
                                            this.updateMinAndMaxStyleZoom(this.objects),
                                            (this.status = 'generated'),
                                            (this.ready = !0),
                                            this.cache.add(this.key, this);
                                    }
                            }
                        }
                        getIdentifyIds() {
                            var e;
                            return null === (e = this.processResponse) || void 0 === e
                                ? void 0
                                : e.objects.identifyIds;
                        }
                        remove() {
                            'generated' === this.status && this.cache.remove(this.key),
                                (this.status = 'initial'),
                                this.objects.length &&
                                    (this.objects.forEach((e) => e.clean(this.mapState)),
                                    (this.objects = [])),
                                (this.ready = !1);
                        }
                        canBeRemoved() {
                            return 'initial' === this.status;
                        }
                        loadModel() {
                            const {
                                    model: {
                                        regionId: e,
                                        metatileHash: t,
                                        id: i,
                                        sourceModel: { fileName: n, matrix: o, offset: r },
                                    },
                                } = this,
                                s = (0, O.IL)(i),
                                a = {
                                    url: (0, T.Gr)('model', {
                                        host: this.mapState.tileServer,
                                        tileSet: this.mapState.tileSet,
                                        protocol: this.mapState.tileProtocol,
                                        subdomain: (0, T.Sy)(this.mapState.subdomains, n),
                                        regionId: e.toString(),
                                        name: n,
                                    }),
                                    id: s,
                                    regionId: e,
                                    metatileHash: t,
                                    selected: this.selectedIds.some((e) => (0, O.v7)(e, s)),
                                    pixelRatio: window.devicePixelRatio,
                                    styleState: this.mapState.styleState,
                                    styleId: this.mapState.handyStyleId,
                                    offset: r,
                                    matrix: o,
                                };
                            this.modules.defaultSource.generateModel(a).then((e) => {
                                this.model.prepareTextures(e.textures), (this.processResponse = e);
                            });
                        }
                        updateMinAndMaxStyleZoom(e) {
                            (this.minStyleZoom = Math.min(
                                ...e.map((e) =>
                                    Math.min(
                                        ...e.children.map((e) => {
                                            var t;
                                            const i = this.modules.styleManager.getStyleLayer(
                                                e.attributes.styleId,
                                                e.attributes.layerId,
                                            );
                                            return 'dem' === (null == i ? void 0 : i.type)
                                                ? 1 / 0
                                                : null !== (t = null == i ? void 0 : i.minzoom) &&
                                                  void 0 !== t
                                                ? t
                                                : -1 / 0;
                                        }),
                                    ),
                                ),
                            )),
                                (this.maxStyleZoom = Math.max(
                                    ...e.map((e) =>
                                        Math.max(
                                            ...e.children.map((e) => {
                                                var t;
                                                const i = this.modules.styleManager.getStyleLayer(
                                                    e.attributes.styleId,
                                                    e.attributes.layerId,
                                                );
                                                return 'dem' === (null == i ? void 0 : i.type)
                                                    ? -1 / 0
                                                    : null !==
                                                          (t = null == i ? void 0 : i.maxzoom) &&
                                                      void 0 !== t
                                                    ? t
                                                    : 1 / 0;
                                            }),
                                        ),
                                    ),
                                ));
                        }
                    }
                    function xa(e) {
                        if (e && 'matrix' in e.attributes) return e.attributes.matrix;
                    }
                    class Sa {
                        constructor(e, t, i, n, o, r) {
                            (this.modules = e),
                                (this.mapState = t),
                                (this.cache = i),
                                (this.regionId = n),
                                (this.metatileHash = o),
                                (this.sourceModel = r),
                                (this.revision = 0),
                                (this.texturesLoaded = !1),
                                (this.textures = []),
                                (this.readiness = 0),
                                (this.id = r.id),
                                (this.readinessTickerName = `model-readiness-${this.id}`);
                        }
                        update() {
                            var e, t;
                            (null === (e = this.currentMod) || void 0 === e ? void 0 : e.useful) &&
                                this.currentMod.update(),
                                (null === (t = this.newMod) || void 0 === t ? void 0 : t.useful) &&
                                    this.newMod.update(),
                                Y.Vx(
                                    this.readinessTickerName,
                                    { step: (e, t) => (this.readiness = t) },
                                    this.mapState,
                                );
                        }
                        isAnimating() {
                            return Y.rS(this.readinessTickerName, this.mapState);
                        }
                        commitMod() {
                            this.newMod &&
                                this.newMod.ready &&
                                ((this.currentMod = this.newMod), (this.newMod = void 0));
                        }
                        setUsefulMod() {
                            const e = this.mapState.handyStyleId,
                                t = this.modules.styleManager.getStyleRevision(e),
                                i = (0, O.IL)(this.id),
                                n = this.mapState.selectedIds.filter((e) => (0, O.v7)(e, i));
                            if (this.currentMod || this.newMod) {
                                if (this.currentMod) {
                                    if (
                                        (0, O.y5)(this.currentMod.selectedIds, n) &&
                                        this.currentMod.styleId === e &&
                                        this.currentMod.styleRevision === t &&
                                        this.currentMod.modelRevision === this.revision
                                    )
                                        return (
                                            (this.currentMod.useful = !0),
                                            void (this.newMod = void 0)
                                        );
                                }
                                if (this.newMod) {
                                    (0, O.y5)(this.newMod.selectedIds, n) &&
                                    this.newMod.styleId === e &&
                                    this.newMod.styleRevision === t &&
                                    this.newMod.modelRevision === this.revision
                                        ? (this.newMod.useful = !0)
                                        : this.createNewMod(n, e, t, this.revision);
                                } else this.createNewMod(n, e, t, this.revision);
                            } else this.createNewMod(n, e, t, this.revision);
                        }
                        getUsefulMod() {
                            return this.currentMod && this.currentMod.useful
                                ? this.currentMod
                                : this.newMod && this.newMod.useful
                                ? this.newMod
                                : void 0;
                        }
                        getCurrentMod() {
                            return this.currentMod;
                        }
                        setAllModsNeedless() {
                            this.currentMod && (this.currentMod.useful = !1),
                                this.newMod && (this.newMod.useful = !1);
                        }
                        getOpacity(e) {
                            return (
                                this.readiness *
                                this.modules.buildingHeightAnimator.getBuildingHeight(e)
                            );
                        }
                        getTexture(e) {
                            return this.textures[e];
                        }
                        prepareTextures(e) {
                            this.texturesLoaded ||
                                (e.isBitmap
                                    ? ((this.textures = e.data.map(
                                          (e) => new it(e, { flipY: !1 }),
                                      )),
                                      (this.texturesLoaded = !0),
                                      this.startReadinessTicker())
                                    : Promise.all(e.data.map((e) => $s(e))).then((e) => {
                                          (this.textures = e.map((e) => new it(e, { flipY: !1 }))),
                                              (this.texturesLoaded = !0),
                                              this.startReadinessTicker();
                                      }));
                        }
                        clean() {
                            this.canBeCleaned() &&
                                (this.texturesLoaded &&
                                    (this.textures.forEach((e) => e.remove()),
                                    (this.textures = []),
                                    (this.texturesLoaded = !1)),
                                this.stopReadinessTicker());
                        }
                        canBeCleaned() {
                            return (
                                (!this.currentMod || this.currentMod.canBeRemoved()) &&
                                (!this.newMod || this.newMod.canBeRemoved())
                            );
                        }
                        createNewMod(e, t, i, n) {
                            const o = (function (e, t, i, n, o) {
                                    const r = t.map((e) => `${e.lo},${e.hi}`).join('|');
                                    return `model=${e}_sId=${i}_sRev=${n}_mRev=${o}_sel=${r}`;
                                })(this.id, e, t, i, n),
                                r = this.cache.get(o);
                            r
                                ? ((this.newMod = r), (this.newMod.useful = !0))
                                : (this.newMod = new wa(
                                      this.modules,
                                      this.mapState,
                                      this.cache,
                                      this,
                                      o,
                                      e,
                                      t,
                                      i,
                                  ));
                        }
                        startReadinessTicker() {
                            (this.readiness = 0),
                                Y.BL(
                                    this.readinessTickerName,
                                    { easing: I.buildingAnimation.easing },
                                    this.mapState,
                                    0,
                                    1,
                                    I.buildingAnimation.duration,
                                );
                        }
                        stopReadinessTicker() {
                            (this.readiness = 0), Y.sT(this.readinessTickerName, this.mapState);
                        }
                    }
                    class Ia {
                        constructor(e, t) {
                            (this.mapState = e),
                                (this.modules = t),
                                (this.buildingsHeight = new Map()),
                                (this.models = new Map()),
                                (this.displayedMods = new Map()),
                                (this.viewportModels = []),
                                (this.requestedModelsInfo = new Set()),
                                (this.loadedModelsInfo = new Set()),
                                (this.isStyleUpdateInProgress = !1),
                                (this.hiddenBuildingIds = new Set()),
                                (this.cache = new ba.L(I.modelCacheSize, (e, t) => t.remove()));
                        }
                        onFeatureStateMapChange() {
                            this.models.forEach((e) => {
                                e.revision++;
                            });
                        }
                        update() {
                            this.findViewportModels(),
                                this.mapState.styleZoom > I.loadModelsInfoStyleZoom &&
                                    this.modules.tileManager.getViewportTiles().forEach((e) => {
                                        'zenith' === e.type &&
                                            e.serverMetadata &&
                                            e.serverMetadata.forEach((t) => {
                                                const i = this.modules.sourceStorage.getSourceById(
                                                    e.sourceId,
                                                );
                                                if (void 0 !== i && 'getUrl' in i) {
                                                    const e = i.getUrl('modelInfo', {
                                                        regionId: t.regionId.toString(),
                                                    });
                                                    this.loadModelsInfo(
                                                        e,
                                                        t.regionId,
                                                        t.metatileHash,
                                                    );
                                                } else {
                                                    const e = (0, T.Gr)('modelInfo', {
                                                        host: this.mapState.tileServer,
                                                        tileSet: this.mapState.tileSet,
                                                        protocol: this.mapState.tileProtocol,
                                                        subdomain: this.mapState.subdomains[0],
                                                        regionId: t.regionId.toString(),
                                                    });
                                                    this.loadModelsInfo(
                                                        e,
                                                        t.regionId,
                                                        t.metatileHash,
                                                    );
                                                }
                                            });
                                    }),
                                this.models.forEach((e) => e.setAllModsNeedless()),
                                this.viewportModels.forEach((e) => e.setUsefulMod()),
                                this.models.forEach((e) => e.update()),
                                this.isStyleUpdateInProgress ||
                                    this.models.forEach((e) => e.commitMod()),
                                this.updateScene(),
                                this.cleanUnnessasaryModels();
                        }
                        activateStyleUpdating() {
                            this.isStyleUpdateInProgress = !0;
                        }
                        finishStyleUpdating() {
                            this.isStyleUpdateInProgress = !1;
                        }
                        redraw() {
                            this.cache.reset(), this.cleanUnnessasaryModels();
                        }
                        isModelsInfoLoaded(e) {
                            return this.loadedModelsInfo.has(e);
                        }
                        getTexture(e, t) {
                            var i;
                            return null === (i = this.models.get(e)) || void 0 === i
                                ? void 0
                                : i.getTexture(t);
                        }
                        getDisplayedIdentifyData() {
                            const e = [];
                            return (
                                this.viewportModels.forEach((t) => {
                                    const i = t.getUsefulMod();
                                    if (!i) return;
                                    const n = i.getIdentifyIds();
                                    n && e.push({ metatileHash: t.metatileHash, ids: n });
                                }),
                                e
                            );
                        }
                        getOpacity(e, t) {
                            var i;
                            return (
                                (null === (i = this.models.get(e)) || void 0 === i
                                    ? void 0
                                    : i.getOpacity(t)) || 0
                            );
                        }
                        hasModel(e) {
                            return this.models.has(e);
                        }
                        setBuildingHeight(e, t) {
                            this.buildingsHeight.set(e, t);
                        }
                        getBuildingHeight(e) {
                            return this.buildingsHeight.get(e) || 0;
                        }
                        getVisibleModelData(e) {
                            const t = this.models.get(e);
                            if (!t) return;
                            const i = t.getCurrentMod();
                            if (!i || !i.ready) return;
                            const n = Math.max(t.sourceModel.minZoom, i.minStyleZoom),
                                o = Math.min(t.sourceModel.maxZoom, i.maxStyleZoom),
                                { styleZoom: r } = this.mapState;
                            return r < n || r >= o
                                ? void 0
                                : {
                                      minStyleZoom: n,
                                      maxStyleZoom: o,
                                      opacity: this.getOpacity(e, n),
                                  };
                        }
                        isIdle() {
                            return (
                                this.viewportModelsReady() &&
                                !this.viewportModels.some((e) => e.isAnimating())
                            );
                        }
                        viewportModelsReady() {
                            return this.viewportModels.every((e) => {
                                const t = e.getUsefulMod();
                                return t && t.ready;
                            });
                        }
                        setHiddenBuildingIds(e) {
                            e.forEach((e) => {
                                this.hiddenBuildingIds.add(e);
                            });
                        }
                        unsetHiddenBuildingIds(e) {
                            e.forEach((e) => {
                                this.hiddenBuildingIds.delete(e);
                            });
                        }
                        findViewportModels() {
                            const { styleZoom: e } = this.mapState;
                            (this.viewportModels = []),
                                this.models.forEach((t) => {
                                    const { bound: i, minZoom: n, maxZoom: o } = t.sourceModel;
                                    if (e < n || e >= o) return;
                                    if (this.modules.floorManager.hasDisplayedFloorBuilding(t.id))
                                        return;
                                    if (!!!this.modules.assetManager.getMetatile(t.metatileHash))
                                        return;
                                    if (this.hiddenBuildingIds.has(t.id)) return;
                                    (0, Oi.M4)(this.mapState.tilesBounds, i) &&
                                        this.viewportModels.push(t);
                                });
                        }
                        updateScene() {
                            let e = !1;
                            const t = new Map();
                            this.viewportModels.forEach((e) => {
                                const i = e.getCurrentMod();
                                i && i.ready && t.set(i.key, i);
                            }),
                                this.displayedMods.forEach((i, n) => {
                                    t.has(n) ||
                                        (i.objects.length &&
                                            i.objects.forEach((e) =>
                                                this.modules.tileManager.removeObject(e),
                                            ),
                                        (e = !0));
                                }),
                                t.forEach((t, i) => {
                                    this.displayedMods.has(i) ||
                                        (t.objects.length &&
                                            t.objects.forEach((e) =>
                                                this.modules.tileManager.addObject(e),
                                            ),
                                        (e = !0)),
                                        this.cache.get(i);
                                }),
                                e &&
                                    ((this.displayedMods = t),
                                    (this.mapState.needRerender = !0),
                                    this.modules.identifier.resetCache());
                        }
                        cleanUnnessasaryModels() {
                            const e = new Set(this.cache.getData().map((e) => e.model));
                            this.models.forEach((t) => {
                                e.has(t) || t.clean();
                            });
                        }
                        loadModelsInfo(e, t, i) {
                            this.requestedModelsInfo.has(t) ||
                                (this.requestedModelsInfo.add(t),
                                fetch(e)
                                    .then((e) => {
                                        if (!e.ok)
                                            throw new Error(
                                                `Failed to load models info for region ${t}`,
                                            );
                                        return e.json();
                                    })
                                    .then((e) => {
                                        this.modules.workers.parser.appendHiddenObjectIds(
                                            e.map((e) => (0, O.IL)(e.id)),
                                        ),
                                            e.forEach((e) => {
                                                const n = new Sa(
                                                    this.modules,
                                                    this.mapState,
                                                    this.cache,
                                                    t,
                                                    i,
                                                    e,
                                                );
                                                this.models.set(n.id, n);
                                            }),
                                            this.loadedModelsInfo.add(t);
                                    })
                                    .catch((e) => {
                                        this.loadedModelsInfo.add(t), console.error(e);
                                    }));
                        }
                    }
                    var Ma = i(7204),
                        Ta = i(2153);
                    class Pa {
                        constructor(e, t) {
                            (this.mapState = e),
                                (this.modules = t),
                                (this.isIdle = () => !this.isGenerating),
                                (this.modCache = new Map()),
                                (this.isGenerating = !1),
                                (this.currentPois = []),
                                (this.currentIdSet = new Ma.c()),
                                (this.currentTrafficState = !1),
                                (this.currentSelectedIds = []),
                                (this.currentModKey = La(
                                    this.currentTrafficState,
                                    this.currentSelectedIds,
                                ));
                        }
                        setPersonalPoi(e) {
                            this.currentPois = e;
                            const t = new Ma.c();
                            for (const i of e) t.add((0, O.IL)(i.id));
                            (this.currentIdSet = t),
                                this.modCache.clear(),
                                (this.displayedModKey = void 0);
                        }
                        redraw() {
                            this.modCache.clear(), (this.displayedModKey = void 0);
                        }
                        getIdentifyDataChunk() {
                            return this.identifyDataChunk;
                        }
                        update() {
                            if (
                                (void 0 === this.regionMetadata &&
                                    (this.regionMetadata =
                                        this.modules.assetManager.getProjectMetadata()),
                                void 0 === this.regionMetadata)
                            )
                                return;
                            this.updateModKey();
                            const e = this.currentModKey,
                                t = this.modCache.get(e);
                            void 0 !== t ||
                                this.isGenerating ||
                                this.generate(e, this.currentPois, this.regionMetadata),
                                void 0 !== t &&
                                    e !== this.displayedModKey &&
                                    this.show(e, t, this.regionMetadata);
                        }
                        generate(e, t, i) {
                            const { regionId: n, metatileHash: o } = i,
                                r = this.modules.map.state;
                            (this.isGenerating = !0),
                                this.modules.workers.parser
                                    .generatePersonalPoi(
                                        t,
                                        n,
                                        o,
                                        window.devicePixelRatio,
                                        r.selectedIds,
                                        r.handyStyleId,
                                        r.styleState,
                                        this.modules.defaultSource.getId(),
                                    )
                                    .then((t) => {
                                        if (void 0 === t) return void (this.isGenerating = !1);
                                        const { collectorOutput: i, styleId: n } = t,
                                            { packedRasters: o, rastersToLoad: r } = i;
                                        void 0 !== o &&
                                            this.modules.assetManager.prepareRasters(n, o),
                                            this.modules.assetManager.loadRasters(r),
                                            this.modCache.set(e, t),
                                            (this.isGenerating = !1);
                                    });
                        }
                        show(e, t, i) {
                            const { metatileHash: n } = i,
                                {
                                    collectorOutput: { labels: o, identifyIds: r },
                                    styleId: s,
                                } = t;
                            this.modules.labeler.removeLabels('ppoi'),
                                o.length &&
                                    this.modules.labeler.addLabels('ppoi', Ta.AL.PersonalPoi, [
                                        { metatileHash: n, labels: o, styleId: s },
                                    ]),
                                (this.identifyDataChunk = { metatileHash: n, ids: r }),
                                this.modules.identifier.resetCache(),
                                (this.displayedModKey = e);
                        }
                        updateModKey() {
                            const e = (0, G.vX)(this.mapState.selectedIds, this.currentIdSet),
                                t = this.modules.trafficTileLayer.isEnabled();
                            ((0, O.y5)(this.currentSelectedIds, e) &&
                                this.currentTrafficState === t) ||
                                ((this.currentTrafficState = t),
                                (this.currentSelectedIds = e),
                                (this.currentModKey = La(t, e)));
                        }
                    }
                    function La(e, t) {
                        return `ppoi_${e}_${t.map((e) => `${e.lo},${e.hi}`).join('|')}`;
                    }
                    const ka = function () {
                        var e = ENTRY_MODULE,
                            t = {};
                        function i(n) {
                            if (t[n]) return t[n].exports;
                            var o = (t[n] = { exports: {} });
                            return e[n](o, o.exports, i), o.exports;
                        }
                        (i.m = e),
                            (i.n = (e) => {
                                var t = e && e.__esModule ? () => e.default : () => e;
                                return i.d(t, { a: t }), t;
                            }),
                            (i.d = (e, t) => {
                                for (var n in t)
                                    i.o(t, n) &&
                                        !i.o(e, n) &&
                                        Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
                            }),
                            (i.g = (function () {
                                if ('[object Object]' === Object.prototype.toString.call(self))
                                    return self;
                                try {
                                    return this || new Function('return this')();
                                } catch (e) {
                                    if (
                                        '[object Object]' === Object.prototype.toString.call(window)
                                    )
                                        return window;
                                }
                            })()),
                            (i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
                            (i.r = (e) => {
                                'undefined' != typeof Symbol &&
                                    Symbol.toStringTag &&
                                    Object.defineProperty(e, Symbol.toStringTag, {
                                        value: 'Module',
                                    }),
                                    Object.defineProperty(e, '__esModule', { value: !0 });
                            });
                        var n = i(ENTRY_MODULE);
                        return n.default || n;
                    };
                    ka.toString();
                    var Ea = '[\\.|\\-|\\+|\\w|/|@]+',
                        Aa = '\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)';
                    function za(e) {
                        return (e + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
                    }
                    function Ca(e, t, n) {
                        var o = {};
                        o[n] = [];
                        var r = t.toString(),
                            s =
                                r.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) ||
                                r.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
                        if (!s) return o;
                        for (
                            var a, l = s[1], c = new RegExp('(\\\\n|\\W)' + za(l) + Aa, 'g');
                            (a = c.exec(r));

                        )
                            'dll-reference' !== a[3] && o[n].push(a[3]);
                        for (
                            c = new RegExp(
                                '\\(' + za(l) + '\\("(dll-reference\\s(' + Ea + '))"\\)\\)' + Aa,
                                'g',
                            );
                            (a = c.exec(r));

                        )
                            e[a[2]] || (o[n].push(a[1]), (e[a[2]] = i(a[1]).m)),
                                (o[a[2]] = o[a[2]] || []),
                                o[a[2]].push(a[4]);
                        for (var d, h = Object.keys(o), u = 0; u < h.length; u++)
                            for (var m = 0; m < o[h[u]].length; m++)
                                (d = o[h[u]][m]), isNaN(1 * d) || (o[h[u]][m] = 1 * o[h[u]][m]);
                        return o;
                    }
                    function Fa(e) {
                        return Object.keys(e).reduce((t, i) => t || e[i].length > 0, !1);
                    }
                    function Oa(e, t, i, n) {
                        let o = e[n].map((e) => `"${e}": ${t[n][e].toString()}`).join(','),
                            r = ka.toString().split('ENTRY_MODULE');
                        return `${r[0]}{${o}}${r[1]}"${i}"${r[2]}`;
                    }
                    function Da(e, t) {
                        t = t || {};
                        var n = { main: i.m },
                            o = t.all
                                ? { main: Object.keys(n.main) }
                                : (function (e, t) {
                                      for (
                                          var i = { main: [t] }, n = { main: [] }, o = { main: {} };
                                          Fa(i);

                                      )
                                          for (var r = Object.keys(i), s = 0; s < r.length; s++) {
                                              var a = r[s],
                                                  l = i[a].pop();
                                              if (((o[a] = o[a] || {}), !o[a][l] && e[a][l])) {
                                                  (o[a][l] = !0), (n[a] = n[a] || []), n[a].push(l);
                                                  for (
                                                      var c = Ca(e, e[a][l], a),
                                                          d = Object.keys(c),
                                                          h = 0;
                                                      h < d.length;
                                                      h++
                                                  )
                                                      (i[d[h]] = i[d[h]] || []),
                                                          (i[d[h]] = i[d[h]].concat(c[d[h]]));
                                              }
                                          }
                                      return n;
                                  })(n, e),
                            r = '';
                        Object.keys(o)
                            .filter((e) => 'main' !== e)
                            .forEach((e) => {
                                for (var t = 0; o[e][t]; ) t++;
                                o[e].push(t),
                                    (n[e][t] =
                                        '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'),
                                    (r += `var ${e} = (${Oa(o, n, t, modules)})();\n`);
                            }),
                            (r += `(${Oa(o, n, e, 'main')})();`);
                        var s = new window.Blob([r], { type: 'text/javascript' });
                        if (t.bare) return s;
                        var a = (
                                window.URL ||
                                window.webkitURL ||
                                window.mozURL ||
                                window.msURL
                            ).createObjectURL(s),
                            l = new window.Worker(a);
                        return (l.objectURL = a), l;
                    }
                    var Ra = i(7256),
                        ja = i(4500),
                        Ba = i(5549),
                        Na = i(4411),
                        Ua = i(2176),
                        Za = i(603);
                    class Ha {
                        constructor() {
                            (this.connector = new Ra.H()),
                                (this.fnRegistry = new ja.J(this.connector)),
                                (this.classRegistry = new Na.Z(this.fnRegistry)),
                                (this.parserWorker = Da(249)),
                                this.connector.addWorker(Ba.P.Parser, this.parserWorker),
                                (this.labelingWorker = Da(4009)),
                                this.connector.addWorker(Ba.P.Labeling, this.labelingWorker),
                                (this.parser = (function (e, t) {
                                    return {
                                        setMetatile: e.get(Ba.P.Parser, 'setMetatile'),
                                        generateFloor: e.get(Ba.P.Parser, 'generateFloor'),
                                        loadFloor: e.get(Ba.P.Parser, 'loadFloor'),
                                        appendHiddenObjectIds: e.get(
                                            Ba.P.Parser,
                                            'appendHiddenObjectIds',
                                        ),
                                        removeHiddenObjectIds: e.get(
                                            Ba.P.Parser,
                                            'removeHiddenObjectIds',
                                        ),
                                        prepareAtlas: e.get(Ba.P.Parser, 'prepareAtlas'),
                                        packRasters: e.get(Ba.P.Parser, 'packRasters'),
                                        fetchTrafficTile: e.get(Ba.P.Parser, 'fetchTrafficTile'),
                                        deleteTrafficTile: e.get(Ba.P.Parser, 'deleteTrafficTile'),
                                        abortTrafficTileRequest: e.get(
                                            Ba.P.Parser,
                                            'abortTrafficTileRequest',
                                        ),
                                        generateTrafficTile: e.get(
                                            Ba.P.Parser,
                                            'generateTrafficTile',
                                        ),
                                        generatePersonalPoi: e.get(
                                            Ba.P.Parser,
                                            'generatePersonalPoi',
                                        ),
                                        syncStyle: e.get(Ba.P.Parser, 'syncStyle'),
                                        loadModel: e.get(Ba.P.Parser, 'loadModel'),
                                        GeoJsonSource: t
                                            .set('GeoJsonSource', Ua.T)
                                            .get(Ba.P.Parser),
                                        ZenithSource: t.set('ZenithWorker', Za.Z).get(Ba.P.Parser),
                                    };
                                })(this.fnRegistry, this.classRegistry)),
                                (this.labeling = (function (e) {
                                    return {
                                        setCommercialPoiRandomSeed: e.get(
                                            Ba.P.Labeling,
                                            'setComPoiRandomSeed',
                                        ),
                                        appendFont: e.get(Ba.P.Labeling, 'appendFont'),
                                        markFontAsLoaded: e.get(Ba.P.Labeling, 'markFontAsLoaded'),
                                        addNewRasterSets: e.get(Ba.P.Labeling, 'addNewRasterSets'),
                                        updatePackingInfo: e.get(
                                            Ba.P.Labeling,
                                            'updatePackingInfo',
                                        ),
                                        syncStyle: e.get(Ba.P.Labeling, 'syncStyle'),
                                        loadRtlPlugin: e.get(Ba.P.Labeling, 'loadRtlPlugin'),
                                        markRtlPluginLoaded: e.get(
                                            Ba.P.Labeling,
                                            'markRtlPluginLoaded',
                                        ),
                                    };
                                })(this.fnRegistry));
                        }
                        destroy() {
                            this.parserWorker.terminate(), this.labelingWorker.terminate();
                        }
                    }
                    class Ga extends k.c {
                        constructor(e, t) {
                            super(),
                                (this.demElevation = 0),
                                (this.demTilesRevision = NaN),
                                (this.options = (0, fe.kn)(t, Ga.options)),
                                (this.uniqId = (0, E.f)()),
                                (this.labelKey = `html-${this.uniqId}`),
                                (this.mapPoint = (0, L.yq)(this.options.coordinates)),
                                (this.screenPoint = [0, 0]),
                                (this.html = (function (e) {
                                    const t = document.createElement('div');
                                    (t.style.position = 'absolute'),
                                        (t.style.top = '0'),
                                        (t.style.left = '0'),
                                        (t.style.zIndex = String(e.zIndex)),
                                        e.interactive || (t.style.pointerEvents = 'none');
                                    e.animate &&
                                        ((t.style.opacity = '0'),
                                        (t.style.transition = `opacity ${e.duration}ms`),
                                        (t.style.willChange = 'opacity'));
                                    const i = document.createElement('div');
                                    'string' == typeof e.html
                                        ? (i.innerHTML = e.html)
                                        : i.append(e.html);
                                    return t.append(i), t;
                                })(this.options)),
                                (this.isHidden = !0),
                                (this.targetOpacity = 0),
                                (this.modules = e.modules),
                                this.modules.layers.addLayer(this),
                                (this.mapState = e.state),
                                (this.rounder = !this.options.disableRounding ? Va : Wa);
                            const { offset: i, labeling: n } = this.options;
                            'none' !== n.type &&
                                this.modules.labeler.addLabelBox(this.labelKey, {
                                    id: this.uniqId,
                                    width: n.width,
                                    height: n.height,
                                    position: this.mapPoint,
                                    offset: i,
                                    labelingGroup: this.getLabelingGroup(),
                                    parentPoiId: 'pinnedToPoi' === n.type ? n.poiId : void 0,
                                });
                        }
                        destroy() {
                            this.removeHtml(),
                                this.modules.labeler.removeLabels(this.labelKey),
                                this.modules.layers.removeLayer(this);
                        }
                        update() {
                            const e = this.checkZoom(),
                                t =
                                    !this.isInvolvedInLabeling() ||
                                    this.modules.labeler.isLabelBoxSurvived(this.uniqId);
                            e && t ? this.show() : this.hide(), this.updatePosition();
                        }
                        setContent(e) {
                            (this.options.html = e), (this.html.innerHTML = '');
                            const t = document.createElement('div');
                            'string' == typeof e ? (t.innerHTML = e) : t.append(e),
                                this.html.append(t);
                        }
                        setLabelingSize(e, t) {
                            'none' !== this.options.labeling.type &&
                                ((this.options.labeling.width = e),
                                (this.options.labeling.height = t),
                                this.updateLabelBox());
                        }
                        setPosition(e) {
                            (this.mapPoint = (0, L.yq)(e)), this.updateLabelBox();
                        }
                        setOffset(e) {
                            (this.options.offset = [e[0], e[1]]), this.updateLabelBox();
                        }
                        setMinZoom(e) {
                            this.options.minZoom = e;
                        }
                        setMaxZoom(e) {
                            this.options.maxZoom = e;
                        }
                        getZIndex() {
                            return this.options.zIndex;
                        }
                        getOffset() {
                            return this.options.offset;
                        }
                        getPosition() {
                            return (0, L.PA)(this.mapPoint);
                        }
                        getHtmlElement() {
                            return this.html.firstChild;
                        }
                        dangerouslyGetRootElement() {
                            return this.html;
                        }
                        isShown() {
                            return !this.isHidden;
                        }
                        show() {
                            if (
                                this.isHidden &&
                                ((this.isHidden = !1),
                                this.appendHtml(),
                                this.emit('shown', {
                                    id: this.uniqId.toString(),
                                    point: [this.screenPoint[0], this.screenPoint[1]],
                                    object: this,
                                }),
                                this.options.animate)
                            ) {
                                if (this.showAnimationTimer) return;
                                this.hideAnimationTimer &&
                                    (clearTimeout(this.hideAnimationTimer),
                                    (this.hideAnimationTimer = void 0)),
                                    1 !== this.targetOpacity &&
                                        (this.showAnimationTimer = window.setTimeout(() => {
                                            this.setHtmlOpacity(1),
                                                (this.showAnimationTimer = void 0);
                                        }, 0));
                            }
                        }
                        hide() {
                            if (!this.isHidden)
                                if (((this.isHidden = !0), this.options.animate)) {
                                    if (this.hideAnimationTimer) return;
                                    this.showAnimationTimer &&
                                        (clearTimeout(this.showAnimationTimer),
                                        (this.showAnimationTimer = void 0)),
                                        this.setHtmlOpacity(0),
                                        (this.hideAnimationTimer = window.setTimeout(() => {
                                            this.removeHtml(), (this.hideAnimationTimer = void 0);
                                        }, this.options.duration));
                                } else this.removeHtml();
                        }
                        setHtmlOpacity(e) {
                            (this.html.style.opacity = String(e)), (this.targetOpacity = e);
                        }
                        removeHtml() {
                            this.html.remove(), (this.screenPoint = [0, 0]);
                        }
                        appendHtml() {
                            this.getMarkerContainer().appendChild(this.html);
                        }
                        getMarkerContainer() {
                            return this.options.preventMapInteractions
                                ? this.modules.layout.htmlContainerOutMap
                                : this.modules.layout.htmlContainerInMap;
                        }
                        updatePosition() {
                            var e, t, i;
                            const n = this.modules.demManager,
                                o = this.mapState;
                            let r = 0;
                            if (o.demMode) {
                                const i = n.getTilesRevision();
                                this.demTilesRevision !== i &&
                                    ((this.demElevation =
                                        null !== (e = n.getElevation(this.mapPoint)) && void 0 !== e
                                            ? e
                                            : 0),
                                    (this.demTilesRevision = i)),
                                    (r =
                                        (this.demElevation -
                                            (null !== (t = o.elevation) && void 0 !== t ? t : 0)) *
                                        o.elevationScale);
                            }
                            const s = [
                                    this.mapPoint[0],
                                    this.mapPoint[1],
                                    ((null !== (i = this.mapPoint[2]) && void 0 !== i ? i : 0) +
                                        r) *
                                        L.C,
                                ],
                                a = this.modules.camera.project(s);
                            this.rounder(
                                a,
                                a[0] + this.options.offset[0],
                                a[1] + this.options.offset[1],
                                this.mapState.stillness,
                            ),
                                z.fS(this.screenPoint, a) ||
                                    ((this.html.style.transform = `translate3d(${a[0]}px, ${a[1]}px, 0px)`),
                                    (this.screenPoint = a));
                        }
                        updateLabelBox() {
                            if ('none' === this.options.labeling.type) return;
                            const {
                                labeling: { width: e, height: t },
                                offset: i,
                            } = this.options;
                            this.modules.labeler.removeLabels(this.labelKey),
                                this.modules.labeler.addLabelBox(this.labelKey, {
                                    id: this.uniqId,
                                    width: e,
                                    height: t,
                                    position: this.mapPoint,
                                    offset: i,
                                    labelingGroup: this.getLabelingGroup(),
                                    parentPoiId:
                                        'pinnedToPoi' === this.options.labeling.type
                                            ? this.options.labeling.poiId
                                            : void 0,
                                });
                        }
                        getLabelingGroup() {
                            return this.isInvolvedInLabeling() ? 'markerText' : 'htmlLabel';
                        }
                        checkZoom() {
                            const { zoom: e } = this.mapState,
                                { minZoom: t, maxZoom: i } = this.options;
                            return e >= t && e < i;
                        }
                        isInvolvedInLabeling() {
                            return (
                                'full' === this.options.labeling.type ||
                                'pinnedToPoi' === this.options.labeling.type
                            );
                        }
                    }
                    Ga.options = {
                        coordinates: [0, 0],
                        html: '',
                        offset: [0, 0],
                        animate: !0,
                        duration: 500,
                        labeling: { type: 'none' },
                        interactive: !0,
                        preventMapInteractions: !1,
                        zIndex: 0,
                        minZoom: -1 / 0,
                        maxZoom: 1 / 0,
                        disableRounding: !1,
                    };
                    const Va = (e, t, i, n) => {
                            const o = Math.round(t) - t,
                                r = Math.round(i) - i;
                            (e[0] = t + n * o), (e[1] = i + n * r);
                        },
                        Wa = (e, t, i) => {
                            (e[0] = t), (e[1] = i);
                        };
                    var qa = i(4389);
                    const $a = D.Ue();
                    class Xa extends A {
                        constructor(e, t) {
                            var i, n, o, r, s, a, l;
                            super(e),
                                (this.options = t),
                                (this.vectors = this.options.coordinates.map((e) => e.map(L.yq))),
                                (this.bouncePosition = 0),
                                (this.growPosition = 1);
                            const {
                                    renderer: c,
                                    tileManager: d,
                                    dynamicStyle: h,
                                    collector: u,
                                    layers: m,
                                } = this.modules,
                                f = (0, W.qw)({
                                    type: 'arrow',
                                    id: `dynamic-entrance-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color:
                                            null !== (i = this.options.color) && void 0 !== i
                                                ? i
                                                : '#0085a0',
                                        strokeColor:
                                            null !== (n = this.options.borderColor) && void 0 !== n
                                                ? n
                                                : '#ffffff',
                                        lineWidth:
                                            null !== (o = this.options.width) && void 0 !== o
                                                ? o
                                                : 3,
                                        strokeWidth:
                                            null !== (r = this.options.borderWidth) && void 0 !== r
                                                ? r
                                                : 1,
                                        tipWidth:
                                            null !== (s = this.options.wingWidthMultiplier) &&
                                            void 0 !== s
                                                ? s
                                                : 2,
                                        tipHeight:
                                            null !== (a = this.options.tipHeightMultiplier) &&
                                            void 0 !== a
                                                ? a
                                                : 4,
                                        animation:
                                            null === (l = this.options.animate) || void 0 === l || l
                                                ? {
                                                      type: 'appearance',
                                                      tipMovementAmplitude:
                                                          this.options.tipMovementAmplitude || 20,
                                                  }
                                                : void 0,
                                    },
                                });
                            if (!f) return;
                            h.addLayer(f, this.options.zIndex), (this.layerId = f.innerId);
                            const p = this.getTileInfo(),
                                _ = (0, V.FJ)({ id: [0, 0] }),
                                v = (0, $.Yi)(this.mapState.styleState, P.i4, P.Dz, _, P.wz);
                            for (let e = 0; e < this.vectors.length; e++) {
                                const t = this.vectors[e],
                                    i = this.getVertices(t, p);
                                (_[P.Dz.id] = [e, 0]),
                                    (0, H.XI)({
                                        collector: u,
                                        generator: qa.l.generate,
                                        args: [h.getStyle().id, f, v, i],
                                    });
                            }
                            const g = u.getAccumulatedData(),
                                y = new C.W('dynamicObject', g.data, c, p.coords, this);
                            if (
                                (this.tileObjects.push(y),
                                d.addObject(y),
                                this.identifyIds.push(g.identifyIds),
                                this.options.animate)
                            ) {
                                const e = `entrance-bounce-${this.uniqId}`,
                                    t = `entrance-grow-${this.uniqId}`;
                                (this.bounceTickerUpdate = Y.Vx.bind(
                                    null,
                                    e,
                                    {
                                        step: (e, t) => (this.bouncePosition = t),
                                        complete: () => {
                                            this.bounceTickerUpdate = void 0;
                                        },
                                    },
                                    this.mapState,
                                )),
                                    (this.growTickerUpdate = Y.Vx.bind(
                                        null,
                                        t,
                                        {
                                            step: (e, t) => (this.growPosition = t),
                                            complete: () => {
                                                this.growTickerUpdate = void 0;
                                            },
                                        },
                                        this.mapState,
                                    )),
                                    Y.BL(
                                        e,
                                        { easing: I.entranceAnimation.bounceType },
                                        this.mapState,
                                        -1,
                                        0,
                                        I.entranceAnimation.bounceTime,
                                    ),
                                    Y.BL(
                                        t,
                                        { easing: I.entranceAnimation.growType },
                                        this.mapState,
                                        0,
                                        1,
                                        I.entranceAnimation.growTime,
                                    );
                            } else (this.bouncePosition = 0), (this.growPosition = 1);
                            m.addLayer(this), u.reset(), (this.mapState.needRerender = !0);
                        }
                        update() {
                            this.bounceTickerUpdate && this.bounceTickerUpdate(),
                                this.growTickerUpdate && this.growTickerUpdate();
                        }
                        entranceAnimationInProgress() {
                            return (
                                void 0 !== this.bounceTickerUpdate ||
                                void 0 !== this.growTickerUpdate
                            );
                        }
                        remove() {
                            void 0 !== this.layerId &&
                                this.modules.dynamicStyle.removeLayer(this.layerId),
                                super.destroy();
                        }
                        getTileInfo() {
                            const e = ee.Ue();
                            for (let t = 0; t < this.vectors.length; t++) {
                                const i = this.vectors[t];
                                for (let t = 0; t < i.length; t++) ee.aM(e, i[t]);
                            }
                            return (0, G.Bs)((0, G.x7)(e));
                        }
                        getVertices(e, t) {
                            const i = [[], [], []];
                            for (let n = 0; n < e.length; n++)
                                (0, G.a2)($a, e[n], t), (i[0][n] = $a[0]), (i[1][n] = $a[1]);
                            return i;
                        }
                    }
                    class Ya {
                        constructor(e) {
                            (this.state = e), (this.layers = []);
                        }
                        addLayer(e) {
                            this.layers.push(e), (this.state.needRerender = !0);
                        }
                        removeLayer(e) {
                            const t = this.layers.indexOf(e);
                            -1 !== t && (this.layers.splice(t, 1), (this.state.needRerender = !0));
                        }
                        getLayers() {
                            return this.layers;
                        }
                        getDynamicObjectLayers() {
                            return this.layers.filter((e) => e instanceof A);
                        }
                        getHtmlMarkers() {
                            return this.layers.filter((e) => e instanceof Ga);
                        }
                        entranceAnimationFinished() {
                            return this.layers.every(
                                (e) => !(e instanceof Xa) || !e.entranceAnimationInProgress(),
                            );
                        }
                    }
                    const Ka = () => '',
                        Ja = [0.5, 0.5];
                    class Qa {
                        constructor(e) {
                            (this.loadingCounter = 0),
                                (this.isIdle = () => 0 === this.loadingCounter),
                                (this.modules = e),
                                (this.cache = {});
                        }
                        getRasterSet(e, t, i, n) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const o = this.getKey(e, i, n),
                                    r = this.getFromCache(o, t);
                                if (r) return r;
                                const s = yield this.loadIcon(e, t, i, n);
                                return s && this.storeInCache(s, o, t), s;
                            });
                        }
                        decreaseLoadingCounter() {
                            this.loadingCounter = Math.max(this.loadingCounter - 1, 0);
                        }
                        loadIcon(e, t, i, n) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const {
                                    dynamicStyle: o,
                                    workers: r,
                                    assetManager: s,
                                } = this.modules;
                                let a = e;
                                this.loadingCounter++,
                                    t &&
                                        (a = yield this.loadImageForTransformer(e)
                                            .then((e) => t(e))
                                            .catch(() => e));
                                const l = yield this.loadImage(a);
                                return l
                                    ? Promise.resolve()
                                          .then(() => {
                                              i = void 0 !== i ? i : [l.width, l.height];
                                              const e =
                                                      void 0 !== n
                                                          ? [n[0] / i[0], n[1] / i[1]]
                                                          : Ja,
                                                  t = [
                                                      i[0] * window.devicePixelRatio,
                                                      i[1] * window.devicePixelRatio,
                                                  ],
                                                  s = (0, Fr.W8)([
                                                      {
                                                          w: t[0],
                                                          h: t[1],
                                                          x: 0,
                                                          y: 0,
                                                          atlasIndex: 0,
                                                          isPacked: !1,
                                                          anchorX: e[0],
                                                          anchorY: e[1],
                                                      },
                                                  ]);
                                              o.appendRasterSet(s),
                                                  r.labeling.addNewRasterSets(o.getStyle().id, [s]);
                                              const a = new Uint16Array(3);
                                              return (
                                                  (a[0] = t[0]),
                                                  (a[1] = t[1]),
                                                  (a[2] = s.index),
                                                  r.parser
                                                      .packRasters(a)
                                                      .then((e) => ({
                                                          packedRasters: e.packedRasters,
                                                          rasterSet: s,
                                                          scaledSize: t,
                                                      }))
                                              );
                                          })
                                          .then((e) => {
                                              const {
                                                  packedRasters: t,
                                                  rasterSet: i,
                                                  scaledSize: n,
                                              } = e;
                                              return (
                                                  void 0 !== t &&
                                                      s.prepareRasters(o.getStyle().id, t, [
                                                          Xs(l, n),
                                                      ]),
                                                  this.decreaseLoadingCounter(),
                                                  i
                                              );
                                          })
                                    : (this.decreaseLoadingCounter(), Promise.resolve(void 0));
                            });
                        }
                        getFromCache(e, t) {
                            const i = this.cache[e];
                            if (i) return i.get(t || Ka);
                        }
                        storeInCache(e, t, i) {
                            this.cache[t] || (this.cache[t] = new Map()),
                                this.cache[t].set(i || Ka, e);
                        }
                        getKey(e, t, i) {
                            return `${e}_${void 0 !== t ? `${t[0]},${t[1]}` : ''}_${
                                void 0 !== i ? `${i[0]},${i[1]}` : ''
                            }`;
                        }
                        loadImage(e) {
                            return new Promise((t) => {
                                const i = new Image();
                                (i.crossOrigin = 'Anonymous'),
                                    (i.src = e),
                                    (i.onload = () => t(i)),
                                    (i.onerror = () => t(void 0));
                            });
                        }
                        loadImageForTransformer(e) {
                            return -1 === e.indexOf('.svg')
                                ? new Promise((t) => {
                                      const i = new Image();
                                      (i.crossOrigin = 'Anonymous'),
                                          (i.src = e),
                                          (i.onload = () => {
                                              t({ type: 'raster', source: i });
                                          }),
                                          (i.onerror = () => {
                                              t({ type: 'unknown' });
                                          });
                                  })
                                : new Promise((t) => {
                                      const i = new XMLHttpRequest();
                                      i.open('GET', e, !0),
                                          (i.onload = function () {
                                              200 === i.status && 0 !== i.response.byteLength
                                                  ? t({ type: 'vector', source: i.response })
                                                  : t({ type: 'unknown' });
                                          }),
                                          (i.onerror = function () {
                                              t({ type: 'unknown' });
                                          }),
                                          i.send();
                                  });
                        }
                    }
                    class el {
                        constructor(e, t, i, n, o, r, s, a, l, c, d, h) {
                            (this.key = i),
                                (this.id = n),
                                (this.object = void 0),
                                (this.ready = !1),
                                (this.modules = e),
                                (this.mapState = t),
                                (this.status = 'initial'),
                                (this.regionId = o),
                                (this.metatileHash = rt.DL),
                                (this.styleId = r),
                                (this.styleRevision = s),
                                (this.floorIndex = a),
                                (this.cache = l),
                                (this.onGenerated = h),
                                (this.useful = !0),
                                (this.selectedIds = c.slice(0)),
                                (this.needFilterIds = d);
                        }
                        update() {
                            switch (this.status) {
                                case 'initial':
                                    this.useful &&
                                        (this.modules.workers.parser
                                            .generateFloor(
                                                this.id,
                                                this.regionId,
                                                window.devicePixelRatio,
                                                this.floorIndex,
                                                this.selectedIds,
                                                this.styleId,
                                                this.mapState.styleState,
                                                this.modules.defaultSource.getId(),
                                                this.mapState.mobileSdkMode,
                                            )
                                            .then((e) => {
                                                const {
                                                    collectorOutput: { packedRasters: t },
                                                    styleId: i,
                                                } = e;
                                                t && this.modules.assetManager.prepareRasters(i, t),
                                                    (this.processResponse = e);
                                            }),
                                        (this.status = 'generating'));
                                    break;
                                case 'generating':
                                    if (this.useful && this.processResponse) {
                                        const {
                                            collectorOutput: { data: e },
                                            tileCoords: t,
                                        } = this.processResponse;
                                        (this.object = new C.W(
                                            'floor',
                                            e,
                                            this.modules.renderer,
                                            t,
                                        )),
                                            (this.status = 'generated'),
                                            (this.ready = !0),
                                            this.cache.add(this.key, this),
                                            this.onGenerated(this);
                                    }
                            }
                        }
                        getLabels() {
                            return this.processResponse &&
                                this.processResponse.collectorOutput.labels.length
                                ? [
                                      {
                                          metatileHash: this.metatileHash,
                                          labels: this.processResponse.collectorOutput.labels,
                                          styleId: this.processResponse.styleId,
                                      },
                                  ]
                                : [];
                        }
                        getGeoIds() {
                            if (this.processResponse)
                                return this.processResponse.collectorOutput.geoIds;
                        }
                        canBeRemoved() {
                            return 'initial' === this.status;
                        }
                        remove() {
                            'generated' === this.status && this.cache.remove(this.key),
                                (this.status = 'initial'),
                                this.object && this.object.clean(this.mapState),
                                (this.ready = !1);
                        }
                        getIdentifyIds() {
                            if (this.processResponse) {
                                const e = {};
                                return (
                                    (e[this.metatileHash] =
                                        this.processResponse.collectorOutput.identifyIds),
                                    e
                                );
                            }
                        }
                        isDataEmpty() {
                            return (
                                !this.processResponse ||
                                0 === this.processResponse.collectorOutput.data.length
                            );
                        }
                    }
                    class tl {
                        constructor(e, t, i, n, o, r) {
                            (this.onModGenerated = (e) => {
                                let t = this.idSetByFloorIndex.get(e.floorIndex);
                                if (!t) {
                                    t = new Ma.c();
                                    const i = e.getGeoIds();
                                    i && t.addFromFlatArray(i),
                                        this.idSetByFloorIndex.set(e.floorIndex, t);
                                }
                                e.needFilterIds &&
                                    ((e.needFilterIds = !1),
                                    (e.selectedIds = (0, G.vX)(e.selectedIds, t)));
                            }),
                                (this.modules = e),
                                (this.mapState = t),
                                (this.id = i),
                                (this.regionId = n),
                                (this.idSetByFloorIndex = new Map()),
                                (this.cache = o),
                                (this.floorIndex = r),
                                this.createNewMod(
                                    r,
                                    this.mapState.selectedIds,
                                    this.mapState.handyStyleId,
                                    this.modules.styleManager.getStyleRevision(
                                        this.mapState.handyStyleId,
                                    ),
                                );
                        }
                        update() {
                            this.currentMod && this.currentMod.useful && this.currentMod.update(),
                                this.newMod && this.newMod.useful && this.newMod.update();
                        }
                        setFloorIndex(e) {
                            this.floorIndex = e;
                        }
                        getCurrentMod() {
                            return this.currentMod;
                        }
                        commitMod() {
                            this.newMod &&
                                this.newMod.ready &&
                                ((this.currentMod = this.newMod), (this.newMod = void 0));
                        }
                        setUsefulMod() {
                            const e = this.mapState.handyStyleId,
                                t = this.modules.styleManager.getStyleRevision(e),
                                i = this.floorIndex;
                            let n = this.mapState.selectedIds;
                            const o = this.idSetByFloorIndex.get(i);
                            if ((o && (n = (0, G.vX)(n, o)), this.currentMod || this.newMod)) {
                                if (this.currentMod) {
                                    if (
                                        (0, O.y5)(this.currentMod.selectedIds, n) &&
                                        this.currentMod.styleId === e &&
                                        this.currentMod.styleRevision === t &&
                                        this.currentMod.floorIndex === i
                                    )
                                        return (
                                            (this.currentMod.useful = !0),
                                            void (this.newMod = void 0)
                                        );
                                }
                                if (this.newMod) {
                                    (0, O.y5)(this.newMod.selectedIds, n) &&
                                    this.newMod.styleId === e &&
                                    this.newMod.styleRevision === t &&
                                    this.newMod.floorIndex === i
                                        ? (this.newMod.useful = !0)
                                        : this.createNewMod(i, n, e, t);
                                } else this.createNewMod(i, n, e, t);
                            } else this.createNewMod(i, n, e, t);
                        }
                        getUsefulMod() {
                            return this.currentMod && this.currentMod.useful
                                ? this.currentMod
                                : this.newMod && this.newMod.useful
                                ? this.newMod
                                : void 0;
                        }
                        setAllModsNeedless() {
                            this.currentMod && (this.currentMod.useful = !1),
                                this.newMod && (this.newMod.useful = !1);
                        }
                        canBeRemoved() {
                            return (
                                (!this.currentMod || this.currentMod.canBeRemoved()) &&
                                (!this.newMod || this.newMod.canBeRemoved())
                            );
                        }
                        remove() {
                            this.currentMod && this.currentMod.remove(),
                                this.newMod && this.newMod.remove();
                        }
                        createNewMod(e, t, i, n) {
                            const o = (function (e, t, i, n, o) {
                                    const r = i.map((e) => `${e.lo},${e.hi}`).join('|');
                                    return `floor_plan=${e}_ind=${t}_sId=${n}_sRev=${o}_sel=${r}`;
                                })(this.id, e, t, i, n),
                                r = this.cache.get(o);
                            if (r) (this.newMod = r), (this.newMod.useful = !0);
                            else {
                                const r = !this.idSetByFloorIndex.has(e);
                                this.newMod = new el(
                                    this.modules,
                                    this.mapState,
                                    o,
                                    this.id,
                                    this.regionId,
                                    i,
                                    n,
                                    e,
                                    this.cache,
                                    t,
                                    r,
                                    this.onModGenerated,
                                );
                            }
                        }
                    }
                    const il = { trafficOn: !1, parkingOn: !1, navigatorOn: !1 };
                    function nl(e) {
                        return Object.assign(Object.assign({}, il), e);
                    }
                    function ol(e, t, i) {
                        return Object.assign(Object.assign({}, e), {
                            _activeFloorIds: t,
                            _activeFloorBuildingIds: i,
                        });
                    }
                    class rl {
                        constructor(e, t) {
                            (this.isStyleUpdateInProgress = !1),
                                (this.state = e),
                                (this.modules = t),
                                (this.floors = new Map()),
                                (this.complexDescriptors = new Map()),
                                (this.hiddenObjectIds = new Map()),
                                (this.displayedMods = new Map()),
                                (this.requestedFloors = new Set()),
                                (this.failedRequestedFloors = new Set()),
                                (this.needUpdate = !1),
                                (this.cache = new ba.L(10, (e, t) => t.remove())),
                                (this.stateDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                ]));
                        }
                        update() {
                            if (this.stateDiffer.check(this.state) || this.needUpdate) {
                                this.needUpdate = !1;
                                const e = this.findActiveFloor();
                                if (this.activeFloor !== e) {
                                    if (
                                        (this.activeFloor &&
                                            this.modules.map.emit('floorcomplexhide', {
                                                id: this.activeFloor,
                                            }),
                                        e)
                                    ) {
                                        const t = this.complexDescriptors.get(e);
                                        if (t) {
                                            const {
                                                id: i,
                                                regionId: n,
                                                defaultFloor: o,
                                                floors: r,
                                            } = t;
                                            let s = this.floors.get(e);
                                            s
                                                ? s.setUsefulMod()
                                                : ((s = new tl(
                                                      this.modules,
                                                      this.state,
                                                      i,
                                                      n,
                                                      this.cache,
                                                      o,
                                                  )),
                                                  this.floors.set(e, s));
                                            const a = s.getUsefulMod();
                                            this.modules.map.emit('floorcomplexshow', {
                                                id: i,
                                                currentFloor: a ? a.floorIndex : o,
                                                floorNames: r.map(({ name: e }) => e),
                                                firmsToFloorIndexMap: t.firmsToFloorIndexMap,
                                            });
                                        }
                                    }
                                    (this.lastFloor = this.activeFloor), (this.activeFloor = e);
                                }
                            }
                            if (
                                (this.floors.forEach((e) => e.setAllModsNeedless()),
                                this.activeFloor)
                            ) {
                                const e = this.floors.get(this.activeFloor);
                                e && e.setUsefulMod();
                            } else
                                this.lastFloor &&
                                    (this.cache.setSize(1),
                                    this.floors.forEach((e, t) => {
                                        t !== this.lastFloor && (e.remove(), this.floors.delete(t));
                                    }),
                                    this.cache.setSize(10),
                                    (this.lastFloor = void 0));
                            this.floors.forEach((e, t) => {
                                e.update(), e.canBeRemoved() && this.floors.delete(t);
                            }),
                                this.updateStyleState(),
                                this.isStyleUpdateInProgress || this.commitMods(),
                                this.updateScene();
                        }
                        getActiveFloorHiddenIds() {
                            const e = [];
                            if (!this.activeFloor) return e;
                            const t = this.complexDescriptors.get(this.activeFloor),
                                i = this.floors.get(this.activeFloor);
                            if (!t || !i) return e;
                            const n = i.getCurrentMod();
                            if (!n) return e;
                            if (n.isDataEmpty()) return e;
                            for (let i = 0; i < t.buildings.length; i++) {
                                const n = this.hiddenObjectIds.get(t.buildings[i]);
                                n && n.forEach((t) => e.push(t));
                            }
                            return e;
                        }
                        prepareFloors(e, t, i, n) {
                            'zenith' === n &&
                                i.forEach((i, n) => {
                                    const o = (0, O.Ak)(n);
                                    let r = this.hiddenObjectIds.get(o);
                                    void 0 === r &&
                                        ((r = new Set()), this.hiddenObjectIds.set(o, r));
                                    for (let e = 0; e < i.length; e += 2)
                                        r.add((0, O.Ak)((0, O.Ru)(i[e], i[e + 1])));
                                    this.loadFloor(o, e, t);
                                });
                        }
                        changeFloorNumber(e, t) {
                            const i = this.floors.get(e),
                                n = this.complexDescriptors.get(e);
                            i &&
                                n &&
                                (i.setFloorIndex(t),
                                this.modules.map.emit('floorcomplexlevelchange', {
                                    id: e,
                                    floorIndex: t,
                                    floorName: n.floors[t].name,
                                }));
                        }
                        resetCache() {
                            this.floors.forEach((e, t) => {
                                e.remove(), this.floors.delete(t);
                            }),
                                this.cache.reset(),
                                (this.activeFloor = void 0),
                                (this.needUpdate = !0);
                        }
                        getDisplayedIdentifyData() {
                            const e = [];
                            return (
                                this.displayedMods.forEach((t) => {
                                    const i = t.getIdentifyIds();
                                    i &&
                                        Object.keys(i).forEach((t) => {
                                            const n = Number(t);
                                            e.push({ ids: i[n], metatileHash: Number(n) });
                                        });
                                }),
                                e
                            );
                        }
                        hasDisplayedFloorBuilding(e) {
                            if (!this.activeFloor) return !1;
                            const t = this.complexDescriptors.get(this.activeFloor),
                                i = this.floors.get(this.activeFloor);
                            if (!t || !i) return !1;
                            const n = i.getCurrentMod();
                            if (!n || !n.ready) return !1;
                            if (n.isDataEmpty()) return !1;
                            for (let i = 0; i < t.buildings.length; i++) {
                                const n = this.hiddenObjectIds.get(t.buildings[i]);
                                if (
                                    n &&
                                    ((Array.isArray(e) && e.some((e) => n.has(e))) ||
                                        ('string' == typeof e && n.has(e)))
                                )
                                    return !0;
                            }
                            return !1;
                        }
                        activateStyleUpdating() {
                            (this.isStyleUpdateInProgress = !0), (this.needUpdate = !0);
                        }
                        finishStyleUpdating() {
                            this.isStyleUpdateInProgress = !1;
                        }
                        activeFloorLoadingOrReady() {
                            if (!this.activeFloor) return !0;
                            const e = this.floors.get(this.activeFloor);
                            if (!e) return !0;
                            const t = e.getUsefulMod();
                            return Boolean(t && t.ready);
                        }
                        floorsReady() {
                            return Array.from(this.requestedFloors).every((e) => {
                                const t = this.floors.get(e);
                                if (!t)
                                    return (
                                        this.failedRequestedFloors.has(e) ||
                                        this.complexDescriptors.has(e)
                                    );
                                const i = t.getUsefulMod();
                                return Boolean(!i || i.ready);
                            });
                        }
                        loadFloor(e, t, i) {
                            this.requestedFloors.has(e) ||
                                (this.requestedFloors.add(e),
                                this.modules.workers.parser
                                    .loadFloor(e, this.state.floorsUrl)
                                    .then((n) => {
                                        if ('error' === n.type)
                                            return (
                                                404 !== n.errorStatus &&
                                                    console.error(`Loading floor ${e} failed`),
                                                void this.failedRequestedFloors.add(e)
                                            );
                                        this.complexDescriptors.set(e, {
                                            id: e,
                                            regionId: t,
                                            metatileHash: i,
                                            center: n.center,
                                            defaultFloor: n.defaultFloor,
                                            floors: n.floors,
                                            buildings: n.buildings,
                                            bound: n.bound,
                                            firmsToFloorIndexMap: n.firmsToFloorIndexMap,
                                        }),
                                            (this.needUpdate = !0);
                                    }));
                        }
                        updateStyleState() {
                            const { styleState: e } = this.state;
                            if (!this.activeFloor)
                                return void (
                                    (e._activeFloorIds || e._activeFloorBuildingIds) &&
                                    (this.state.styleState = ol(e, void 0, void 0))
                                );
                            const t = this.complexDescriptors.get(this.activeFloor),
                                i = this.floors.get(this.activeFloor);
                            if (!t || !i) return;
                            const n = i.getUsefulMod();
                            if (!n) return;
                            const o = t.floors[n.floorIndex].ids,
                                r = t.buildings;
                            (o === e._activeFloorIds && r === e._activeFloorBuildingIds) ||
                                (this.state.styleState = ol(e, o, r));
                        }
                        updateScene() {
                            let e = !1;
                            const t = new Map();
                            if (this.activeFloor) {
                                const e = this.floors.get(this.activeFloor);
                                if (!e) return;
                                const i = e.getCurrentMod();
                                i && i.ready && t.set(i.key, i);
                            }
                            this.displayedMods.forEach((i, n) => {
                                t.has(n) || (this.removeFloorMod(i), (e = !0));
                            }),
                                t.forEach((t, i) => {
                                    this.displayedMods.has(i) || (this.addFloorMod(t), (e = !0)),
                                        this.cache.get(i);
                                }),
                                e &&
                                    ((this.displayedMods = t),
                                    (this.state.needLabeling = !0),
                                    (this.state.needRerender = !0),
                                    this.modules.identifier.resetCache());
                        }
                        addFloorMod(e) {
                            e.object &&
                                (this.modules.tileManager.addObject(e.object),
                                this.modules.labeler.addLabels(e.key, Ta.AL.Floor, e.getLabels()));
                        }
                        removeFloorMod(e) {
                            e.object &&
                                (this.modules.tileManager.removeObject(e.object),
                                this.modules.labeler.removeLabels(e.key));
                        }
                        commitMods() {
                            if (this.activeFloor) {
                                const e = this.floors.get(this.activeFloor);
                                e && e.commitMod();
                            }
                        }
                        findActiveFloor() {
                            const e = this.complexDescriptors,
                                {
                                    center: t,
                                    zoom: i,
                                    styleZoom: n,
                                    rotation: o,
                                    size: r,
                                    pitch: s,
                                    viewport: a,
                                    padding: l,
                                } = this.state;
                            if (n < I.floors.displayStyleZoom) return;
                            const c = new Hi.V({
                                center: t,
                                zoom: i,
                                rotation: o,
                                size: [
                                    Math.floor(r[0] * (1 - I.floors.viewportPadding)),
                                    Math.floor(r[1] * (1 - I.floors.viewportPadding)),
                                ],
                                pitch: s,
                                viewport: a,
                                padding: l,
                            });
                            let d,
                                h = 1 / 0;
                            return (
                                e.forEach((e) => {
                                    const i = z.TE(t, e.center);
                                    h > i &&
                                        (0, Oi.M4)(c.getViewportVertices(), e.bound) &&
                                        ((h = i), (d = e));
                                }),
                                d ? d.id : void 0
                            );
                        }
                    }
                    class sl {
                        constructor(e, t) {
                            (this.state = e),
                                (this.modules = t),
                                (this.tileLayers = []),
                                (this.objects = []),
                                (this.viewportDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                    { path: 'elevation', type: 'number' },
                                    { path: 'minElevation', type: 'number' },
                                ]));
                        }
                        addTileLayer(e) {
                            -1 === this.tileLayers.indexOf(e) &&
                                (this.tileLayers.push(e),
                                e.redraw(),
                                this.modules.identifier.resetCache(),
                                (this.state.needLabeling = !0),
                                (this.state.needRerender = !0));
                        }
                        removeTileLayer(e) {
                            (0, fe.VJ)(this.tileLayers, e) &&
                                (e.resetHoverId(),
                                this.modules.identifier.resetCache(),
                                (this.state.needLabeling = !0),
                                (this.state.needRerender = !0));
                        }
                        redraw() {
                            this.modules.labeler.clearPreviousLabels();
                            for (const e of this.tileLayers) e.resetHoverId(), e.redraw();
                            this.state.needRerender = !0;
                        }
                        activateStyleUpdating() {
                            this.tileLayers.forEach((e) => e.activateStyleUpdating());
                        }
                        finishStyleUpdating() {
                            this.tileLayers.forEach((e) => e.finishStyleUpdating());
                        }
                        setSelectedIds() {
                            this.tileLayers.forEach((e) => e.setSelectedIds());
                        }
                        getViewportTiles() {
                            const e = [];
                            for (const t of this.tileLayers) e.push(...t.getViewportTiles());
                            return e;
                        }
                        viewportTilesReady() {
                            return this.tileLayers.every((e) => e.viewportTilesReady());
                        }
                        displayedTilesAnimationFinished() {
                            return this.tileLayers.every((e) =>
                                e.displayedTilesAnimationFinished(),
                            );
                        }
                        getDisplayedIdentifyData() {
                            const e = [];
                            for (const t of this.tileLayers)
                                e.push(...t.getDisplayedIdentifyData());
                            return e;
                        }
                        getLabelingData() {
                            return this.tileLayers.map((e) => e.getLabelingData());
                        }
                        isIdle() {
                            return (
                                this.viewportTilesReady() && this.displayedTilesAnimationFinished()
                            );
                        }
                        update() {
                            const e = this.state;
                            this.viewportDiffer.check(e) &&
                                this.tileLayers.forEach((e) => e.updateViewport());
                            for (const e of this.tileLayers) e.update();
                            if ((this.updateTickers(), e.collectStats)) {
                                this.state.stats.tileCount = 0;
                                for (const e of this.tileLayers)
                                    this.state.stats.tileCount += e.getTileCount();
                                this.state.stats.dynamicTileCount = this.objects.filter(
                                    (e) => 'dynamicObject' === e.purpose || 'floor' === e.purpose,
                                ).length;
                            }
                        }
                        getTileObjects() {
                            return this.objects;
                        }
                        addObject(e) {
                            -1 === this.objects.indexOf(e) &&
                                (this.objects.push(e), (this.state.needRerender = !0));
                        }
                        removeObject(e) {
                            (0, fe.VJ)(this.objects, e) && (this.state.needRerender = !0);
                        }
                        destroy() {
                            for (const e of this.tileLayers) e.destroy();
                            this.objects.forEach((e) => e.clean(this.state));
                        }
                        updateTickers() {
                            this.objects.forEach((e) => e.updateTicker(this.state));
                        }
                    }
                    const al = Y.Vx.bind(null, 'labelingOpacity', {
                        step: (e, t) => (e.labelingOpacity = t),
                    });
                    class ll {
                        constructor(e, t) {
                            (this.state = e),
                                (this.modules = t),
                                (this.viewportDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                ])),
                                (this.useThrottleUpdate = !0),
                                (this.isLabelingInProgress = !1),
                                (this.skipHysteresisInNextLabeling = !1),
                                (this.alwaysActiveLabelKeys = []),
                                (this.survivedLabelBoxes = new Set()),
                                (this.prevSurvivedCommPoiIds = new Set()),
                                (this.demKeys = {}),
                                (this.worker = ((e) => ({
                                    appendLabels: e.get(Ba.P.Labeling, 'appendLabels'),
                                    appendLabelBox: e.get(Ba.P.Labeling, 'appendLabelBox'),
                                    removeLabels: e.get(Ba.P.Labeling, 'removeLabels'),
                                    processLabels: e.get(Ba.P.Labeling, 'processLabels'),
                                    clearPreviousLabels: e.get(
                                        Ba.P.Labeling,
                                        'clearPreviousLabels',
                                    ),
                                }))(this.modules.workers.fnRegistry)),
                                this.setLabelingInterval(I.labeling.interval);
                        }
                        disableThrottleUpdateOnce() {
                            this.useThrottleUpdate = !1;
                        }
                        update() {
                            al(this.state),
                                (!this.viewportDiffer.check(this.state) &&
                                    !this.state.needLabeling) ||
                                    this.isLabelingInProgress ||
                                    ((this.state.needLabeling = !1),
                                    (this.isLabelingInProgress = !0),
                                    this.useThrottleUpdate
                                        ? this.throttledUpdateLabeling()
                                        : ((this.useThrottleUpdate = !0),
                                          this.generateLabelingTile()));
                        }
                        isIdle() {
                            return (
                                void 0 === this.state.tickers.labelingOpacity &&
                                !this.isLabelingInProgress &&
                                !this.state.needLabeling
                            );
                        }
                        setLabelingInterval(e) {
                            this.throttledUpdateLabeling = Ce(() => {
                                this.generateLabelingTile();
                            }, e);
                        }
                        addLabels(e, t, i) {
                            this.worker.appendLabels(
                                e,
                                t,
                                i,
                                this.state.styleState,
                                this.state.styleZoom,
                            ),
                                this.enrichWithElevation(i, e),
                                this.alwaysActiveLabelKeys.push(e),
                                (this.state.needLabeling = !0);
                        }
                        addTileLabels(e, t, i) {
                            this.worker.appendLabels(
                                e,
                                t,
                                i,
                                this.state.styleState,
                                this.state.styleZoom,
                            ),
                                this.enrichWithElevation(i, e),
                                (this.state.needLabeling = !0);
                        }
                        addLabelBox(e, t) {
                            this.worker.appendLabelBox(e, t), (this.state.needLabeling = !0);
                        }
                        removeLabels(e) {
                            this.worker.removeLabels(e);
                            const t = this.alwaysActiveLabelKeys.indexOf(e);
                            -1 !== t && this.alwaysActiveLabelKeys.splice(t, 1),
                                (this.state.needLabeling = !0);
                        }
                        isLabelBoxSurvived(e) {
                            return this.survivedLabelBoxes.has(e);
                        }
                        clearPreviousLabels() {
                            this.worker.clearPreviousLabels();
                        }
                        resetHysteresis() {
                            (this.skipHysteresisInNextLabeling = !0),
                                (this.state.needLabeling = !0);
                        }
                        generateLabelingTile() {
                            const e = (0, G.x7)(
                                    (0, Oi.BS)(this.state.tilesBounds),
                                    I.labeling.tileMultiplier,
                                ),
                                t = {
                                    center: this.state.center,
                                    elevation: this.state.elevation,
                                    zoom: this.state.zoom,
                                    styleZoom: this.state.styleZoom,
                                    rotation: this.state.rotation,
                                    size: this.state.size,
                                    pitch: this.state.pitch,
                                    viewport: this.state.viewport,
                                    padding: this.state.padding,
                                    styleState: this.state.styleState,
                                    buildingHeight:
                                        this.modules.buildingHeightAnimator.getDefaultBuildingHeight(),
                                    tilesBounds: this.state.tilesBounds,
                                    debugLabels: this.modules.labelsDebug.isEnabled(),
                                    disableSurvivedPoiPrevalence:
                                        this.state.disableSurvivedPoiPrevalence,
                                };
                            this.worker
                                .processLabels(
                                    this.modules.tileManager.getLabelingData(),
                                    this.alwaysActiveLabelKeys,
                                    t,
                                    (0, G.Bs)(e),
                                    window.devicePixelRatio,
                                    this.modules.floorManager.getActiveFloorHiddenIds(),
                                    I.labeling.commercialMargins,
                                    this.skipHysteresisInNextLabeling,
                                )
                                .then((t) => {
                                    this.survivedLabelBoxes.clear(),
                                        t.survivedLabelBoxIds.forEach((e) =>
                                            this.survivedLabelBoxes.add(e),
                                        ),
                                        this.processSurvivedCommPoiIds(t.survivedCommPois),
                                        this.labelTile &&
                                            (this.modules.tileManager.removeObject(this.labelTile),
                                            this.labelTile.clean(this.state)),
                                        this.modules.assetManager.loadRasters(
                                            t.collectorOutput.rastersToLoad,
                                        ),
                                        (this.labelTile = new C.W(
                                            'labeling',
                                            t.collectorOutput.data,
                                            this.modules.renderer,
                                            e,
                                        )),
                                        this.modules.tileManager.addObject(this.labelTile);
                                    const i = this.state.metrics;
                                    Number.isNaN(i.firstlabeling) &&
                                        t.collectorOutput.data.length > 0 &&
                                        (i.firstlabeling = performance.now() - i.start);
                                    const {
                                        animationTime: n,
                                        animationType: o,
                                        interval: r,
                                    } = I.labeling;
                                    var s, a, l, c, d;
                                    (s = this.state),
                                        (a = o),
                                        (l = 0),
                                        (c = 1),
                                        (d = Math.min(n, r)),
                                        Y.BL('labelingOpacity', { easing: a }, s, l, c, d),
                                        (this.state.needRerender = !0),
                                        t.labels && this.modules.labelsDebug.drawLabels(t.labels),
                                        (this.isLabelingInProgress = !1);
                                }),
                                (this.skipHysteresisInNextLabeling = !1);
                        }
                        processSurvivedCommPoiIds(e) {
                            if (0 === e.length) return void this.prevSurvivedCommPoiIds.clear();
                            const t = e.filter((e) => !this.prevSurvivedCommPoiIds.has(e.id));
                            0 !== t.length && this.modules.map.emit('commpoishow', { commPois: t }),
                                (this.prevSurvivedCommPoiIds = new Set(e.map((e) => e.id)));
                        }
                        enrichWithElevation(e, t) {
                            const { demManager: i, map: n } = this.modules;
                            if (n.state.demMode) {
                                const n = this.demKeys[t],
                                    o = i.getLabelsDemKey(e);
                                if (void 0 === o || o === n) return;
                                i.enrichWithElevation(e), (this.demKeys[t] = o);
                            }
                        }
                    }
                    const cl = 10,
                        dl = 7,
                        hl = 3,
                        ul = 2,
                        ml = 0,
                        fl = 4,
                        pl = 2,
                        _l = '#ffffff',
                        vl = '#667799',
                        gl = '#ffffff',
                        yl = 5,
                        bl = 4,
                        wl = 2,
                        xl = 1,
                        Sl = '#667799',
                        Il = '#ffffff',
                        Ml = '#00000026',
                        Tl = '#66779966',
                        Pl = 13,
                        Ll = {
                            start: { en: 'Start', ru: '' },
                            addPoint: { en: 'Add point', ru: ' ' },
                            meter: { en: 'm', ru: '' },
                            kilometer: { en: 'km', ru: '' },
                        };
                    function kl(e, t, i) {
                        if (t) return Ll.start[i] || Ll.start.en;
                        if (e < 1e3) return `${e} ${Ll.meter[i] || Ll.meter.en}`;
                        return `${(e / 1e3).toFixed(1)} ${Ll.kilometer[i] || Ll.kilometer.en}`;
                    }
                    function El(e, t) {
                        return `\n        <div style="font-size: ${t}px;\n            color: #667799;\n            user-select: none;\n            font-family: SuisseIntl, Helvetica, Arial, sans-serif;\n            text-shadow: 1px 0px 1px #fff, -1px 0px 1px #fff, 0px 1px 1px #fff, 0px -1px 1px #fff;\n            white-space: nowrap;\n            cursor: pointer;\n        ">\n            ${e}\n        </div>\n    `;
                    }
                    function Al(e, t) {
                        return `\n        <div style="text-shadow: 1px 0px 1px #fff, -1px 0px 1px #fff, 0px 1px 1px #fff, 0px -1px 1px #fff;\n            user-select: none;\n            color: #667799;\n            font-family: SuisseIntl, Helvetica, Arial, sans-serif;\n            font-size: 13px;\n            margin: -12px 0 0 12px; /**     */\n            white-space: nowrap;\n            cursor: pointer;\n        ">\n            ${e}\n            <br>\n            ${(function (
                            e,
                        ) {
                            return Ll.addPoint[e] || Ll.addPoint.en;
                        })(t)}\n        </div>\n    `;
                    }
                    function zl(e, t, i, n) {
                        return new X(n, {
                            coordinates: e,
                            interactive: i,
                            draggable: i,
                            width: t ? dl : ml,
                            borderWidth: t ? hl : fl,
                            border2Width: t ? ul : pl,
                            color: _l,
                            borderColor: vl,
                            border2Color: gl,
                            zIndex: cl,
                        });
                    }
                    function Cl(e, t, i) {
                        return new qc(i, {
                            coordinates: e,
                            zIndex: yl,
                            zIndex2: yl - 1,
                            zIndex3: yl - 2,
                            width: bl,
                            width2: t ? 0 : bl + 2 * wl,
                            width3: t ? 0 : bl + 2 * (wl + xl),
                            color: t ? Tl : Sl,
                            color2: Il,
                            color3: Ml,
                            interactive: !t,
                        });
                    }
                    const Fl =
                        'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjIiIGhlaWdodD0iMjIiPjxkZWZzPjxwYXRoIGlkPSJBIiBkPSJNMTIgMTAuNTg2bDMuNzkzLTMuNzkzIDEuNDE0IDEuNDE0TDEzLjQxNCAxMmwzLjc5MyAzLjc5My0xLjQxNCAxLjQxNEwxMiAxMy40MTRsLTMuNzkzIDMuNzkzLTEuNDE0LTEuNDE0TDEwLjU4NiAxMiA2Ljc5MyA4LjIwN2wxLjQxNC0xLjQxNEwxMiAxMC41ODZ6Ii8+PC9kZWZzPjxnIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEgLTEpIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMC41IiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS1vcGFjaXR5PSIuMTUiLz48bWFzayBpZD0iQiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjQSIvPjwvbWFzaz48dXNlIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0ibm9uemVybyIgeGxpbms6aHJlZj0iI0EiLz48ZyBmaWxsPSIjMjYyNjI2IiBtYXNrPSJ1cmwoI0IpIj48cGF0aCBkPSJNMCAwaDI0djI0SDB6Ii8+PC9nPjwvZz48L3N2Zz4=';
                    class Ol extends k.c {
                        constructor(e, t, i, n) {
                            super(),
                                (this.markerOrLabelMouseover = () => {
                                    this.markerOrLabelHovered ||
                                        ((this.markerOrLabelHovered = !0),
                                        void 0 === this.hoverTimer && this.emit('mouseover'));
                                }),
                                (this.markerOrLabelMouseout = () => {
                                    this.markerOrLabelHovered &&
                                        ((this.markerOrLabelHovered = !1),
                                        (this.hoverTimer = window.setTimeout(() => {
                                            this.markerOrLabelHovered ||
                                                (this.emit('mouseout'), (this.hoverTimer = void 0));
                                        }, 100)));
                                }),
                                (this.onClick = () => this.emit('click')),
                                (this.labelText = kl(n, i, e.state.lang)),
                                (this.point = t),
                                (this.distance = n),
                                (this.label = (function (e, t, i) {
                                    const n = El(t, Pl),
                                        o = (function (e, t) {
                                            return 0.55 * t * e.length;
                                        })(t, Pl);
                                    return new Ga(i, {
                                        coordinates: e,
                                        html: n,
                                        offset: [(dl + hl + ul) / 2 + 2, -Pl / 2 - 2],
                                        labeling: { type: 'full', width: o, height: Pl },
                                        animate: !1,
                                        zIndex: yl + 1,
                                    });
                                })(t, this.labelText, e)),
                                (this.marker = zl(t, i, !0, e)),
                                (this.markerOrLabelHovered = !1);
                            const o = this.label.dangerouslyGetRootElement();
                            o.addEventListener('mouseover', this.markerOrLabelMouseover),
                                o.addEventListener('mouseout', this.markerOrLabelMouseout),
                                o.addEventListener('click', this.onClick),
                                this.marker.on('mouseover', () => this.markerOrLabelMouseover()),
                                this.marker.on('mouseout', () => this.markerOrLabelMouseout()),
                                this.marker.on('dragstart', (e) => {
                                    const { lngLat: t, originalEvent: i, point: n, target: o } = e;
                                    this.emit('dragstart', {
                                        lngLat: t,
                                        originalEvent: i,
                                        point: n,
                                        targetData: this,
                                        target: o,
                                    });
                                }),
                                this.marker.on('dragend', (e) => {
                                    const { lngLat: t, originalEvent: i, point: n, target: o } = e;
                                    this.emit('dragend', {
                                        lngLat: t,
                                        originalEvent: i,
                                        point: n,
                                        targetData: this,
                                        target: o,
                                    });
                                });
                        }
                        getDistance() {
                            return this.distance;
                        }
                        getPoint() {
                            return this.point;
                        }
                        getMarkerUniqId() {
                            return this.marker.uniqId;
                        }
                        getLabelUniqId() {
                            return this.label.uniqId;
                        }
                        setPoint(e) {
                            this.point = e;
                        }
                        remove() {
                            this.marker.remove();
                            const e = this.label.dangerouslyGetRootElement();
                            e.removeEventListener('mouseover', this.markerOrLabelMouseover),
                                e.removeEventListener('mouseout', this.markerOrLabelMouseout),
                                e.removeEventListener('click', this.onClick),
                                this.label.destroy();
                        }
                        activateHover() {
                            this.label.setContent(
                                `\n        <img style="\n            user-select: none;\n            width: 24px;\n            height: 24px;\n            margin-top: -4px;\n            cursor: pointer;\n        " src="data:image/svg+xml;base64,${Fl}" alt="close">\n    `,
                            );
                        }
                        deactivateHover() {
                            this.label.setContent(El(this.labelText, Pl));
                        }
                    }
                    class Dl {
                        constructor(e, t) {
                            (this.onDocumentMouseMove = (e) => {
                                (this.mousePos = (0, F.yK)(
                                    this.modules.layout.rootContainer,
                                    e.clientX,
                                    e.clientY,
                                )),
                                    (this.needsUpdate = !0);
                            }),
                                (this.modules = t),
                                (this.state = e),
                                (this.joints = []),
                                (this.enabled = !1),
                                (this.needsUpdate = !1),
                                (this.hidePreviewLine = !1),
                                (this.hideMouseElem = !1),
                                (this.mousePos = [0, 0]),
                                document.addEventListener('mousemove', this.onDocumentMouseMove),
                                (this.langDiffer = new De([{ path: 'lang', type: 'string' }]));
                        }
                        destroy() {
                            document.removeEventListener('mousemove', this.onDocumentMouseMove);
                        }
                        enable() {
                            this.enabled ||
                                ((this.enabled = !0),
                                (this.state.identifyPickDistance = 2 * I.identify.pickDistance),
                                (this.popup = new Ga(this.modules.map, {
                                    coordinates: [0, 0],
                                    html: '',
                                    interactive: !1,
                                    animate: !1,
                                    zIndex: 1,
                                })));
                        }
                        disable() {
                            (this.enabled = !1),
                                this.reset(),
                                void 0 !== this.mouseElem &&
                                    (this.mouseElem.remove(), (this.mouseElem = void 0)),
                                (this.state.identifyPickDistance = I.identify.pickDistance),
                                this.popup && (this.popup.destroy(), (this.popup = void 0));
                        }
                        update() {
                            this.enabled &&
                                (this.langDiffer.check(this.state) && this.recalculate(),
                                this.needsUpdate &&
                                    ((this.needsUpdate = !1),
                                    this.drawMousePoint(),
                                    this.drawPreviewLine()));
                        }
                        setPoints(e) {
                            this.reset(),
                                e.forEach((e) => this.addPointToEnd(e)),
                                this.drawPolyline(),
                                this.sendRulerChangeEvent(!1);
                        }
                        handleClick(e, t) {
                            const i = this.getJointByUniqId(t && t.dynamicObjectId);
                            if (i) {
                                const e = this.getJointIndexByReferer(i);
                                void 0 !== e &&
                                    (i.remove(),
                                    this.joints.splice(e, 1),
                                    this.recalculate(),
                                    (this.hidePreviewLine = !1),
                                    (this.hideMouseElem = !1)),
                                    this.popup && this.popup.setContent('');
                            } else if (
                                t &&
                                this.polyline &&
                                this.polyline.uniqId === t.dynamicObjectId
                            ) {
                                const t = this.polyline.snapPoint(e),
                                    i = this.getJointIndexByDistance(t.distance),
                                    n = this.createJoint(t.point, !1, t.distance);
                                this.joints.splice(i, 0, n),
                                    (this.hidePreviewLine = !0),
                                    (this.hideMouseElem = !0),
                                    this.drawPolyline(),
                                    this.sendRulerChangeEvent(!0),
                                    this.popup && this.popup.setContent('');
                            } else {
                                const t = (0, L.PA)(this.modules.camera.unproject(e));
                                this.addPointToEnd(t),
                                    this.drawPolyline(),
                                    this.sendRulerChangeEvent(!0);
                            }
                        }
                        recalculate() {
                            const e = [];
                            this.joints.forEach((t, i) => {
                                t.remove();
                                const n = 0 === i;
                                let o = 0;
                                if (!n) {
                                    const n = e[i - 1];
                                    o = n.getDistance() + (0, L.vn)(n.getPoint(), t.getPoint());
                                }
                                const r = this.createJoint(t.getPoint(), n, o);
                                e.push(r);
                            }),
                                (this.joints = e),
                                this.drawPolyline(),
                                this.sendRulerChangeEvent(!0);
                        }
                        sendRulerChangeEvent(e) {
                            this.modules.map.emit('rulerchange', {
                                points: this.getPoints(),
                                isUser: e,
                            });
                        }
                        getJointByUniqId(e) {
                            if (void 0 !== e)
                                for (const t of this.joints)
                                    if (e === t.getMarkerUniqId() || e === t.getLabelUniqId())
                                        return t;
                        }
                        getJointIndexByDistance(e) {
                            let t = 0;
                            for (const i of this.joints) {
                                if (e < i.getDistance()) break;
                                t++;
                            }
                            return t;
                        }
                        getJointIndexByReferer(e) {
                            let t = 0;
                            for (const i of this.joints) {
                                if (i === e) return t;
                                t++;
                            }
                        }
                        getPoints() {
                            return this.joints.map((e) => e.getPoint());
                        }
                        reset() {
                            this.joints.forEach((e) => e.remove()),
                                (this.joints = []),
                                void 0 !== this.polyline &&
                                    (this.polyline.remove(), (this.polyline = void 0)),
                                void 0 !== this.previewLine &&
                                    (this.previewLine.remove(), (this.previewLine = void 0)),
                                (this.hidePreviewLine = !1),
                                (this.hideMouseElem = !1),
                                this.popup && this.popup.setContent('');
                        }
                        createJoint(e, t, i) {
                            const n = new Ol(this.modules.map, e, t, i);
                            return (
                                n.on('mouseover', () => {
                                    void 0 === this.draggableJointIndex &&
                                        (this.requestUpdate(!0, !0), n.activateHover());
                                }),
                                n.on('mouseout', () => {
                                    void 0 === this.draggableJointIndex &&
                                        (this.requestUpdate(!1, !0), n.deactivateHover());
                                }),
                                n.on('dragstart', () => {
                                    this.requestUpdate(!1, !0),
                                        (this.draggableJointIndex = this.getJointIndexByReferer(n));
                                }),
                                n.on('dragend', (e) => {
                                    this.requestUpdate(!1, !0),
                                        (this.draggableJointIndex = void 0),
                                        n.setPoint(e.lngLat),
                                        this.recalculate();
                                }),
                                n.on('click', () => {
                                    const e = this.getJointIndexByReferer(n);
                                    void 0 !== e &&
                                        (n.remove(),
                                        this.joints.splice(e, 1),
                                        this.recalculate(),
                                        (this.hidePreviewLine = !1),
                                        (this.hideMouseElem = !1)),
                                        this.popup && this.popup.setContent('');
                                }),
                                n
                            );
                        }
                        addPointToEnd(e) {
                            let t = !0,
                                i = 0;
                            if (this.joints.length > 0) {
                                t = !1;
                                const n = this.joints[this.joints.length - 1];
                                i = n.getDistance() + (0, L.vn)(n.getPoint(), e);
                            }
                            const n = this.createJoint(e, t, i);
                            this.joints.push(n);
                        }
                        drawPolyline() {
                            void 0 !== this.polyline &&
                                (this.polyline.remove(), (this.polyline = void 0));
                            const e = this.getPoints();
                            if (e.length < 2) return;
                            const t = Cl(e, !1, this.modules.map);
                            t.on('mousemove', (e) => {
                                if (void 0 === this.draggableJointIndex) {
                                    if (this.popup) {
                                        const i = t.snapPoint(e.point),
                                            n = kl(i.distance, !1, this.state.lang);
                                        this.popup.setPosition(i.point),
                                            this.popup.setContent(Al(n, this.state.lang)),
                                            (this.snapPoint = i.point);
                                    }
                                    this.requestUpdate(!0, !1);
                                }
                            }),
                                t.on('mouseout', () => {
                                    void 0 === this.draggableJointIndex &&
                                        (this.popup && this.popup.setContent(''),
                                        this.requestUpdate(!1, !0));
                                }),
                                (this.polyline = t);
                        }
                        requestUpdate(e, t) {
                            (this.hidePreviewLine = e),
                                (this.hideMouseElem = t),
                                (this.needsUpdate = !0);
                        }
                        getPreviewPoints() {
                            const e = this.getPoints();
                            if (this.hidePreviewLine || e.length < 1) return [];
                            const t = this.draggableJointIndex,
                                i = (0, L.PA)(this.modules.camera.unproject(this.mousePos));
                            if (void 0 === t || 1 === e.length) return [];
                            if (t === this.joints.length - 1) return [e[e.length - 2], i];
                            if (0 === t) return [e[1], i];
                            const n = this.joints[t - 1],
                                o = this.joints[t + 1];
                            return [n.getPoint(), i, o.getPoint()];
                        }
                        drawPreviewLine() {
                            void 0 !== this.previewLine &&
                                (this.previewLine.remove(), (this.previewLine = void 0));
                            const e = this.getPreviewPoints();
                            e.length < 1 || (this.previewLine = Cl(e, !0, this.modules.map));
                        }
                        drawMousePoint() {
                            void 0 !== this.mouseElem &&
                                (this.mouseElem.remove(), (this.mouseElem = void 0)),
                                this.hideMouseElem ||
                                    void 0 === this.snapPoint ||
                                    (this.mouseElem = zl(this.snapPoint, !0, !1, this.modules.map));
                        }
                    }
                    class Rl {
                        constructor(e, t, i) {
                            (this.type = e),
                                (this.handler = i),
                                (this.mouseDownPoint = t),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.modules.map.emit('interactionstart', {
                                    target: 'pitch/rotation',
                                });
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'mousemove':
                                    return this.processMouseMoveAction(e);
                                case 'mouseup':
                                    return this.processMouseUpAction(e);
                                case 'keyup':
                                    return this.processKeyUpAction(e);
                                default:
                                    return this;
                            }
                        }
                        processMouseMoveAction(e) {
                            const t = (0, F.yK)(this.handler.container, e.clientX, e.clientY);
                            return new jl(this.type, this.mouseDownPoint, t, this.handler);
                        }
                        processMouseUpAction(e) {
                            switch (this.type) {
                                case 'keyPrimary':
                                    if (0 === e.button && (e.ctrlKey || e.metaKey))
                                        return this.returnToInitialState();
                                    break;
                                case 'secondary':
                                    if (2 === e.button) {
                                        const t = (0, F.yK)(
                                            this.handler.container,
                                            e.clientX,
                                            e.clientY,
                                        );
                                        return (
                                            this.handler.modules.identifier
                                                .search('contextmenu', t, !0)
                                                .then((i) => {
                                                    U('contextmenu', i, e, t, this.handler.modules);
                                                }),
                                            this.returnToInitialState()
                                        );
                                    }
                                    break;
                                case 'auxiliary':
                                    if (1 === e.button) return this.returnToInitialState();
                            }
                            return this;
                        }
                        processKeyUpAction(e) {
                            return 'keyPrimary' !== this.type ||
                                ('Control' !== e.key && 'Meta' !== e.key)
                                ? this
                                : (this.handler.modules.map.emit('interactionend', {
                                      target: 'pitch/rotation',
                                  }),
                                  new Bl(this.mouseDownPoint, this.handler));
                        }
                        returnToInitialState() {
                            return (
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'pitch/rotation',
                                }),
                                new $l(this.handler)
                            );
                        }
                    }
                    class jl {
                        constructor(e, t, i, n) {
                            (this.type = e),
                                (this.mouseDownPoint = t),
                                (this.mouseMovePoint = i),
                                (this.handler = n),
                                (this.handler.mapState.userHasInteracted = !0),
                                (this.handler.mapState.disablePitchByUserInteraction &&
                                    this.handler.mapState.disableRotationByUserInteraction) ||
                                    this.handler.container.classList.add('mapgl-rotating'),
                                this.update(this.handler.mapState);
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'mousemove':
                                    return this.processMouseMoveAction(e);
                                case 'mouseleave':
                                    return this.returnToInitialState();
                                case 'mouseup':
                                    return this.processMouseUpAction(e);
                                case 'keyup':
                                    return this.processKeyUpAction(e);
                                default:
                                    return this;
                            }
                        }
                        update(e) {
                            0 === this.mouseDownPoint[0] &&
                                0 === this.mouseDownPoint[1] &&
                                (this.mouseDownPoint = this.mouseMovePoint);
                            const t = (0, fe.Te)(e.size, this.mouseDownPoint),
                                i = (0, fe.Te)(e.size, this.mouseMovePoint),
                                n = (t[0] - i[0]) * I.zoom.mouseRotateDelta,
                                o = (i[1] - t[1]) * I.zoom.mousePitchDelta;
                            Fe(e),
                                e.disableRotationByUserInteraction ||
                                    he(e, e.rotation + n, { animate: !1 }),
                                e.disablePitchByUserInteraction ||
                                    _e(e, (0, fe.uZ)(e.pitch + o, e.minPitch, e.maxPitch), {
                                        animate: !1,
                                    }),
                                (this.mouseDownPoint = this.mouseMovePoint),
                                (e.needRerender = !0);
                        }
                        processMouseMoveAction(e) {
                            return (
                                (this.mouseMovePoint = (0, F.yK)(
                                    this.handler.container,
                                    e.clientX,
                                    e.clientY,
                                )),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState),
                                this
                            );
                        }
                        processMouseUpAction(e) {
                            switch (this.type) {
                                case 'keyPrimary':
                                    if (0 === e.button && (e.ctrlKey || e.metaKey))
                                        return this.returnToInitialState();
                                    break;
                                case 'secondary':
                                    if (2 === e.button) return this.returnToInitialState();
                                    break;
                                case 'auxiliary':
                                    if (1 === e.button) return this.returnToInitialState();
                            }
                            return this;
                        }
                        processKeyUpAction(e) {
                            return 'keyPrimary' !== this.type ||
                                ('Control' !== e.key && 'Meta' !== e.key)
                                ? this
                                : (this.handler.container.classList.remove('mapgl-rotating'),
                                  this.handler.modules.map.emit('interactionend', {
                                      target: 'pitch/rotation',
                                  }),
                                  new Bl(this.mouseMovePoint, this.handler));
                        }
                        returnToInitialState() {
                            return (
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.container.classList.remove('mapgl-rotating'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'pitch/rotation',
                                }),
                                new $l(this.handler)
                            );
                        }
                    }
                    class Bl {
                        constructor(e, t) {
                            (this.handler = t),
                                (this.toInitialOnMouseUp = !1),
                                (this.mouseDownPoint = e),
                                (this.dragStartPoint = e),
                                (this.isTimerStarted = void 0 !== this.handler.dblClickTimer),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.modules.map.emit('interactionstart', {
                                    target: 'center',
                                }),
                                this.isTimerStarted &&
                                    (window.clearTimeout(this.handler.dblClickTimer),
                                    (this.handler.dblClickTimer = void 0));
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'mousedown':
                                    return (this.toInitialOnMouseUp = !0), this;
                                case 'mouseup':
                                    return this.processMouseUpAction(e);
                                case 'mousemove':
                                    return this.processMouseMoveAction(e);
                                case 'click':
                                    return this.processMouseClickAction(e);
                                case 'keydown':
                                    return this.processKeyDownAction(e);
                                default:
                                    return this;
                            }
                        }
                        processMouseUpAction(e) {
                            return 0 !== e.button ||
                                (!this.toInitialOnMouseUp &&
                                    this.handler.modules.layout.isActionWithCanvas(e))
                                ? this
                                : ((this.handler.mapState.userHasInteracted = !0),
                                  this.handler.modules.map.emit('interactionend', {
                                      target: 'center',
                                  }),
                                  new $l(this.handler));
                        }
                        processMouseMoveAction(e) {
                            const t = (0, F.yK)(this.handler.container, e.clientX, e.clientY);
                            return this.handler.mapState.disableDragging
                                ? ((this.mouseDownPoint = t),
                                  (this.dragStartPoint = t),
                                  (this.toInitialOnMouseUp = !0),
                                  this)
                                : z.TE(this.mouseDownPoint, t) < I.events.dragThreshold
                                ? ((this.dragStartPoint = t), this)
                                : new Nl(t, this.dragStartPoint, this.handler);
                        }
                        processMouseClickAction(e) {
                            if (!this.handler.modules.layout.isActionWithCanvas(e)) return this;
                            if (this.isTimerStarted) {
                                if (this.handler.mapState.zoom < this.handler.mapState.maxZoom) {
                                    const t = this.handler.mapState,
                                        i = Math.min(t.zoom + 1, t.maxZoom),
                                        n = (0, F.yK)(this.handler.container, e.clientX, e.clientY);
                                    Fe(t),
                                        be(t, i, {
                                            duration: I.zoom.animDuration,
                                            zoomPoint: t.keepCenterWhileUserZoomRotate ? void 0 : n,
                                            blockBuildingAnimation: !0,
                                        }),
                                        (this.handler.mapState.needRerender = !0);
                                }
                            } else {
                                const t = (0, F.yK)(this.handler.container, e.clientX, e.clientY);
                                this.handler.modules.identifier
                                    .search('mouseClick', t, !0)
                                    .then((i) => {
                                        const n = this.handler.modules.ruler;
                                        n.enabled
                                            ? n.handleClick(t, i)
                                            : this.handler.dblClickTimer ||
                                              (this.handler.dblClickTimer = window.setTimeout(
                                                  () => {
                                                      U('click', i, e, t, this.handler.modules),
                                                          (this.handler.dblClickTimer = void 0);
                                                  },
                                                  I.events.doubleClickTime,
                                              ));
                                    });
                            }
                            return (
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'center',
                                }),
                                new $l(this.handler)
                            );
                        }
                        processKeyDownAction(e) {
                            return 'Control' === e.key || 'Meta' === e.key
                                ? (this.handler.modules.map.emit('interactionend', {
                                      target: 'center',
                                  }),
                                  new Rl('keyPrimary', this.mouseDownPoint, this.handler))
                                : this;
                        }
                    }
                    class Nl {
                        constructor(e, t, i) {
                            (this.mouseMovePoint = e),
                                (this.dragStartPoint = t),
                                (this.handler = i),
                                this.handler.container.classList.add('mapgl-dragging'),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState);
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'mousemove':
                                    return this.processMouseMoveAction(e);
                                case 'mouseup':
                                    return this.processMouseUpAction(e);
                                case 'keydown':
                                    return this.processKeyDownAction(e);
                                default:
                                    return this;
                            }
                        }
                        update(e) {
                            const t = this.handler.modules.camera.unproject(this.dragStartPoint),
                                i = this.handler.modules.camera.unproject(this.mouseMovePoint),
                                n = D.d9(e.center);
                            D.IH(n, n, t),
                                D.lu(n, n, i),
                                Fe(e),
                                se(e, n, { animate: !1 }),
                                (this.dragStartPoint = this.mouseMovePoint),
                                (e.needRerender = !0);
                        }
                        processMouseMoveAction(e) {
                            return (
                                (this.mouseMovePoint = (0, F.yK)(
                                    this.handler.container,
                                    e.clientX,
                                    e.clientY,
                                )),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState),
                                this
                            );
                        }
                        processMouseUpAction(e) {
                            return 0 === e.button ? this.returnToInitialState() : this;
                        }
                        processKeyDownAction(e) {
                            return 'Control' === e.key || 'Meta' === e.key
                                ? (this.handler.container.classList.remove('mapgl-dragging'),
                                  this.handler.modules.map.emit('interactionend', {
                                      target: 'center',
                                  }),
                                  new Rl('keyPrimary', this.mouseMovePoint, this.handler))
                                : this;
                        }
                        returnToInitialState() {
                            return (
                                this.handler.container.classList.remove('mapgl-dragging'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'center',
                                }),
                                (this.handler.mapState.userHasInteracted = !0),
                                new $l(this.handler)
                            );
                        }
                    }
                    var Ul = i(9090);
                    class Zl {
                        constructor(e, t, i) {
                            (this.handler = i),
                                (this.touchStartPoints = t),
                                (this.touchMovePoints = e),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.mapState.disablePitchByUserInteraction ||
                                    this.handler.container.classList.add('mapgl-rotating'),
                                this.update(this.handler.mapState);
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'touchstart':
                                    return this.processTouchStartAction(e);
                                case 'touchmove':
                                    return this.processTouchMoveAction(e);
                                case 'touchend':
                                    return this.processTouchEndAction(e);
                                default:
                                    return this;
                            }
                        }
                        processTouchStartAction(e) {
                            return (
                                this.handler.container.classList.remove('mapgl-rotating'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'pitch/zoom/rotation',
                                }),
                                new Vl(e, this.handler, !1)
                            );
                        }
                        processTouchMoveAction(e) {
                            return (
                                e.preventDefault(),
                                (this.touchMovePoints = (0, F.KK)(
                                    e.touches,
                                    this.handler.container,
                                )),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState),
                                this
                            );
                        }
                        processTouchEndAction(e) {
                            return (
                                this.handler.container.classList.remove('mapgl-rotating'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'pitch/zoom/rotation',
                                }),
                                0 === e.touches.length
                                    ? ((this.handler.mapState.userHasInteracted = !0),
                                      new $l(this.handler))
                                    : new Vl(e, this.handler, !1)
                            );
                        }
                    }
                    class Hl extends Zl {
                        constructor(e, t, i) {
                            super(e, t, i),
                                (this.startPxAngle = 0),
                                (this.rotationDetected = !1),
                                t.length > 1 && (this.startPxAngle = (0, Ul.Hl)(t[0], t[1]));
                        }
                        update(e) {
                            if (this.touchStartPoints.length < 2 || this.touchMovePoints.length < 2)
                                return;
                            const t = (0, Ul.L$)(this.touchMovePoints[0], this.touchMovePoints[1]),
                                i =
                                    z.TK(this.touchMovePoints[0], this.touchMovePoints[1]) /
                                    z.TK(this.touchStartPoints[0], this.touchStartPoints[1]),
                                n = e.zoom + (Math.log(i) / Math.log(2)) * I.zoom.mobilePinchDelta;
                            let o = 0,
                                r = 0;
                            if (!this.rotationDetected) {
                                const e = (0, Ul.Hl)(
                                    this.touchMovePoints[0],
                                    this.touchMovePoints[1],
                                );
                                (r = Math.abs(this.startPxAngle - e)),
                                    r > Math.PI && (r = 2 * Math.PI - r),
                                    r >= this.handler.mapState.touchRotationThreshold &&
                                        (this.rotationDetected = !0);
                            }
                            if (this.rotationDetected) {
                                const e = this.handler.modules.camera.unproject(
                                        this.touchStartPoints[0],
                                    ),
                                    t = this.handler.modules.camera.unproject(
                                        this.touchStartPoints[1],
                                    ),
                                    i = this.handler.modules.camera.unproject(
                                        this.touchMovePoints[0],
                                    ),
                                    n = this.handler.modules.camera.unproject(
                                        this.touchMovePoints[1],
                                    );
                                if (e && t && i && n) {
                                    o = (0, Ul.Hl)(e, t) - (0, Ul.Hl)(i, n);
                                }
                            }
                            const s = e.rotation + o,
                                a = e.center;
                            e.keepCenterWhileUserZoomRotate ||
                                D.IH(a, e.center, (0, fe.Kv)(e, t, { zoom: n, rotation: s })),
                                Fe(e),
                                se(e, a, { animate: !1 }),
                                be(e, n, { animate: !1 }),
                                this.handler.mapState.disableRotationByUserInteraction ||
                                    he(e, s, { animate: !1 }),
                                (this.touchStartPoints = this.touchMovePoints),
                                (e.needRerender = !0);
                        }
                    }
                    class Gl extends Zl {
                        constructor(e, t, i) {
                            super(e, t, i);
                        }
                        update(e) {
                            const t = this.touchStartPoints.map((t) => (0, fe.Te)(e.size, t)),
                                i = this.touchMovePoints.map((t) => (0, fe.Te)(e.size, t)),
                                n = (0, Ul.L$)(t[0], t[1]),
                                o = ((0, Ul.L$)(i[0], i[1])[1] - n[1]) * I.zoom.mousePitchDelta;
                            Fe(e),
                                _e(e, (0, fe.uZ)(e.pitch + o, e.minPitch, e.maxPitch), {
                                    animate: !1,
                                }),
                                (this.touchStartPoints = this.touchMovePoints),
                                (e.needRerender = !0);
                        }
                    }
                    class Vl {
                        constructor(e, t, i) {
                            (this.handler = t),
                                (this.needClickOnTouchEnd = i),
                                (this.toZoomRotate = !1),
                                (this.touchStartPoints = (0, F.KK)(
                                    e.touches,
                                    this.handler.container,
                                )),
                                (this.handler.mapState.userHasInteracted = !0),
                                (this.isTimerStarted = void 0 !== this.handler.dblClickTimer),
                                (0, F.N2)(e)
                                    ? (this.startedInteractionTarget = 'pitch/zoom/rotation')
                                    : this.isTimerStarted
                                    ? ((this.startedInteractionTarget = 'zoom/rotation'),
                                      window.clearTimeout(this.handler.dblClickTimer),
                                      (this.handler.dblClickTimer = void 0))
                                    : (this.startedInteractionTarget = 'center'),
                                this.handler.modules.map.emit('interactionstart', {
                                    target: this.startedInteractionTarget,
                                });
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'touchstart':
                                    return this.processTouchStartAction(e);
                                case 'touchmove':
                                    return this.processTouchMoveAction(e);
                                case 'touchend':
                                    return this.processTouchEndAction(e);
                                default:
                                    return this;
                            }
                        }
                        getStartedInteractionTarget() {
                            return this.startedInteractionTarget;
                        }
                        processTouchStartAction(e) {
                            return (
                                e.preventDefault(),
                                1 === this.touchStartPoints.length &&
                                    ((this.needClickOnTouchEnd = !1),
                                    this.handler.modules.map.emit('interactionend', {
                                        target: 'center',
                                    }),
                                    (this.startedInteractionTarget = 'pitch/zoom/rotation'),
                                    this.handler.modules.map.emit('interactionstart', {
                                        target: this.startedInteractionTarget,
                                    }),
                                    (this.handler.mapState.userHasInteracted = !0)),
                                (this.touchStartPoints = (0, F.KK)(
                                    e.touches,
                                    this.handler.container,
                                )),
                                this
                            );
                        }
                        processTouchMoveAction(e) {
                            e.preventDefault();
                            const t = (0, F.KK)(e.touches, this.handler.container);
                            if (!(0, F.N2)(e))
                                return z.TE(this.touchStartPoints[0], t[0]) < I.events.dragThreshold
                                    ? ((this.touchStartPoints = t), this)
                                    : this.isTimerStarted
                                    ? new ql(t[0], this.touchStartPoints[0], this.handler)
                                    : this.handler.mapState.disableDragging
                                    ? ((this.touchStartPoints = t),
                                      (this.needClickOnTouchEnd = !1),
                                      this)
                                    : new Wl(t[0], this.touchStartPoints[0], this.handler);
                            if (this.touchStartPoints.length < 2)
                                return this.processTouchStartAction(e);
                            const i = z.Ue(),
                                n = z.Ue();
                            z.lu(i, t[0], this.touchStartPoints[0]),
                                z.lu(n, t[1], this.touchStartPoints[1]);
                            const o = z.AK(i, n);
                            if (o > 0) {
                                const e = z.TE(this.touchStartPoints[0], t[0]),
                                    i = z.TE(this.touchStartPoints[1], t[1]);
                                return e < I.events.pitchThreshold || i < I.events.pitchThreshold
                                    ? ((this.touchStartPoints = t), this)
                                    : this.handler.mapState.disablePitchByUserInteraction
                                    ? this
                                    : new Gl(t, this.touchStartPoints, this.handler);
                            }
                            if (o < 0) return new Hl(t, this.touchStartPoints, this.handler);
                            return (0, Ul.se)(i) || (0, Ul.se)(n)
                                ? this.pitchWaitingTimer
                                    ? this
                                    : this.toZoomRotate
                                    ? ((this.toZoomRotate = !1),
                                      new Hl(t, this.touchStartPoints, this.handler))
                                    : ((this.pitchWaitingTimer = window.setTimeout(() => {
                                          (this.toZoomRotate = !0),
                                              (this.pitchWaitingTimer = void 0);
                                      }, I.events.pitchWaitingTime)),
                                      this)
                                : new Hl(t, this.touchStartPoints, this.handler);
                        }
                        processTouchEndAction(e) {
                            return (
                                e.cancelable && e.preventDefault(),
                                0 === e.touches.length
                                    ? 1 === e.changedTouches.length && this.needClickOnTouchEnd
                                        ? this.processTouchClickAction(this.touchStartPoints[0], e)
                                        : ((this.handler.mapState.userHasInteracted = !0),
                                          this.handler.modules.map.emit('interactionend', {
                                              target:
                                                  e.changedTouches.length > 1
                                                      ? 'pitch/zoom/rotation'
                                                      : 'center',
                                          }),
                                          new $l(this.handler))
                                    : ((0, F.N2)(e) ||
                                          (this.handler.modules.map.emit('interactionend', {
                                              target: 'pitch/zoom/rotation',
                                          }),
                                          (this.startedInteractionTarget = 'center'),
                                          this.handler.modules.map.emit('interactionstart', {
                                              target: this.startedInteractionTarget,
                                          }),
                                          (this.handler.mapState.userHasInteracted = !0)),
                                      (this.touchStartPoints = (0, F.KK)(
                                          e.touches,
                                          this.handler.container,
                                      )),
                                      this)
                            );
                        }
                        processTouchClickAction(e, t) {
                            if (this.isTimerStarted) {
                                if (this.handler.mapState.zoom < this.handler.mapState.maxZoom) {
                                    const t = this.handler.mapState,
                                        i = Math.min(t.zoom + 1, t.maxZoom),
                                        n = t.keepCenterWhileUserZoomRotate ? void 0 : e;
                                    Fe(t),
                                        be(t, i, {
                                            duration: I.zoom.animDuration,
                                            zoomPoint: n,
                                            blockBuildingAnimation: !0,
                                        }),
                                        (this.handler.mapState.needRerender = !0);
                                }
                            } else if (this.handler.modules.layout.isActionWithCanvas(t))
                                this.handler.modules.identifier
                                    .search('mouseClick', e, !0)
                                    .then((i) => {
                                        const n = this.handler.modules.ruler;
                                        n.enabled
                                            ? n.handleClick(e, i)
                                            : this.handler.dblClickTimer ||
                                              (this.handler.dblClickTimer = window.setTimeout(
                                                  () => {
                                                      U('click', i, t, e, this.handler.modules),
                                                          (this.handler.dblClickTimer = void 0);
                                                  },
                                                  I.events.doubleClickTime,
                                              ));
                                    });
                            else {
                                const e = t.changedTouches[0];
                                t.target &&
                                    e &&
                                    t.target.dispatchEvent(
                                        new MouseEvent('click', {
                                            bubbles: !0,
                                            cancelable: !0,
                                            clientX: e.clientX,
                                            clientY: e.clientY,
                                        }),
                                    );
                            }
                            return (
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'center',
                                }),
                                new $l(this.handler)
                            );
                        }
                    }
                    class Wl {
                        constructor(e, t, i) {
                            (this.handler = i),
                                (this.touchMovePoint = e),
                                (this.touchStartPoint = t),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.handler.container.classList.add('mapgl-dragging'),
                                this.update(this.handler.mapState);
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'touchstart':
                                    return this.processTouchStartAction(e);
                                case 'touchmove':
                                    return this.processTouchMoveAction(e);
                                case 'touchend':
                                    return this.processTouchEndAction();
                                default:
                                    return this;
                            }
                        }
                        update(e) {
                            const t = this.handler.modules.camera.unproject(this.touchStartPoint),
                                i = this.handler.modules.camera.unproject(this.touchMovePoint),
                                n = D.d9(e.center);
                            D.IH(n, n, t),
                                D.lu(n, n, i),
                                Fe(e),
                                se(e, n, { animate: !1 }),
                                (this.touchStartPoint = this.touchMovePoint),
                                (e.needRerender = !0);
                        }
                        processTouchStartAction(e) {
                            return (
                                this.handler.container.classList.remove('mapgl-dragging'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'center',
                                }),
                                new Vl(e, this.handler, !1)
                            );
                        }
                        processTouchMoveAction(e) {
                            e.preventDefault();
                            const t = (0, F.KK)(e.touches, this.handler.container);
                            return (
                                (this.touchMovePoint = t[0]),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState),
                                this
                            );
                        }
                        processTouchEndAction() {
                            return (
                                this.handler.container.classList.remove('mapgl-dragging'),
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'center',
                                }),
                                (this.handler.mapState.userHasInteracted = !0),
                                new $l(this.handler)
                            );
                        }
                    }
                    class ql {
                        constructor(e, t, i) {
                            (this.handler = i),
                                (this.mapHeight = i.mapState.size[1]),
                                (this.startZoom = i.mapState.zoom),
                                (this.touchMovePointY = e[1]),
                                (this.touchStartPoint = t),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState);
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'touchstart':
                                    return this.processTouchStartAction(e);
                                case 'touchmove':
                                    return this.processTouchMoveAction(e);
                                case 'touchend':
                                    return this.processTouchEndAction();
                                default:
                                    return this;
                            }
                        }
                        update(e) {
                            const t = this.touchMovePointY - this.touchStartPoint[1];
                            if (0 === t) return;
                            const i = t / this.mapHeight,
                                n = (0, fe.uZ)(
                                    this.startZoom + i * I.zoom.mobileTapDelta,
                                    e.minZoom,
                                    e.maxZoom,
                                ),
                                o = e.center;
                            e.keepCenterWhileUserZoomRotate ||
                                D.IH(o, e.center, (0, fe.Kv)(e, this.touchStartPoint, { zoom: n })),
                                Fe(e),
                                se(e, o, { animate: !1 }),
                                be(e, n, { animate: !1 }),
                                (e.needRerender = !0);
                        }
                        processTouchStartAction(e) {
                            return (
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'zoom/rotation',
                                }),
                                new Vl(e, this.handler, !1)
                            );
                        }
                        processTouchMoveAction(e) {
                            e.preventDefault();
                            const t = (0, F.KK)(e.touches, this.handler.container);
                            return (
                                (this.touchMovePointY = t[0][1]),
                                (this.handler.mapState.userHasInteracted = !0),
                                this.update(this.handler.mapState),
                                this
                            );
                        }
                        processTouchEndAction() {
                            return (
                                this.handler.modules.map.emit('interactionend', {
                                    target: 'zoom/rotation',
                                }),
                                (this.handler.mapState.userHasInteracted = !0),
                                new $l(this.handler)
                            );
                        }
                    }
                    class $l {
                        constructor(e) {
                            this.handler = e;
                        }
                        processAction(e) {
                            switch (e.type) {
                                case 'mousedown':
                                    return this.processMouseDownAction(e);
                                case 'touchstart':
                                    return this.processTouchStartAction(e);
                                default:
                                    return this;
                            }
                        }
                        processMouseDownAction(e) {
                            const t = (0, F.yK)(this.handler.container, e.clientX, e.clientY);
                            switch (e.button) {
                                case 0:
                                    if (e.ctrlKey || e.metaKey)
                                        return new Rl('keyPrimary', t, this.handler);
                                    if (this.handler.modules.layout.isActionWithCanvas(e)) {
                                        U(
                                            'mousedown',
                                            this.handler.modules.identifier.searchSync(t),
                                            e,
                                            t,
                                            this.handler.modules,
                                        );
                                    }
                                    return new Bl(t, this.handler);
                                case 1:
                                    return new Rl('auxiliary', t, this.handler);
                                case 2:
                                    return new Rl('secondary', t, this.handler);
                                default:
                                    return this;
                            }
                        }
                        processTouchStartAction(e) {
                            if ((e.preventDefault(), !e.touches)) return this;
                            if (this.handler.modules.layout.isActionWithCanvas(e)) {
                                const t = (0, F.yK)(
                                    this.handler.container,
                                    e.changedTouches[0].clientX,
                                    e.changedTouches[0].clientY,
                                );
                                U(
                                    'touchstart',
                                    this.handler.modules.identifier.searchSync(t),
                                    e,
                                    t,
                                    this.handler.modules,
                                );
                            }
                            return new Vl(e, this.handler, 1 === e.touches.length);
                        }
                    }
                    class Xl {
                        processAction() {
                            return this;
                        }
                    }
                    class Yl {
                        constructor(e, t) {
                            (this.preventDefault = (e) => {
                                e.preventDefault();
                            }),
                                (this.onMouseMove = (e) => {
                                    this.dblClickTimer && (this.dblClickTimer = void 0),
                                        this.switchState(e);
                                }),
                                (this.onTouchStart = (e) => {
                                    this.modules.layout.isActionWithMap(e) && this.switchState(e);
                                }),
                                (this.switchState = (e) => {
                                    this.state;
                                    const t = this.state.processAction(e);
                                    this.state instanceof Xl || (this.state = t);
                                }),
                                (this.state = new $l(this)),
                                (this.mapState = e),
                                (this.modules = t),
                                (this.container = t.layout.mapContainer),
                                document.addEventListener('mouseup', this.switchState),
                                document.addEventListener('keydown', this.switchState),
                                document.addEventListener('keyup', this.switchState),
                                document.addEventListener('mouseleave', this.switchState),
                                document.addEventListener('mousemove', this.onMouseMove),
                                this.container.addEventListener('click', this.switchState),
                                this.container.addEventListener('mousedown', this.switchState),
                                this.container.addEventListener('mouseout', this.switchState),
                                document.addEventListener('touchstart', this.onTouchStart),
                                document.addEventListener('touchend', this.switchState),
                                document.addEventListener('touchmove', this.switchState),
                                this.container.addEventListener('dragstart', this.preventDefault),
                                this.container.addEventListener('drag', this.preventDefault),
                                this.container.addEventListener('dragend', this.preventDefault),
                                this.container.addEventListener('contextmenu', this.preventDefault),
                                this.container.addEventListener('touchmove', this.preventDefault);
                        }
                        destroy() {
                            document.removeEventListener('mouseup', this.switchState),
                                document.removeEventListener('keydown', this.switchState),
                                document.removeEventListener('keyup', this.switchState),
                                document.removeEventListener('mouseleave', this.switchState),
                                document.removeEventListener('mousemove', this.onMouseMove),
                                this.container.removeEventListener('click', this.switchState),
                                this.container.removeEventListener('mousedown', this.switchState),
                                this.container.removeEventListener('mouseout', this.switchState),
                                document.removeEventListener('touchstart', this.onTouchStart),
                                document.removeEventListener('touchend', this.switchState),
                                document.removeEventListener('touchmove', this.switchState),
                                this.container.removeEventListener(
                                    'dragstart',
                                    this.preventDefault,
                                ),
                                this.container.removeEventListener('drag', this.preventDefault),
                                this.container.removeEventListener('dragend', this.preventDefault),
                                this.container.removeEventListener(
                                    'contextmenu',
                                    this.preventDefault,
                                ),
                                this.container.removeEventListener(
                                    'touchmove',
                                    this.preventDefault,
                                );
                        }
                        block() {
                            if (this.state instanceof Xl) return;
                            const { map: e } = this.modules;
                            switch (
                                (this.container.classList.remove('mapgl-dragging'),
                                this.container.classList.remove('mapgl-rotating'),
                                this.state.constructor)
                            ) {
                                case Bl:
                                case Nl:
                                case Wl:
                                    e.emit('interactionend', { target: 'center' });
                                    break;
                                case Rl:
                                case jl:
                                    e.emit('interactionend', { target: 'pitch/rotation' });
                                    break;
                                case ql:
                                    e.emit('interactionend', { target: 'zoom/rotation' });
                                    break;
                                case Hl:
                                case Gl:
                                    e.emit('interactionend', { target: 'pitch/zoom/rotation' });
                                    break;
                                case Vl: {
                                    const t = this.state.getStartedInteractionTarget();
                                    e.emit('interactionend', { target: t });
                                    break;
                                }
                            }
                            this.state = new Xl();
                        }
                        unblock() {
                            this.state instanceof $l ||
                                (this.state instanceof Xl && (this.state = new $l(this)));
                        }
                    }
                    var Kl = i(9311),
                        Jl = i(4288),
                        Ql = i(4635),
                        ec = i(9833),
                        tc = i(1683),
                        ic = i(1285);
                    class nc {
                        constructor(e, t) {
                            (this.mapState = e),
                                (this.modules = t),
                                (this.enabled = !1),
                                (this.justEnabled = !1),
                                (this.isMetaLoading = !1),
                                (this.lastUpdateTime = -1 / 0),
                                (this.regionIds = new Set()),
                                (this.id = (0, E.f)()),
                                (this.gridState = (0, Ql.y7)(
                                    'traffic',
                                    0,
                                    this.id,
                                    I.traffic.minZoom,
                                    I.traffic.maxZoom,
                                    I.traffic.minZoom,
                                    I.traffic.maxDetailLevel,
                                    t,
                                    e,
                                )),
                                (this.viewportDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'demMode', type: 'boolean' },
                                ]));
                        }
                        show() {
                            this.enabled ||
                                ((this.enabled = !0),
                                (this.justEnabled = !0),
                                this.modules.map.emit('trafficshow'));
                        }
                        hide() {
                            this.enabled &&
                                ((0, Ql.d1)(this.gridState),
                                (this.enabled = !1),
                                this.modules.map.emit('traffichide'));
                        }
                        isEnabled() {
                            return this.enabled;
                        }
                        destroy() {
                            (0, Ql.d1)(this.gridState);
                        }
                        redraw() {
                            this.enabled &&
                                ((0, Ql.d1)(this.gridState),
                                (0, Kl.o)(this.gridState, this.mapState));
                        }
                        activateStyleUpdating() {
                            this.enabled &&
                                (0, ic.I2)(
                                    this.gridState,
                                    this.mapState.handyStyleId,
                                    this.modules.styleManager.getStyleRevision(
                                        this.mapState.handyStyleId,
                                    ),
                                    this.modules.map.core.getIsFirstStyleUpdate(),
                                );
                        }
                        finishStyleUpdating() {
                            this.enabled && (0, ic.cA)(this.gridState);
                        }
                        update() {
                            if (!this.enabled) return;
                            if (
                                ((0, fe.TH)(this.regionIds, this.mapState.shownRegionIds) ||
                                    ((this.regionIds = new Set(this.mapState.shownRegionIds)),
                                    this.fetchMeta()),
                                Date.now() - this.lastUpdateTime > I.traffic.updateInterval &&
                                    this.fetchMeta(),
                                void 0 === this.timestamp)
                            )
                                return;
                            (this.viewportDiffer.check(this.mapState) || this.justEnabled) &&
                                ((this.justEnabled = !1),
                                (0, Kl.o)(this.gridState, this.mapState),
                                (this.mapState.needRerender = !0));
                            const e = Object.assign({}, this.gridState.displayedMods);
                            (0, Jl.r)(this.gridState, this.mapState, this.modules),
                                this.fetch((0, Ql.w1)(this.gridState), this.timestamp),
                                this.abortFetch((0, Ql.lH)(this.gridState)),
                                this.generate((0, Ql.e)(this.gridState)),
                                this.clearTiles((0, Ql.HM)(this.gridState)),
                                (0, Ql.aq)(
                                    this.modules.tileManager,
                                    this.mapState,
                                    this.gridState,
                                    e,
                                );
                        }
                        viewportTilesReady() {
                            return (0, Ql.ej)(this.gridState.tiles, this.gridState.viewportTiles);
                        }
                        fetch(e, t) {
                            e.sort((e, t) => (0, G.qu)(this.mapState.center, e, t)).forEach((e) =>
                                (function (e, t, i, n, o) {
                                    if (!n.size) return;
                                    t.workers.parser
                                        .fetchTrafficTile({
                                            coords: e.coords,
                                            tileServer: i.trafficServer,
                                            tileProtocol: i.trafficProtocol || i.tileProtocol,
                                            regionIds: Array.from(n),
                                            timestamp: o,
                                        })
                                        .then(() => {
                                            e.status === ec.z3.Loading &&
                                                (e.serverMetadata = [
                                                    { regionId: 0, metatileHash: -2 },
                                                ]);
                                        });
                                })(e, this.modules, this.mapState, this.regionIds, t),
                            );
                        }
                        abortFetch(e) {
                            e.forEach((e) =>
                                this.modules.workers.parser.abortTrafficTileRequest(e.key),
                            );
                        }
                        generate(e) {
                            e.sort((e, t) => (0, G.qu)(this.mapState.center, e, t)).forEach((e) => {
                                const t = (0, ec._v)(e);
                                t &&
                                    this.modules.workers.parser
                                        .generateTrafficTile({
                                            styleId: this.mapState.handyStyleId,
                                            coords: e.coords,
                                            pixelRatio: window.devicePixelRatio,
                                            styleState: this.mapState.styleState,
                                            sourceId: this.modules.defaultSource.getId(),
                                        })
                                        .then(({ results: e }) => (0, tc.aK)(t, e));
                            });
                        }
                        clearTiles(e) {
                            for (const t of e)
                                this.modules.workers.parser.deleteTrafficTile(t.key),
                                    delete this.gridState.tiles[t.key];
                        }
                        fetchMeta() {
                            if (this.isMetaLoading || !this.regionIds.size) return;
                            this.isMetaLoading = !0;
                            const e = this.mapState,
                                t = (0, T.XK)(I.traffic.timestampUrl, {
                                    host: e.trafficServer,
                                    protocol: e.trafficProtocol || e.tileProtocol,
                                    regions: Array.from(this.regionIds).join(','),
                                });
                            fetch(t)
                                .then((e) => {
                                    if (e.ok) return e.json();
                                    throw new Error(
                                        `Request traffic timestamp error with status ${e.status}`,
                                    );
                                })
                                .then((e) => {
                                    var t, i;
                                    if (
                                        !e.length ||
                                        void 0 ===
                                            (null === (t = e[0]) || void 0 === t
                                                ? void 0
                                                : t.time) ||
                                        void 0 ===
                                            (null === (i = e[0]) || void 0 === i ? void 0 : i.score)
                                    )
                                        throw new Error(
                                            `Bad traffic timestamp and score response ${e}`,
                                        );
                                    let n = 0;
                                    e.forEach((e) => (n += e.score)),
                                        (n = Math.round(n / e.length)),
                                        this.modules.map.emit('trafficscore', { score: n }),
                                        (this.timestamp = e[0].time),
                                        (this.isMetaLoading = !1),
                                        (this.lastUpdateTime = Date.now()),
                                        this.redraw();
                                })
                                .catch((e) => {
                                    (this.isMetaLoading = !1), console.error(e);
                                });
                        }
                    }
                    class oc {
                        constructor(e) {
                            (this.externalContainer = e),
                                (this.rootContainer = document.createElement('div')),
                                (this.rootContainer.style.position = 'relative'),
                                (this.rootContainer.style.height = '100%'),
                                (this.rootContainer.style.width = '100%'),
                                (this.rootContainer.style.overflow = 'hidden'),
                                this.externalContainer.appendChild(this.rootContainer),
                                (this.mapContainer = document.createElement('div')),
                                (this.mapContainer.style.position = 'relative'),
                                (this.mapContainer.style.height = '100%'),
                                (this.mapContainer.style.width = '100%'),
                                (this.mapContainer.style.touchAction = 'none'),
                                (this.mapContainer.style.webkitUserSelect = 'none'),
                                (this.mapContainer.style.userSelect = 'none'),
                                this.rootContainer.appendChild(this.mapContainer),
                                (this.canvas = document.createElement('canvas')),
                                (this.canvas.style.display = 'block'),
                                this.mapContainer.appendChild(this.canvas),
                                (this.htmlContainerInMap = document.createElement('div')),
                                (this.htmlContainerInMap.style.position = 'absolute'),
                                (this.htmlContainerInMap.style.left = '0'),
                                (this.htmlContainerInMap.style.top = '0'),
                                (this.htmlContainerInMap.style.width = '100%'),
                                (this.htmlContainerInMap.style.height = '0'),
                                (this.htmlContainerInMap.style.webkitUserSelect = 'auto'),
                                (this.htmlContainerInMap.style.userSelect = 'auto'),
                                this.mapContainer.appendChild(this.htmlContainerInMap),
                                (this.htmlContainerOutMap = document.createElement('div')),
                                (this.htmlContainerOutMap.style.position = 'absolute'),
                                (this.htmlContainerOutMap.style.left = '0'),
                                (this.htmlContainerOutMap.style.top = '0'),
                                (this.htmlContainerOutMap.style.width = '100%'),
                                (this.htmlContainerOutMap.style.height = '0'),
                                this.mapContainer.after(this.htmlContainerOutMap);
                        }
                        setCanvasSize(e, t) {
                            const i = window.devicePixelRatio;
                            return (
                                (this.canvas.width = e * i),
                                (this.canvas.height = t * i),
                                (this.canvas.style.width = e + 'px'),
                                (this.canvas.style.height = t + 'px'),
                                this
                            );
                        }
                        destroy() {
                            for (; this.externalContainer.lastChild; )
                                this.externalContainer.removeChild(
                                    this.externalContainer.lastChild,
                                );
                        }
                        isActionWithCanvas(e) {
                            return e.target === this.canvas;
                        }
                        isActionWithMap(e) {
                            if (e instanceof MouseEvent || e instanceof KeyboardEvent)
                                return this.isTargetInMap(e.target);
                            return Array.from(e.touches)
                                .map((e) => e.target)
                                .some((e) => this.isTargetInMap(e));
                        }
                        isTargetInMap(e) {
                            return !!(e && e instanceof Node) && this.mapContainer.contains(e);
                        }
                    }
                    class rc {
                        constructor(e, t) {
                            (this.loadingCounter = 0),
                                (this.isIdle = () => 0 === this.loadingCounter),
                                (this.state = e),
                                (this.modules = t),
                                (this.textureKeys = []),
                                (this.texturesMap = new Map());
                        }
                        addTexture(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                this.loadingCounter++;
                                const i = yield $s(e);
                                return yield this.storeTexture(i, t);
                            });
                        }
                        addPreparedTexture(e) {
                            const t = `prepared-${(0, E.f)()}`;
                            return (
                                this.textureKeys.push(t),
                                this.texturesMap.set(t, e),
                                this.textureKeys.length - 1
                            );
                        }
                        updatePreparedTexture(e, t) {
                            this.deleteTexture(e), this.texturesMap.set(this.textureKeys[e], t);
                        }
                        loadTexture(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                this.loadingCounter++;
                                const i = yield this.loadImage(e);
                                if (i) return yield this.storeTexture(i, t);
                                this.decreaseLoadingCounter();
                            });
                        }
                        getTexture(e) {
                            return this.texturesMap.get(this.textureKeys[e]);
                        }
                        destroy() {
                            (this.textureKeys = []), this.texturesMap.clear();
                        }
                        deleteTexture(e) {
                            var t;
                            const i = this.textureKeys[e];
                            return (
                                null === (t = this.texturesMap.get(i)) ||
                                    void 0 === t ||
                                    t.remove(),
                                this.texturesMap.delete(i)
                            );
                        }
                        decreaseLoadingCounter() {
                            this.loadingCounter = Math.max(this.loadingCounter - 1, 0);
                        }
                        storeTexture(e, t) {
                            var i, n;
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const o = null == t ? void 0 : t.size,
                                    r =
                                        null !== (i = null == t ? void 0 : t.pixelRatio) &&
                                        void 0 !== i
                                            ? i
                                            : window.devicePixelRatio,
                                    s =
                                        null !== (n = null == t ? void 0 : t.imagePadding) &&
                                        void 0 !== n
                                            ? n
                                            : 1;
                                this.decreaseLoadingCounter();
                                const a = (function (e, t) {
                                        const i = void 0 !== t ? `_${t[0]},${t[1]}` : '';
                                        return `${e}${i}`;
                                    })(e.getAttribute('src') || e.currentSrc, o),
                                    l = this.textureKeys.indexOf(a);
                                if (l > -1 && this.texturesMap.has(a)) return l;
                                const c = this.modules.renderer.getRenderingContext(),
                                    d = (o || [e.width, e.height]).map((e) => e * r),
                                    h = Xs(e, d),
                                    u = d.map((e) => e + 2 * s);
                                if (
                                    !(null == t ? void 0 : t.skipAtlasSizeChecking) &&
                                    (u[0] > I.atlasSize[0] || u[1] > I.atlasSize[1])
                                )
                                    throw new Error(
                                        `Image texture dimensions ${u} are larger than the maximum possible ${I.atlasSize}`,
                                    );
                                const m = new it(void 0, {
                                    size: u,
                                    flipY: !1,
                                    magFilter: it.LinearFilter,
                                    minFilter: it.LinearFilter,
                                }).prepare(c);
                                return (
                                    m.subImage(c, h, s, s),
                                    this.texturesMap.set(a, m),
                                    this.textureKeys.push(a),
                                    (this.state.needRerender = !0),
                                    this.textureKeys.length - 1
                                );
                            });
                        }
                        loadImage(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                return new Promise((t) => {
                                    const i = new Image();
                                    (i.crossOrigin = 'Anonymous'),
                                        (i.src = e),
                                        (i.onload = () => t(i)),
                                        (i.onerror = () => t(void 0));
                                });
                            });
                        }
                    }
                    var sc = i(6849),
                        ac = i(1e3);
                    class lc {
                        constructor(e) {
                            (this.isLoading = !1),
                                (this.getKeyInfo = () =>
                                    (0, S.mG)(this, void 0, void 0, function* () {
                                        return yield this.request;
                                    })),
                                (this.isIdle = () => !this.isLoading);
                            const { tileKey: t } = e;
                            if (t === I.tiles.tileKey || ac.X)
                                this.request = Promise.resolve({ showCommPoi: !1, urbi: !1 });
                            else {
                                const e = (0, T.IG)(sc.ns, { keyID: t });
                                (this.isLoading = !0),
                                    (this.request = fetch(e)
                                        .then(
                                            (e) => {
                                                if (e.ok) return e.json();
                                            },
                                            () => {
                                                console.error(
                                                    'Could not load tile key info. A style layers with commercial POI will be added to applied styles.',
                                                );
                                            },
                                        )
                                        .then((e) => {
                                            if (
                                                ((this.isLoading = !1),
                                                !e || !e.result || 200 !== e.meta.code)
                                            )
                                                return { showCommPoi: true, urbi: false };
                                            const { showCommPoi: t, urbi: i } =
                                                e.result.service.properties.public;
                                            return {
                                                showCommPoi: null == t || t,
                                                urbi: null != i && i,
                                            };
                                        }));
                            }
                        }
                    }
                    class cc {
                        constructor() {
                            this.sources = [];
                        }
                        addSource(e) {
                            this.sources.push(e);
                        }
                        removeSource(e) {
                            this.sources = this.sources.filter((t) => t.getId() !== e);
                        }
                        getSourceById(e) {
                            return this.sources.find((t) => t.getId() === e);
                        }
                    }
                    class dc {
                        constructor(e, t, i) {
                            (this.options = t),
                                (this.type = 'zenith'),
                                (this.id = (0, In.Q)()),
                                (this.state = e.state),
                                (this.modules = e.modules),
                                (this.zenithSource = new ea.nt(
                                    this.id,
                                    this.modules,
                                    this.options,
                                )),
                                (this.tileLayer = new Ct.I(
                                    I.tiles.maxUniverseZoom + 1,
                                    I.tiles.maxRegionalZoom,
                                    I.tiles.maxUniverseZoom + 1,
                                    I.tiles.maxDetailLevel,
                                    this.modules,
                                    this.state,
                                    this.zenithSource,
                                )),
                                this.modules.tileManager.addTileLayer(this.tileLayer),
                                this.modules.sourceStorage.addSource(this),
                                (this.mapglApiSource = i);
                        }
                        getId() {
                            return this.id;
                        }
                        getAttributes() {
                            return this.zenithSource.getAttributes();
                        }
                        setAttributes(e) {
                            this.zenithSource.setAttributes(e), this.tileLayer.redraw();
                        }
                        getUrl(e, t) {
                            return (0, T.Gr)(
                                e,
                                Object.assign(
                                    {
                                        host: this.options.tileServer,
                                        tileSet: this.options.tileSet,
                                        protocol: this.options.tileProtocol,
                                        subdomain: this.options.subdomains[0],
                                    },
                                    t,
                                ),
                            );
                        }
                        destroy() {
                            this.modules.tileManager.removeTileLayer(this.tileLayer),
                                this.tileLayer.destroy(),
                                this.modules.sourceStorage.removeSource(this.id),
                                this.zenithSource.destroy();
                        }
                        setFeatureStateMap(e) {
                            this.zenithSource.setFeatureStateMap(e);
                        }
                        setFeatureStateMapBinary(e) {
                            this.zenithSource.setFeatureStateMapBinary(e);
                        }
                        isIdentifiedAsDefault() {
                            var e;
                            return (
                                null === (e = this.options.identifyAsDefaultSource) ||
                                void 0 === e ||
                                e
                            );
                        }
                    }
                    var hc = i(7231);
                    class uc {
                        constructor(e, t) {
                            var i, n;
                            (this.modules = t),
                                (this.type = 'default'),
                                (this.id = (0, In.Q)()),
                                (this.options = {
                                    tileServer: e.tileServer,
                                    tileSet: e.tileSet,
                                    tileProtocol: e.tileProtocol,
                                    tileKey: e.tileKey,
                                    subdomains: e.subdomains,
                                    appId: e.appId,
                                    defaultLang: e.tileServerDefaultLang,
                                    sessionId:
                                        null !== (i = e.tileSessionId) && void 0 !== i
                                            ? i
                                            : e.sessionId,
                                    isDefaultSource: !0,
                                    identifyAsDefaultSource: !0,
                                    modelsPath: e.defaultSourceModelsRootUrl,
                                }),
                                (this.zenithSource = new ea.nt(
                                    this.id,
                                    this.modules,
                                    this.options,
                                )),
                                (this.universeTileLayer = new Ct.I(
                                    0,
                                    I.tiles.maxUniverseZoom,
                                    0,
                                    I.tiles.maxUniverseZoom,
                                    this.modules,
                                    e,
                                    this.zenithSource,
                                )),
                                (this.universeTileLayer.getLabelingData = () => {
                                    const e = Ct.I.prototype.getLabelingData.call(
                                        this.universeTileLayer,
                                    );
                                    return (
                                        this.regionalTileLayer.isBlank() || (e.labelsKeys = []), e
                                    );
                                }),
                                this.modules.tileManager.addTileLayer(this.universeTileLayer),
                                (this.regionalTileLayer = new Ct.I(
                                    I.tiles.maxUniverseZoom + 1,
                                    I.tiles.maxRegionalZoom,
                                    I.tiles.maxUniverseZoom + 1,
                                    I.tiles.maxDetailLevel,
                                    this.modules,
                                    e,
                                    this.zenithSource,
                                )),
                                this.modules.tileManager.addTileLayer(this.regionalTileLayer),
                                (this.commercialPoiSource = new hc.n(this.id, this.modules, {
                                    url: (0, T.Nt)('commercialPoi', {
                                        host: e.tileServer,
                                        tileSet: e.commercialTileSet,
                                        protocol: I.tiles.protocol,
                                        lang: e.lang,
                                    }),
                                    flipY: !0,
                                    identifyAsDefaultSource: !0,
                                })),
                                (this.commercialPoiTileLayer = new Ct.I(
                                    I.commercialPoi.minZoom,
                                    I.commercialPoi.maxZoom,
                                    I.commercialPoi.minZoom,
                                    no.rR,
                                    this.modules,
                                    e,
                                    this.commercialPoiSource,
                                )),
                                this.modules.tileManager.addTileLayer(this.commercialPoiTileLayer),
                                (this.modelSource = new hc.n((0, E.f)(), this.modules, {
                                    minZoom: I.models.minZoom,
                                    maxZoom: I.models.maxZoom,
                                    url: (0, T.Nt)(
                                        { url: e.modelsTilesUrl },
                                        {
                                            host: e.tileServer,
                                            tileSet: e.modelsTileSet,
                                            protocol: I.tiles.protocol,
                                            lang: e.lang,
                                        },
                                    ),
                                    ignoreMissingTiles: !0,
                                    identifyAsDefaultSource: !0,
                                    modelsPath:
                                        null !== (n = e.defaultSourceModelsRootUrl) && void 0 !== n
                                            ? n
                                            : (0, T.Nt)('gltfModel', {
                                                  host: e.tileServer,
                                                  tileSet: e.tileSet,
                                                  protocol: I.tiles.protocol,
                                                  lang: e.lang,
                                              }),
                                    flipY: !0,
                                })),
                                this.modelSource.setAttributes({ sourceName: 'models' }),
                                (this.modelTileLayer = new Ct.I(
                                    I.models.minZoom,
                                    I.models.maxZoom,
                                    I.models.minZoom,
                                    I.tiles.maxDetailLevel,
                                    this.modules,
                                    e,
                                    this.modelSource,
                                )),
                                this.modules.tileManager.addTileLayer(this.modelTileLayer),
                                this.modules.sourceStorage.addSource({
                                    isIdentifiedAsDefault: () => !0,
                                    getId: () => {
                                        var e;
                                        return null === (e = this.modelSource) || void 0 === e
                                            ? void 0
                                            : e.id;
                                    },
                                }),
                                this.modules.sourceStorage.addSource(this);
                        }
                        destroy() {
                            var e;
                            this.modules.tileManager.removeTileLayer(this.universeTileLayer),
                                this.universeTileLayer.destroy(),
                                this.modules.tileManager.removeTileLayer(this.regionalTileLayer),
                                this.regionalTileLayer.destroy(),
                                this.zenithSource.destroy(),
                                this.commercialPoiTileLayer &&
                                    (this.modules.tileManager.removeTileLayer(
                                        this.commercialPoiTileLayer,
                                    ),
                                    this.commercialPoiTileLayer.destroy()),
                                null === (e = this.commercialPoiSource) ||
                                    void 0 === e ||
                                    e.destroy(),
                                this.modelTileLayer &&
                                    (this.modules.tileManager.removeTileLayer(this.modelTileLayer),
                                    this.modelTileLayer.destroy()),
                                this.modelSource && this.modelSource.destroy(),
                                this.modules.sourceStorage.removeSource(this.id);
                        }
                        setAttributes(e) {
                            var t, i;
                            this.zenithSource.setAttributes(
                                Object.assign(Object.assign({}, e), P.so),
                            ),
                                this.universeTileLayer.redraw(),
                                this.regionalTileLayer.redraw(),
                                null === (t = this.commercialPoiSource) ||
                                    void 0 === t ||
                                    t.setAttributes(e),
                                null === (i = this.commercialPoiTileLayer) ||
                                    void 0 === i ||
                                    i.redraw();
                        }
                        getAttributes() {
                            return this.zenithSource.getAttributes();
                        }
                        getId() {
                            return this.id;
                        }
                        setHoverId(e) {
                            this.regionalTileLayer.setHoverId(e);
                        }
                        setDisabledRegionsId(e) {
                            (this.regionalTileLayer.disabledRegions = e),
                                (this.universeTileLayer.disabledRegions = e);
                        }
                        resetHoverId() {
                            this.regionalTileLayer.resetHoverId();
                        }
                        setFeatureStateMap(e) {
                            this.zenithSource.setFeatureStateMap(e),
                                this.universeTileLayer.onFeatureStateMapChange(),
                                this.regionalTileLayer.onFeatureStateMapChange(),
                                this.modules.modelLayer.onFeatureStateMapChange();
                        }
                        setFeatureStateMapBinary(e) {
                            this.zenithSource.setFeatureStateMapBinary(e),
                                this.universeTileLayer.onFeatureStateMapChange(),
                                this.regionalTileLayer.onFeatureStateMapChange(),
                                this.modules.modelLayer.onFeatureStateMapChange();
                        }
                        setHiddenBuildingIds(e) {
                            this.zenithSource.appendHiddenObjectIds(e),
                                this.regionalTileLayer.onHiddenBuildingsChange(e);
                        }
                        unsetHiddenBuildingIds(e) {
                            this.zenithSource.removeHiddenObjectIds(e),
                                this.regionalTileLayer.onHiddenBuildingsChange(e);
                        }
                        triggerOnHiddenBuildingsChange(e) {
                            this.regionalTileLayer.onHiddenBuildingsChange(e);
                        }
                        generateHoverTile(e, t, i, n, o, r, s, a) {
                            return this.zenithSource.generateTile(e, t, i, n, o, r, s, a);
                        }
                        generateModel(e) {
                            return this.zenithSource.generateModel(e);
                        }
                        isIdentifiedAsDefault() {
                            return !0;
                        }
                    }
                    const mc = {
                        dead: !0,
                        alive: !0,
                        unused: !0,
                        commercialDead: !1,
                        commercialAlive: !1,
                    };
                    class fc {
                        constructor(e, t) {
                            (this.mapState = e),
                                (this.modules = t),
                                (this.options = {}),
                                (this.viewportDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                ])),
                                (this.sizeDiffer = new De([{ path: 'size', type: 'vec2' }]));
                        }
                        update() {
                            this.isEnabled() &&
                                (this.sizeDiffer.check(this.mapState) && this.updateSize(),
                                this.viewportDiffer.check(this.mapState) && this.clear());
                        }
                        isEnabled() {
                            return !!this.canvas;
                        }
                        show(e = mc) {
                            this.options = e;
                            Object.values(e).every((e) => !1 === e)
                                ? this.hide()
                                : (this.createCanvas(), (this.mapState.needLabeling = !0));
                        }
                        hide() {
                            this.canvas &&
                                (this.modules.layout.mapContainer.removeChild(this.canvas),
                                (this.ctx = void 0),
                                (this.canvas = void 0));
                        }
                        drawLabels(e) {
                            if (!this.canvas || !this.ctx) return;
                            const t = this.ctx,
                                i = this.options,
                                n = {
                                    [Ta.m3.Dead]: '#ff0000',
                                    [Ta.m3.Alive]: '#30763c',
                                    [Ta.m3.Unused]: '#aaa',
                                    [Ta.m3.CommercialAlive]: '#3a9f22',
                                    [Ta.m3.CommercialDead]: '#ff0000',
                                },
                                o = new Int32Array(e),
                                r = {
                                    [Ta.m3.Dead]: [],
                                    [Ta.m3.Alive]: [],
                                    [Ta.m3.Unused]: [],
                                    [Ta.m3.CommercialAlive]: [],
                                    [Ta.m3.CommercialDead]: [],
                                };
                            for (let e = 0; e < o.length; e += 5) {
                                const t = o[e + 4];
                                r[t].push({
                                    x: o[e],
                                    y: o[e + 1],
                                    width: o[e + 2],
                                    height: o[e + 3],
                                });
                            }
                            this.clear();
                            const s = window.devicePixelRatio,
                                a = (e) => {
                                    (t.strokeStyle = n[e]),
                                        r[e].forEach((e) =>
                                            t.strokeRect(
                                                e.x * s + 0.5,
                                                e.y * s + 0.5,
                                                e.width * s,
                                                e.height * s,
                                            ),
                                        );
                                };
                            t.setLineDash([]),
                                i.unused && a(Ta.m3.Unused),
                                i.dead && a(Ta.m3.Dead),
                                i.alive && a(Ta.m3.Alive),
                                t.setLineDash([6]),
                                i.commercialDead && a(Ta.m3.CommercialDead),
                                i.commercialAlive && a(Ta.m3.CommercialAlive);
                        }
                        clear() {
                            if (this.canvas && this.ctx) {
                                const { clientWidth: e, clientHeight: t } = this.canvas;
                                this.ctx.clearRect(
                                    0,
                                    0,
                                    e * window.devicePixelRatio,
                                    t * window.devicePixelRatio,
                                );
                            }
                        }
                        createCanvas() {
                            this.canvas ||
                                ((this.canvas = document.createElement('canvas')),
                                (this.canvas.style.position = 'absolute'),
                                (this.canvas.style.left = '0'),
                                (this.canvas.style.top = '0'),
                                (this.canvas.style.pointerEvents = 'none'),
                                this.modules.layout.mapContainer.appendChild(this.canvas),
                                (this.ctx = this.canvas.getContext('2d') || void 0),
                                this.updateSize());
                        }
                        updateSize() {
                            if (!this.canvas) return;
                            const { clientWidth: e, clientHeight: t } =
                                this.modules.layout.rootContainer;
                            (this.canvas.width = e * window.devicePixelRatio),
                                (this.canvas.height = t * window.devicePixelRatio),
                                (this.canvas.style.width = e + 'px'),
                                (this.canvas.style.height = t + 'px');
                        }
                    }
                    function pc(e, t, i) {
                        const n = document.createElement('script');
                        (n.onload = t),
                            (n.onerror = (e) =>
                                i(
                                    (function (e) {
                                        let t = 'A problem with loading of the script';
                                        'string' == typeof e
                                            ? (t = `${t} ${e}`)
                                            : e.target instanceof Element &&
                                              (t = `${t} ${e.target.getAttribute('src') || ''}`);
                                        return t;
                                    })(e),
                                )),
                            (n.src = e),
                            document.head.appendChild(n);
                    }
                    function _c(e) {
                        return new Promise((t, i) => {
                            pc(e, t, i);
                        });
                    }
                    class vc {
                        isReady() {
                            return !0;
                        }
                        render() {}
                        update() {}
                        hasDisplayedBuilding() {
                            return !1;
                        }
                        getEventTarget() {}
                    }
                    class gc {
                        constructor(e, t) {
                            (this.state = e),
                                (this.modules = t),
                                (this.impl = new vc()),
                                (this.scriptFetchState = 'init');
                        }
                        getEventTarget(e) {
                            return this.impl.getEventTarget(e);
                        }
                        hasDisplayedBuilding(e) {
                            return this.impl.hasDisplayedBuilding(e);
                        }
                        isReady() {
                            return (
                                ('init' === this.scriptFetchState ||
                                    'done' === this.scriptFetchState) &&
                                this.impl.isReady()
                            );
                        }
                        render() {
                            this.impl.render();
                        }
                        update() {
                            if (!this.state.needRerender) return;
                            const e = [];
                            this.modules.tileManager.getTileObjects().forEach(({ children: t }) => {
                                if (t)
                                    return t
                                        .filter(
                                            ({ symbol: e, sink: t }) =>
                                                'gltfModel' === e && 'anchor' === t,
                                        )
                                        .forEach(({ attributes: t }) => {
                                            e.push(t);
                                        });
                            }),
                                0 !== e.length &&
                                    'init' === this.scriptFetchState &&
                                    ((this.scriptFetchState = 'loading'),
                                    (function (e, t) {
                                        return (0, S.mG)(this, void 0, void 0, function* () {
                                            const i = e.threeJs.path,
                                                n = `${i}/three.min.js`,
                                                o = `${i}/DRACOLoader.js`,
                                                r = `${i}/GLTFLoader.js`;
                                            if (window.THREE) return new yc(e, t, window.THREE);
                                            try {
                                                yield _c(n), yield Promise.all([_c(o), _c(r)]);
                                                const { THREE: i } = window;
                                                return new yc(e, t, i);
                                            } catch (e) {
                                                console.error(e);
                                            }
                                        });
                                    })(this.state, this.modules).then((t) => {
                                        t &&
                                            ((this.impl = t),
                                            (this.scriptFetchState = 'done'),
                                            this.impl.update(e));
                                    })),
                                this.impl.update(e);
                        }
                    }
                    class yc {
                        constructor(e, t, i) {
                            (this.state = e),
                                (this.modules = t),
                                (this.three = i),
                                (this.maxStyleZoom = -1 / 0),
                                (this.minStyleZoom = 1 / 0),
                                (this.isModelReady = !1),
                                (this.modelFetchState = 'init'),
                                (this.scene = new this.three.Scene()),
                                (this.tmpMatrix = new this.three.Matrix4()),
                                (this.camera = new this.three.PerspectiveCamera()),
                                (this.modelDataMap = {}),
                                (this.modelIds = new Set()),
                                (this.displayedModelAttributes = new Map()),
                                (this.modelsVisibilityMap = new Map()),
                                (this.modelsMapPoints = new Map()),
                                (this.camera.updateMatrix = () => {}),
                                (this.camera.updateMatrixWorld = () => {}),
                                (this.camera.updateProjectionMatrix = () => {}),
                                (this.renderer = new this.three.WebGLRenderer({
                                    canvas: this.modules.map.getCanvas(),
                                    context: this.modules.map.getWebGLContext(),
                                    alpha: !0,
                                    antialias: window.devicePixelRatio < 2,
                                })),
                                (this.renderer.physicallyCorrectLights = !0),
                                (this.renderer.outputEncoding = this.three.sRGBEncoding),
                                (this.renderer.autoClear = !1);
                            const n = new this.three.AmbientLight(16777215, 2.9);
                            this.scene.add(n),
                                (this.raycaster = new this.three.Raycaster()),
                                (this.pointer = new this.three.Vector2());
                            const o = new this.three.LoadingManager(),
                                r = new this.three.DRACOLoader(o).setDecoderPath(
                                    this.state.threeJs.path.concat('/draco/'),
                                );
                            this.loader = new this.three.GLTFLoader().setDRACOLoader(r);
                        }
                        render() {
                            const e = this.modules.map.getStyleZoom();
                            e < this.minStyleZoom ||
                                e > this.maxStyleZoom ||
                                (this.camera.projectionMatrix.fromArray(
                                    this.modules.camera.projectionMatrix,
                                ),
                                this.camera.projectionMatrixInverse
                                    .copy(this.camera.projectionMatrix)
                                    .invert(),
                                this.tmpMatrix.fromArray(
                                    this.modules.camera.viewProjectionMatrix.slice(),
                                ),
                                this.camera.matrixWorldInverse.multiplyMatrices(
                                    this.camera.projectionMatrixInverse,
                                    this.tmpMatrix,
                                ),
                                this.camera.matrixWorld
                                    .copy(this.camera.matrixWorldInverse)
                                    .invert(),
                                this.camera.matrix.copy(this.camera.matrixWorld),
                                this.camera.matrix.decompose(
                                    this.camera.position,
                                    this.camera.quaternion,
                                    this.camera.scale,
                                ),
                                this.renderer.resetState(),
                                this.renderer.setViewport(
                                    this.state.viewport.left * window.devicePixelRatio,
                                    this.state.viewport.bottom * window.devicePixelRatio,
                                    this.state.size[0] * window.devicePixelRatio,
                                    this.state.size[1] * window.devicePixelRatio,
                                ),
                                this.renderer.render(this.scene, this.camera),
                                'done' === this.modelFetchState &&
                                    ((this.isModelReady = !0), (this.modelFetchState = 'init')));
                        }
                        hasDisplayedBuilding(e) {
                            const { styleZoom: t } = this.state;
                            return (
                                t >= this.minStyleZoom &&
                                t <= this.maxStyleZoom &&
                                this.modelIds.has(e)
                            );
                        }
                        getEventTarget(e) {
                            const { clientX: t, clientY: i } =
                                    'changedTouches' in e ? e.changedTouches[0] : e,
                                n = this.getThreeJsViewportBounds();
                            if (!(0, ee.r3)(n, [t, window.innerHeight - i])) return;
                            const o = n.max[0] - n.min[0],
                                r = n.max[1] - n.min[1],
                                s = t - n.min[0],
                                a = window.innerHeight - i - n.min[1];
                            (this.pointer.x = (s / o) * 2 - 1),
                                (this.pointer.y = (a / r) * 2 - 1),
                                this.raycaster.setFromCamera(this.pointer, this.camera);
                            const l = this.raycaster.intersectObjects(this.scene.children, !0),
                                c = l[0] ? l[0] : void 0;
                            return c && 'Mesh' === c.object.type
                                ? {
                                      target: c,
                                      distance: c.distance,
                                      symbol: 'buildingModel',
                                      id: c.object.userData._id,
                                  }
                                : void 0;
                        }
                        isReady() {
                            return (
                                'init' === this.modelFetchState ||
                                !('done' !== this.modelFetchState || !this.isModelReady)
                            );
                        }
                        update(e) {
                            let t = !1;
                            const i = new Map();
                            e.forEach((e) => {
                                i.set(e.buildingId, e);
                            });
                            const n = [];
                            this.displayedModelAttributes.forEach((e, o) => {
                                i.has(o) || (n.push(e), (t = !0));
                            });
                            const o = [];
                            i.forEach((e, i) => {
                                this.displayedModelAttributes.has(i) || (o.push(e), (t = !0));
                            }),
                                t &&
                                    (this.updateMinAndMaxStyleZoom(e),
                                    this.loadAndDisplayModels(o),
                                    this.removeOldModels(n),
                                    (this.displayedModelAttributes = i),
                                    (t = !1)),
                                this.updateModelsVisibilityState();
                        }
                        getThreeJsViewportBounds() {
                            const e = window.devicePixelRatio,
                                t = new this.three.Vector4();
                            this.renderer.getViewport(t);
                            const i = t.x / e,
                                n = t.y / e,
                                o = t.z / e,
                                r = t.w / e;
                            return (0, ee.Ue)([i, n], [i + o, n + r]);
                        }
                        updateMinAndMaxStyleZoom(e) {
                            e.forEach((e) => {
                                var t, i;
                                const n = this.modules.styleManager.getStyleLayer(
                                    e.styleId,
                                    e.layerId,
                                );
                                (this.minStyleZoom = Math.min(
                                    null !== (t = null == n ? void 0 : n.minzoom) && void 0 !== t
                                        ? t
                                        : -1 / 0,
                                    this.minStyleZoom,
                                )),
                                    (this.maxStyleZoom = Math.max(
                                        null !== (i = null == n ? void 0 : n.maxzoom) &&
                                            void 0 !== i
                                            ? i
                                            : 1 / 0,
                                        this.maxStyleZoom,
                                    ));
                            });
                        }
                        updateModelsVisibilityState() {
                            const { styleZoom: e } = this.state;
                            if (e < this.minStyleZoom)
                                return (
                                    this.displayedModelAttributes.forEach((e) => {
                                        this.modelsVisibilityMap.get(e.buildingId) &&
                                            this.modules.map.emit('commmodelhide', {
                                                buildingId: e.buildingId,
                                            });
                                    }),
                                    void this.modelsVisibilityMap.clear()
                                );
                            const t = new Hi.V(this.state).getViewportVertices();
                            this.displayedModelAttributes.forEach((e) => {
                                var i;
                                const n =
                                        null !== (i = this.modelsMapPoints.get(e.buildingId)) &&
                                        void 0 !== i
                                            ? i
                                            : (0, M.projectGeoToMap)(e.lngLat),
                                    o = this.modelsVisibilityMap.get(e.buildingId),
                                    r = (0, ee.r3)((0, Oi.BS)(t), n);
                                if (void 0 === o)
                                    return (
                                        r &&
                                            this.modules.map.emit('commmodelshow', {
                                                buildingId: e.buildingId,
                                            }),
                                        void this.modelsVisibilityMap.set(e.buildingId, r)
                                    );
                                o !== r &&
                                    (this.modules.map.emit(r ? 'commmodelshow' : 'commmodelhide', {
                                        buildingId: e.buildingId,
                                    }),
                                    this.modelsVisibilityMap.set(e.buildingId, r));
                            });
                        }
                        appendHiddenObjectIds() {
                            const e = [];
                            this.modelIds.forEach((t) => {
                                e.push((0, O.IL)(t));
                            }),
                                this.modules.defaultSource.setHiddenBuildingIds(e);
                        }
                        loadAndDisplayModels(e) {
                            0 !== e.length &&
                                ((this.isModelReady = !1),
                                (this.modelFetchState = 'loading'),
                                Promise.all(
                                    e.reduce(
                                        (e, t) => (
                                            e.push(
                                                new Promise((e) => {
                                                    const i = new this.three.Object3D();
                                                    this.loader.load(
                                                        t.modelSrc,
                                                        (n) => {
                                                            n.scene.traverse((e) => {
                                                                e.isMesh &&
                                                                    (e.userData._id = t.buildingId);
                                                            }),
                                                                i.add(n.scene);
                                                            const o = (0, M.projectGeoToMap)(
                                                                    t.lngLat,
                                                                ),
                                                                r = (0, M.projectGeoToMap)(
                                                                    t.lngLatDirection,
                                                                ),
                                                                s = r[0] - o[0],
                                                                a = r[1] - o[1];
                                                            i.rotateX(Math.PI / 2),
                                                                i.rotateY(Math.atan2(a, s));
                                                            const l = z.TE(o, r);
                                                            i.scale.set(l, l, l),
                                                                i.position.set(o[0], o[1], 0);
                                                            const c = bc(t);
                                                            (this.modelDataMap[c] = i),
                                                                this.modelsMapPoints.set(
                                                                    t.buildingId,
                                                                    o,
                                                                ),
                                                                e({
                                                                    id: c,
                                                                    model: i,
                                                                    buildingId: t.buildingId,
                                                                });
                                                        },
                                                        () => {},
                                                        () => e(void 0),
                                                    );
                                                }),
                                            ),
                                            e
                                        ),
                                        [],
                                    ),
                                )
                                    .then((e) => {
                                        e.forEach((e) => {
                                            if (!e) return;
                                            const t = this.modelDataMap[e.id];
                                            t &&
                                                (this.scene.add(t),
                                                (this.state.needRerender = !0),
                                                (this.modelFetchState = 'done'),
                                                this.modelIds.add(e.buildingId));
                                        }),
                                            this.appendHiddenObjectIds();
                                    })
                                    .catch(() => {
                                        this.modelFetchState = 'init';
                                    }));
                        }
                        removeOldModels(e) {
                            0 !== e.length &&
                                e.forEach((e) => {
                                    const t = bc(e),
                                        i = this.modelDataMap[t];
                                    i &&
                                        (this.scene.remove(i),
                                        this.disposeObject(i),
                                        (this.modelDataMap[t] = void 0),
                                        this.modelIds.delete(e.buildingId),
                                        this.appendHiddenObjectIds()),
                                        this.modelsMapPoints.delete(e.buildingId);
                                });
                        }
                        disposeObject(e) {
                            const t = e.children;
                            if (t) for (let e = 0; e < t.length; e += 1) this.disposeObject(t[e]);
                            const i = e.geometry,
                                n = e.material;
                            if ((i && i.dispose(), n)) {
                                const e = n.map;
                                e && e.dispose(), n.dispose();
                            }
                        }
                    }
                    function bc(e) {
                        return `${e.modelSrc}_${e.buildingId}`;
                    }
                    class wc {
                        constructor(e) {
                            (this.fogLimits = new Float32Array([1e3, 1e6])),
                                (this.fogHorizonBlend = 0.2),
                                (this.lastStyleId = NaN),
                                (this.modules = e),
                                (this.program = this.modules.renderer.getShaderProgram('sky'));
                            const t = new Ft.l(new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]));
                            (this.vao = ((e, t) => {
                                const i = new Ot(e, {
                                    itemSize: 2,
                                    dataType: Ft.l.Float,
                                    stride: 0,
                                    offset: 0,
                                    normalized: !1,
                                });
                                return new Xe(t, { a_vec2_vertex: i });
                            })(t, this.program)),
                                (this.shaderDefinitions = [
                                    { type: 'SKY', value: '' },
                                    ...e.renderer.commonShaderDefines,
                                ]);
                        }
                        update() {
                            const e = this.modules.map.state;
                            e.enableSky &&
                                (isNaN(e.handyStyleId) ||
                                    (this.lastStyleId !== e.handyStyleId &&
                                        (this.updateSky(), (this.lastStyleId = e.handyStyleId))));
                        }
                        setParameters(e) {
                            const t = this.modules.map.state;
                            void 0 !== e.min && (this.fogLimits[0] = e.min),
                                void 0 !== e.max && (this.fogLimits[1] = e.max),
                                void 0 !== e.horizonBlend &&
                                    (this.fogHorizonBlend = e.horizonBlend);
                            const i = this.modules.styleManager.getStyleLayer(
                                t.handyStyleId,
                                Pi.t5,
                            );
                            i &&
                                (void 0 !== e.color &&
                                    (i.style.fogColor = (0, oo.nS)(e.color)
                                        ? (0, oo.lK)(e.color)
                                        : e.color),
                                void 0 !== e.skyColor &&
                                    (i.style.skyColor = (0, oo.nS)(e.skyColor)
                                        ? (0, oo.lK)(e.skyColor)
                                        : e.skyColor),
                                void 0 !== e.highColor &&
                                    (i.style.highColor = (0, oo.nS)(e.highColor)
                                        ? (0, oo.lK)(e.highColor)
                                        : e.highColor),
                                (t.needRerender = !0));
                        }
                        renderSky(e) {
                            if (!this.envStyleLayer) return;
                            const t = this.modules.map.state,
                                i = (0, $.jJ)(t.styleZoom, t.styleState, []),
                                n = this.modules.renderer.webGlExtensions;
                            Ji(e, rn),
                                this.program.enable(e, this.shaderDefinitions),
                                this.program.bind(e, {
                                    u_vec4_color: (0, $.m2)(
                                        (0, $.zn)(this.envStyleLayer.style.skyColor, i),
                                    ),
                                }),
                                ((e, t, i) => {
                                    const n = i.camera.viewMatrixTranspose,
                                        o = i.camera.projectionMatrixInverse;
                                    t.bind(e, {
                                        u_mat4_view_transposed: n,
                                        u_mat4_proj_inverted: o,
                                    });
                                })(e, this.program, this.modules),
                                Et(e, this.program, this.modules.map.state, this.modules),
                                this.vao.bind({ gl: e, extensions: n }),
                                e.drawArrays(e.TRIANGLE_FAN, 0, 4);
                        }
                        updateSky() {
                            const e = this.modules.styleManager.getStyleLayer(
                                this.modules.map.state.handyStyleId,
                                Pi.t5,
                            );
                            this.envStyleLayer = e;
                        }
                    }
                    class xc {
                        constructor(e, t, i) {
                            (this.map = i),
                                (this.camera = new Hi.V(e)),
                                (this.layout = new oc(t)),
                                (this.collector = new tt.P('main')),
                                (this.workers = new Ha()),
                                (this.styleManager = new sa(this)),
                                (this.assetManager = new ya(e, this)),
                                (this.imageManager = new rc(e, this)),
                                (this.floorManager = new rl(e, this)),
                                (this.personalPoiManager = new Pa(e, this)),
                                (this.buildingHeightAnimator = new qe(e, this)),
                                (this.gltfAnimator = new et(e, this)),
                                (this.renderer = new Hs(e, this)),
                                (this.layers = new Ya(e)),
                                (this.sourceStorage = new cc()),
                                (this.tileManager = new sl(e, this)),
                                (this.modelLayer = new Ia(e, this)),
                                (this.dynamicStyle = new V.hX()),
                                (this.imageCache = new Qa(this)),
                                (this.identifier = new Vs(e, this)),
                                (this.labeler = new ll(e, this)),
                                (this.ruler = new Dl(e, this)),
                                (this.trafficTileLayer = new nc(e, this)),
                                (this.handler = new Yl(e, this)),
                                (this.mouseMoveHandler = new Ve(this)),
                                (this.tileKeyInfo = new lc(e)),
                                (this.demManager = new On(this)),
                                (this.defaultSource = new uc(e, this)),
                                (this.labelsDebug = new fc(e, this)),
                                (this.environmentManager = new wc(this)),
                                e.threeJs.active && (this.threeJsSceneManager = new gc(e, this));
                        }
                        destroy() {
                            this.demManager.disable(),
                                this.imageManager.destroy(),
                                this.trafficTileLayer.destroy(),
                                this.tileManager.destroy(),
                                this.workers.destroy(),
                                this.renderer.destroy(),
                                this.handler.destroy(),
                                this.mouseMoveHandler.destroy(),
                                this.ruler.destroy(),
                                this.labelsDebug.hide(),
                                this.layout.destroy();
                        }
                    }
                    class Sc {
                        constructor(e, t = {}, i) {
                            var n, o, r, s, a, l;
                            (this.isStyleUpdateInProgress = !1),
                                (this.isFirstStyleUpdate = !0),
                                (this.lastResizeTime = -1 / 0),
                                (this.renderLoop = (e) => {
                                    var t;
                                    (this.requestedFrame = requestAnimationFrame(this.renderLoop)),
                                        this.updateImmersiveLevel(),
                                        this.modules.map.emit('framestart');
                                    const i = this.state;
                                    (i.time = Date.now()),
                                        i.collectStats &&
                                            ((i.stats.drawCount = 0),
                                            (i.stats.vertexCount = 0),
                                            (i.stats.tileCount = 0));
                                    const n = i.metrics,
                                        o = performance.now() - n.start > I.metricsTimeout;
                                    if (
                                        ((Number.isNaN(n.interactive + n.firstlabeling + n.ready) &&
                                            !o) ||
                                            i.metricsSent ||
                                            ((n.fail = o),
                                            this.modules.map.emit('metrics', i.metrics),
                                            (i.metricsSent = !0)),
                                        this.state.enableTrackResize && this.autoResize(e),
                                        this.modules.mouseMoveHandler.update(),
                                        this.handlers.forEach((e) => e.update()),
                                        xe(i),
                                        le(i),
                                        me(i),
                                        ge(i),
                                        this.stillnessUpdater.update(i),
                                        ne(i, this.modules.layout.rootContainer),
                                        ((e, t, i) => {
                                            Y.Vx(
                                                'viewport',
                                                {
                                                    step: (e, n) => {
                                                        (e.viewport = {
                                                            top: n[0],
                                                            right: n[1],
                                                            bottom: n[2],
                                                            left: n[3],
                                                        }),
                                                            K(e, t, i);
                                                    },
                                                },
                                                e,
                                            );
                                        })(
                                            i,
                                            this.modules.layout.rootContainer,
                                            this.modules.renderer,
                                        ),
                                        ((e, t) => {
                                            Y.Vx(
                                                'padding',
                                                {
                                                    step: (e, i) => {
                                                        (e.padding = {
                                                            top: i[0],
                                                            right: i[1],
                                                            bottom: i[2],
                                                            left: i[3],
                                                        }),
                                                            Q(e, t);
                                                    },
                                                },
                                                e,
                                            );
                                        })(i, this.modules.renderer),
                                        this.modules.buildingHeightAnimator.update(),
                                        this.modules.gltfAnimator.update(),
                                        null === (t = this.modules.threeJsSceneManager) ||
                                            void 0 === t ||
                                            t.update(),
                                        (i.demMode =
                                            this.checkDemEnabled() && i.elevationScale > 0),
                                        this.modules.camera.update(),
                                        this.updateElevation(),
                                        this.updateTilesBounds(),
                                        this.modules.demManager.update(),
                                        this.modules.environmentManager.update(),
                                        this.modules.labelsDebug.update(),
                                        this.modules.trafficTileLayer.update(),
                                        this.modules.layers.getLayers().forEach((e) => {
                                            void 0 !== e.update && e.update();
                                        }),
                                        this.modules.tileManager.update(),
                                        this.modules.floorManager.update(),
                                        this.modules.modelLayer.update(),
                                        this.modules.personalPoiManager.update(),
                                        this.modules.ruler.update(),
                                        this.modules.dynamicStyle.update(),
                                        this.modules.map.emit('update'),
                                        this.modules.labeler.update(),
                                        this.performanceChecker.update(),
                                        this.modules.identifier.update(),
                                        I.render.alwaysRerender || i.needRerender)
                                    ) {
                                        let e = this.modules.tileManager.getTileObjects();
                                        i.demMode &&
                                            (e = e.concat(
                                                this.modules.demManager.getGroundTiles(),
                                            )),
                                            Number.isNaN(i.metrics.firstdraw) &&
                                                (i.metrics.firstdraw =
                                                    performance.now() - i.metrics.start),
                                            this.modules.renderer.renderLabelingTexture(e),
                                            this.modules.renderer.renderTileObjects(e),
                                            (i.needRerender = !1),
                                            i.collectStats &&
                                                this.modules.map.emit('stats', i.stats);
                                    }
                                    this.finishStyleUpdatingCheck(),
                                        this.modules.map.update(),
                                        this.isReady() &&
                                            this.modules.assetManager.invalidateUsedModels(),
                                        (i.shouldIsReadyWaitForUpdates = !1),
                                        this.modules.map.emit('frameend');
                                }),
                                (this.onWindowUnload = () => {
                                    const e = this.performanceChecker.getEarlyFps();
                                    void 0 !== e &&
                                        ze({
                                            eventAction: 'FPS',
                                            eventLabel: 'Early',
                                            eventValue: e,
                                        });
                                });
                            const c = Object.assign(Object.assign({}, Sc.options), t),
                                d = Object.assign(Object.assign({}, Sc.options.padding), c.padding),
                                h = Object.assign(
                                    Object.assign({}, Sc.options.viewport),
                                    c.viewport,
                                ),
                                u = c.maxBounds ? ee.X3(c.maxBounds) : L.Vv,
                                m = (0, L.yq)(c.center);
                            ee.Rk(m, u, m);
                            const f = (this.state = {
                                time: Date.now(),
                                center: m,
                                zoom: void 0 !== c.styleZoom ? (0, L.Z3)(c.styleZoom, m) : c.zoom,
                                styleZoom:
                                    void 0 !== c.styleZoom ? c.styleZoom : (0, L.X$)(c.zoom, m),
                                zoomTypePreserving: void 0 !== c.styleZoom ? 'styleZoom' : 'zoom',
                                minZoom: c.minZoom,
                                maxZoom: c.maxZoom,
                                maxBounds: u,
                                rotation: (0, fe.Id)(c.rotation),
                                touchRotationThreshold: (0, fe.Id)(c.touchRotationThreshold),
                                pitch: (0, fe.Id)(c.pitch),
                                minPitch: (0, fe.Id)(c.minPitch),
                                maxPitch: (0, fe.Id)(c.maxPitch),
                                size: [
                                    Math.max(1, e.clientWidth - h.left - h.right),
                                    Math.max(1, e.clientHeight - h.top - h.bottom),
                                ],
                                selectedIds: [],
                                hiddenObjects: { other: new Set(), gltfModel: new Set() },
                                tickers: {},
                                stillness: 1,
                                needRerender: !0,
                                needLabeling: !1,
                                userHasInteracted: !1,
                                viewport: h,
                                padding: d,
                                labelingOpacity: 0,
                                tileServer: c.tileServer,
                                tileSet: c.tileSet,
                                tileProtocol: c.tileProtocol,
                                commercialTileSet: c.commercialTileSet,
                                modelsTileSet:
                                    null !== (n = c.modelsTileSet) && void 0 !== n
                                        ? n
                                        : I.models.tileSet,
                                modelsTilesUrl:
                                    null !== (o = c.modelsTilesUrl) && void 0 !== o
                                        ? o
                                        : I.urls.models,
                                defaultSourceModelsRootUrl: c.defaultSourceModelsRootUrl,
                                subdomains: c.subdomains.split(''),
                                floorsEnabled: c.floorsEnabled,
                                floorsUrl: c.floorsUrl,
                                collectStats: c.collectStats,
                                stats: {
                                    tileCount: 0,
                                    dynamicTileCount: 0,
                                    drawCount: 0,
                                    vertexCount: 0,
                                },
                                trafficServer: c.trafficServer,
                                trafficProtocol: c.trafficProtocol,
                                identifyPickDistance: I.identify.pickDistance,
                                lang: c.lang,
                                tileServerDefaultLang: c.tileServerDefaultLang,
                                tileKey: c.key,
                                appId: c.appId,
                                disableHoverStyles: c.disableHoverStyles,
                                keepCenterWhileUserZoomRotate: !!c.keepCenterWhileUserZoomRotate,
                                disableRotationByUserInteraction:
                                    !!c.disableRotationByUserInteraction,
                                disablePitchByUserInteraction: !!c.disablePitchByUserInteraction,
                                disableDragging: !!c.disableDragging,
                                performanceCaveatEmitted: !1,
                                sessionId: c.sessionId,
                                tileSessionId: c.tileSessionId,
                                shownRegionIds: new Set(),
                                preserveDrawingBuffer: !!c.preserveDrawingBuffer,
                                defaultBackgroundColor: c.defaultBackgroundColor,
                                handyStyleId: NaN,
                                styleState: nl(c.styleState),
                                disableIconCache: c.disableIconCache,
                                rtlPlugin: {
                                    scenario:
                                        null !== (r = c.useRtlTextPlugin) && void 0 !== r
                                            ? r
                                            : 'depends-on-language',
                                    loadFailed: !1,
                                    url: null !== (s = c.rtlPluginUrl) && void 0 !== s ? s : sc.k0,
                                    hash:
                                        null !== (a = c.rtlPluginHash) && void 0 !== a ? a : sc.aT,
                                },
                                mobileSdkMode: c.mobileSdkMode,
                                demMode: !1,
                                tilesBounds: [
                                    [0, 0],
                                    [0, 0],
                                    [0, 0],
                                    [0, 0],
                                ],
                                demTilesBounds: [
                                    [0, 0],
                                    [0, 0],
                                    [0, 0],
                                    [0, 0],
                                ],
                                elevation: void 0,
                                elevationScale: 0,
                                minElevation: void 0,
                                skipElevationAnimation: c.skipElevationAnimation,
                                metrics: {
                                    start: performance.now(),
                                    init: NaN,
                                    firstdraw: NaN,
                                    firstlabeling: NaN,
                                    firstcontent: NaN,
                                    interactive: NaN,
                                    ready: NaN,
                                    fail: !1,
                                },
                                metricsSent: !1,
                                shouldIsReadyWaitForUpdates: !1,
                                commercialPoiRandomSeed: c.commercialPoiRandomSeed,
                                disableSurvivedPoiPrevalence: Boolean(
                                    c.disableSurvivedPoiPrevalence,
                                ),
                                webglVersion: c.webglVersion,
                                threeJs: {
                                    active: !!c.useThreeJs,
                                    path: null !== (l = c.threeJsPath) && void 0 !== l ? l : sc.Dd,
                                },
                                enableTrackResize: !!c.enableTrackResize,
                                autoResizeInterval: I.render.autoResizeInterval,
                                showDefaultTileBounds: !!c.showDefaultTileBounds,
                                immersiveLevel: { drawLevels: !1 },
                                enableSky: !!c.enableSky,
                                enableFog: !!c.enableFog,
                                pitchHightLimitation:
                                    void 0 === c.pitchHightLimitation
                                        ? (0, fe.Id)(90)
                                        : (0, fe.Id)(c.pitchHightLimitation),
                                labelingDepthTestDisabled: !1,
                            });
                            var p, _, v, g, y, b;
                            (this.modules = new xc(f, e, i)),
                                'number' == typeof f.commercialPoiRandomSeed &&
                                    this.modules.workers.labeling.setCommercialPoiRandomSeed(
                                        f.commercialPoiRandomSeed,
                                    ),
                                this.modules.styleManager.setDynamicStyle(
                                    this.modules.dynamicStyle.getStyle(),
                                ),
                                (this.handlers = [
                                    new je(f, this.modules.layout.mapContainer),
                                    new Be(this.modules),
                                ]),
                                c.disableZoomOnScroll ||
                                    this.handlers.push(new Oe(f, this.modules.layout.mapContainer)),
                                Le && ke && this.handlers.push(new Ne(f, e, i)),
                                (this.performanceChecker = new Ue(f)),
                                (this.stillnessUpdater = new Ge()),
                                (this.requestedFrame = requestAnimationFrame(this.renderLoop)),
                                c.sendAnalytics &&
                                    ((p = window),
                                    (_ = document),
                                    (v = 'script'),
                                    (g = 'ga'),
                                    (p.GoogleAnalyticsObject = g),
                                    (p.ga =
                                        p.ga ||
                                        function () {
                                            (p.ga.q = p.ga.q || []).push(arguments);
                                        }),
                                    (p.ga.l = Date.now()),
                                    (y = _.createElement(v)),
                                    (b = _.getElementsByTagName(v)[0]),
                                    (y.async = 1),
                                    (y.src = 'https://www.google-analytics.com/analytics.js'),
                                    b.parentNode.insertBefore(y, b),
                                    window.ga &&
                                        (window.ga('create', I.analytics.gaCode, {
                                            storage: 'none',
                                            name: I.analytics.gaName,
                                            sampleRate: 80,
                                        }),
                                        window.ga(`${I.analytics.gaName}.set`, 'anonymizeIp', !0),
                                        window.ga(`${I.analytics.gaName}.send`, 'pageview')),
                                    window.addEventListener('unload', this.onWindowUnload));
                        }
                        destroy() {
                            cancelAnimationFrame(this.requestedFrame),
                                this.modules.destroy(),
                                this.handlers.forEach((e) => e.destroy()),
                                window.removeEventListener('unload', this.onWindowUnload);
                        }
                        isIdle() {
                            return (
                                !this.state.needRerender &&
                                this.modules.tileManager.isIdle() &&
                                this.modules.assetManager.isIdle() &&
                                this.modules.trafficTileLayer.viewportTilesReady() &&
                                this.modules.floorManager.activeFloorLoadingOrReady() &&
                                this.modules.layers.entranceAnimationFinished() &&
                                this.modules.modelLayer.isIdle() &&
                                !this.modules.buildingHeightAnimator.isAnimating() &&
                                !this.modules.gltfAnimator.isAnimating() &&
                                this.modules.labeler.isIdle()
                            );
                        }
                        isReady() {
                            var e;
                            let t = !0;
                            return (
                                (null === (e = this.modules) || void 0 === e
                                    ? void 0
                                    : e.threeJsSceneManager) &&
                                    (t = this.modules.threeJsSceneManager.isReady()),
                                this.isIdle() &&
                                    this.modules.floorManager.floorsReady() &&
                                    this.modules.identifier.isIdle() &&
                                    this.modules.imageManager.isIdle() &&
                                    this.modules.imageCache.isIdle() &&
                                    this.modules.personalPoiManager.isIdle() &&
                                    this.modules.tileKeyInfo.isIdle() &&
                                    !this.state.shouldIsReadyWaitForUpdates &&
                                    t
                            );
                        }
                        redrawMap() {
                            this.modules.tileManager.redraw(),
                                this.modules.trafficTileLayer.redraw(),
                                this.modules.modelLayer.redraw(),
                                this.modules.floorManager.resetCache(),
                                this.modules.personalPoiManager.redraw();
                        }
                        activateStyleUpdating() {
                            this.modules.tileManager.activateStyleUpdating(),
                                this.modules.floorManager.activateStyleUpdating(),
                                this.modules.modelLayer.activateStyleUpdating(),
                                this.modules.trafficTileLayer.activateStyleUpdating(),
                                (this.isStyleUpdateInProgress = !0);
                        }
                        getIsFirstStyleUpdate() {
                            return this.isFirstStyleUpdate;
                        }
                        finishStyleUpdatingCheck() {
                            if (
                                this.isStyleUpdateInProgress &&
                                this.modules.tileManager.viewportTilesReady() &&
                                this.modules.trafficTileLayer.viewportTilesReady() &&
                                this.modules.floorManager.activeFloorLoadingOrReady() &&
                                this.modules.modelLayer.viewportModelsReady()
                            ) {
                                this.modules.tileManager.finishStyleUpdating(),
                                    this.modules.floorManager.finishStyleUpdating(),
                                    this.modules.trafficTileLayer.finishStyleUpdating(),
                                    this.modules.modelLayer.finishStyleUpdating(),
                                    this.modules.personalPoiManager.redraw();
                                const e = this.modules.styleManager.getStyle(
                                    this.state.handyStyleId,
                                );
                                e && this.modules.renderer.setClearColor(e.background.color),
                                    (this.isStyleUpdateInProgress = !1),
                                    (this.isFirstStyleUpdate = !1),
                                    (this.state.needRerender = !0),
                                    (this.state.needLabeling = !0);
                            }
                        }
                        checkDemEnabled() {
                            return (
                                !0 === this.state.styleState.terrainEnabled
                                    ? this.modules.demManager.isEnabled() ||
                                      this.modules.demManager.enable()
                                    : this.modules.demManager.isEnabled() &&
                                      this.modules.demManager.disable(),
                                this.modules.demManager.isEnabled()
                            );
                        }
                        updateImmersiveLevel() {
                            var e;
                            const t = Number(
                                null !== (e = this.state.styleState.immersiveLevel) && void 0 !== e
                                    ? e
                                    : 0,
                            );
                            this.state.immersiveLevel.drawLevels =
                                !!t && this.state.styleZoom >= 15;
                        }
                        updateTilesBounds() {
                            const { size: e, zoom: t } = this.state,
                                [i, n, o, r] = this.modules.camera.getViewportVertices(),
                                s = (0, Gi.hS)(i, n);
                            let a = (0, Gi.Oy)(o, s);
                            const l = (0, L.h0)(e[1], t) * I.camera.viewportLimitRatio;
                            if (a > l) {
                                const e = l / a;
                                D.t7(o, n, o, e), D.t7(r, i, r, e), (a = l);
                            }
                            if (
                                ((this.state.tilesBounds[0] = i.slice()),
                                (this.state.tilesBounds[1] = n.slice()),
                                (this.state.tilesBounds[2] = o.slice()),
                                (this.state.tilesBounds[3] = r.slice()),
                                this.state.demMode)
                            ) {
                                const e = (0, Gi.iE)(this.modules.camera.position, s);
                                if (e < 0) {
                                    const t = (a + Math.abs(e)) / a;
                                    D.t7(i, r, i, t), D.t7(n, o, n, t);
                                }
                                if (
                                    void 0 !== this.state.elevation &&
                                    !Number.isNaN(this.state.elevation)
                                ) {
                                    const e = this.modules.camera.position[2],
                                        t =
                                            void 0 === this.state.minElevation ||
                                            Number.isNaN(this.state.minElevation)
                                                ? this.state.elevation
                                                : this.state.minElevation,
                                        s = (Math.max(this.state.elevation - t, 0) * L.C) / e + 1,
                                        a =
                                            (s - 1) *
                                                Math.max(
                                                    1 - this.state.pitch / this.state.maxPitch,
                                                    0.1,
                                                ) +
                                            1,
                                        l = Math.max(
                                            (this.state.pitch / this.state.maxPitch) * 30,
                                            4,
                                        );
                                    D.t7(i, this.modules.camera.position, i, Math.min(a, l)),
                                        D.t7(n, this.modules.camera.position, n, Math.min(a, l)),
                                        D.t7(r, this.modules.camera.position, r, Math.min(s, l)),
                                        D.t7(o, this.modules.camera.position, o, Math.min(s, l));
                                }
                            }
                            (this.state.demTilesBounds[0] = i),
                                (this.state.demTilesBounds[1] = n),
                                (this.state.demTilesBounds[2] = o),
                                (this.state.demTilesBounds[3] = r);
                        }
                        updateElevation() {
                            if (
                                ((this.state.elevationScale =
                                    this.modules.demManager.getVerticalScale()),
                                !this.state.demMode)
                            )
                                return void (
                                    void 0 !== this.state.elevation &&
                                    ((this.state.needRerender = !0),
                                    (this.state.elevation = void 0))
                                );
                            const e = this.modules.demManager.getElevation(this.state.center);
                            if (void 0 !== e)
                                if (
                                    void 0 === this.state.elevation ||
                                    this.state.skipElevationAnimation
                                )
                                    this.state.elevation = e;
                                else {
                                    const t = 0.1 * (e - this.state.elevation);
                                    Math.abs(t) < 0.3
                                        ? (this.state.elevation = e)
                                        : (this.state.elevation += t);
                                    const i = this.modules.demManager.getElevation(
                                        this.modules.camera.position,
                                    );
                                    if (void 0 !== i) {
                                        const e = this.state.elevationScale,
                                            t = i * e,
                                            n = this.modules.camera.position[2] / L.C,
                                            o = Math.min(30, 0.2 * n),
                                            r = this.state.elevation * e + n - o;
                                        t > r && (this.state.elevation += (t - r) / e);
                                    }
                                }
                            const t = this.modules.demManager.getMinElevation();
                            void 0 !== t && (this.state.minElevation = t);
                        }
                        autoResize(e) {
                            if (e - this.lastResizeTime >= this.state.autoResizeInterval) {
                                const t = this.modules.layout.canvas,
                                    { clientWidth: i, clientHeight: n } =
                                        this.modules.layout.rootContainer,
                                    o = window.devicePixelRatio;
                                (t.width === Math.floor(i * o) && t.height === Math.floor(n * o)) ||
                                    ((this.lastResizeTime = e), this.modules.map.invalidateSize());
                            }
                        }
                    }
                    Sc.options = {
                        center: [0, 0],
                        zoom: 0,
                        minZoom: I.MAP_DEFAULTS.minZoom,
                        maxZoom: I.MAP_DEFAULTS.maxZoom,
                        rotation: 0,
                        touchRotationThreshold: 10,
                        pitch: 0,
                        minPitch: 0,
                        maxPitch: 45,
                        viewport: { top: 0, right: 0, bottom: 0, left: 0 },
                        padding: { top: 0, right: 0, bottom: 0, left: 0 },
                        tileServer: I.tiles.server,
                        tileSet: I.tiles.tileSet,
                        tileProtocol: I.tiles.protocol,
                        commercialTileSet: I.commercialPoi.tileSet,
                        key: I.tiles.tileKey,
                        subdomains: I.tiles.subdomains,
                        floorsEnabled: I.floors.enabled,
                        floorsUrl: I.floors.url,
                        trafficProtocol: I.traffic.protocol,
                        trafficServer: I.traffic.host,
                        collectStats: !1,
                        style: '',
                        styleState: Object.assign({}, il),
                        styleOptions: {
                            rootUrl: '',
                            iconsPath: '',
                            fontsPath: '',
                            stylePath: '',
                            modelsPath: '',
                        },
                        sendAnalytics: !0,
                        lang: I.defaultLang,
                        appId: I.tiles.appId,
                        disableHoverStyles: !1,
                        disableZoomOnScroll: !1,
                        disableDragging: !1,
                        disableRotationByUserInteraction: !1,
                        disablePitchByUserInteraction: !1,
                        defaultBackgroundColor: '#f6f2de',
                        disableIconCache: !1,
                        mobileSdkMode: !1,
                        skipElevationAnimation: !1,
                        enableTrackResize: !1,
                        showDefaultTileBounds: !1,
                        immersiveOn: !1,
                        pitchHightLimitation: 90,
                    };
                    const Ic = ['disableDragging', 'enableTrackResize'];
                    var Mc = i(3379),
                        Tc = i.n(Mc),
                        Pc = i(7795),
                        Lc = i.n(Pc),
                        kc = i(569),
                        Ec = i.n(kc),
                        Ac = i(3565),
                        zc = i.n(Ac),
                        Cc = i(9216),
                        Fc = i.n(Cc),
                        Oc = i(4589),
                        Dc = i.n(Oc),
                        Rc = i(5618),
                        jc = {};
                    (jc.styleTagTransform = Dc()),
                        (jc.setAttributes = zc()),
                        (jc.insert = Ec().bind(null, 'head')),
                        (jc.domAPI = Lc()),
                        (jc.insertStyleElement = Fc());
                    Tc()(Rc.Z, jc);
                    Rc.Z && Rc.Z.locals && Rc.Z.locals;
                    var Bc = i(7636),
                        Nc = i(9981),
                        Uc = i(297);
                    const Zc = ['zoom', 'rotation', 'pitch', 'center'];
                    class Hc extends k.c {
                        constructor(e, t) {
                            var i;
                            super();
                            const n = (this.core = new Sc(e, t, this));
                            (this.state = n.state),
                                (this.modules = n.modules),
                                (this.performanceChecker = n.performanceChecker),
                                (this.values = { isMoveChanging: !1, isIdle: !1 }),
                                Zc.forEach((e) => {
                                    this.cloneFromStateToValues(e, `${e}1`),
                                        this.cloneFromStateToValues(e, `${e}2`),
                                        this.cloneFromStateToValues(e, `${e}End1`),
                                        this.cloneFromStateToValues(e, `${e}End2`),
                                        (this.values[`${e}EndTime`] = 0),
                                        (this.values[`is${e}Changing`] = !1);
                                }),
                                this.cloneFromStateToValues('size', 'size'),
                                this.performanceChecker.on('performancecaveat', () => {
                                    this.emit('performancecaveat'),
                                        ze({ eventAction: 'FPS', eventLabel: 'performancecaveat' });
                                }),
                                this.performanceChecker.on('fps', (e) =>
                                    ze({
                                        eventAction: 'FPS',
                                        eventLabel: 'Average',
                                        eventValue: e,
                                    }),
                                );
                            this.setStyle(
                                null !== (i = null == t ? void 0 : t.style) && void 0 !== i
                                    ? i
                                    : rt.rx,
                                null == t ? void 0 : t.styleOptions,
                            ).catch((e) => {
                                if (e instanceof Error) throw e;
                            }),
                                this.setLang(this.state.lang),
                                (this.state.metrics.init =
                                    performance.now() - this.state.metrics.start);
                        }
                        setCenter(e, t) {
                            if (!(0, L.Iy)(e)) return this;
                            this.state.userHasInteracted = !1;
                            const i = (0, L.yq)(e);
                            return se(this.state, i, t), this;
                        }
                        setZoom(e, t) {
                            return (0, fe.Kh)(e, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
                                ? ((this.state.zoomTypePreserving = 'zoom'),
                                  (this.state.userHasInteracted = !1),
                                  be(this.state, e, t),
                                  (this.state.shouldIsReadyWaitForUpdates = !0),
                                  this)
                                : this;
                        }
                        setStyleZoom(e, t) {
                            if (!(0, fe.Kh)(e, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER))
                                return this;
                            const i = (0, L.Z3)(e, this.state.center);
                            return (
                                (this.state.zoomTypePreserving = 'styleZoom'),
                                (this.state.userHasInteracted = !1),
                                be(this.state, i, t),
                                this
                            );
                        }
                        setMinZoom(e, t) {
                            return (this.state.minZoom = e), this.setZoom(this.state.zoom, t), this;
                        }
                        setMaxZoom(e, t) {
                            return (this.state.maxZoom = e), this.setZoom(this.state.zoom, t), this;
                        }
                        setRotation(e, t) {
                            return (0, fe.Kh)(e, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
                                ? ((this.state.userHasInteracted = !1),
                                  he(this.state, (0, fe.Id)(e), t),
                                  this)
                                : this;
                        }
                        setPitch(e, t) {
                            return (0, fe.Kh)(e, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
                                ? ((this.state.userHasInteracted = !1),
                                  _e(this.state, (0, fe.Id)(e), t),
                                  this)
                                : this;
                        }
                        setMinPitch(e, t) {
                            return (
                                (this.state.minPitch = (0, fe.Id)(e)),
                                this.setPitch((0, fe.ZY)(this.state.pitch), t),
                                this
                            );
                        }
                        setMaxPitch(e, t) {
                            return (
                                (this.state.maxPitch = (0, fe.Id)(e)),
                                this.setPitch((0, fe.ZY)(this.state.pitch), t),
                                this
                            );
                        }
                        setViewport(e, t) {
                            return (
                                (this.state.userHasInteracted = !1),
                                ((e, t, i, n, o = {}) => {
                                    const r = Object.assign(
                                        { top: 0, right: 0, bottom: 0, left: 0 },
                                        n,
                                    );
                                    if (!1 === o.animate || 0 === o.duration)
                                        (e.viewport = r), K(e, t, i);
                                    else {
                                        const t = e.viewport,
                                            i = void 0 !== o.easing ? o.easing : 'easeOutCubic',
                                            n = void 0 !== o.duration ? o.duration : 300;
                                        Y.BL(
                                            'viewport',
                                            { easing: i },
                                            e,
                                            [t.top, t.right, t.bottom, t.left],
                                            [r.top, r.right, r.bottom, r.left],
                                            n,
                                        );
                                    }
                                })(
                                    this.state,
                                    this.modules.layout.rootContainer,
                                    this.modules.renderer,
                                    e,
                                    t,
                                ),
                                this
                            );
                        }
                        setMaxBounds(e) {
                            return (this.state.maxBounds = (0, ee.X3)(e)), this;
                        }
                        setPadding(e, t) {
                            var i, n, o, r;
                            const s = {
                                top: null !== (i = e.top) && void 0 !== i ? i : 0,
                                left: null !== (n = e.left) && void 0 !== n ? n : 0,
                                right: null !== (o = e.right) && void 0 !== o ? o : 0,
                                bottom: null !== (r = e.bottom) && void 0 !== r ? r : 0,
                            };
                            return (
                                (this.state.userHasInteracted = !1),
                                ((e, t, i, n = {}) => {
                                    const o = J(i, e.size);
                                    if (!1 === n.animate || 0 === n.duration)
                                        (e.padding = o), Q(e, t);
                                    else {
                                        const t = e.padding,
                                            i = void 0 !== n.easing ? n.easing : 'easeOutCubic',
                                            r = void 0 !== n.duration ? n.duration : 300;
                                        Y.BL(
                                            'padding',
                                            { easing: i },
                                            e,
                                            [t.top, t.right, t.bottom, t.left],
                                            [o.top, o.right, o.bottom, o.left],
                                            r,
                                        );
                                    }
                                })(this.state, this.modules.renderer, s, t),
                                this
                            );
                        }
                        getPadding() {
                            return this.state.padding;
                        }
                        getCenter() {
                            return (0, L.PA)(this.state.center);
                        }
                        getZoom() {
                            return this.state.zoom;
                        }
                        getStyleZoom() {
                            return this.state.styleZoom;
                        }
                        getMinZoom() {
                            return this.state.minZoom;
                        }
                        getMaxZoom() {
                            return this.state.maxZoom;
                        }
                        getRotation() {
                            return (0, fe.ZY)(this.state.rotation);
                        }
                        getPitch() {
                            return (0, fe.ZY)(this.state.pitch);
                        }
                        getViewport() {
                            return this.state.viewport;
                        }
                        getSize() {
                            return [this.state.size[0], this.state.size[1]];
                        }
                        getBounds() {
                            this.modules.camera.update();
                            const e = (0, Oi.BS)(this.modules.camera.getViewportVertices());
                            return { southWest: (0, L.PA)(e.min), northEast: (0, L.PA)(e.max) };
                        }
                        getDefaultSource() {
                            return this.modules.defaultSource;
                        }
                        hideBuildingsById(e) {
                            e.forEach((e) => {
                                this.state.hiddenObjects.gltfModel.add(e),
                                    this.state.hiddenObjects.other.add(e);
                            }),
                                this.modules.modelLayer.setHiddenBuildingIds(e);
                            const t = e.map((e) => (0, O.IL)(e));
                            this.modules.defaultSource.setHiddenBuildingIds(t);
                        }
                        showHiddenBuildingsById(e) {
                            const t = [],
                                i = [];
                            if (
                                (e.forEach((e) => {
                                    this.modules.gltfAnimator.hasBuildingId(e)
                                        ? t.push(e)
                                        : i.push(e);
                                }),
                                0 !== t.length)
                            ) {
                                t.forEach((e) => {
                                    this.state.hiddenObjects.gltfModel.delete(e);
                                }),
                                    this.modules.modelLayer.unsetHiddenBuildingIds(t);
                                const e = t.map((e) => (0, O.IL)(e));
                                this.modules.defaultSource.triggerOnHiddenBuildingsChange(e);
                            }
                            if (0 !== i.length) {
                                i.forEach((e) => {
                                    this.state.hiddenObjects.other.delete(e);
                                }),
                                    this.modules.modelLayer.unsetHiddenBuildingIds(i);
                                const e = i.map((e) => (0, O.IL)(e));
                                this.modules.defaultSource.unsetHiddenBuildingIds(e);
                            }
                        }
                        getWebGLContext() {
                            return this.modules.renderer.getRenderingContext();
                        }
                        getCanvas() {
                            return this.modules.layout.canvas;
                        }
                        enableRuler() {
                            this.modules.ruler.enable();
                        }
                        setRulerPoints(e) {
                            this.modules.ruler.enabled || this.modules.ruler.enable(),
                                this.modules.ruler.setPoints(e);
                        }
                        disableRuler() {
                            this.modules.ruler.disable();
                        }
                        showTraffic() {
                            this.modules.trafficTileLayer.show();
                        }
                        hideTraffic() {
                            this.modules.trafficTileLayer.hide();
                        }
                        setPersonalPoi(e) {
                            this.modules.personalPoiManager.setPersonalPoi(e);
                        }
                        setSelectedIds(e = []) {
                            return (
                                (this.state.selectedIds = e
                                    .map(O.IL)
                                    .filter((e) => !Number.isNaN(e.lo) && !Number.isNaN(e.hi))
                                    .sort((e, t) => e.hi - t.hi || e.lo - t.lo)),
                                this.modules.tileManager.setSelectedIds(),
                                this.modules.identifier.debouncedFillCache(),
                                this
                            );
                        }
                        project(e) {
                            return this.modules.camera.project((0, L.yq)(e));
                        }
                        unproject(e) {
                            return (0, L.PA)(this.modules.camera.unproject(e));
                        }
                        getCameraProjectionMatrix() {
                            return this.modules.camera.projectionMatrix;
                        }
                        getCameraViewMatrix() {
                            return this.modules.camera.viewMatrix;
                        }
                        getCameraViewProjectionMatrix() {
                            return this.modules.camera.viewProjectionMatrix;
                        }
                        invalidateSize() {
                            this.state.userHasInteracted = !1;
                            const e = window.devicePixelRatio,
                                { viewport: t } = this.state,
                                { clientWidth: i, clientHeight: n } =
                                    this.modules.layout.rootContainer;
                            return (
                                (this.state.size = [
                                    Math.max(1, i - t.left - t.right),
                                    Math.max(1, n - t.top - t.bottom),
                                ]),
                                this.modules.renderer.setPixelRatio(e),
                                this.modules.renderer.setSize(i, n),
                                (this.state.needRerender = !0),
                                this
                            );
                        }
                        destroy() {
                            this.core.destroy();
                        }
                        refresh() {
                            return (
                                (this.state.needRerender = !0),
                                (this.state.needLabeling = !0),
                                this.modules.identifier.resetCache(),
                                this
                            );
                        }
                        changeFloorNumber(e, t) {
                            return (
                                this.modules.floorManager.changeFloorNumber(e, t),
                                (this.state.shouldIsReadyWaitForUpdates = !0),
                                this
                            );
                        }
                        addLayer(e, t) {
                            return (
                                this.modules.styleManager.addLayer(e, t),
                                this.core.activateStyleUpdating(),
                                this
                            );
                        }
                        removeLayer(e) {
                            return (
                                this.modules.styleManager.removeLayer(e),
                                this.core.activateStyleUpdating(),
                                this
                            );
                        }
                        setStyle(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                let i;
                                return (
                                    'string' == typeof e
                                        ? (i = (0, Nc.aU)(e)
                                              ? yield this.setCustomStyleById(e, t)
                                              : yield this.setCustomStyleFromUrl(e, t))
                                        : (yield this.setCustomStyleDirectly(e, t), (i = e)),
                                    this.emit('styleload', { style: i }),
                                    i
                                );
                            });
                        }
                        addIcon(e, t) {
                            if (!e) return console.error('The icon name is empty.'), this;
                            return (
                                this.modules.styleManager.addIcon(e, t) &&
                                    this.core.activateStyleUpdating(),
                                this
                            );
                        }
                        removeIcon(e) {
                            if (!e) return this;
                            return (
                                this.modules.styleManager.removeIcon(e) &&
                                    this.core.activateStyleUpdating(),
                                this
                            );
                        }
                        addModel(e, t) {
                            if (!e) return console.error('The model name is empty.'), this;
                            return (
                                this.modules.styleManager.addModel(e, t) &&
                                    this.core.activateStyleUpdating(),
                                this
                            );
                        }
                        useOldStyles(e) {
                            return this.setCustomStyleById(rt.rx, e), this;
                        }
                        waitForGpuToFinishDrawing() {
                            return this.modules.renderer.readIdentifyPixels(), this;
                        }
                        setLang(e) {
                            const t = (0, Uc.Iw)(this.state.rtlPlugin.scenario, e);
                            (this.state.rtlPlugin.loadFailed && t) ||
                                ((this.state.lang = e),
                                this.state.rtlPlugin.loadFailed ||
                                    (0, Uc.w7)(this.state.rtlPlugin, this.modules, e).catch((e) => {
                                        throw (
                                            ((this.state.rtlPlugin.loadFailed = !0),
                                            this.setLang(I.defaultLang),
                                            e)
                                        );
                                    }),
                                this.modules.tileManager.redraw());
                        }
                        showLabelsDebug(e) {
                            this.modules.labelsDebug.show(e);
                        }
                        hideLabelsDebug() {
                            this.modules.labelsDebug.hide();
                        }
                        getContainer() {
                            return this.modules.layout.mapContainer;
                        }
                        getExternalContainer() {
                            return this.modules.layout.externalContainer;
                        }
                        fitBounds({ northEast: e, southWest: t }, i) {
                            const n = Object.assign(
                                    { top: 0, left: 0, right: 0, bottom: 0 },
                                    (null == i ? void 0 : i.padding) ? i.padding : {},
                                ),
                                o = this.getViewport(),
                                r = this.getPadding(),
                                s = (null == i ? void 0 : i.skipMapPadding)
                                    ? n
                                    : ((l = n),
                                      {
                                          top: (a = r).top + l.top,
                                          bottom: a.bottom + l.bottom,
                                          left: a.left + l.left,
                                          right: a.right + l.right,
                                      });
                            var a, l;
                            const c = this.getSize(),
                                d = (null == i ? void 0 : i.considerRotation)
                                    ? this.getRotation()
                                    : 0;
                            if (c[0] - s.left - s.right <= 0 || c[1] - s.top - s.bottom <= 0)
                                return (
                                    console.warn(
                                        'Map cannot fit within canvas with the given bounds and padding.',
                                    ),
                                    this
                                );
                            (null == i ? void 0 : i.considerRotation) ||
                                he(this.state, d, { animate: !1 });
                            const h = (0, Bc.g)([[t[0], e[1]], e, [e[0], t[1]], t], d, [
                                c[0] - s.left - s.right,
                                c[1] - s.top - s.bottom,
                            ]);
                            if (!h)
                                return (
                                    console.warn(
                                        'Map cannot fit within canvas with the given bounds and padding.',
                                    ),
                                    this
                                );
                            const u = [
                                (c[0] - s.left - s.right) / 2 + s.left + o.left,
                                (c[1] - s.top - s.bottom) / 2 + s.top + o.top,
                            ];
                            let m;
                            (m =
                                void 0 !== (null == i ? void 0 : i.maxZoom)
                                    ? Math.min(h.zoom, null == i ? void 0 : i.maxZoom)
                                    : h.zoom),
                                (m = (0, fe.uZ)(m, this.state.minZoom, this.state.maxZoom));
                            const f = new Hi.V({
                                    zoom: m,
                                    rotation: this.state.rotation,
                                    size: this.state.size,
                                    padding: this.state.padding,
                                    viewport: this.state.viewport,
                                    pitch: 0,
                                    center: h.center,
                                }).unproject(u),
                                p = [0, 0];
                            z.lu(p, h.center, f);
                            const _ = [0, 0, 0];
                            z.IH(_, h.center, p);
                            const v = (null == i ? void 0 : i.animation) ? i.animation : {};
                            v.easing || (v.easing = 'easeOutCubic');
                            const g = Object.assign(Object.assign({}, v), { animateHeight: !0 });
                            return (
                                se(this.state, _, v),
                                be(this.state, m, g),
                                _e(this.state, 0, v),
                                this
                            );
                        }
                        update() {
                            const e = this.state,
                                { time: t, userHasInteracted: i } = e,
                                n = this.values,
                                o = {};
                            Zc.forEach((i) => {
                                let r = e[i];
                                'zoom' === i &&
                                    'styleZoom' === e.zoomTypePreserving &&
                                    (r = e.styleZoom),
                                    (o[`${i}start`] =
                                        !n[`is${i}Changing`] &&
                                        !this.areEqual(r, n[`${i}1`]) &&
                                        this.areEqual(n[`${i}1`], n[`${i}2`])),
                                    o[`${i}start`] && (n[`is${i}Changing`] = !0),
                                    n[`is${i}Changing`] &&
                                        ((o[i] = !this.areEqual(r, n[`${i}1`])),
                                        t - n[`${i}EndTime`] > 150 &&
                                            ((o[`${i}end`] =
                                                this.areEqual(r, n[`${i}End1`]) &&
                                                !this.areEqual(n[`${i}End1`], n[`${i}End2`])),
                                            o[`${i}end`] && (n[`is${i}Changing`] = !1),
                                            this.copyFromValuesToValues(`${i}End2`, `${i}End1`),
                                            this.copyFromStateToValues(r, `${i}End1`),
                                            (n[`${i}EndTime`] = t))),
                                    this.copyFromValuesToValues(`${i}2`, `${i}1`),
                                    this.copyFromStateToValues(r, `${i}1`);
                            }),
                                (o.resize = !this.areEqual(e.size, n.size)),
                                this.copyFromStateToValues(e.size, 'size'),
                                (o.movestart =
                                    (o.zoomstart ||
                                        o.rotationstart ||
                                        o.centerstart ||
                                        o.pitchstart) &&
                                    !n.isMoveChanging),
                                o.movestart && (n.isMoveChanging = !0),
                                (o.move =
                                    n.iszoomChanging ||
                                    n.isrotationChanging ||
                                    n.iscenterChanging ||
                                    n.ispitchChanging),
                                (o.moveend =
                                    (o.zoomend || o.rotationend || o.centerend || o.pitchend) &&
                                    !o.move),
                                o.moveend && (n.isMoveChanging = !1);
                            const r = n.isIdle,
                                s = n.isReady;
                            (n.isIdle = this.isIdle()),
                                (n.isReady = this.isReady()),
                                (o.idle = !r && n.isIdle),
                                (o.ready = !s && n.isReady),
                                Number.isNaN(e.metrics.ready) &&
                                    o.ready &&
                                    (e.metrics.ready = performance.now() - e.metrics.start);
                            for (const e in o) {
                                const t = e;
                                o[t] && this.emit(t, { isUser: i });
                            }
                        }
                        isIdle() {
                            return (
                                !this.values.isMoveChanging &&
                                !this.currentPendingStyle &&
                                this.core.isIdle()
                            );
                        }
                        isReady() {
                            return (
                                !this.values.isMoveChanging &&
                                !this.currentPendingStyle &&
                                this.core.isReady()
                            );
                        }
                        setAutoHoverMode(e) {
                            this.modules.defaultSource.resetHoverId(),
                                (this.state.disableHoverStyles = !e);
                        }
                        setStyleState(e) {
                            (this.state.styleState = nl(e)), (this.state.needRerender = !0);
                        }
                        getStyleState() {
                            return Object.assign({}, this.state.styleState);
                        }
                        patchStyleState(e) {
                            var t, i;
                            (this.state.styleState =
                                ((t = this.state.styleState),
                                (i = e),
                                Object.assign(Object.assign(Object.assign({}, t), i), {
                                    _activeFloorIds: t._activeFloorIds,
                                    _activeFloorBuildingIds: t._activeFloorBuildingIds,
                                }))),
                                (this.state.needRerender = !0);
                        }
                        setOption(e, t) {
                            -1 !== Ic.indexOf(e)
                                ? (this.state[e] = t)
                                : console.error(`Can't change the "${e}" option.`);
                        }
                        getOption(e) {
                            if (-1 !== Ic.indexOf(e)) return this.state[e];
                            console.error(`Can't get the value of the "${e}" option.`);
                        }
                        getGroundPoint(e) {
                            return this.modules.demManager.getGroundPoint(e);
                        }
                        setCustomStyleById(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                this.currentPendingStyle = e;
                                const i = (0, fe.kn)(t || {}, {
                                        rootUrl: I.styles.url,
                                        stylePath: I.styles.path,
                                        iconsPath: I.icons.defaultUrl,
                                        fontsPath: I.fonts.defaultUrl,
                                        modelsPath: sc.LP,
                                    }),
                                    n = yield this.fetchStyleById((0, ta.z)(i), e, rt.rx);
                                if (this.currentPendingStyle !== e)
                                    return Promise.reject(
                                        `Cancel setting the style ${e}, there is a newer style was set`,
                                    );
                                if (!n)
                                    throw (
                                        ((this.currentPendingStyle = void 0),
                                        new Error(`There is no correct style with id ${e}`))
                                    );
                                const { style: o, loadedId: r } = n;
                                return yield this.setCustomStyle(o, i, r), e;
                            });
                        }
                        setCustomStyleFromUrl(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                this.currentPendingStyle = e;
                                const i = (0, fe.kn)(t || {}, {
                                        rootUrl: e,
                                        iconsPath: '',
                                        fontsPath: '',
                                        stylePath: 'style.json',
                                        modelsPath: '',
                                    }),
                                    n = yield (function (e) {
                                        return fetch(e).then((e) => {
                                            if (e.ok) return e.json();
                                        });
                                    })((0, ta.z)(i));
                                if (e !== this.currentPendingStyle)
                                    return Promise.reject(
                                        `Cancel setting the style ${e}, there is a newer style was set`,
                                    );
                                if (!n)
                                    throw (
                                        ((this.currentPendingStyle = void 0),
                                        new Error(`There are no correct styles by url ${e}`))
                                    );
                                return yield this.setCustomStyle(n, i), e;
                            });
                        }
                        setCustomStyleDirectly(e, t) {
                            const i = window.location.protocol,
                                n = window.location.host,
                                o = (0, fe.kn)(t || {}, {
                                    rootUrl: `${i}//${n}`,
                                    stylePath: '',
                                    iconsPath: '',
                                    fontsPath: '',
                                    modelsPath: '',
                                });
                            return this.setCustomStyle(e, o);
                        }
                        setCustomStyle(e, t, i) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                if (((this.currentPendingStyle = void 0), !e))
                                    throw new Error("Can't set empty style");
                                const { showCommPoi: n } =
                                        yield this.modules.tileKeyInfo.getKeyInfo(),
                                    o = this.modules.styleManager.createStyle(e, t, n, i);
                                (this.state.handyStyleId = o.id),
                                    this.state.hiddenObjects.other.clear(),
                                    this.state.hiddenObjects.gltfModel.clear(),
                                    this.core.activateStyleUpdating();
                            });
                        }
                        copyFromStateToValues(e, t) {
                            Gc(e) ? z.JG(this.values[t], e) : (this.values[t] = e);
                        }
                        cloneFromStateToValues(e, t) {
                            const i = this.state[e];
                            Gc(i) ? (this.values[t] = z.d9(i)) : (this.values[t] = i);
                        }
                        copyFromValuesToValues(e, t) {
                            const i = this.values[t];
                            Gc(i) ? z.JG(this.values[e], i) : (this.values[e] = i);
                        }
                        areEqual(e, t) {
                            return Gc(e) && Gc(t) ? z.I6(e, t) : e === t;
                        }
                        fetchStyleById(e, t, i) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const n = new URL((0, T.XK)(e, { id: t }));
                                n.searchParams.append('key', this.state.tileKey);
                                const o = yield fetch(n.toString());
                                if (404 === o.status && i && Number.isNaN(this.state.handyStyleId))
                                    return (
                                        console.warn(
                                            `No access to style with id ${t}. Fallback to default style ${i}.`,
                                        ),
                                        this.fetchStyleById(e, i)
                                    );
                                if (!o.ok) return;
                                const r = yield o.json();
                                return r && r.result ? { loadedId: t, style: r.result } : void 0;
                            });
                        }
                    }
                    function Gc(e) {
                        return void 0 !== e.length;
                    }
                    var Vc = i(8450),
                        Wc = i(8799);
                    class qc extends A {
                        constructor(e, t) {
                            var i, n, o, r, s, a, l, c, d, h;
                            super(e),
                                (this.length = 1),
                                (this.removed = !1),
                                (this.options = t),
                                (this.isInteractive =
                                    null === (i = t.interactive) || void 0 === i || i),
                                (this.geoPoints = this.options.coordinates.filter(
                                    (e, t, i) => 0 === t || !D.I6(i[t], i[t - 1]),
                                )),
                                (this.points = this.geoPoints.map(L.yq));
                            let u = 0;
                            (this.distances = []), this.distances.push(u);
                            for (let e = 1; e < this.geoPoints.length; e++)
                                (u += (0, L.vn)(this.geoPoints[e - 1], this.geoPoints[e])),
                                    this.distances.push(u);
                            t.showAnimation &&
                                !1 !== t.showAnimation.animate &&
                                this.points.length > 1 &&
                                ((this.animationTickerName = `polyline-${this.uniqId}`),
                                this.startShowTicker(this.animationTickerName)),
                                (this.stateDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                    { path: 'demMode', type: 'boolean' },
                                ])),
                                (this.debouncedGenerate = (0, He.D)(() => {
                                    this.generate();
                                }, 200)),
                                (this.tileAttrs = (0, V.FJ)({
                                    id: this.isInteractive ? (0, O.Ru)(0, 0) : NaN,
                                    beginningIsCut: 0,
                                    endingIsCut: 0,
                                }));
                            const { dynamicStyle: m, layers: f } = this.modules;
                            if (0 !== this.options.width) {
                                this.rawStyleLayer = {
                                    type: 'line',
                                    id: `dynamic-polyline-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color:
                                            null !== (n = this.options.color) && void 0 !== n
                                                ? n
                                                : '#3388ff',
                                        width:
                                            null !== (o = this.options.width) && void 0 !== o
                                                ? o
                                                : 3,
                                    },
                                    webglState: this.options.webglState,
                                };
                                const e = (0, W.qw)(this.rawStyleLayer);
                                e &&
                                    ((this.styleLayerId = e.innerId),
                                    m.addLayer(
                                        e,
                                        null !== (r = this.options.zIndex) && void 0 !== r ? r : 0,
                                    ));
                            }
                            if (this.options.width2) {
                                this.rawStyleLayer2 = {
                                    type: 'line',
                                    id: `dynamic-polyline2-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color:
                                            null !== (s = this.options.color2) && void 0 !== s
                                                ? s
                                                : '#00000000',
                                        width:
                                            null !== (a = this.options.width2) && void 0 !== a
                                                ? a
                                                : 0,
                                    },
                                };
                                const e = (0, W.qw)(this.rawStyleLayer2);
                                e &&
                                    ((this.styleLayer2Id = e.innerId),
                                    m.addLayer(
                                        e,
                                        null !== (l = this.options.zIndex2) && void 0 !== l
                                            ? l
                                            : -1,
                                    ));
                            }
                            if (this.options.width3) {
                                this.rawStyleLayer3 = {
                                    type: 'line',
                                    id: `dynamic-polyline3-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color:
                                            null !== (c = this.options.color3) && void 0 !== c
                                                ? c
                                                : '#00000000',
                                        width:
                                            null !== (d = this.options.width3) && void 0 !== d
                                                ? d
                                                : 0,
                                    },
                                };
                                const e = (0, W.qw)(this.rawStyleLayer3);
                                e &&
                                    ((this.styleLayer3Id = e.innerId),
                                    m.addLayer(
                                        e,
                                        null !== (h = this.options.zIndex3) && void 0 !== h
                                            ? h
                                            : -2,
                                    ));
                            }
                            (void 0 === this.styleLayerId &&
                                void 0 === this.styleLayer2Id &&
                                void 0 === this.styleLayer3Id) ||
                                (f.addLayer(this), this.generate());
                        }
                        update() {
                            this.removed ||
                                (this.stateDiffer.check(this.mapState) && this.debouncedGenerate(),
                                this.animationTickerName &&
                                    this.updateShowTicker(this.animationTickerName));
                        }
                        snapPoint(e) {
                            const t = this.points.map((e) => this.modules.camera.project(e));
                            let i = 1 / 0,
                                n = t[0],
                                o = 0;
                            for (let r = 0; r < t.length - 1; r++) {
                                const s = t[r],
                                    a = t[r + 1],
                                    l = (0, Gi.Z4)(e, s, a),
                                    c = l[0] - e[0],
                                    d = l[1] - e[1],
                                    h = c * c + d * d;
                                h < i && ((i = h), (n = l), (o = r));
                            }
                            const r = (0, L.PA)(this.modules.camera.unproject(n));
                            return {
                                point: r,
                                distance: this.distances[o] + (0, L.vn)(r, this.geoPoints[o]),
                            };
                        }
                        setStyle(e) {
                            this.setSubLayerStyle(this.styleLayerId, this.rawStyleLayer, e.color),
                                this.setSubLayerStyle(
                                    this.styleLayer2Id,
                                    this.rawStyleLayer2,
                                    e.color2,
                                ),
                                this.setSubLayerStyle(
                                    this.styleLayer3Id,
                                    this.rawStyleLayer3,
                                    e.color3,
                                );
                        }
                        remove() {
                            this.removed ||
                                ((this.removed = !0),
                                this.animationTickerName &&
                                    Y.sT(this.animationTickerName, this.mapState),
                                this.isInteractive && this.modules.identifier.resetCache(),
                                void 0 !== this.styleLayerId &&
                                    this.modules.dynamicStyle.removeLayer(this.styleLayerId),
                                void 0 !== this.styleLayer2Id &&
                                    this.modules.dynamicStyle.removeLayer(this.styleLayer2Id),
                                void 0 !== this.styleLayer3Id &&
                                    this.modules.dynamicStyle.removeLayer(this.styleLayer3Id),
                                super.destroy());
                        }
                        startShowTicker(e) {
                            var t, i, n;
                            const o =
                                    void 0 !==
                                    (null === (t = this.options.showAnimation) || void 0 === t
                                        ? void 0
                                        : t.easing)
                                        ? this.options.showAnimation.easing
                                        : 'linear',
                                r =
                                    void 0 !==
                                    (null === (i = this.options.showAnimation) || void 0 === i
                                        ? void 0
                                        : i.duration)
                                        ? this.options.showAnimation.duration
                                        : 250;
                            Y.BL(
                                e,
                                {
                                    easing: o,
                                    animationGroup:
                                        null === (n = this.options.showAnimation) || void 0 === n
                                            ? void 0
                                            : n.animationGroup,
                                },
                                this.mapState,
                                0,
                                1,
                                r,
                            ),
                                (this.length = 0);
                        }
                        setSubLayerStyle(e, t, i) {
                            if (void 0 !== e && i && t && i !== t.style.color) {
                                const { dynamicStyle: n } = this.modules;
                                t.style.color = i;
                                const o = (0, W.qw)(t);
                                o && (n.updateLayerStyle(e, o), (this.mapState.needRerender = !0));
                            }
                        }
                        updateShowTicker(e) {
                            Y.Vx(
                                e,
                                {
                                    step: (e, t) => {
                                        var i, n, o, r;
                                        const s = (0, fe.sB)(
                                            (null ===
                                                (n =
                                                    null === (i = this.options.showAnimation) ||
                                                    void 0 === i
                                                        ? void 0
                                                        : i.durationRange) || void 0 === n
                                                ? void 0
                                                : n.start) || 0,
                                            (null ===
                                                (r =
                                                    null === (o = this.options.showAnimation) ||
                                                    void 0 === o
                                                        ? void 0
                                                        : o.durationRange) || void 0 === r
                                                ? void 0
                                                : r.end) || 1,
                                            t,
                                        );
                                        s !== this.length && ((this.length = s), this.generate());
                                    },
                                },
                                this.mapState,
                            );
                        }
                        generate() {
                            if (this.points.length < 2 || this.removed) return;
                            const {
                                    dynamicStyle: e,
                                    collector: t,
                                    renderer: i,
                                    tileManager: n,
                                    identifier: o,
                                    map: r,
                                } = this.modules,
                                { tileProps: s } = P.nF,
                                a = Math.min(Math.floor(r.getZoom()), 12),
                                l = (0, G.aq)(a),
                                c = (0, Gi.z_)(this.points, this.distances, this.length),
                                d = (0, Gi.Jh)(c, l),
                                h = D.Ue(),
                                u = ee.Ue();
                            this.tileObjects.forEach((e) => {
                                e.clean(this.mapState), n.removeObject(e);
                            }),
                                (this.tileObjects = []);
                            for (let o = 0; o < d.length; o++) {
                                const r = d[o];
                                ee.mc(u);
                                for (let e = 0; e < r.length; e++) ee.aM(u, r[e]);
                                ee.be(h, u);
                                const l = (0, G.z6)(h, a);
                                if (!(0, G.Ny)(l, this.mapState.tilesBounds)) continue;
                                if (this.options.displayTileBounds) {
                                    const o = e
                                        .getStyle()
                                        .layers.find((e) => 'debug-tile-bounds' === e.id);
                                    (0, Gs.cX)(t, o, this.mapState.styleState);
                                    const r = t.getAccumulatedData(),
                                        s = new C.W('dynamicObject', r.data, i, l);
                                    this.tileObjects.push(s), n.addObject(s);
                                }
                                const c = (0, G.Bs)(l),
                                    m = [[], []];
                                for (let e = 0; e < r.length; e++)
                                    (0, G.a2)(h, r[e], c), (m[0][e] = h[0]), (m[1][e] = h[1]);
                                (this.tileAttrs[s.beginningIsCut] = 0),
                                    (this.tileAttrs[s.endingIsCut] = 0),
                                    0 !== o && (this.tileAttrs[s.beginningIsCut] = 1),
                                    o + 1 !== d.length && (this.tileAttrs[s.endingIsCut] = 1);
                                const f = (0, $.Yi)(
                                    this.mapState.styleState,
                                    P.i4,
                                    P.Dz,
                                    this.tileAttrs,
                                    P.wz,
                                );
                                if (void 0 !== this.styleLayerId) {
                                    const i = e.getStyle().layersById[this.styleLayerId];
                                    (0, Vc.ot)(i) &&
                                        (0, H.XI)({
                                            collector: t,
                                            generator: Wc.z.generate,
                                            args: [e.getStyle().id, i, f, c, m],
                                        });
                                }
                                if (void 0 !== this.styleLayer2Id) {
                                    const i = e.getStyle().layersById[this.styleLayer2Id];
                                    (0, Vc.ot)(i) &&
                                        (0, H.XI)({
                                            collector: t,
                                            generator: Wc.z.generate,
                                            args: [e.getStyle().id, i, f, c, m],
                                        });
                                }
                                if (void 0 !== this.styleLayer3Id) {
                                    const i = e.getStyle().layersById[this.styleLayer3Id];
                                    (0, Vc.ot)(i) &&
                                        (0, H.XI)({
                                            collector: t,
                                            generator: Wc.z.generate,
                                            args: [e.getStyle().id, i, f, c, m],
                                        });
                                }
                                const p = t.getAccumulatedData(),
                                    _ = new C.W('dynamicObject', p.data, i, c.coords);
                                n.addObject(_),
                                    this.tileObjects.push(_),
                                    this.isInteractive && this.identifyIds.push(p.identifyIds);
                            }
                            this.isInteractive && o.resetCache(),
                                t.reset(),
                                (this.mapState.needRerender = !0);
                        }
                    }
                    var $c = i(3097);
                    class Xc extends A {
                        constructor(e, t) {
                            var i, n, o, r, s, a;
                            if (
                                (super(e),
                                (this.length = 1),
                                (this.removed = !1),
                                (this.options = t),
                                (this.interactive =
                                    null === (i = t.interactive) || void 0 === i || i),
                                (this.points = this.options.coordinates.map(L.yq)),
                                (this.distances = []),
                                t.showAnimation &&
                                    !1 !== t.showAnimation.animate &&
                                    this.points.length > 1)
                            ) {
                                let e = 0;
                                this.distances.push(e);
                                for (let t = 1; t < this.options.coordinates.length; t++)
                                    (e += (0, L.vn)(
                                        this.options.coordinates[t - 1],
                                        this.options.coordinates[t],
                                    )),
                                        this.distances.push(e);
                                (this.animationTickerName = `dashedLine-${this.uniqId}`),
                                    this.startShowTicker(this.animationTickerName);
                            }
                            (this.stateDiffer = new De([
                                { path: 'center', type: 'vec2' },
                                { path: 'zoom', type: 'number' },
                                { path: 'size', type: 'vec2' },
                                { path: 'rotation', type: 'number' },
                                { path: 'pitch', type: 'number' },
                                { path: 'padding', type: 'padding' },
                                { path: 'demMode', type: 'boolean' },
                            ])),
                                (this.debouncedGenerate = (0, He.D)(() => {
                                    this.generate();
                                }, 200)),
                                (this.tileAttrs = (0, V.FJ)({
                                    previousPointX: 0,
                                    previousPointY: 0,
                                    nextPointX: 0,
                                    nextPointY: 0,
                                    beginningIsCut: 0,
                                    endingIsCut: 0,
                                    componentDistanceStart: 0,
                                    objectLength: 0,
                                    id: this.interactive ? (0, O.Ru)(0, 0) : NaN,
                                }));
                            const { layers: l } = this.modules;
                            l.addLayer(this),
                                (this.dashLayerRaw = {
                                    type: 'dashedLine',
                                    id: `dynamic-dashed-polyline-dash-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color: this.options.dashColor || '#2480ff',
                                        dashLength:
                                            null !== (n = this.options.dashLength) && void 0 !== n
                                                ? n
                                                : 6,
                                        gapColor: this.options.gapColor || '#ffffff00',
                                        gapLength:
                                            null !== (o = this.options.gapLength) && void 0 !== o
                                                ? o
                                                : 20,
                                        width:
                                            null !== (r = this.options.width) && void 0 !== r
                                                ? r
                                                : 8,
                                    },
                                }),
                                (this.baseLayerRaw = {
                                    type: 'line',
                                    id: `dynamic-dashed-polyline-base-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color: this.options.dash2Color || '#ffffff',
                                        width:
                                            null !==
                                                (a =
                                                    null === (s = this.options) || void 0 === s
                                                        ? void 0
                                                        : s.width2) && void 0 !== a
                                                ? a
                                                : 12,
                                    },
                                }),
                                (this.dashLayer = (0, W.qw)(this.dashLayerRaw)),
                                (this.baseLayer = (0, W.qw)(this.baseLayerRaw)),
                                this.generate();
                        }
                        update() {
                            this.removed ||
                                (this.stateDiffer.check(this.mapState) && this.debouncedGenerate(),
                                this.animationTickerName &&
                                    this.updateShowTicker(this.animationTickerName));
                        }
                        setStyle(e) {
                            const { dashColor: t, dash2Color: i, gapColor: n } = e,
                                { dynamicStyle: o } = this.modules;
                            if (this.dashLayer) {
                                void 0 !== t && (this.dashLayerRaw.style.color = t),
                                    void 0 !== n && (this.dashLayerRaw.style.gapColor = n);
                                const e = (0, W.qw)(this.dashLayerRaw);
                                e && o.updateLayerStyle(this.dashLayer.innerId, e);
                            }
                            if (this.baseLayer) {
                                void 0 !== i && (this.baseLayerRaw.style.color = i);
                                const e = (0, W.qw)(this.baseLayerRaw);
                                e && o.updateLayerStyle(this.baseLayer.innerId, e);
                            }
                            this.mapState.needRerender = !0;
                        }
                        remove() {
                            this.removed ||
                                ((this.removed = !0),
                                this.animationTickerName &&
                                    Y.sT(this.animationTickerName, this.mapState),
                                this.interactive && this.modules.identifier.resetCache(),
                                this.baseLayer &&
                                    this.modules.dynamicStyle.removeLayer(this.baseLayer.innerId),
                                this.dashLayer &&
                                    this.modules.dynamicStyle.removeLayer(this.dashLayer.innerId),
                                super.destroy());
                        }
                        updateShowTicker(e) {
                            Y.Vx(
                                e,
                                {
                                    step: (e, t) => {
                                        var i, n, o, r;
                                        const s = (0, fe.sB)(
                                            (null ===
                                                (n =
                                                    null === (i = this.options.showAnimation) ||
                                                    void 0 === i
                                                        ? void 0
                                                        : i.durationRange) || void 0 === n
                                                ? void 0
                                                : n.start) || 0,
                                            (null ===
                                                (r =
                                                    null === (o = this.options.showAnimation) ||
                                                    void 0 === o
                                                        ? void 0
                                                        : o.durationRange) || void 0 === r
                                                ? void 0
                                                : r.end) || 1,
                                            t,
                                        );
                                        s !== this.length && ((this.length = s), this.generate());
                                    },
                                },
                                this.mapState,
                            );
                        }
                        startShowTicker(e) {
                            var t, i, n;
                            const o =
                                    void 0 !==
                                    (null === (t = this.options.showAnimation) || void 0 === t
                                        ? void 0
                                        : t.easing)
                                        ? this.options.showAnimation.easing
                                        : 'linear',
                                r =
                                    void 0 !==
                                    (null === (i = this.options.showAnimation) || void 0 === i
                                        ? void 0
                                        : i.duration)
                                        ? this.options.showAnimation.duration
                                        : 250;
                            Y.BL(
                                e,
                                {
                                    easing: o,
                                    animationGroup:
                                        null === (n = this.options.showAnimation) || void 0 === n
                                            ? void 0
                                            : n.animationGroup,
                                },
                                this.mapState,
                                0,
                                1,
                                r,
                            ),
                                (this.length = 0);
                        }
                        generate() {
                            if (this.points.length < 2 || this.removed) return;
                            const {
                                    dynamicStyle: e,
                                    collector: t,
                                    renderer: i,
                                    tileManager: n,
                                    map: o,
                                    identifier: r,
                                } = this.modules,
                                { tileProps: s } = P.nF,
                                a = Math.min(Math.floor(o.getZoom()), 12),
                                l = (0, G.aq)(a),
                                c = (0, Gi.z_)(this.points, this.distances, this.length),
                                d = (0, Gi.Jh)(c, l),
                                h = D.Ue(),
                                u = ee.Ue();
                            this.tileObjects.forEach((e) => {
                                e.clean(this.mapState), n.removeObject(e);
                            }),
                                (this.tileObjects = []);
                            const m = [];
                            let f = 0;
                            for (const e of d) {
                                ee.mc(u);
                                for (let t = 0; t < e.length; t++) ee.aM(u, e[t]);
                                ee.be(h, u);
                                const t = (0, G.z6)(h, a),
                                    i = (0, G.Bs)(t),
                                    n = [[], []];
                                let o = 0;
                                for (let t = 0; t < e.length; t++)
                                    if (
                                        ((0, G.a2)(h, e[t], i),
                                        (n[0][t] = h[0]),
                                        (n[1][t] = h[1]),
                                        0 !== t)
                                    ) {
                                        const e = n[0][t] - n[0][t - 1],
                                            i = n[1][t] - n[1][t - 1];
                                        o += Math.sqrt(e * e + i * i);
                                    }
                                (f += o), m.push({ vertices: n, tileInfo: i, distance: o });
                            }
                            let p = 0;
                            const _ = (0, $.Yi)(
                                this.mapState.styleState,
                                P.i4,
                                P.Dz,
                                this.tileAttrs,
                                P.wz,
                            );
                            m.forEach((o, r) => {
                                var a, l;
                                const { tileInfo: c, distance: u, vertices: v } = o;
                                if (
                                    ((this.tileAttrs[s.beginningIsCut] = 0),
                                    (this.tileAttrs[s.endingIsCut] = 0),
                                    (this.tileAttrs[s.previousPointX] = 0),
                                    (this.tileAttrs[s.previousPointY] = 0),
                                    (this.tileAttrs[s.nextPointX] = 0),
                                    (this.tileAttrs[s.nextPointY] = 0),
                                    (this.tileAttrs[s.componentDistanceStart] = p),
                                    (p += u),
                                    (this.tileAttrs[s.objectLength] = f),
                                    0 !== r)
                                ) {
                                    const e = d[r - 1],
                                        t = e[e.length - 2];
                                    (0, G.a2)(h, t, c),
                                        (this.tileAttrs[s.beginningIsCut] = 1),
                                        (this.tileAttrs[s.previousPointX] = h[0]),
                                        (this.tileAttrs[s.previousPointY] = h[1]);
                                }
                                if (r !== m.length - 1) {
                                    const e = d[r + 1][1];
                                    (0, G.a2)(h, e, c),
                                        (this.tileAttrs[s.endingIsCut] = 1),
                                        (this.tileAttrs[s.nextPointX] = h[0]),
                                        (this.tileAttrs[s.nextPointY] = h[1]);
                                }
                                if (!(0, G.Ny)(c.coords, this.mapState.tilesBounds)) return;
                                this.dashLayer &&
                                    (e.addLayer(
                                        this.dashLayer,
                                        null !== (a = this.options.zIndex) && void 0 !== a ? a : 0,
                                    ),
                                    (0, H.XI)({
                                        collector: t,
                                        generator: $c.L.generate,
                                        args: [e.getStyle().id, this.dashLayer, _, c, v],
                                    })),
                                    this.baseLayer &&
                                        (e.addLayer(
                                            this.baseLayer,
                                            null !== (l = this.options.zIndex2) && void 0 !== l
                                                ? l
                                                : -1,
                                        ),
                                        (0, H.XI)({
                                            collector: t,
                                            generator: Wc.z.generate,
                                            args: [e.getStyle().id, this.baseLayer, _, c, v],
                                        }));
                                const g = t.getAccumulatedData(),
                                    y = new C.W('dynamicObject', g.data, i, c.coords);
                                n.addObject(y),
                                    this.tileObjects.push(y),
                                    this.interactive && this.identifyIds.push(g.identifyIds);
                            }),
                                this.interactive && r.resetCache(),
                                t.reset(),
                                (this.mapState.needRerender = !0);
                        }
                    }
                    var Yc = i(7084),
                        Kc = i(2097);
                    class Jc extends A {
                        constructor(e, t) {
                            var i;
                            super(e),
                                (this.options = t),
                                (this.isInteractive =
                                    null === (i = t.interactive) || void 0 === i || i);
                            const n = this.options.coordinates.map((e) => {
                                const t = e.map(L.yq);
                                if (t.length > 1) {
                                    const e = t[0],
                                        i = t[t.length - 1];
                                    (e[0] === i[0] && e[1] === i[1]) || t.push(e);
                                }
                                return t;
                            });
                            let o = [];
                            const r = [],
                                {
                                    dynamicStyle: s,
                                    collector: a,
                                    renderer: l,
                                    tileManager: c,
                                    identifier: d,
                                    layers: h,
                                } = this.modules;
                            n.forEach((e) => {
                                o.length && r.push(o.length), (o = o.concat(e));
                            });
                            const u = (0, W.qw)({
                                type: 'polygon',
                                id: `dynamic-polygon-${this.uniqId}`,
                                minzoom: this.options.minZoom,
                                maxzoom: this.options.maxZoom,
                                style: { color: this.options.color || '#3388ff33' },
                            });
                            if (!u) return;
                            s.addLayer(u, this.options.zIndex), (this.fillLayerId = u.innerId);
                            const m = (0, V.FJ)({
                                    id: this.isInteractive ? (0, O.Ru)(0, 0) : NaN,
                                    beginningIsCut: 0,
                                    endingIsCut: 0,
                                }),
                                f = ee.Ue();
                            for (let e = 0; e < o.length; e++) ee.aM(f, o[e]);
                            const p = (0, G.x7)(f),
                                _ = (0, G.Bs)(p),
                                v = [];
                            for (let e = 0; e < o.length; e++) v.push(o[e][0]), v.push(o[e][1]);
                            const g = Yc(v, r),
                                y = D.Ue(),
                                b = [[], [], []],
                                w = (0, $.Yi)(this.mapState.styleState, P.i4, P.Dz, m, P.wz);
                            for (let e = 0; e < g.length; e += 3) {
                                for (let t = 0; t < 3; t++)
                                    (0, G.a2)(y, o[g[e + t]], _),
                                        (b[0][t] = y[0]),
                                        (b[1][t] = y[1]),
                                        (b[2][t] = 0);
                                (0, H.XI)({
                                    collector: a,
                                    generator: Kc.a.generate,
                                    args: [
                                        s.getStyle().id,
                                        u,
                                        w,
                                        b,
                                        (0, Nc.o1)(window.devicePixelRatio),
                                        s.getStyle().rasterSets,
                                    ],
                                });
                            }
                            if (0 !== this.options.strokeWidth) {
                                const e = (0, W.qw)({
                                    type: 'line',
                                    id: `dynamic-polygon-stroke-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color: this.options.strokeColor || '#3388ff',
                                        width: this.options.strokeWidth || 3,
                                    },
                                });
                                e &&
                                    (s.addLayer(e, this.options.zIndex),
                                    (this.borderLayerId = e.innerId),
                                    n.forEach((t) => {
                                        const i = [[], [], []];
                                        t.forEach((e, t) => {
                                            (0, G.a2)(y, e, _), (i[0][t] = y[0]), (i[1][t] = y[1]);
                                        }),
                                            (0, H.XI)({
                                                collector: a,
                                                generator: Wc.z.generate,
                                                args: [s.getStyle().id, e, w, _, i],
                                            });
                                    }));
                            }
                            const x = a.getAccumulatedData(),
                                S = new C.W('dynamicObject', x.data, l, _.coords);
                            c.addObject(S),
                                this.tileObjects.push(S),
                                this.isInteractive && this.identifyIds.push(x.identifyIds),
                                h.addLayer(this),
                                a.reset(),
                                (this.mapState.needRerender = !0),
                                this.isInteractive && d.resetCache();
                        }
                        remove() {
                            this.isInteractive && this.modules.identifier.resetCache(),
                                this.fillLayerId &&
                                    this.modules.dynamicStyle.removeLayer(this.fillLayerId),
                                this.borderLayerId &&
                                    this.modules.dynamicStyle.removeLayer(this.borderLayerId),
                                super.destroy();
                        }
                    }
                    class Qc extends A {
                        constructor(e, t) {
                            var i, n, o, r, s;
                            if (
                                (super(e),
                                (this.options = t),
                                (this.isInteractive =
                                    null === (i = t.interactive) || void 0 === i || i),
                                t.segments && t.segments <= 0)
                            )
                                return;
                            const {
                                    dynamicStyle: a,
                                    collector: l,
                                    renderer: c,
                                    tileManager: d,
                                    identifier: h,
                                    layers: u,
                                } = this.modules,
                                m = (function (e, t, i) {
                                    const n = [];
                                    if (i > 0) {
                                        n.push(D.al(e[0] + t, e[1], e[2]));
                                        const o = Math.PI / Math.ceil(i / 2);
                                        for (let i = o; i < Math.PI; i += o) {
                                            const o = t * Math.cos(i),
                                                r = t * Math.sin(i);
                                            n.push(
                                                D.al(e[0] + o, e[1] + r, e[2]),
                                                D.al(e[0] + o, e[1] - r, e[2]),
                                            );
                                        }
                                        n.push(D.al(e[0] - t, e[1], e[2]));
                                    }
                                    return n;
                                })(
                                    (0, L.yq)(this.options.coordinates),
                                    (0, L.a4)(this.options.coordinates, this.options.radius),
                                    null !== (n = this.options.segments) && void 0 !== n ? n : 150,
                                ),
                                f = (0, W.qw)({
                                    type: 'polygon',
                                    id: `dynamic-circle-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        color:
                                            null !== (o = this.options.color) && void 0 !== o
                                                ? o
                                                : '#3388ff33',
                                        strokeWidth:
                                            null !== (r = this.options.borderWidth) && void 0 !== r
                                                ? r
                                                : 1,
                                        strokeColor:
                                            null !== (s = this.options.borderColor) && void 0 !== s
                                                ? s
                                                : '#3388ff',
                                    },
                                });
                            if (!f) return;
                            a.addLayer(f, this.options.zIndex), (this.layerId = f.innerId);
                            const p = (0, V.FJ)({ id: this.isInteractive ? (0, O.Ru)(0, 0) : NaN }),
                                _ = ee.Ue();
                            for (let e = 0; e < m.length; e++) ee.aM(_, m[e]);
                            const v = (0, G.x7)(_),
                                g = (0, G.Bs)(v),
                                y = [[], [], []],
                                b = D.Ue(),
                                w = 0 !== this.options.borderWidth ? 1 : 0;
                            for (let e = 0; e < m.length; e++)
                                (0, G.a2)(b, m[e], g),
                                    (y[0][e] = b[0]),
                                    (y[1][e] = b[1]),
                                    (y[2][e] = w);
                            const x = (0, $.Yi)(this.mapState.styleState, P.i4, P.Dz, p, P.wz);
                            (0, H.XI)({
                                collector: l,
                                generator: Kc.a.generate,
                                args: [
                                    a.getStyle().id,
                                    f,
                                    x,
                                    y,
                                    (0, Nc.o1)(window.devicePixelRatio),
                                ],
                            });
                            const S = l.getAccumulatedData(),
                                I = new C.W('dynamicObject', S.data, c, g.coords);
                            d.addObject(I),
                                this.tileObjects.push(I),
                                this.isInteractive && this.identifyIds.push(S.identifyIds),
                                u.addLayer(this),
                                l.reset(),
                                (this.mapState.needRerender = !0),
                                this.isInteractive && h.resetCache();
                        }
                        remove() {
                            this.isInteractive && this.modules.identifier.resetCache(),
                                this.layerId && this.modules.dynamicStyle.removeLayer(this.layerId),
                                super.destroy();
                        }
                    }
                    function ed(e, t, i, n, o, r) {
                        if (o - n <= i) return;
                        const s = (n + o) >> 1;
                        td(e, t, s, n, o, r % 2),
                            ed(e, t, i, n, s - 1, r + 1),
                            ed(e, t, i, s + 1, o, r + 1);
                    }
                    function td(e, t, i, n, o, r) {
                        for (; o > n; ) {
                            if (o - n > 600) {
                                const s = o - n + 1,
                                    a = i - n + 1,
                                    l = Math.log(s),
                                    c = 0.5 * Math.exp((2 * l) / 3),
                                    d =
                                        0.5 *
                                        Math.sqrt((l * c * (s - c)) / s) *
                                        (a - s / 2 < 0 ? -1 : 1);
                                td(
                                    e,
                                    t,
                                    i,
                                    Math.max(n, Math.floor(i - (a * c) / s + d)),
                                    Math.min(o, Math.floor(i + ((s - a) * c) / s + d)),
                                    r,
                                );
                            }
                            const s = t[2 * i + r];
                            let a = n,
                                l = o;
                            for (id(e, t, n, i), t[2 * o + r] > s && id(e, t, n, o); a < l; ) {
                                for (id(e, t, a, l), a++, l--; t[2 * a + r] < s; ) a++;
                                for (; t[2 * l + r] > s; ) l--;
                            }
                            t[2 * n + r] === s ? id(e, t, n, l) : (l++, id(e, t, l, o)),
                                l <= i && (n = l + 1),
                                i <= l && (o = l - 1);
                        }
                    }
                    function id(e, t, i, n) {
                        nd(e, i, n), nd(t, 2 * i, 2 * n), nd(t, 2 * i + 1, 2 * n + 1);
                    }
                    function nd(e, t, i) {
                        const n = e[t];
                        (e[t] = e[i]), (e[i] = n);
                    }
                    function od(e, t, i, n) {
                        const o = e - i,
                            r = t - n;
                        return o * o + r * r;
                    }
                    const rd = (e) => e[0],
                        sd = (e) => e[1];
                    class ad {
                        constructor(e, t = rd, i = sd, n = 64, o = Float64Array) {
                            (this.nodeSize = n), (this.points = e);
                            const r = e.length < 65536 ? Uint16Array : Uint32Array,
                                s = (this.ids = new r(e.length)),
                                a = (this.coords = new o(2 * e.length));
                            for (let n = 0; n < e.length; n++)
                                (s[n] = n), (a[2 * n] = t(e[n])), (a[2 * n + 1] = i(e[n]));
                            ed(s, a, n, 0, s.length - 1, 0);
                        }
                        range(e, t, i, n) {
                            return (function (e, t, i, n, o, r, s) {
                                const a = [0, e.length - 1, 0],
                                    l = [];
                                let c, d;
                                for (; a.length; ) {
                                    const h = a.pop(),
                                        u = a.pop(),
                                        m = a.pop();
                                    if (u - m <= s) {
                                        for (let s = m; s <= u; s++)
                                            (c = t[2 * s]),
                                                (d = t[2 * s + 1]),
                                                c >= i &&
                                                    c <= o &&
                                                    d >= n &&
                                                    d <= r &&
                                                    l.push(e[s]);
                                        continue;
                                    }
                                    const f = Math.floor((m + u) / 2);
                                    (c = t[2 * f]),
                                        (d = t[2 * f + 1]),
                                        c >= i && c <= o && d >= n && d <= r && l.push(e[f]);
                                    const p = (h + 1) % 2;
                                    (0 === h ? i <= c : n <= d) &&
                                        (a.push(m), a.push(f - 1), a.push(p)),
                                        (0 === h ? o >= c : r >= d) &&
                                            (a.push(f + 1), a.push(u), a.push(p));
                                }
                                return l;
                            })(this.ids, this.coords, e, t, i, n, this.nodeSize);
                        }
                        within(e, t, i) {
                            return (function (e, t, i, n, o, r) {
                                const s = [0, e.length - 1, 0],
                                    a = [],
                                    l = o * o;
                                for (; s.length; ) {
                                    const c = s.pop(),
                                        d = s.pop(),
                                        h = s.pop();
                                    if (d - h <= r) {
                                        for (let o = h; o <= d; o++)
                                            od(t[2 * o], t[2 * o + 1], i, n) <= l && a.push(e[o]);
                                        continue;
                                    }
                                    const u = Math.floor((h + d) / 2),
                                        m = t[2 * u],
                                        f = t[2 * u + 1];
                                    od(m, f, i, n) <= l && a.push(e[u]);
                                    const p = (c + 1) % 2;
                                    (0 === c ? i - o <= m : n - o <= f) &&
                                        (s.push(h), s.push(u - 1), s.push(p)),
                                        (0 === c ? i + o >= m : n + o >= f) &&
                                            (s.push(u + 1), s.push(d), s.push(p));
                                }
                                return a;
                            })(this.ids, this.coords, e, t, i, this.nodeSize);
                        }
                    }
                    function ld(e, t) {
                        const i = [],
                            n = [],
                            o = [],
                            r = D.Ue();
                        return (
                            e.forEach(({ mapCoords: e, weight: s }) => {
                                !(function (e, t, i) {
                                    (e[0] = ((t[0] - i.offset[0]) * rt._H) / i.size),
                                        (e[1] = ((t[1] - i.offset[1]) * rt._H) / i.size);
                                })(r, e, t);
                                const a = r[0],
                                    l = r[1];
                                for (let e = 0; e < 6; e++) i.push(a, l), o.push(s);
                                n.push(-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1);
                            }),
                            {
                                vertices: new Ft.l(new Uint16Array(i), {
                                    itemSize: 2,
                                    dataType: Ft.l.UnsignedShort,
                                    stride: 0,
                                    offset: 0,
                                    normalized: !0,
                                }),
                                widens: new Ft.l(new Int8Array(n), {
                                    itemSize: 2,
                                    dataType: Ft.l.Byte,
                                    stride: 0,
                                    offset: 0,
                                    normalized: !1,
                                }),
                                weights: new Ft.l(new Float32Array(o), {
                                    itemSize: 1,
                                    dataType: Ft.l.Float,
                                    stride: 0,
                                    offset: 0,
                                    normalized: !1,
                                }),
                            }
                        );
                    }
                    function cd(e) {
                        const t = new Error(
                                "The palette is not valid. The heatmap won't be rendered.",
                            ),
                            i = Object.getOwnPropertyNames(e);
                        if (0 === i.length) throw t;
                        const n = i.map((e) => Number(e));
                        if (n.some((e) => Number.isNaN(e) || e < 0 || e > 1)) throw t;
                        const o = {};
                        n.forEach((i) => {
                            if ('string' != typeof e[i]) throw t;
                            o[i] = (0, ds.MV)(e[i]);
                        });
                        const r = Math.min(...n),
                            s = Math.max(...n);
                        return r > 0 && (o[0] = o[r]), s < 1 && (o[1] = o[s]), o;
                    }
                    function dd(e, t) {
                        const i = Object.keys(e)
                            .map((e) => Number(e))
                            .sort((e, t) => e - t);
                        let n = 0;
                        const o = [],
                            r = t - 1;
                        for (let s = 0; s < t; s++) {
                            const t = s / r;
                            t > i[n + 1] && n++;
                            const a = i[n],
                                l = i[n + 1],
                                c = (t - a) / (l - a);
                            for (let t = 0; t < 4; t++)
                                o[4 * s + t] = hd(e[a].value[t], e[l].value[t], c);
                        }
                        return o.map((e) => Math.round(e));
                    }
                    function hd(e, t, i) {
                        return e * (1 - i) + t * i;
                    }
                    const ud = {
                        0: 'rgba(89, 0, 89, 0)',
                        0.25: 'rgba(0, 0, 89, 0.78)',
                        0.5: 'rgba(0, 198, 68, 1)',
                        0.7: 'rgba(198, 186, 0, 1)',
                        0.8: 'rgba(249, 152, 0, 1)',
                        1: 'rgba(200, 0, 0, 1)',
                    };
                    class md extends A {
                        constructor(e, t = {}) {
                            super(e),
                                (this.offscreenTextureIndex = -1),
                                (this.fillBuffers = () => {
                                    if (!this.tree) return;
                                    const e = (0, Oi.BS)(this.mapState.tilesBounds),
                                        t = (0, G.x7)(e);
                                    if (
                                        this.tileCoords &&
                                        ((i = t),
                                        (n = this.tileCoords),
                                        i.every((e, t) => e === n[t]))
                                    )
                                        return;
                                    var i, n;
                                    this.resetBuffers(), (this.tileCoords = t);
                                    const o = (0, G.aq)(t[2]),
                                        r = (0, G.Oy)(t);
                                    $e.wA(this.matrix, r, D.al(o, o, rt._9));
                                    const s = this.tree
                                            .range(r[0], r[1], r[0] + o, r[1] + o)
                                            .map((e) => this.points[e]),
                                        a = (0, G.Bs)(t);
                                    (this.buffers = ld(s, a)),
                                        (this.vertexCount = 6 * s.length),
                                        (this.vao = new Xe(this.offscreenProgram, {
                                            a_vec2_position: this.buffers.vertices,
                                            a_vec2_widen: this.buffers.widens,
                                            a_float_weight: this.buffers.weights,
                                        }));
                                }),
                                (this.resizeFrameBuffer = () => {
                                    this.frameBuffer.setSize([
                                        Math.ceil(
                                            (this.mapState.size[0] * window.devicePixelRatio) /
                                                this.downscale,
                                        ),
                                        Math.ceil(
                                            (this.mapState.size[1] * window.devicePixelRatio) /
                                                this.downscale,
                                        ),
                                    ]),
                                        this.frameBuffer.bind(this.gl),
                                        this.frameBuffer.unbind(this.gl);
                                    const e = this.frameBuffer.getTexture();
                                    e
                                        ? this.modules.imageManager.updatePreparedTexture(
                                              this.offscreenTextureIndex,
                                              e,
                                          )
                                        : (0, hs.cM)("Can't update a non-prepared texture"),
                                        (this.needRerender = !0),
                                        (this.mapState.needRerender = !0);
                                });
                            const {
                                downscale: i,
                                palette: n,
                                points: o,
                                minZoom: r,
                                maxZoom: s,
                                zIndex: a,
                                pointRadius: l,
                                intensity: c,
                                opacity: d,
                            } = t;
                            (this.rampTextureIndex = this.modules.imageManager.addPreparedTexture(
                                (function (e, t) {
                                    const i = dd(cd(e), t);
                                    return new it(new Uint8Array(i), { size: [t, 1] });
                                })(null != n ? n : ud, 256),
                            )),
                                (this.gl = this.modules.renderer.getRenderingContext()),
                                (this.downscale = null != i ? i : 1),
                                (this.frameBuffer = new nt({
                                    size: [
                                        Math.ceil(
                                            (this.mapState.size[0] * window.devicePixelRatio) /
                                                this.downscale,
                                        ),
                                        Math.ceil(
                                            (this.mapState.size[1] * window.devicePixelRatio) /
                                                this.downscale,
                                        ),
                                    ],
                                    magFilter: it.LinearFilter,
                                    minFilter: it.LinearFilter,
                                    wrapS: it.ClampToEdgeWrapping,
                                    wrapT: it.ClampToEdgeWrapping,
                                }));
                            const h = this.frameBuffer.getTexture();
                            h
                                ? (this.offscreenTextureIndex =
                                      this.modules.imageManager.addPreparedTexture(h))
                                : (0, hs.cM)("Can't add a non-prepared texture."),
                                (this.offscreenProgram = new $r({
                                    vertex: ns('heatmap'),
                                    fragment: os('heatmap'),
                                    uniforms: [
                                        { name: 'u_mat4_mvp', type: 'mat4' },
                                        { name: 'u_float_radius', type: '1f' },
                                        { name: 'u_float_intensity', type: '1f' },
                                        { name: 'u_float_tile_to_pixel_ratio', type: '1f' },
                                    ],
                                    attributes: [
                                        { name: 'a_vec2_position', location: 0 },
                                        { name: 'a_vec2_widen', location: 1 },
                                        { name: 'a_float_weight', location: 2 },
                                    ],
                                })),
                                (this.points = []),
                                (this.vertexCount = 0),
                                (this.isDestroyed = !1),
                                (this.needRerender = !1),
                                (this.matrix = $e.Ue()),
                                (this.mvpMatrix = $e.Ue()),
                                (this.viewDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'padding', type: 'padding' },
                                ])),
                                (this.sizeDiffer = new De([{ path: 'size', type: 'vec2' }])),
                                (this.throttledFillBuffer = Ce(this.fillBuffers, 50));
                            const u = (0, W.qw)({
                                type: 'heatmap',
                                id: `dynamic-heatmap-${this.uniqId}`,
                                minzoom: r,
                                maxzoom: s,
                                style: {
                                    opacity: null != d ? d : 0.5,
                                    intensity: null != c ? c : 3,
                                    radius: null != l ? l : 10,
                                },
                            });
                            if (!u) throw new Error('There is no correct style layer for heatmap');
                            (this.layer = u),
                                this.modules.dynamicStyle.addLayer(u, a),
                                o && this.setPoints(o);
                        }
                        setPoints(e) {
                            if (!this.isDestroyed) {
                                if (
                                    ((this.points = e.map(({ coordinates: e, weight: t }) => ({
                                        mapCoords: (0, L.yq)(e),
                                        weight: null != t ? t : 1,
                                    }))),
                                    (this.tree = new ad(
                                        this.points,
                                        (e) => e.mapCoords[0],
                                        (e) => e.mapCoords[1],
                                    )),
                                    (this.tileCoords = void 0),
                                    !this.tileObjects.length)
                                ) {
                                    const {
                                        layers: e,
                                        collector: t,
                                        dynamicStyle: i,
                                        renderer: n,
                                        tileManager: o,
                                    } = this.modules;
                                    (0, H.XI)({
                                        collector: t,
                                        generator: Rt.B.generateTexture,
                                        args: [
                                            i.getStyle().id,
                                            this.layer,
                                            this.offscreenTextureIndex,
                                            this.rampTextureIndex,
                                        ],
                                    });
                                    const r = t.getAccumulatedData(),
                                        s = new C.W('dynamicObject', r.data, n);
                                    o.addObject(s),
                                        this.tileObjects.push(s),
                                        e.addLayer(this),
                                        t.reset();
                                }
                                (this.mapState.needRerender = !0), (this.needRerender = !0);
                            }
                        }
                        update() {
                            if (
                                (this.sizeDiffer.check(this.mapState) && this.resizeFrameBuffer(),
                                !this.needRerender && !this.viewDiffer.check(this.mapState))
                            )
                                return;
                            if (!this.tree) return;
                            const { zoom: e, styleZoom: t, styleState: i } = this.mapState,
                                n = this.gl;
                            if (
                                (this.throttledFillBuffer(),
                                !(this.vao && this.buffers && this.tree && this.tileCoords))
                            )
                                return;
                            const o = (0, $.jJ)(t, i, []),
                                r = (0, $.vn)(this.layer.style.radius, o),
                                s = (0, $.vn)(this.layer.style.intensity, o),
                                a =
                                    rt.y4 *
                                    Math.pow(2, e - this.tileCoords[2]) *
                                    window.devicePixelRatio;
                            this.offscreenProgram.enable(n),
                                this.offscreenProgram.bind(n, {
                                    u_mat4_mvp: $e.dC(
                                        this.mvpMatrix,
                                        this.modules.camera.viewProjectionMatrix,
                                        this.matrix,
                                    ),
                                    u_float_radius: r * window.devicePixelRatio,
                                    u_float_intensity: s,
                                    u_float_tile_to_pixel_ratio: 1 / a,
                                }),
                                this.vao.bind({
                                    gl: n,
                                    extensions: this.modules.renderer.webGlExtensions,
                                }),
                                this.gl.viewport(
                                    0,
                                    0,
                                    Math.ceil(
                                        (this.mapState.size[0] * window.devicePixelRatio) /
                                            this.downscale,
                                    ),
                                    Math.ceil(
                                        (this.mapState.size[1] * window.devicePixelRatio) /
                                            this.downscale,
                                    ),
                                ),
                                this.frameBuffer.bind(n),
                                n.clearColor(0, 0, 0, 0),
                                n.clear(n.COLOR_BUFFER_BIT),
                                n.blendFunc(n.ONE, n.ONE),
                                n.enable(n.BLEND),
                                n.drawArrays(n.TRIANGLES, 0, this.vertexCount),
                                this.frameBuffer.unbind(n),
                                (this.needRerender = !1);
                        }
                        destroy() {
                            if (this.isDestroyed) return;
                            super.destroy(),
                                (this.points = []),
                                (this.tree = void 0),
                                (this.isDestroyed = !0),
                                this.resetBuffers(),
                                this.layer &&
                                    this.modules.dynamicStyle.removeLayer(this.layer.innerId),
                                this.frameBuffer.remove();
                            const { imageManager: e } = this.modules;
                            e.deleteTexture(this.offscreenTextureIndex),
                                e.deleteTexture(this.rampTextureIndex);
                        }
                        resetBuffers() {
                            this.buffers &&
                                (Object.values(this.buffers).forEach((e) => e.remove()),
                                (this.buffers = void 0)),
                                this.vao && (this.vao.remove(), (this.vao = void 0));
                        }
                    }
                    var fd = i(9808),
                        pd = i(4333);
                    const _d = [0, 0],
                        vd = [0, 0, 0, 0];
                    class gd extends A {
                        constructor(e, t) {
                            var i, n, o, r, s, a, l, c, d, h, u, m;
                            super(e), (this.status = 'visible'), (this.options = t);
                            const f = null !== (i = t.font) && void 0 !== i ? i : rt.Uo,
                                p =
                                    null !== (n = t.fontSize) && void 0 !== n
                                        ? n
                                        : I.fonts.baseSize,
                                _ = null !== (o = t.letterSpacing) && void 0 !== o ? o : 0,
                                v =
                                    null !== (r = t.lineHeight) && void 0 !== r
                                        ? r
                                        : I.fonts.baseLineHeight,
                                g = [
                                    null !==
                                        (a =
                                            null === (s = this.options.offset) || void 0 === s
                                                ? void 0
                                                : s[0]) && void 0 !== a
                                        ? a
                                        : _d[0],
                                    null !==
                                        (c =
                                            null === (l = this.options.offset) || void 0 === l
                                                ? void 0
                                                : l[1]) && void 0 !== c
                                        ? c
                                        : _d[1],
                                ],
                                y = (0, W.qw)({
                                    type: 'point',
                                    id: `dynamic-pointLabel-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: {
                                        textFont: f,
                                        textFontSize: p,
                                        textColor:
                                            null !== (d = t.color) && void 0 !== d ? d : '#000000',
                                        textHaloWidth:
                                            null !== (h = t.haloRadius) && void 0 !== h ? h : 0,
                                        textHaloColor:
                                            null !== (u = t.haloColor) && void 0 !== u
                                                ? u
                                                : '#ffffff',
                                        textLetterSpacing: _,
                                        textLineHeight: v,
                                        textOffset: g,
                                    },
                                });
                            if (((this.position = (0, L.yq)(this.options.coordinates)), !y)) return;
                            const {
                                    dynamicStyle: b,
                                    collector: w,
                                    assetManager: x,
                                    styleManager: S,
                                    renderer: M,
                                    tileManager: T,
                                    layers: k,
                                    defaultSource: E,
                                } = this.modules,
                                A = null !== (m = this.options.zIndex) && void 0 !== m ? m : 0;
                            b.addLayer(y, A);
                            const z = (0, V.FJ)({ db_label: this.options.text }),
                                F = (0, G.IR)(this.position),
                                O = (0, $.Yi)(
                                    this.mapState.styleState,
                                    P.i4,
                                    P.nF.tileProps,
                                    z,
                                    P.wz,
                                );
                            (0, H.XI)({
                                collector: w,
                                generator: pd.p,
                                args: [
                                    b.getStyle(),
                                    y,
                                    O,
                                    P.nF,
                                    F,
                                    E.getId(),
                                    [[0], [0]],
                                    (0, Nc.o1)(window.devicePixelRatio),
                                ],
                            });
                            const D = w.getAccumulatedData();
                            if (!D.labels.length) return;
                            const R = [
                                    {
                                        metatileHash: -1,
                                        labels: D.labels,
                                        styleId: b.getStyle().id,
                                    },
                                ],
                                j = (0, fd.v)(
                                    R,
                                    Ta.AL.DynamicObject,
                                    S,
                                    this.mapState.styleState,
                                    this.mapState.styleZoom,
                                );
                            if (1 !== j.length) return;
                            const B = j[0];
                            Uc.GY.then(() => {
                                var e;
                                (B.label =
                                    null !== (e = (0, Uc.iY)(B.label)) && void 0 !== e ? e : ''),
                                    B.updateRanges();
                            })
                                .then(() => Promise.all(B.ranges.map((e) => x.loadFont(f, e))))
                                .then(() => {
                                    if ('destroyed' === this.status) return;
                                    B.textMetrics = (0, Ks.JA)(B.label, _, x.getFontGlyphs(f));
                                    const e = (function (e) {
                                            return [
                                                e && void 0 !== e[0] ? (0, fe.uZ)(e[0], 0, 1) : 0.5,
                                                e && void 0 !== e[1] ? (0, fe.uZ)(e[1], 0, 1) : 0.5,
                                            ];
                                        })(t.anchor),
                                        i = p / I.fonts.baseSize,
                                        n = p * v * B.textMetrics.lines.length,
                                        o = i * B.textMetrics.maxWidth,
                                        r = [-o * (e[0] - 0.5), -n * (e[1] - 0.5)],
                                        [s, a] = g;
                                    (0, H.XI)({
                                        collector: w,
                                        generator: io.qp,
                                        args: [
                                            B,
                                            1,
                                            B.textMetrics,
                                            [0, 0, 0],
                                            0,
                                            [s + r[0], a + r[1]],
                                            y,
                                            b.getStyle().fontNameToIndex[f],
                                            window.devicePixelRatio,
                                        ],
                                    });
                                    const l = w.getAccumulatedData(),
                                        c = new C.W(
                                            'dynamicObject',
                                            l.data,
                                            M,
                                            (0, G.IR)(this.position),
                                        );
                                    'visible' === this.status && T.addObject(c),
                                        k.addLayer(this),
                                        this.tileObjects.push(c),
                                        w.reset(),
                                        (this.mapState.needRerender = !0),
                                        this.initImageIfNeed(B, o, n, g, r);
                                });
                        }
                        hide() {
                            'visible' === this.status &&
                                ((this.status = 'hidden'),
                                this.tileObjects.forEach((e) => {
                                    this.modules.tileManager.removeObject(e);
                                }));
                        }
                        show() {
                            'hidden' === this.status &&
                                ((this.status = 'visible'),
                                this.tileObjects.forEach((e) => {
                                    this.modules.tileManager.addObject(e);
                                }));
                        }
                        remove() {
                            'destroyed' !== this.status &&
                                (super.destroy(), (this.status = 'destroyed'));
                        }
                        setCoordinates(e) {
                            'destroyed' !== this.status &&
                                ((this.position = (0, L.yq)(e)),
                                this.tileObjects.forEach((e) => {
                                    e.setTileCoords((0, G.IR)(this.position));
                                }),
                                0 !== this.tileObjects.length &&
                                    'visible' === this.status &&
                                    (this.mapState.needRerender = !0));
                        }
                        getCoordinates() {
                            return (0, L.PA)(this.position);
                        }
                        initImageIfNeed(e, t, i, n, o) {
                            var r, s;
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                if (!this.options.image) return;
                                const a = window.devicePixelRatio,
                                    l = yield this.modules.imageCache.getRasterSet(
                                        this.options.image.url,
                                        void 0,
                                        this.options.image.size,
                                        [0, 0],
                                    );
                                if (!l || 'destroyed' === this.status) return;
                                const c = l.rasters[0];
                                this.modules.dynamicStyle.appendRasterSet(
                                    l,
                                    (0, oo.PR)(this.options.image.url, 0, 0),
                                );
                                const [d, h, u, m] = this.options.image.padding || vd,
                                    f = (t + m + h) * a,
                                    p = (i + d + u) * a,
                                    _ = ((h - m) / 2 + n[0] + o[0]) * a,
                                    v = ((u - d) / 2 + n[1] + o[1]) * a,
                                    g =
                                        null === (r = this.options.image.stretchX) || void 0 === r
                                            ? void 0
                                            : r.map(([e, t]) => [e * a, t * a]),
                                    y =
                                        null === (s = this.options.image.stretchY) || void 0 === s
                                            ? void 0
                                            : s.map(([e, t]) => [e * a, t * a]);
                                (0,
                                H.XI)({ collector: this.modules.collector, generator: io.GN, args: [e, [0,
                                            0, 0], 0, c, f, p, _, v, window.devicePixelRatio, g, y] });
                                const b = this.modules.collector.getAccumulatedData(),
                                    w = new C.W(
                                        'dynamicObject',
                                        b.data,
                                        this.modules.renderer,
                                        (0, G.IR)(this.position),
                                    );
                                this.tileObjects.push(w),
                                    'hidden' !== this.status &&
                                        this.modules.tileManager.addObject(w),
                                    this.modules.collector.reset();
                            });
                        }
                    }
                    const yd = [0.5, 0.5],
                        bd = [0, 18];
                    class wd extends Z {
                        constructor(e, t) {
                            super(e, t.draggable), (this.map = e);
                            const {
                                coordinates: i,
                                size: n,
                                zIndex: o,
                                minZoom: r,
                                maxZoom: s,
                                interactive: a,
                                hoverIcon: l,
                                hoverSize: c,
                                hoverAnchor: d,
                                label: h,
                                rotation: u,
                            } = t;
                            (this.status = 'normal'),
                                (this.position = (0, L.yq)(i)),
                                (this.rotation = (0, fe.Id)(null != u ? u : 0)),
                                (this.zIndex = void 0 !== o ? o : 0),
                                (this.minZoom = null != r ? r : -1 / 0),
                                (this.maxZoom = null != s ? s : 1 / 0),
                                (this.interactive = void 0 === a || a);
                            const m = void 0 !== t.icon ? t.icon : I.defaultMarkerIcon,
                                f = void 0 !== t.icon ? t.anchor : I.defaultMarkerAnchor;
                            this.on('mouseover', this.switchToHoveredStyle),
                                this.on('mouseout', this.switchToNormalStyle),
                                this.modules.layers.addLayer(this),
                                this.setIconInternal({ icon: m, anchor: f, size: n }).then(() => {
                                    void 0 !== l &&
                                        this.setHoverIconInternal({ icon: l, anchor: d, size: c });
                                }),
                                this.setLabel(h);
                        }
                        destroy() {
                            var e;
                            'destroyed' !== this.status &&
                                ((this.status = 'destroyed'),
                                null === (e = this.label) || void 0 === e || e.remove(),
                                this.interactive && this.modules.identifier.resetCache(),
                                this.off('mouseover', this.switchToHoveredStyle),
                                this.off('mouseout', this.switchToNormalStyle),
                                super.destroy());
                        }
                        setRotation(e) {
                            'destroyed' !== this.status &&
                                ((this.rotation = (0, fe.Id)(e)),
                                this.normalStateData &&
                                    ((this.normalStateData.styleLayer.style.iconRotation =
                                        this.rotation),
                                    (this.mapState.needRerender = !0)),
                                this.hoverStateData &&
                                    ((this.hoverStateData.styleLayer.style.iconRotation =
                                        this.rotation),
                                    (this.mapState.needRerender = !0)));
                        }
                        getRotation() {
                            return (0, fe.ZY)(this.rotation);
                        }
                        setIcon(e) {
                            'destroyed' !== this.status && this.setIconInternal(e);
                        }
                        setHoverIcon(e) {
                            if ('destroyed' !== this.status)
                                return e
                                    ? void this.setHoverIconInternal(e)
                                    : ('hover' === this.status && this.switchToNormalStyle(),
                                      void (
                                          this.hoverStateData &&
                                          ((0, fe.VJ)(
                                              this.tileObjects,
                                              this.hoverStateData.tileObject,
                                          ),
                                          (0, fe.VJ)(
                                              this.identifyIds,
                                              this.hoverStateData.identifyIds,
                                          ),
                                          this.hoverStateData.tileObject.clean(this.mapState),
                                          (this.hoverStateData = void 0))
                                      ));
                        }
                        setLabel(e) {
                            var t, i, n, o, r;
                            'destroyed' !== this.status &&
                                (null === (t = this.label) || void 0 === t || t.remove(),
                                e &&
                                    (this.label = new gd(
                                        this.map,
                                        Object.assign(
                                            Object.assign(
                                                { coordinates: this.getCoordinates() },
                                                e,
                                            ),
                                            {
                                                minZoom: Math.max(
                                                    null !== (i = e.minZoom) && void 0 !== i
                                                        ? i
                                                        : this.minZoom,
                                                    this.minZoom,
                                                ),
                                                maxZoom: Math.min(
                                                    null !== (n = e.maxZoom) && void 0 !== n
                                                        ? n
                                                        : this.maxZoom,
                                                    this.maxZoom,
                                                ),
                                                fontSize:
                                                    null !== (o = e.fontSize) && void 0 !== o
                                                        ? o
                                                        : 18,
                                                anchor: e.anchor || yd,
                                                offset: e.offset || bd,
                                                zIndex:
                                                    null !== (r = e.zIndex) && void 0 !== r
                                                        ? r
                                                        : this.zIndex + 1e-5,
                                            },
                                        ),
                                    )));
                        }
                        setCoordinates(e) {
                            var t;
                            this.setPosition((0, L.yq)(e)),
                                null === (t = this.label) || void 0 === t || t.setCoordinates(e);
                        }
                        getCoordinates() {
                            return (0, L.PA)(this.getPosition());
                        }
                        show() {
                            var e;
                            'hidden' === this.status &&
                                (null === (e = this.label) || void 0 === e || e.show(),
                                this.normalStateData &&
                                    (this.modules.tileManager.addObject(
                                        this.normalStateData.tileObject,
                                    ),
                                    (this.mapState.needRerender = !0),
                                    this.interactive && this.modules.identifier.resetCache()),
                                (this.status = 'normal'));
                        }
                        hide() {
                            var e, t, i;
                            if ('destroyed' === this.status || 'hidden' === this.status) return;
                            null === (e = this.label) || void 0 === e || e.hide();
                            const n =
                                'normal' === this.status
                                    ? null === (t = this.normalStateData) || void 0 === t
                                        ? void 0
                                        : t.tileObject
                                    : null === (i = this.hoverStateData) || void 0 === i
                                    ? void 0
                                    : i.tileObject;
                            n &&
                                (this.modules.tileManager.removeObject(n),
                                (this.mapState.needRerender = !0),
                                this.interactive && this.modules.identifier.resetCache()),
                                (this.status = 'hidden');
                        }
                        setPosition(e) {
                            (this.position = e),
                                this.tileObjects.length &&
                                    (this.tileObjects.forEach((t) => {
                                        t.setTileCoords((0, G.IR)(e));
                                    }),
                                    'hidden' !== this.status &&
                                        ((this.mapState.needRerender = !0),
                                        this.interactive && this.modules.identifier.resetCache()));
                        }
                        getPosition() {
                            return this.position;
                        }
                        isInteractive() {
                            return this.interactive;
                        }
                        contains(e) {
                            if (!this.normalStateData) return !1;
                            const { hoverStateData: t, normalStateData: i } = this,
                                n = void 0 !== t ? t.size : i.size,
                                o = void 0 !== t ? t.anchor : i.anchor,
                                r = this.modules.camera.project(this.position),
                                s = r[0] - n[0] * o[0],
                                a = r[0] + n[0] * (1 - o[0]),
                                l = r[1] - n[1] * o[1],
                                c = r[1] + n[1] * (1 - o[1]);
                            return e[0] > s && e[0] < a && e[1] > l && e[1] < c;
                        }
                        switchToHoveredStyle() {
                            if (
                                'normal' === this.status &&
                                this.hoverStateData &&
                                this.normalStateData
                            ) {
                                const { tileManager: e } = this.modules;
                                e.removeObject(this.normalStateData.tileObject),
                                    e.addObject(this.hoverStateData.tileObject),
                                    (this.status = 'hover'),
                                    (this.mapState.needRerender = !0);
                            }
                        }
                        switchToNormalStyle() {
                            if (
                                'hover' === this.status &&
                                this.normalStateData &&
                                this.hoverStateData
                            ) {
                                const { tileManager: e } = this.modules;
                                e.removeObject(this.hoverStateData.tileObject),
                                    e.addObject(this.normalStateData.tileObject),
                                    (this.status = 'normal'),
                                    (this.mapState.needRerender = !0);
                            }
                        }
                        getMarkerStateData(e, { icon: t, anchor: i, size: n }) {
                            const { zIndex: o, interactive: r, position: s } = this,
                                {
                                    collector: a,
                                    renderer: l,
                                    dynamicStyle: c,
                                    styleManager: d,
                                    defaultSource: h,
                                } = this.modules,
                                u = (0, V.FJ)({
                                    id: r ? (0, O.Ru)(0, 0) : NaN,
                                    dpi: 96 * window.devicePixelRatio,
                                }),
                                m = (0, G.IR)(s),
                                f = (0, W.qw)({
                                    type: 'point',
                                    id: `dynamic-marker-${this.uniqId}`,
                                    minzoom: this.minZoom,
                                    maxzoom: this.maxZoom,
                                    style: {
                                        iconImage: t,
                                        iconAnchor: i,
                                        iconRotation: this.rotation,
                                    },
                                });
                            if (!f)
                                throw new Error(
                                    `Marker with icon ${t} was created with null style layer`,
                                );
                            c.addLayer(f, o),
                                c.appendRasterSet(
                                    e,
                                    (0, oo.PR)(t, f.style.iconAnchor[0], f.style.iconAnchor[1]),
                                );
                            const p = (0, $.Yi)(
                                this.mapState.styleState,
                                P.i4,
                                P.nF.tileProps,
                                u,
                                P.wz,
                            );
                            (0, H.XI)({
                                collector: a,
                                generator: pd.p,
                                args: [
                                    c.getStyle(),
                                    f,
                                    p,
                                    P.nF,
                                    m,
                                    h.getId(),
                                    [[0], [0]],
                                    (0, Nc.o1)(window.devicePixelRatio),
                                ],
                            });
                            const { identifyIds: _, labels: v } = a.getAccumulatedData();
                            if (!v.length)
                                throw new Error(
                                    `Marker with icon ${t} was created with empty labels`,
                                );
                            const g = [{ metatileHash: -1, labels: v, styleId: c.getStyle().id }],
                                y = (0, fd.v)(
                                    g,
                                    Ta.AL.DynamicObject,
                                    d,
                                    this.mapState.styleState,
                                    this.mapState.styleZoom,
                                );
                            if (1 !== y.length)
                                throw new Error(`Marker with icon ${t} has empty unpacked labels`);
                            const b = y[0];
                            (0, io.vg)(a, b, [0, 0, 0], 0, e.rasters[0], window.devicePixelRatio);
                            const { data: w } = a.getAccumulatedData();
                            a.reset();
                            return {
                                styleLayer: f,
                                tileObject: new C.W('dynamicObject', w, l, m, this),
                                identifyIds: _,
                                icon: t,
                                anchor: [e.rasters[0].anchorX, e.rasters[0].anchorY],
                                size: n || [
                                    e.rasters[0].w / window.devicePixelRatio,
                                    e.rasters[0].h / window.devicePixelRatio,
                                ],
                            };
                        }
                        setIconInternal(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                return this.modules.imageCache
                                    .getRasterSet(e.icon, void 0, e.size, e.anchor)
                                    .then((t) => {
                                        if ('destroyed' === this.status || !t) return;
                                        const i = this.normalStateData,
                                            n = this.getMarkerStateData(t, e);
                                        'normal' === this.status &&
                                            (i &&
                                                this.modules.tileManager.removeObject(i.tileObject),
                                            this.modules.tileManager.addObject(n.tileObject),
                                            (this.mapState.needRerender = !0),
                                            this.interactive &&
                                                this.modules.identifier.resetCache()),
                                            i &&
                                                ((0, fe.VJ)(this.tileObjects, i.tileObject),
                                                (0, fe.VJ)(this.identifyIds, i.identifyIds),
                                                i.tileObject.clean(this.mapState)),
                                            this.tileObjects.push(n.tileObject),
                                            this.interactive &&
                                                this.identifyIds.push(n.identifyIds),
                                            (this.normalStateData = n);
                                    });
                            });
                        }
                        setHoverIconInternal(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                return this.modules.imageCache
                                    .getRasterSet(e.icon, void 0, e.size, e.anchor)
                                    .then((t) => {
                                        if ('destroyed' === this.status || !t) return;
                                        const i = this.hoverStateData,
                                            n = this.getMarkerStateData(t, e);
                                        'hover' === this.status &&
                                            (i &&
                                                this.modules.tileManager.removeObject(i.tileObject),
                                            this.modules.tileManager.addObject(n.tileObject),
                                            (this.mapState.needRerender = !0),
                                            this.interactive &&
                                                this.modules.identifier.resetCache()),
                                            i &&
                                                ((0, fe.VJ)(this.tileObjects, i.tileObject),
                                                (0, fe.VJ)(this.identifyIds, i.identifyIds),
                                                i.tileObject.clean(this.mapState)),
                                            this.tileObjects.push(n.tileObject),
                                            this.interactive &&
                                                this.identifyIds.push(n.identifyIds),
                                            (this.hoverStateData = n);
                                    });
                            });
                        }
                    }
                    var xd = i(5600),
                        Sd = i(2702);
                    const Id = (0, xd.D)({
                        symbol: 'polygon',
                        sinks: {
                            fill: {
                                stride: 8,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.localID = new Uint32Array(t, 4));
                                },
                                packObjectAttributes: (e, t, i, n) => (0, Sd.v$)([e, t], i, n),
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    tileData: e.slice(2),
                                }),
                            },
                        },
                        generate(e, t, i, n, o) {
                            const r = o[0],
                                s = o[1],
                                a = e.idIndexer.getIndex({
                                    id: n.tileAttrs[n.tileProps.id],
                                    styleId: t,
                                    layer: i,
                                    sublayer: n.tileAttrs[n.tileProps.db_sublayer],
                                }),
                                l = e.getBucket(
                                    i.type,
                                    'fill',
                                    Kc.a.sinks.fill.packObjectAttributes(
                                        t,
                                        i.innerId,
                                        NaN,
                                        i.dataKeys,
                                        n,
                                    ),
                                    Kc.a.sinks.fill.binder,
                                );
                            let c = l.elements.offset;
                            !(function (e, t, i, n, o, r, s, a) {
                                const l = e.buffer,
                                    c = e.offset;
                                (l[c] = t + i),
                                    (l[c + 1] = t + n),
                                    (l[c + 2] = t + o),
                                    (l[c + 3] = t + r),
                                    (l[c + 4] = t + s),
                                    (l[c + 5] = t + a),
                                    (e.offset = c + 6);
                            })(l.indices, c, 0, 1, 2, 2, 1, 3),
                                Md(l, c++, r[0], s[0], a),
                                Md(l, c++, r[1], s[1], a),
                                Md(l, c++, r[2], s[2], a),
                                Md(l, c++, r[3], s[3], a),
                                (l.elements.offset = c);
                        },
                    });
                    function Md(e, t, i, n, o) {
                        const r = 4 * t;
                        (e.views.position[r] = rt.jO + i), (e.views.position[r + 1] = rt.jO + n);
                        const s = 2 * t;
                        e.views.localID[s] = o;
                    }
                    class Td extends A {
                        constructor(e, t) {
                            super(e);
                            const {
                                dynamicStyle: i,
                                collector: n,
                                renderer: o,
                                tileManager: r,
                                identifier: s,
                                layers: a,
                            } = this.modules;
                            (this.options = t), (this.points = []);
                            const l = (0, W.qw)({
                                type: 'polygon',
                                id: `dynamic-polygon-${this.uniqId}`,
                                minzoom: this.options.minZoom,
                                maxzoom: this.options.maxZoom,
                                style: { color: this.options.color || '#0085a0' },
                            });
                            if (!l) return;
                            i.addLayer(l, this.options.zIndex), (this.layerId = l.innerId);
                            const c = (0, V.FJ)({
                                id: this.options.interactive ? [0, this.uniqId] : NaN,
                            });
                            this.points = (function (e, t, i) {
                                const n = t / 2,
                                    o = i / 2,
                                    r = e[0],
                                    s = e[1],
                                    a = e[2];
                                return [
                                    [r - n, s - o, a],
                                    [r + n, s - o, a],
                                    [r - n, s + o, a],
                                    [r + n, s + o, a],
                                ];
                            })(
                                (0, L.yq)(this.options.center),
                                (0, L.a4)(this.options.center, this.options.width),
                                (0, L.a4)(this.options.center, this.options.height),
                            );
                            const d = ee.Ue();
                            for (let e = 0; e < this.points.length; e++) ee.aM(d, this.points[e]);
                            const h = (0, G.x7)(d),
                                u = (0, G.Bs)(h),
                                m = [[], []],
                                f = D.Ue();
                            for (let e = 0; e < this.points.length; e++)
                                (0, G.a2)(f, this.points[e], u), (m[0][e] = f[0]), (m[1][e] = f[1]);
                            const p = (0, $.Yi)(this.mapState.styleState, P.i4, P.Dz, c, P.wz);
                            (0, H.XI)({
                                collector: n,
                                generator: Id.generate,
                                args: [i.getStyle().id, l, p, m],
                            });
                            const _ = n.getAccumulatedData(),
                                v = new C.W('dynamicObject', _.data, o, h);
                            r.addObject(v),
                                this.tileObjects.push(v),
                                this.options.interactive && this.identifyIds.push(_.identifyIds),
                                a.addLayer(this),
                                n.reset(),
                                (this.mapState.needRerender = !0),
                                this.options.interactive && s.resetCache();
                        }
                        destroy() {
                            void 0 !== this.layerId &&
                                this.modules.dynamicStyle.removeLayer(this.layerId),
                                this.options.interactive &&
                                    this.modules &&
                                    this.modules.identifier.resetCache(),
                                super.destroy();
                        }
                    }
                    class Pd extends A {
                        constructor(e, t) {
                            super(e);
                            const { dynamicStyle: i } = this.modules;
                            (this.options = Object.assign(Object.assign({}, t), {
                                image: { url: t.image.url },
                            })),
                                (this.points = []),
                                (this.styleLayer = (0, W.qw)({
                                    type: 'raster',
                                    id: `dynamic-raster-${this.uniqId}`,
                                    minzoom: this.options.minZoom,
                                    maxzoom: this.options.maxZoom,
                                    style: { opacity: this.options.opacity },
                                })),
                                this.styleLayer &&
                                    (i.addLayer(this.styleLayer, this.options.zIndex),
                                    (this.layerId = this.styleLayer.innerId),
                                    this.modules.imageManager
                                        .loadTexture(this.options.image.url, {
                                            skipAtlasSizeChecking: !0,
                                        })
                                        .then((e) => {
                                            (this.textureIndex = e), this.generate();
                                        }));
                        }
                        destroy() {
                            void 0 !== this.layerId &&
                                this.modules.dynamicStyle.removeLayer(this.layerId),
                                super.destroy();
                        }
                        updateImage(e) {
                            const { url: t, bounds: i } = e;
                            if (!t && !i) return Promise.resolve();
                            t && (this.options.image.url = t), i && (this.options.bounds = i);
                            return (
                                t
                                    ? this.modules.imageManager.loadTexture(t, {
                                          skipAtlasSizeChecking: !0,
                                      })
                                    : Promise.resolve(this.textureIndex)
                            ).then((e) => {
                                (this.textureIndex = e), this.clean(), this.generate();
                            });
                        }
                        generate() {
                            if (!this.styleLayer || void 0 === this.textureIndex) return;
                            const {
                                collector: e,
                                dynamicStyle: t,
                                tileManager: i,
                                layers: n,
                                renderer: o,
                            } = this.modules;
                            this.points = (function (e) {
                                const { min: t, max: i } = ee.X3(e);
                                return [t, [i[0], t[1]], [t[0], i[1]], i];
                            })(this.options.bounds);
                            const r = ee.Ue();
                            for (let e = 0; e < this.points.length; e++) ee.aM(r, this.points[e]);
                            const s = (0, G.x7)(r),
                                a = (0, G.Bs)(s),
                                l = [[], []],
                                c = D.Ue();
                            for (let e = 0; e < this.points.length; e++)
                                (0, G.a2)(c, this.points[e], a), (l[0][e] = c[0]), (l[1][e] = c[1]);
                            (0, H.XI)({
                                collector: e,
                                generator: Dt.h.generate,
                                args: [l, t.getStyle().id, this.styleLayer, this.textureIndex],
                            });
                            const d = e.getAccumulatedData(),
                                h = new C.W('dynamicObject', d.data, o, s);
                            i.addObject(h),
                                this.tileObjects.push(h),
                                n.addLayer(this),
                                e.reset(),
                                (this.mapState.needRerender = !0);
                        }
                        clean() {
                            const e = this.tileObjects[0];
                            e &&
                                (e.clean(this.mapState),
                                this.modules.tileManager.removeObject(e),
                                this.modules.layers.removeLayer(this),
                                (this.tileObjects = []));
                        }
                    }
                    class Ld {
                        constructor(e, t, i) {
                            (this.id = e),
                                (this.modules = t),
                                (this.options = i),
                                (this.type = 'raster'),
                                (this.textureIndices = {}),
                                (this.tileLoader = new Ci.U('arrayBuffer')),
                                (this.attributes = {}),
                                (this.tiles = new Map()),
                                (this.sourceAttrs = i.attributes || {}),
                                (this.url = (e) => {
                                    const [t, i, n] = (0, G._W)(e);
                                    return this.options.url(t, i, n);
                                });
                        }
                        deleteTextures() {
                            for (const e in this.textureIndices)
                                this.modules.imageManager.deleteTexture(this.textureIndices[e]);
                            this.textureIndices = {};
                        }
                        abortTileFetch(e) {
                            this.tileLoader.abortRequest((0, G.gx)(e));
                        }
                        deleteTile(e) {
                            const t = (0, G.gx)(e);
                            this.tiles.delete(t);
                        }
                        fetchTile(e) {
                            const t = (0, G.gx)(e),
                                i = this.url(e);
                            return this.tileLoader
                                .fetch(e, () => i)
                                .then((e) => {
                                    e.rejected || this.tiles.set(t, e.data);
                                    return [{ regionId: 0, metatileHash: -1 }];
                                });
                        }
                        generateTile(e, t) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                const i = [],
                                    n = [],
                                    o = this.modules.styleManager.getStyle(e.handyStyleId),
                                    r = (0, G.gx)(t),
                                    s = this.tiles.get(r);
                                if (!s || !o)
                                    return Promise.resolve({ results: i, transferable: n });
                                const a = yield this.modules.imageManager.addTexture(s, {
                                    imagePadding: 0,
                                });
                                if (void 0 === a)
                                    return Promise.resolve({ results: i, transferable: n });
                                this.textureIndices[r] = a;
                                const l = [[], []],
                                    c = D.Ue(),
                                    d = (function (e, t) {
                                        const i = e[0],
                                            n = e[1],
                                            o = e[2];
                                        return [
                                            [i, n, o],
                                            [i + t, n, o],
                                            [i, n + t, o],
                                            [i + t, n + t, o],
                                        ];
                                    })((0, G.Oy)(t), (0, G.aq)(t[2])),
                                    h = (0, G.Bs)(t);
                                for (let e = 0; e < d.length; e++)
                                    (0, G.a2)(c, d[e], h), (l[0][e] = c[0]), (l[1][e] = c[1]);
                                const u = (0, $.Yi)(e.styleState, this.sourceAttrs, P.Dz, [], P.wz);
                                o.layers
                                    .filter((e) => 'raster' === e.type && (0, $.FR)(e.filter, u))
                                    .forEach((e) => {
                                        'raster' === e.type &&
                                            (0, H.XI)({
                                                collector: this.modules.collector,
                                                generator: Dt.h.generate,
                                                args: [l, o.id, e, a],
                                            });
                                    });
                                const m = this.modules.collector.getAccumulatedData();
                                return (
                                    i.push({
                                        regionId: 0,
                                        metatileHash: 0,
                                        styleId: o.id,
                                        collectorOutput: m,
                                    }),
                                    n.push(...m.transferable),
                                    Promise.resolve({ results: i, transferable: n })
                                );
                            });
                        }
                        getAttributes() {
                            return this.attributes;
                        }
                        setAttributes(e) {
                            this.attributes = e;
                        }
                        destroy() {
                            this.tileLoader.destroy();
                        }
                    }
                    class kd {
                        constructor(e, t) {
                            var i, n;
                            (this.type = 'raster'),
                                (this.id = (0, In.Q)()),
                                (this.modules = e.modules),
                                (this.source = new Ld(this.id, this.modules, t));
                            const o =
                                    null !== (i = t.minZoom) && void 0 !== i
                                        ? i
                                        : I.MAP_DEFAULTS.minZoom,
                                r =
                                    null !== (n = t.maxZoom) && void 0 !== n
                                        ? n
                                        : I.MAP_DEFAULTS.maxZoom;
                            (this.layer = new Ct.I(o, r, o, r, this.modules, e.state, this.source)),
                                this.modules.tileManager.addTileLayer(this.layer);
                        }
                        destroy() {
                            this.source.deleteTextures(),
                                this.modules.tileManager.removeTileLayer(this.layer),
                                this.layer.destroy();
                        }
                        getAttributes() {
                            return this.source.getAttributes();
                        }
                        getId() {
                            return this.source.id;
                        }
                        setAttributes(e) {
                            this.source.setAttributes(e), this.layer.redraw();
                        }
                        isIdentifiedAsDefault() {
                            return !1;
                        }
                    }
                    class Ed extends A {
                        constructor(e, t) {
                            var i;
                            super(e),
                                (this.position = (0, L.yq)(t.coordinates)),
                                (this.zIndex = null !== (i = t.zIndex) && void 0 !== i ? i : 0),
                                (this.isDestroyed = !1),
                                (this.labelKey = `onlineMarker-${this.uniqId}`),
                                this.setIcon(t.icon);
                        }
                        destroy() {
                            (this.isDestroyed = !0),
                                this.modules.identifier.resetCache(),
                                this.modules.labeler.removeLabels(this.labelKey),
                                super.destroy();
                        }
                        setIcon({ url: e, transformer: t, size: i, anchor: n }) {
                            this.modules.imageCache.getRasterSet(e, t, i, n).then((t) => {
                                if (this.isDestroyed || !t) return;
                                this.removeIcon();
                                const o = (0, W.qw)({
                                        type: 'point',
                                        id: `dynamic-onlineMarker-${this.uniqId}`,
                                        minzoom: -1 / 0,
                                        maxzoom: 1 / 0,
                                        style: { iconImage: e, iconAnchor: n },
                                    }),
                                    r = (0, V.FJ)({ id: (0, O.Ru)(0, 0) }),
                                    {
                                        collector: s,
                                        dynamicStyle: a,
                                        styleManager: l,
                                        defaultSource: c,
                                    } = this.modules,
                                    d = this.zIndex;
                                if (!o) return;
                                a.addLayer(o, d),
                                    a.appendRasterSet(
                                        t,
                                        (0, oo.PR)(e, o.style.iconAnchor[0], o.style.iconAnchor[1]),
                                    );
                                const h = (0, G.IR)(this.position),
                                    u = (0, $.Yi)(
                                        this.mapState.styleState,
                                        P.i4,
                                        P.nF.tileProps,
                                        r,
                                        P.wz,
                                    );
                                (0, H.XI)({
                                    collector: s,
                                    generator: pd.p,
                                    args: [
                                        a.getStyle(),
                                        o,
                                        u,
                                        P.nF,
                                        h,
                                        c.getId(),
                                        [[0], [0]],
                                        (0, Nc.o1)(window.devicePixelRatio),
                                    ],
                                });
                                const m = s.getAccumulatedData(),
                                    { identifyIds: f, labels: p } = m;
                                if (!p.length) return;
                                const _ = [
                                        { metatileHash: -1, labels: p, styleId: a.getStyle().id },
                                    ],
                                    v = (0, fd.v)(
                                        _,
                                        Ta.AL.DynamicObject,
                                        l,
                                        this.mapState.styleState,
                                        this.mapState.styleZoom,
                                    );
                                if (1 !== v.length) return;
                                const g = v[0];
                                (0, io.vg)(
                                    s,
                                    g,
                                    [0, 0, 0],
                                    0,
                                    t.rasters[0],
                                    window.devicePixelRatio,
                                );
                                const y = s.getAccumulatedData();
                                s.reset();
                                const b = new C.W(
                                    'dynamicObject',
                                    y.data,
                                    this.modules.renderer,
                                    (0, G.IR)(this.position),
                                    this,
                                );
                                this.tileObjects.push(b),
                                    (this.identifyIds = [f]),
                                    this.modules.tileManager.addObject(b),
                                    this.modules.layers.addLayer(this),
                                    this.modules.identifier.debouncedFillCache(),
                                    this.modules.labeler.removeLabels(this.labelKey),
                                    this.modules.labeler.addLabelBox(this.labelKey, {
                                        id: this.uniqId,
                                        width: i[0],
                                        height: i[1],
                                        position: this.position,
                                        offset: [-n[0], -n[1]],
                                        labelingGroup: 'marker',
                                    }),
                                    (this.mapState.needRerender = !0);
                            });
                        }
                        removeIcon() {
                            const e = this.tileObjects[0];
                            e &&
                                (e.clean(this.mapState),
                                this.modules.tileManager.removeObject(e),
                                (this.tileObjects = []));
                        }
                    }
                    function Ad(e) {
                        return {
                            type: 'data',
                            key: (0, G.gx)(e),
                            coords: e,
                            zoomLevel: e[2],
                            detailLevel: e[3],
                            needFetch: !1,
                            needAbortFetch: !1,
                            status: ec.z3.Initial,
                        };
                    }
                    function zd(e, t, i, n, o) {
                        return (function (e, t, i, n, o, r) {
                            return {
                                type: e,
                                maxDetailLevel: r,
                                minDetailLevel: o,
                                maxZoomLevel: n,
                                minZoomLevel: i,
                                zoomLevel: Math.floor(t),
                                tiles: {},
                                viewportTiles: [],
                            };
                        })('data', e, t, i, n, o);
                    }
                    class Cd extends k.c {
                        constructor(e, t, i) {
                            super(),
                                (this.prevZoomLevel = 0),
                                (this.mapState = e),
                                (this.modules = t),
                                (this.config = i),
                                (this.gridState = zd(
                                    e.styleZoom,
                                    i.minZoom,
                                    i.maxZoom,
                                    i.minZoom,
                                    i.maxZoom,
                                )),
                                (this.viewportDiffer = new De([
                                    { path: 'center', type: 'vec2' },
                                    { path: 'zoom', type: 'number' },
                                    { path: 'size', type: 'vec2' },
                                    { path: 'rotation', type: 'number' },
                                    { path: 'pitch', type: 'number' },
                                    { path: 'demMode', type: 'boolean' },
                                ])),
                                (this.dataTileLoader = new Ci.U('json')),
                                this.modules.layers.addLayer(this);
                        }
                        destroy() {
                            var e;
                            ((e = this.gridState).tiles = {}),
                                (e.viewportTiles = []),
                                this.modules.layers.removeLayer(this);
                        }
                        update() {
                            let e = !0;
                            if (this.viewportDiffer.check(this.mapState)) {
                                const t = Math.floor(this.mapState.styleZoom);
                                t !== this.prevZoomLevel && (e = !1),
                                    (this.prevZoomLevel = t),
                                    (this.gridState.zoomLevel = t),
                                    (function (e, t, i) {
                                        if (e.zoomLevel < e.minZoomLevel)
                                            return void (e.viewportTiles = []);
                                        const n = (0, fe.uZ)(
                                                e.zoomLevel,
                                                e.minZoomLevel,
                                                e.maxZoomLevel,
                                            ),
                                            o = (0, fe.uZ)(
                                                e.zoomLevel,
                                                e.minDetailLevel,
                                                e.maxDetailLevel,
                                            );
                                        e.viewportTiles = (0, G.b5)(t, n, e.minZoomLevel, o).map(
                                            G.gx,
                                        );
                                        for (let t = 0; t < e.viewportTiles.length; t++) {
                                            const n = e.viewportTiles[t];
                                            let o = e.tiles[n];
                                            o || (o = e.tiles[n] = i((0, G.cL)(n)));
                                        }
                                    })(this.gridState, this.mapState, Ad),
                                    this.emit('tilesSetChanged', {
                                        tileIds: this.gridState.viewportTiles,
                                    });
                            }
                            for (const e in this.gridState.tiles)
                                this.gridState.viewportTiles.includes(e)
                                    ? this.gridState.tiles[e].status === ec.z3.Initial &&
                                      ((this.gridState.tiles[e].needFetch = !0),
                                      (this.gridState.tiles[e].status = ec.z3.Loading))
                                    : this.gridState.tiles[e].status === ec.z3.Loading &&
                                      (this.gridState.tiles[e].needAbortFetch = !0);
                            e &&
                                (this.fetch(
                                    (function (e) {
                                        const t = [];
                                        for (const i in e.tiles) {
                                            const n = e.tiles[i];
                                            n.needFetch && ((n.needFetch = !1), t.push(n));
                                        }
                                        return t;
                                    })(this.gridState),
                                ),
                                this.abortFetch(
                                    (function (e) {
                                        const t = [];
                                        for (const i in e.tiles) {
                                            const n = e.tiles[i];
                                            n.needAbortFetch &&
                                                ((n.needAbortFetch = !1), t.push(n));
                                        }
                                        return t;
                                    })(this.gridState),
                                ),
                                this.clearTiles(
                                    (function (e, t) {
                                        const i = new Set(e.viewportTiles),
                                            n = [];
                                        for (const o in e.tiles) {
                                            const r = e.tiles[o],
                                                s = !t || t(r);
                                            !i.has(o) && s && n.push(r);
                                        }
                                        return n;
                                    })(this.gridState),
                                ));
                        }
                        fetch(e) {
                            e.sort((e, t) => (0, G.qu)(this.mapState.center, e, t)).forEach((e) =>
                                this.fetchTile(e),
                            );
                        }
                        abortFetch(e) {
                            e.forEach((e) => {
                                this.dataTileLoader.abortRequest(e.key);
                            });
                        }
                        clearTiles(e) {
                            for (const t of e)
                                delete this.gridState.tiles[t.key],
                                    this.emit('dataTileCleared', { tileId: t.key });
                        }
                        fetchTile(e) {
                            const { tsURLTemplate: t } = this.config;
                            this.dataTileLoader.fetch(e.coords, t).then((t) => {
                                t.rejected ||
                                    this.emit('dataTileLoaded', { tileId: e.key, data: t.data });
                            });
                        }
                    }
                    class Fd {
                        constructor() {
                            this.events = {};
                        }
                        on(e, t) {
                            let i = this.events[e];
                            return i || (i = this.events[e] = []), i.push(t), this;
                        }
                        once(e, t) {
                            const i = (n) => {
                                this.off(e, i), t.call(this, n);
                            };
                            return this.on(e, i), this;
                        }
                        off(e, t) {
                            const i = this.events[e];
                            if (!i) return this;
                            const n = i.indexOf(t);
                            return -1 !== n && i.splice(n, 1), this;
                        }
                        emit(e, t) {
                            const i = this.events[e];
                            if (!i) return this;
                            const n = i.slice();
                            for (let e = 0; e < n.length; e++) n[e].call(this, t);
                            return this;
                        }
                    }
                    class Od {
                        constructor(e, t, i) {
                            var n;
                            const { position: o } = i;
                            (this._wrap = document.createElement('div')),
                                (this._wrap.style.userSelect = 'none'),
                                (this._wrap.innerHTML = t),
                                (this._position = o),
                                (this._controlPane = e._controlPane),
                                (this._container = this._controlPane.getContainerByPosition(o)),
                                null === (n = this._container) ||
                                    void 0 === n ||
                                    n.append(this._wrap);
                        }
                        destroy() {
                            this._wrap.remove();
                        }
                        getPosition() {
                            return this._position;
                        }
                        setPosition(e) {
                            this._container.removeChild(this._wrap),
                                (this._container = this._controlPane.getContainerByPosition(e)),
                                this._container.append(this._wrap),
                                (this._position = e);
                        }
                        getContainer() {
                            return this._wrap;
                        }
                    }
                    var Dd = i(8585),
                        Rd = {};
                    (Rd.styleTagTransform = Dc()),
                        (Rd.setAttributes = zc()),
                        (Rd.insert = Ec().bind(null, 'head')),
                        (Rd.domAPI = Lc()),
                        (Rd.insertStyleElement = Fc());
                    Tc()(Dd.Z, Rd);
                    const jd = Dd.Z && Dd.Z.locals ? Dd.Z.locals : void 0,
                        Bd = `\n    <div class="${jd.root}">\n        <button class="${jd.button} ${jd.zoomIn}">\n            <svg\n                xmlns="http://www.w3.org/2000/svg"\n                viewBox="0 0 32 32"\n                width="32"\n                height="32"\n                fill="currentColor"\n            >\n                <path d="M24 15h-7V8h-2v7H8v2h7v7h2v-7h7v-2z"></path>\n            </svg>\n        </button>\n        <button class="${jd.button} ${jd.zoomOut}">\n            <svg\n                xmlns="http://www.w3.org/2000/svg"\n                viewBox="0 0 32 32"\n                fill="currentColor"\n                width="32"\n                height="32"\n            >\n                <path d="M8 15h16v2H8z"></path>\n            </svg>\n        </button>\n    </div>\n`;
                    class Nd extends Od {
                        constructor(e, t) {
                            super(e, Bd, t),
                                (this._zoomIn = () => {
                                    this._map.setZoom(this._map.getZoom() + 1, { duration: 400 });
                                }),
                                (this._zoomOut = () => {
                                    this._map.setZoom(this._map.getZoom() - 1, { duration: 400 });
                                }),
                                (this._checkZoom = () => {
                                    const e = this._map.getZoom();
                                    e <= this._map.getMinZoom()
                                        ? (this._zoomOutButton.disabled = !0)
                                        : (this._zoomOutButton.disabled = !1),
                                        e >= this._map.getMaxZoom()
                                            ? (this._zoomInButton.disabled = !0)
                                            : (this._zoomInButton.disabled = !1);
                                }),
                                (this._map = e),
                                (this._zoomInButton = this._wrap.querySelector(`.${jd.zoomIn}`)),
                                (this._zoomOutButton = this._wrap.querySelector(`.${jd.zoomOut}`)),
                                this._zoomInButton.addEventListener('click', this._zoomIn),
                                this._zoomOutButton.addEventListener('click', this._zoomOut),
                                this._map.on('zoom', this._checkZoom);
                        }
                        destroy() {
                            this._map.off('zoom', this._checkZoom),
                                this._zoomInButton.removeEventListener('click', this._zoomIn),
                                this._zoomOutButton.removeEventListener('click', this._zoomOut),
                                super.destroy();
                        }
                    }
                    var Ud = i(4928),
                        Zd = {};
                    (Zd.styleTagTransform = Dc()),
                        (Zd.setAttributes = zc()),
                        (Zd.insert = Ec().bind(null, 'head')),
                        (Zd.domAPI = Lc()),
                        (Zd.insertStyleElement = Fc());
                    Tc()(Ud.Z, Zd);
                    const Hd = Ud.Z && Ud.Z.locals ? Ud.Z.locals : void 0;
                    class Gd extends Od {
                        constructor(e, t) {
                            super(e, '', t),
                                (this._onClick = () => {
                                    this._trafficVisible
                                        ? (this._map.hideTraffic(),
                                          this._map.patchStyleState({ trafficOn: !1 }))
                                        : (this._map.showTraffic(),
                                          this._map.patchStyleState({ trafficOn: !0 }));
                                }),
                                (this._map = e),
                                (this._trafficVisible = !1),
                                this._render(),
                                e.on('trafficscore', ({ score: e }) => {
                                    (this._score = e), this._render();
                                }),
                                e.on('trafficshow', () => {
                                    (this._trafficVisible = !0), this._render();
                                }),
                                e.on('traffichide', () => {
                                    (this._trafficVisible = !1), this._render();
                                });
                        }
                        _render() {
                            const e = this._trafficVisible
                                    ? (function (e) {
                                          if (void 0 === e) return '';
                                          if (e > 6) return Hd.hard;
                                          if (e > 3) return Hd.medium;
                                          return Hd.easy;
                                      })(this._score)
                                    : Hd.none,
                                t = `\n            <div class="${
                                    Hd.root
                                }">\n                <button class="${
                                    Hd.button
                                } ${e}">\n                    ${
                                    this._trafficVisible && void 0 !== this._score
                                        ? this._score
                                        : '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="14" viewBox="0 0 20 14" style="margin-top: 4px">\n    <path d="M 18,5 C 18,4 17,1 15,1 H 12 10 C 8,1 7,4 7,5 H 5 v 2 h 1 v 4 c 0,0.6 0,1 1,1 v 2 h 2 v -2 h 7 v 2 h 2 v -2 c 1,0 1,-0.4 1,-1 V 7 h 1 V 5 H 18 z M 10,3 h 2 3 c 2,0 2,1 2,3 H 8 C 8,4 8,3 10,3 z M 9,10 H 8 C 7.4,10 7,9.6 7,9 7,8.4 7.4,8 8,8 h 1 c 0.6,0 1,0.4 1,1 0,0.6 -0.4,1 -1,1 z m 8,0 H 16 C 15.4,10 15,9.6 15,9 15,8.4 15.4,8 16,8 h 1 c 0.6,0 1,0.4 1,1 0,0.6 -0.4,1 -1,1 z M 4,4 H 6 V 3 H 4 C 1,3 1,6 1,7 H 0 v 1 h 1 v 4 H 3 V 11 H 5 V 7 H 2 C 2,6 2,4 4,4 z M 3,9 4,10 H 2 V 9 h 1 z" fill="#616161" fill-rule="evenodd"/>\n    <g fill="#fff">\n        <path d="m 16,8 h 1 c 0.4,0 0.7,0.2 0.8,0.5 C 17.9,8.4 18,8.2 18,8 18,7.4 17.6,7 17,7 h -1 c -0.6,0 -1,0.4 -1,1 0,0.2 0.1,0.4 0.2,0.5 C 15.3,8.2 15.6,8 16,8 z"/>\n        <path d="M 8,8 H 9 C 9.4,8 9.7,8.2 9.8,8.5 9.9,8.4 10,8.2 10,8 10,7.4 9.6,7 9,7 H 8 C 7.4,7 7,7.4 7,8 7,8.2 7.1,8.4 7.2,8.5 7.3,8.2 7.6,8 8,8 z"/>\n        <path d="M 6,3 H 4 C 4,3 4,3 4,3 2,3 2,5 2,6 H 2 C 2.1,5 2.5,4 4,4 H 5 6 V 3 z"/>\n        <path d="M0 7H1V8H0z"/>\n        <path d="M 15,2 H 12 10 C 8,2 8,3 8,5 H 8 C 8,3.7 8.3,3 10,3 h 2 3 c 1.7,0 1.9,0.7 2,2 h 0 C 17,3 17,2 15,2 z"/>\n        <path d="M3 9L4 9 3 8 2 8 2 9 2 9 2 9 3 9z"/>\n        <path d="M 7,11 C 6,11 6,10.6 6,10 v 1 c 0,0.6 0,1 1,1 v -1 z"/>\n        <path d="m 18,11 v 1 c 1,0 1,-0.4 1,-1 v -1 c 0,0.6 0,1 -1,1 z"/>\n        <path d="M19 6H20V7H19z"/>\n        <path d="M3 11L1 11 1 12 3 12 3 11 5 11 5 7 5 7 5 10 3 10z"/>\n        <path d="M16 13H18V14H16z"/>\n        <path d="M5 6H6V7H5z"/>\n        <path d="M9 13L7 13 7 14 9 14 9 12 16 12 16 11 9 11z"/>\n    </g>\n    <g fill="#444">\n        <path d="M 2,6 C 2,6.4 2,6.7 2,7 H 5 V 6 H 2 z"/>\n        <path d="M2 9L2 10 4 10 3 9z"/>\n        <path d="M 4,3 H 6 V 2 H 4 C 1,2 1,5 1,6 H 0 V 7 H 1 C 1,6 1,3 4,3 z"/>\n        <path d="M 18,4 C 18,3 17,0 15,0 H 12 10 C 8,0 7,3 7,4 H 6 5 V 5 H 7 C 7,4 8,1 10,1 h 2 3 c 2,0 3,3 3,4 h 2 V 4 h -2 z"/>\n        <path d="M 8,10 H 9 C 9.6,10 10,9.6 10,9 10,8.8 9.9,8.6 9.8,8.5 9.7,8.8 9.4,9 9,9 H 8 C 7.6,9 7.3,8.8 7.2,8.5 7.1,8.6 7,8.8 7,9 c 0,0.6 0.4,1 1,1 z"/>\n        <path d="M 17,6 C 17,5.6 17,5.3 17,5 H 8 c 0,0.3 0,0.6 0,1 h 9 z"/>\n        <path d="M 17.8,8.5 C 17.7,8.8 17.4,9 17,9 H 16 C 15.6,9 15.3,8.8 15.2,8.5 15.1,8.6 15,8.8 15,9 c 0,0.6 0.4,1 1,1 h 1 c 0.6,0 1,-0.4 1,-1 0,-0.2 -0.1,-0.4 -0.2,-0.5 z"/>\n    </g>\n</svg>\n'
                                }\n                </button>\n            </div>\n        `;
                            this._wrap.innerHTML = t;
                            this._wrap
                                .querySelector(`.${Hd.button}`)
                                .addEventListener('click', this._onClick);
                        }
                    }
                    var Vd = i(4306),
                        Wd = {};
                    (Wd.styleTagTransform = Dc()),
                        (Wd.setAttributes = zc()),
                        (Wd.insert = Ec().bind(null, 'head')),
                        (Wd.domAPI = Lc()),
                        (Wd.insertStyleElement = Fc());
                    Tc()(Vd.Z, Wd);
                    const qd = Vd.Z && Vd.Z.locals ? Vd.Z.locals : void 0;
                    var $d;
                    !(function (e) {
                        (e.osm = 'osm'), (e.api = 'api'), (e.license = 'license');
                    })($d || ($d = {}));
                    class Xd extends Od {
                        constructor(e, t) {
                            var i;
                            super(
                                e,
                                ((i = t.copyrightType),
                                `\n    <div class=${qd.container}>\n        <div class=${
                                    qd.logos
                                }>\n            ${
                                    '2gis' === i
                                        ? '<a href="https://dev.2gis.ru" target="_blank" style="height: 20px;">\n    <svg width="40" height="20" viewBox="0 0 40 20" fill="none" xmlns="http://www.w3.org/2000/svg">\n        <path d="M2.00011 8.72731C1.98229 5.72738 4.05025 4 6.80779 4C9.47674 4 11.2797 5.58179 11.2797 8.05437C11.2797 10.1091 10.0602 11.2546 7.99196 12.2727C7.21431 12.6547 6.34807 13.1818 5.46454 13.4544H11.3681V16H2.00011V12.66C3.85604 12.0235 4.88111 11.3271 6.59576 10.4728C7.90363 9.81815 8.71666 9.23633 8.71666 8.1819C8.71666 7.16358 7.97439 6.36366 6.80779 6.36366C5.27006 6.36366 4.52753 7.52729 4.56292 8.72731H2.00011Z" fill="#6E7173"/>\n        <path d="M23.6348 9.63643V10.5453C23.6348 13.5455 21.6552 16 18.067 16C14.6202 16 12.2518 13.4727 12.2518 9.99986C12.2518 6.52731 14.5497 4 18.1554 4C21.2487 4 23.1751 5.8363 23.6348 7.99991H21.0717C20.6301 6.96353 19.534 6.36366 18.2261 6.36366C15.9813 6.36366 14.7263 8.14523 14.7263 9.99986C14.7263 11.8545 15.9991 13.6363 18.2086 13.6363C19.5872 13.6363 20.736 12.9456 21.0896 11.8181H17.7313V9.63643H23.6348Z" fill="#6E7173"/>\n        <path d="M27.4528 16H24.9783V4H27.4528V16Z" fill="#6E7173"/>\n        <path d="M38.4292 7.63648H35.8662C35.6185 6.85461 34.947 6.18167 33.4446 6.18167C32.1543 6.18167 31.5004 6.69096 31.5004 7.41809C31.5004 8.30915 32.7375 8.56366 34.293 8.83623L34.361 8.84818C36.4076 9.20779 38.5 9.57545 38.5 12.2727C38.5 14.8 36.4672 16 33.7274 16C31.1998 16 28.9373 14.4727 28.6899 12.1818H31.2527C31.5712 13.1273 32.5079 13.8181 33.8512 13.8181C35.1415 13.8181 35.8662 13.3818 35.8662 12.5455C35.8662 11.514 34.3606 11.2653 32.8555 11.0167C32.8221 11.0112 32.7887 11.0056 32.7553 11.0001C31.1468 10.7273 28.8844 9.9818 28.8844 7.54535C28.8844 5.34534 30.7581 4 33.5332 4C36.2727 4 38.164 5.41814 38.4292 7.63648Z" fill="#6E7173"/>\n    </svg>\n</a>'
                                        : '<a href="https://dev.urbi.ae" target="_blank" style="height: 20px; line-height: 20px;">\n    <svg style="width: auto; height: 16px;" width="29" height="12" viewBox="0 0 29 12" fill="none" xmlns="http://www.w3.org/2000/svg">\n        <path fill-rule="evenodd" clip-rule="evenodd" d="M5 4V8.0625C5 9.13823 4.64701 9.5 3.75 9.5C3.00479 9.5 2.5 9.15185 2.5 8.0625V4H0V8.5C0 10.6515 1.45917 12 3.75 12C6.19263 12 7.5 10.6515 7.5 8.5V4H5ZM18.5 9.5V2H16V11.9993L20.5 12C23.013 12.0276 24.5 10.4576 24.5 8C24.5 5.4872 23.2711 4 20.5 4H19.5V6.5H20.5C21.6954 6.5 22 6.9645 22 8C22 9.06311 21.3422 9.51381 20.5 9.5H18.5ZM13 4C12.1529 4 11.7541 4.19542 11.5 5L11 4H9.01412V12H11.5V7.75C11.5 6.87606 12.1106 6.5 13 6.5H15V4H13ZM28.25 12V4H25.75V12H28.25ZM27 3C27.9508 3 28.75 2.32569 28.75 1.5C28.75 0.674312 27.9508 0 27 0C26.0492 0 25.25 0.674312 25.25 1.5C25.25 2.32569 26.0492 3 27 3Z" fill="#6E7173"/>\n    </svg>\n</a>'
                                }\n        </div>\n    </div>\n`),
                                t,
                            ),
                                (this._onClick = (e) => {
                                    if (
                                        e.target &&
                                        (t = e.target) &&
                                        'href' in t &&
                                        'dataset' in t
                                    ) {
                                        const t = e.target.dataset.type;
                                        t &&
                                            (function (e) {
                                                return e in $d;
                                            })(t) &&
                                            this._map.emit('copyrightclick', {
                                                type: t,
                                                href: e.target.href,
                                                originalEvent: e,
                                            });
                                    }
                                    var t;
                                }),
                                (this._map = e),
                                !1 === t.interactive && (this._wrap.style.pointerEvents = 'none');
                            this._wrap
                                .querySelector(`.${qd.container}`)
                                .addEventListener('click', this._onClick);
                        }
                        destroy() {
                            this._wrap
                                .querySelector(`.${qd.container}`)
                                .removeEventListener('click', this._onClick),
                                super.destroy();
                        }
                    }
                    var Yd = i(438),
                        Kd = {};
                    (Kd.styleTagTransform = Dc()),
                        (Kd.setAttributes = zc()),
                        (Kd.insert = Ec().bind(null, 'head')),
                        (Kd.domAPI = Lc()),
                        (Kd.insertStyleElement = Fc());
                    Tc()(Yd.Z, Kd);
                    const Jd = Yd.Z && Yd.Z.locals ? Yd.Z.locals : void 0;
                    const Qd = `\n    <div class=${Jd.container}>\n        Your MapGL key is invalid. Please contact api@2gis.com to get MapGL key.\n    </div>\n`;
                    class eh extends class {
                        constructor(e, t) {
                            (this.rootContainer = e._impl.modules.layout.rootContainer),
                                (this.content = t),
                                (this.isShown = !1);
                        }
                        display() {
                            this.isShown ||
                                (this.wrap || (this.wrap = this.initWrap()),
                                this.rootContainer.appendChild(this.wrap),
                                (this.isShown = !0));
                        }
                        hide() {
                            this.isShown &&
                                (this.wrap && this.rootContainer.removeChild(this.wrap),
                                (this.isShown = !1));
                        }
                        isDisplayed() {
                            return this.isShown;
                        }
                    } {
                        constructor(e) {
                            super(e, Qd),
                                e._impl.on('invalidtilekey', () => {
                                    this.isDisplayed() || this.display();
                                });
                        }
                        initWrap() {
                            const e = document.createElement('div');
                            return e.classList.add(`${Jd.wrap}`), (e.innerHTML = this.content), e;
                        }
                    }
                    const th = () => {
                        let e,
                            t = '';
                        for (let i = 0; i < 32; i++)
                            (e = (16 * Math.random()) | 0),
                                i > 4 && i < 21 && !(i % 4) && (t += '-'),
                                (t += (12 === i ? 4 : 16 === i ? (3 & e) | 8 : e).toString(16));
                        return t;
                    };
                    class ih {
                        constructor(e) {
                            (this.northEast = e.northEast), (this.southWest = e.southWest);
                        }
                        extend(e) {
                            return (
                                (this.southWest = [
                                    Math.min(this.southWest[0], e[0]),
                                    Math.min(this.southWest[1], e[1]),
                                ]),
                                (this.northEast = [
                                    Math.max(this.northEast[0], e[0]),
                                    Math.max(this.northEast[1], e[1]),
                                ]),
                                this
                            );
                        }
                    }
                    var nh = i(1704),
                        oh = {};
                    (oh.styleTagTransform = Dc()),
                        (oh.setAttributes = zc()),
                        (oh.insert = Ec().bind(null, 'head')),
                        (oh.domAPI = Lc()),
                        (oh.insertStyleElement = Fc());
                    Tc()(nh.Z, oh);
                    const rh = nh.Z && nh.Z.locals ? nh.Z.locals : void 0,
                        sh = `\n    <div class="${rh.root}">\n        <div class="${rh.container}">\n            <div class="${rh.scroller}">\n                <div class="${rh.content}" />\n            </div>\n        </div>\n    </div>\n`;
                    class ah extends Od {
                        constructor(e, t) {
                            super(e, sh, t),
                                (this._removeButtonsEventListeners = () => {
                                    this._content &&
                                        this._content.childNodes.forEach((e) => {
                                            if (this._handlers.has(e)) {
                                                const t = this._handlers.get(e);
                                                void 0 !== t && e.removeEventListener('click', t);
                                            }
                                        });
                                }),
                                (this._showControl = (e) => {
                                    var t;
                                    const {
                                        currentFloorLevelIndex: i,
                                        floorPlanId: n,
                                        floorLevels: o,
                                    } = e;
                                    let r;
                                    if (
                                        ((this._floor = {
                                            currentFloorLevelIndex: i,
                                            floorPlanId: n,
                                        }),
                                        (this._root.style.display = 'block'),
                                        (this._content.innerHTML = ''),
                                        o.forEach(({ floorLevelIndex: e, floorLevelName: t }) => {
                                            const n = document.createElement('button');
                                            (n.className = rh.control),
                                                (n.innerHTML = `<div class="${rh.label}">${t}</div>`),
                                                (n.name = e.toLocaleString()),
                                                i === e && ((n.disabled = !0), (r = n));
                                            const o = this._controlHandler(e);
                                            n.addEventListener('click', o),
                                                this._handlers.set(n, o),
                                                this._content.append(n);
                                        }),
                                        r && r.offsetTop)
                                    ) {
                                        const e =
                                            null === (t = r.parentElement) || void 0 === t
                                                ? void 0
                                                : t.parentElement;
                                        e && (e.scrollTop = r.offsetTop);
                                    }
                                }),
                                (this._hideControl = () => {
                                    this._removeButtonsEventListeners(),
                                        (this._floor = void 0),
                                        (this._root.style.display = 'none');
                                }),
                                (this._onLevelChange = (e) => {
                                    this._switchCurrentFloorLevel(e.floorLevelIndex);
                                }),
                                (this._controlHandler = (e) => () => {
                                    this._switchCurrentFloorLevel(e),
                                        this._floor &&
                                            this._map.setFloorPlanLevel(this._floor.floorPlanId, e);
                                }),
                                (this._switchCurrentFloorLevel = (e) => {
                                    this._floor &&
                                        ((this._wrap.querySelector(
                                            `.${rh.control}[name="${this._floor.currentFloorLevelIndex}"]`,
                                        ).disabled = !1),
                                        (this._wrap.querySelector(
                                            `.${rh.control}[name="${e}"]`,
                                        ).disabled = !0),
                                        (this._floor.currentFloorLevelIndex = e));
                                }),
                                (this._map = e),
                                (this._root = this._wrap.querySelector(`.${rh.root}`)),
                                (this._content = this._wrap.querySelector(`.${rh.content}`)),
                                (this._handlers = new WeakMap()),
                                (this._root.style.display = 'none'),
                                e.on('floorplanshow', this._showControl),
                                e.on('floorplanhide', this._hideControl),
                                e.on('floorlevelchange', this._onLevelChange);
                        }
                        destroy() {
                            this._map.off('floorplanshow', this._showControl),
                                this._map.off('floorplanhide', this._hideControl),
                                this._map.off('floorlevelchange', this._onLevelChange),
                                this._removeButtonsEventListeners(),
                                super.destroy();
                        }
                    }
                    var lh = i(3274),
                        ch = {};
                    (ch.styleTagTransform = Dc()),
                        (ch.setAttributes = zc()),
                        (ch.insert = Ec().bind(null, 'head')),
                        (ch.domAPI = Lc()),
                        (ch.insertStyleElement = Fc());
                    Tc()(lh.Z, ch);
                    const dh = lh.Z && lh.Z.locals ? lh.Z.locals : void 0;
                    class hh {
                        constructor(e, t) {
                            (this.wrap = document.createElement('div')),
                                (this.wrap.className = dh.controlPane),
                                (this.containers = {});
                            const { rootContainer: i } = e._impl.modules.layout;
                            i.appendChild(this.wrap),
                                (this.padding = { top: 10, right: 10, bottom: 10, left: 10 }),
                                this.setPadding(t.padding || {});
                        }
                        setPadding(e) {
                            Object.keys(this.padding).forEach((t) => {
                                var i;
                                const n = t;
                                (this.padding[n] = null !== (i = e[n]) && void 0 !== i ? i : 10),
                                    (this.wrap.style[
                                        `margin${n.replace(/^\w/, (e) => e.toUpperCase())}`
                                    ] = `${this.padding[n]}px`);
                            });
                        }
                        getPadding() {
                            return Object.assign({}, this.padding);
                        }
                        destroy() {
                            this.wrap.remove();
                        }
                        getContainerByPosition(e) {
                            let t = this.containers[e];
                            return t || (t = this.containers[e] = this._initControlContainer(e)), t;
                        }
                        _initControlContainer(e) {
                            const t = document.createElement('div');
                            return (
                                t.classList.add(dh.container, dh[e]), this.wrap.appendChild(t), t
                            );
                        }
                    }
                    const uh = 2,
                        mh = 20,
                        fh = 5e3;
                    class ph {
                        constructor(e, t) {
                            var i;
                            (this.queue = []),
                                (this.commPoiMsgOrderNumber = 0),
                                (this.utcOffset = (function () {
                                    const e = new Date().getTimezoneOffset(),
                                        t = e > 0 ? '-' : '+',
                                        i = `${Math.floor(Math.abs(e) / 60)}`,
                                        n = '' + (Math.abs(e) % 60);
                                    return (
                                        t +
                                        (i.length > 1 ? i : '0' + i) +
                                        ':' +
                                        (n.length > 1 ? n : '0' + n)
                                    );
                                })()),
                                (this.unsentMessages = []),
                                (this.onCommPoiShowEvent = ({ commPois: e }) => {
                                    const t = Date.now(),
                                        { tileKey: i, sessionId: n } = this.map._impl.state;
                                    for (const o of e)
                                        this.queue.push(
                                            _h(
                                                o,
                                                t,
                                                this.commPoiMsgOrderNumber++,
                                                i,
                                                this.utcOffset,
                                                n,
                                            ),
                                        );
                                    this.timer ||
                                        (this.timer = window.setTimeout(this.sendMessages, fh));
                                }),
                                (this.onMetricsEvent = (e) => {
                                    const t = Date.now();
                                    this.queue.push(
                                        (function (e, t) {
                                            return {
                                                type: 411,
                                                eventType: 'mapglCounter',
                                                eventId: th(),
                                                timestamp: t,
                                                payload: { mapGlMapMetrics: e },
                                                common: {
                                                    formatVersion: 3,
                                                    appVersion: 'v1',
                                                    product: 44,
                                                },
                                            };
                                        })(e, t),
                                    ),
                                        this.timer ||
                                            (this.timer = window.setTimeout(this.sendMessages, fh));
                                }),
                                (this.onSendFail = (e) => {
                                    this.unsentMessages.push(...e),
                                        this.timer ||
                                            (this.timer = window.setTimeout(this.sendMessages, fh));
                                }),
                                (this.sendMessages = () => {
                                    this.timer = void 0;
                                    const e = [...this.unsentMessages, ...this.queue];
                                    (this.queue = []),
                                        (this.unsentMessages = []),
                                        e.length &&
                                            fetch(this.bssUrl, {
                                                method: 'POST',
                                                body: JSON.stringify(e),
                                                headers: { 'Content-Type': 'application/json' },
                                            }).then(
                                                (t) => {
                                                    t.ok || this.onSendFail(e);
                                                },
                                                () => this.onSendFail(e),
                                            );
                                }),
                                (this.map = e),
                                (this.bssUrl =
                                    null !== (i = t.bssUrl) && void 0 !== i
                                        ? i
                                        : 'https://s1.bss.2gis.com/bss/3'),
                                t.disableBssStatisticsForCommPoi ||
                                    e._impl.on('commpoishow', this.onCommPoiShowEvent),
                                e._impl.on('metrics', this.onMetricsEvent);
                        }
                        destroy() {
                            clearTimeout(this.timer),
                                (this.queue = []),
                                (this.timer = void 0),
                                this.map._impl.off('commpoishow', this.onCommPoiShowEvent);
                        }
                    }
                    function _h(e, t, i, n, o, r) {
                        const s = { adsHighlight: !0, entity: { id: e.id, type: 'branch' } };
                        void 0 !== e.adsPriority && (s.adsPriority = e.adsPriority);
                        const a = {
                            type: 302,
                            eventType: 'view',
                            eventId: th(),
                            eventOrdinal: i,
                            uiElement: { name: 'POI', ownerName: 'map' },
                            timestamp: t,
                            utcOffset: o,
                            payload: { POI: s },
                            common: { formatVersion: 3, appVersion: 'v1', product: 44, apikey: n },
                        };
                        return r && (a.common.sessionId = r), a;
                    }
                    var vh = i(6032),
                        gh = {};
                    (gh.styleTagTransform = Dc()),
                        (gh.setAttributes = zc()),
                        (gh.insert = Ec().bind(null, 'head')),
                        (gh.domAPI = Lc()),
                        (gh.insertStyleElement = Fc());
                    Tc()(vh.Z, gh);
                    const yh = vh.Z && vh.Z.locals ? vh.Z.locals : void 0,
                        bh = { en: 'm', ru: '' },
                        wh = { en: 'km', ru: '' };
                    class xh extends Od {
                        constructor(e, t) {
                            super(e, '', t),
                                (this._render = () => {
                                    const e = this._wrap.getBoundingClientRect(),
                                        t = this._calcSize([e.x, e.y], e.width || 66, 0),
                                        i = `\n            <div class="${
                                            yh.root
                                        }">\n                <div class="${
                                            yh.label
                                        }">\n                    ${(function (e, t) {
                                            if (e < 1e3) return `${e} ${bh[t] || bh.en}`;
                                            return `${(e / 1e3).toFixed(1)} ${wh[t] || wh.en}`;
                                        })(
                                            t,
                                            this._map.getLanguage(),
                                        )}\n                </div>\n            </div>\n        `;
                                    this._wrap.innerHTML = i;
                                }),
                                (this._map = e),
                                this._render(),
                                e.on('zoom', this._render),
                                e.on('pitch', this._render),
                                e.on('changeLanguage', this._render);
                        }
                        destroy() {
                            this._map.off('zoom', this._render),
                                this._map.off('pitch', this._render),
                                this._map.off('changeLanguage', this._render),
                                super.destroy();
                        }
                        _calcSize(e, t, i) {
                            return L.$X(
                                this._map.getCenter(),
                                this._map.getZoom(),
                                this._map.getRotation(),
                                this._map.getSize(),
                                this._map.getPitch(),
                                e,
                                void 0,
                                this._map.getPadding(),
                                t,
                                i,
                            );
                        }
                    }
                    class Sh {
                        constructor(e) {
                            this._impl = e._impl.getDefaultSource();
                        }
                        setFeatureStateMap(e) {
                            this._impl.setFeatureStateMap(e);
                        }
                        setFeatureStateMapBinary(e) {
                            this._impl.setFeatureStateMapBinary(e);
                        }
                    }
                    class Ih extends Fd {
                        constructor(e, t) {
                            var i, n, o;
                            let r;
                            if ((super(), 'string' == typeof e)) {
                                const t = document.getElementById(e);
                                if (!t)
                                    throw new Error(`Could not found html element with id: ${e}`);
                                r = t;
                            } else r = e;
                            const s = Object.assign({}, t.styleOptions),
                                a = Object.assign(Object.assign({}, t), {
                                    disableHoverStyles:
                                        null === (i = t.disableHoverStyles) || void 0 === i || i,
                                    tileServer: t.tileServer || 'tile{subdomain}-sdk.maps.2gis.com',
                                    sendAnalytics: !1 === t.disableAnalytics,
                                    style: t.style || 'c080bb6a-8134-4993-93a1-5b4d8c36a59b',
                                    styleOptions: s,
                                    styleState: t.styleState,
                                    minZoom: null !== (n = t.minZoom) && void 0 !== n ? n : uh,
                                    maxZoom: null !== (o = t.maxZoom) && void 0 !== o ? o : mh,
                                    sessionId: th(),
                                    tileSessionId: t.tileSessionId,
                                });
                            (this._impl = new Hc(r, a)),
                                this._impl
                                    .on('idle', (e) => this._emitMapEvent('idle', e))
                                    .on('ready', (e) => this._emitMapEvent('ready', e))
                                    .on('resize', (e) => this._emitMapEvent('resize', e))
                                    .on('move', (e) => this._emitMapEvent('move', e))
                                    .on('movestart', (e) => this._emitMapEvent('movestart', e))
                                    .on('moveend', (e) => this._emitMapEvent('moveend', e))
                                    .on('center', (e) => this._emitMapEvent('center', e))
                                    .on('centerstart', (e) => this._emitMapEvent('centerstart', e))
                                    .on('centerend', (e) => this._emitMapEvent('centerend', e))
                                    .on('zoom', (e) => this._emitMapEvent('zoom', e))
                                    .on('zoomstart', (e) => this._emitMapEvent('zoomstart', e))
                                    .on('zoomend', (e) => this._emitMapEvent('zoomend', e))
                                    .on('rotation', (e) => this._emitMapEvent('rotation', e))
                                    .on('rotationstart', (e) =>
                                        this._emitMapEvent('rotationstart', e),
                                    )
                                    .on('rotationend', (e) => this._emitMapEvent('rotationend', e))
                                    .on('pitch', (e) => this._emitMapEvent('pitch', e))
                                    .on('pitchstart', (e) => this._emitMapEvent('pitchstart', e))
                                    .on('pitchend', (e) => this._emitMapEvent('pitchend', e))
                                    .on('trafficshow', () => this.emit('trafficshow'))
                                    .on('traffichide', () => this.emit('traffichide'))
                                    .on(
                                        'floorcomplexshow',
                                        ({ id: e, currentFloor: t, floorNames: i }) =>
                                            this.emit('floorplanshow', {
                                                floorPlanId: e,
                                                currentFloorLevelIndex: t,
                                                floorLevels: i.map((e, t) => ({
                                                    floorLevelIndex: t,
                                                    floorLevelName: e,
                                                })),
                                            }),
                                    )
                                    .on('floorcomplexhide', (e) =>
                                        this.emit('floorplanhide', { floorPlanId: e.id }),
                                    )
                                    .on('floorcomplexlevelchange', (e) =>
                                        this.emit('floorlevelchange', {
                                            floorLevelName: e.floorName,
                                            floorLevelIndex: e.floorIndex,
                                            floorPlanId: e.id,
                                        }),
                                    )
                                    .on('commmodelshow', (e) => this.emit('commmodelshow', e))
                                    .on('commmodelhide', (e) => this.emit('commmodelhide', e)),
                                this._impl
                                    .on('click', (e) => this._emitMapPointerEvent('click', e))
                                    .on('dblclick', (e) => this._emitMapPointerEvent('dblclick', e))
                                    .on('contextmenu', (e) =>
                                        this._emitMapPointerEvent('contextmenu', e),
                                    )
                                    .on('mousemove', (e) =>
                                        this._emitMapPointerEvent('mousemove', e),
                                    )
                                    .on('mouseover', (e) =>
                                        this._emitMapPointerEvent('mouseover', e),
                                    )
                                    .on('mouseout', (e) => this._emitMapPointerEvent('mouseout', e))
                                    .on('mousedown', (e) =>
                                        this._emitMapPointerEvent('mousedown', e),
                                    )
                                    .on('mouseup', (e) => this._emitMapPointerEvent('mouseup', e))
                                    .on('touchstart', (e) =>
                                        this._emitMapPointerEvent('touchstart', e),
                                    )
                                    .on('touchend', (e) =>
                                        this._emitMapPointerEvent('touchend', e),
                                    ),
                                this._impl.on('trafficscore', ({ score: e }) =>
                                    this.emit('trafficscore', { score: e }),
                                ),
                                this._impl.on('styleload', ({ style: e }) =>
                                    this.emit('styleload', { style: e }),
                                ),
                                (this._controlPane = new hh(this, {
                                    padding: t.controlsLayoutPadding,
                                })),
                                this._initControls(t),
                                t.disableBssStatistics ||
                                    (this._bssDispatcher = new ph(this, {
                                        disableBssStatisticsForCommPoi:
                                            !!t.disableBssStatisticsForCommPoi,
                                        bssUrl: t.bssUrl,
                                    })),
                                new eh(this),
                                (this._defaultSource = new Sh(this));
                        }
                        setCenter(e, t) {
                            return this._impl.setCenter(e, t), this;
                        }
                        getCenter() {
                            return this._impl.getCenter();
                        }
                        setZoom(e, t) {
                            return this._impl.setZoom(e, t), this;
                        }
                        getZoom() {
                            return this._impl.getZoom();
                        }
                        getStyleZoom() {
                            return this._impl.getStyleZoom();
                        }
                        setStyleZoom(e, t) {
                            return this._impl.setStyleZoom(e, t), this;
                        }
                        setRotation(e, t) {
                            return this._impl.setRotation(e, t), this;
                        }
                        getRotation() {
                            return this._impl.getRotation();
                        }
                        setPitch(e, t) {
                            return this._impl.setPitch(e, t), this;
                        }
                        getPitch() {
                            return this._impl.getPitch();
                        }
                        setMinZoom(e, t) {
                            return this._impl.setMinZoom(e, t), this;
                        }
                        getMinZoom() {
                            return this._impl.getMinZoom();
                        }
                        getMaxZoom() {
                            return this._impl.getMaxZoom();
                        }
                        setMaxZoom(e, t) {
                            return this._impl.setMaxZoom(e, t), this;
                        }
                        setMinPitch(e, t) {
                            return this._impl.setMinPitch(e, t), this;
                        }
                        setMaxPitch(e, t) {
                            return this._impl.setMaxPitch(e, t), this;
                        }
                        getSize() {
                            return this._impl.getSize();
                        }
                        isIdle() {
                            return this._impl.isIdle();
                        }
                        getBounds() {
                            return new ih(this._impl.getBounds());
                        }
                        project(e) {
                            return this._impl.project(e);
                        }
                        unproject(e) {
                            return this._impl.unproject(e);
                        }
                        getProjectionMatrix() {
                            return this._impl.getCameraViewProjectionMatrix().slice();
                        }
                        getProjectionMatrixForGltfPlugin() {
                            return this._impl.getCameraProjectionMatrix().slice();
                        }
                        getWebGLContext() {
                            return this._impl.getWebGLContext();
                        }
                        getCanvas() {
                            return this._impl.getCanvas();
                        }
                        getContainer() {
                            return this._impl.getExternalContainer();
                        }
                        invalidateSize() {
                            return this._impl.invalidateSize(), this;
                        }
                        showTraffic() {
                            return this._impl.showTraffic(), this;
                        }
                        hideTraffic() {
                            return this._impl.hideTraffic(), this;
                        }
                        setSelectedObjects(e = []) {
                            return this._impl.setSelectedIds(e), this;
                        }
                        setStyleById(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                return this._impl.setStyle(e);
                            });
                        }
                        setLanguage(e) {
                            return (
                                this._impl.setLang(e),
                                this.emit('changeLanguage', { lang: e }),
                                this
                            );
                        }
                        getLanguage() {
                            return this._impl.state.lang;
                        }
                        setFloorPlanLevel(e, t) {
                            this._impl.changeFloorNumber(e, t);
                        }
                        setMaxBounds(e) {
                            return this._impl.setMaxBounds(e), this;
                        }
                        getPadding() {
                            return this._impl.getPadding();
                        }
                        getDefaultSource() {
                            return this._defaultSource;
                        }
                        setPadding(e, t) {
                            return this._impl.setPadding(e, t), this;
                        }
                        setStyle(e, t) {
                            return this._impl.setStyle(e, t);
                        }
                        addLayer(e, t) {
                            return this._impl.addLayer(e, t), this;
                        }
                        addIcon(e, t) {
                            return this._impl.addIcon(e, t), this;
                        }
                        removeIcon(e) {
                            return this._impl.removeIcon(e), this;
                        }
                        addModel(e, t) {
                            return this._impl.addModel(e, t), this;
                        }
                        removeLayer(e) {
                            return this._impl.removeLayer(e), this;
                        }
                        setAutoHoverMode(e) {
                            return this._impl.setAutoHoverMode(e), this;
                        }
                        fitBounds(e, t) {
                            return this._impl.fitBounds(e, t), this;
                        }
                        setStyleState(e) {
                            return this._impl.setStyleState(e), this;
                        }
                        getStyleState() {
                            return this._impl.getStyleState();
                        }
                        setStyleOptions(e) {
                            return this._impl.patchStyleState({ trafficOn: e.traffic }), this;
                        }
                        setOption(e, t) {
                            return this._impl.setOption(e, t), this;
                        }
                        getOption(e) {
                            return this._impl.getOption(e);
                        }
                        patchStyleState(e) {
                            return this._impl.patchStyleState(e), this;
                        }
                        destroy() {
                            var e;
                            null === (e = this._bssDispatcher) || void 0 === e || e.destroy(),
                                this._controlPane.destroy(),
                                this._impl.destroy(),
                                this.emit('destroy');
                        }
                        triggerRerender() {
                            this._impl.state.needRerender = !0;
                        }
                        setControlsLayoutPadding(e) {
                            this._controlPane.setPadding(e);
                        }
                        getControlsLayoutPadding() {
                            return this._controlPane.getPadding();
                        }
                        setHiddenObjects(e) {
                            this._impl.hideBuildingsById(e);
                        }
                        setEnvironmentParams(e) {
                            this._impl.modules.environmentManager.setParameters(e);
                        }
                        unsetHiddenObjects(e) {
                            this._impl.showHiddenBuildingsById(e);
                        }
                        showLabelsDebug(e) {
                            this._impl.showLabelsDebug(e);
                        }
                        hideLabelsDebug() {
                            this._impl.hideLabelsDebug();
                        }
                        getGroundPoint(e) {
                            return this._impl.getGroundPoint(e);
                        }
                        _emitMapEvent(e, t) {
                            this.emit(e, { isUser: t.isUser });
                        }
                        _emitMapPointerEvent(e, t) {
                            const {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                target: r,
                                targetData: s,
                            } = t;
                            let a, l;
                            if (void 0 !== s)
                                switch (s.type) {
                                    case 'geojson':
                                        a = {
                                            type: s.type,
                                            source: s.source.mapglApiSource,
                                            feature: s.feature,
                                        };
                                        break;
                                    case 'zenith':
                                        a = {
                                            type: s.type,
                                            id: s.id,
                                            source: s.source.mapglApiSource,
                                        };
                                        break;
                                    case 'default': {
                                        a = { type: s.type, id: s.id };
                                        const { floorId: e } = s;
                                        e && (a.floorId = e);
                                        break;
                                    }
                                }
                            void 0 !== r && ((l = { id: r.id }), r.center && (l.center = r.center)),
                                this.emit(e, {
                                    originalEvent: i,
                                    lngLat: n,
                                    point: o,
                                    target: l,
                                    targetData: a,
                                });
                        }
                        _initControls(e) {
                            if (
                                (!1 !== e.copyright &&
                                    this._impl.modules.tileKeyInfo
                                        .getKeyInfo()
                                        .then(({ urbi: t }) => {
                                            new Xd(this, {
                                                position:
                                                    'string' == typeof e.copyright
                                                        ? e.copyright
                                                        : 'bottomRight',
                                                interactive: e.interactiveCopyright,
                                                copyrightType: t ? 'Urbi' : '2gis',
                                            });
                                        }),
                                !1 !== e.zoomControl)
                            ) {
                                const t =
                                    'string' == typeof e.zoomControl ? e.zoomControl : 'topRight';
                                new Nd(this, { position: t });
                            }
                            if (e.trafficControl) {
                                const t =
                                    'string' == typeof e.trafficControl
                                        ? e.trafficControl
                                        : 'topRight';
                                new Gd(this, { position: t });
                            }
                            if (e.scaleControl) {
                                const t =
                                    'string' == typeof e.scaleControl
                                        ? e.scaleControl
                                        : 'bottomLeft';
                                new xh(this, { position: t });
                            }
                            if (e.floorControl) {
                                const t =
                                    'string' == typeof e.floorControl ? e.floorControl : 'topRight';
                                new ah(this, { position: t });
                            }
                        }
                    }
                    function Mh(e, t) {
                        const i = Object.assign({}, e);
                        for (const e in t) {
                            const n = e;
                            void 0 === i[n] && (i[n] = t[n]);
                        }
                        return i;
                    }
                    const Th = {
                            minZoom: -1 / 0,
                            maxZoom: 1 / 0,
                            anchor: [0.5, 0.5],
                            offset: [0, 18],
                            relativeAnchor: [0.5, 0.5],
                            zIndex: 0,
                            lineHeight: 1.2,
                            letterSpacing: 0,
                            haloRadius: 0,
                            fontSize: 18,
                            color: '#000000',
                            haloColor: '#ffffff',
                        },
                        Ph = {
                            minZoom: -1 / 0,
                            maxZoom: 1 / 0,
                            zIndex: 0,
                            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzBweCIgaGVpZ2h0PSI0OHB4IiB2aWV3Qm94PSIwIDAgMzAgNDgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA1MS4yICg1NzUxOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+PHRpdGxlPlBhZ2UgMSBDb3B5PC90aXRsZT48ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjUwJSIgeTE9IjUwJSIgeDI9IjUwJSIgeTI9IjAlIiBpZD0ibGluZWFyR3JhZGllbnQtMSI+PHN0b3Agc3RvcC1jb2xvcj0iIzFCODlFRSIgb2Zmc2V0PSIwJSI+PC9zdG9wPjxzdG9wIHN0b3AtY29sb3I9IiMzMTk4RUMiIG9mZnNldD0iMTAwJSI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxnIGlkPSJSZWNvdmVyeS0wMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTgzOS4wMDAwMDAsIC00MjUuMDAwMDAwKSI+PGcgaWQ9IlBhZ2UtMS1Db3B5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MzkuMDAwMDAwLCA0MjUuMDAwMDAwKSI+PGVsbGlwc2UgaWQ9Ik92YWwtMyIgZmlsbD0iIzAwMDAwMCIgb3BhY2l0eT0iMC4wMzYzODA1OTciIGN4PSIxNSIgY3k9IjQ1LjUiIHJ4PSIzIiByeT0iMS41Ij48L2VsbGlwc2U+PGVsbGlwc2UgaWQ9Ik92YWwtMy1Db3B5IiBmaWxsPSIjMDAwMDAwIiBvcGFjaXR5PSIwLjAzNjM4MDU5NyIgY3g9IjE1IiBjeT0iNDUuNSIgcng9IjQuNSIgcnk9IjIuNSI+PC9lbGxpcHNlPjxwYXRoIGQ9Ik0xNSw0NS44ODM2MzUzIEwxNS44ODIzNTI5LDQ1Ljg4MzYzNTMgQzE1Ljg4MjM1MjksMjkuMjE3NzUyOSAyMC43NzY3NjQ3LDIzLjc5NzQ1ODggMjcuOTg3MzUyOSwyMy43OTc0NTg4IEwyOC4zMjk3MDU5LDIzLjc5NzQ1ODggQzI5LjA3Nzk0MTIsMjEuNTkwNjk0MSAzMCwxNy45OTE1NzY1IDMwLDE1LjAwMDQgQzMwLDcuMTQzOTI5NDEgMjMuNzY3OTQxMiwwLjAwMDQgMTUsMC4wMDA0IEM2LjIzMjA1ODgyLDAuMDAwNCAwLDcuMTQzOTI5NDEgMCwxNS4wMDA0IEMwLDE3Ljk5MTU3NjUgMC45MjIwNTg4MjQsMjEuNTkwNjk0MSAxLjY3MDI5NDEyLDIzLjc5NzQ1ODggTDIuMDEyNjQ3MDYsMjMuNzk3NDU4OCBDOS4yMjQxMTc2NSwyMy43OTc0NTg4IDE0LjExNzY0NzEsMjkuMjE3NzUyOSAxNC4xMTc2NDcxLDQ1Ljg4MzYzNTMgTDE1LDQ1Ljg4MzYzNTMgWiIgaWQ9IkZpbGwtMSIgZmlsbD0idXJsKCNsaW5lYXJHcmFkaWVudC0xKSI+PC9wYXRoPjwvZz48L2c+PC9nPjwvc3ZnPg==',
                            interactive: !0,
                            hoverSize: [15, 43],
                            rotation: 0,
                            userData: void 0,
                        };
                    class Lh extends Fd {
                        constructor(e, t) {
                            super(), t.icon || (t.anchor = [15, 46]);
                            const i = Mh(t, Ph);
                            (this.userData = i.userData),
                                (this.rootOptions = {
                                    zIndex: i.zIndex,
                                    minZoom: i.minZoom,
                                    maxZoom: i.maxZoom,
                                }),
                                (this._impl = new wd(e._impl, {
                                    coordinates: i.coordinates,
                                    icon: i.icon,
                                    zIndex: i.zIndex,
                                    minZoom: i.minZoom,
                                    maxZoom: i.maxZoom,
                                    interactive: i.interactive,
                                    label: kh(this.rootOptions, t.label),
                                    anchor: t.anchor,
                                    size: t.size,
                                    rotation: t.rotation,
                                    hoverIcon: t.hoverIcon,
                                    hoverSize: t.hoverSize,
                                    hoverAnchor: t.hoverAnchor,
                                })),
                                this._impl
                                    .on('click', (e) => this._emitPointerEvent('click', e))
                                    .on('dblclick', (e) => this._emitPointerEvent('dblclick', e))
                                    .on('mousemove', (e) => this._emitPointerEvent('mousemove', e))
                                    .on('mouseover', (e) => this._emitPointerEvent('mouseover', e))
                                    .on('mouseout', (e) => this._emitPointerEvent('mouseout', e))
                                    .on('mousedown', (e) => this._emitPointerEvent('mousedown', e))
                                    .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                    .on('touchstart', (e) =>
                                        this._emitPointerEvent('touchstart', e),
                                    )
                                    .on('touchend', (e) => this._emitPointerEvent('touchend', e));
                        }
                        setIcon(e) {
                            return this._impl.setIcon(e), this;
                        }
                        setHoverIcon(e) {
                            return this._impl.setHoverIcon(e), this;
                        }
                        setRotation(e) {
                            return this._impl.setRotation(e), this;
                        }
                        getRotation() {
                            return this._impl.getRotation();
                        }
                        setLabel(e) {
                            return this._impl.setLabel(kh(this.rootOptions, e)), this;
                        }
                        setCoordinates(e) {
                            return this._impl.setCoordinates(e), this;
                        }
                        getCoordinates() {
                            return this._impl.getCoordinates();
                        }
                        show() {
                            return this._impl.show(), this;
                        }
                        hide() {
                            return this._impl.hide(), this;
                        }
                        destroy() {
                            this._impl.destroy();
                        }
                        _emitPointerEvent(e, t) {
                            const { originalEvent: i, lngLat: n, point: o } = t;
                            this.emit(e, {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                targetData: this,
                            });
                        }
                    }
                    function kh(e, t) {
                        var i, n, o;
                        if (!t) return;
                        (t.minZoom = Math.max(
                            null !== (i = t.minZoom) && void 0 !== i ? i : e.minZoom,
                            e.minZoom,
                        )),
                            (t.maxZoom = Math.min(
                                null !== (n = t.maxZoom) && void 0 !== n ? n : e.maxZoom,
                                e.maxZoom,
                            )),
                            (t.zIndex =
                                null !== (o = t.zIndex) && void 0 !== o ? o : e.zIndex + 1e-5);
                        const r = Mh(t, Th);
                        return (
                            void 0 === t.offset &&
                                void 0 !== t.anchor &&
                                (r.offset = t.anchor.map((e) => -e)),
                            {
                                text: r.text,
                                image: t.image,
                                minZoom: r.minZoom,
                                maxZoom: r.maxZoom,
                                color: r.color,
                                fontSize: r.fontSize,
                                haloRadius: r.haloRadius,
                                haloColor: r.haloColor,
                                letterSpacing: r.letterSpacing,
                                lineHeight: r.lineHeight,
                                zIndex: r.zIndex,
                                offset: r.offset,
                                anchor: r.relativeAnchor,
                                font: 'Noto_Sans',
                            }
                        );
                    }
                    const Eh = {
                        anchor: [0, 0],
                        offset: [0, 0],
                        fontSize: 24,
                        color: '#000000',
                        haloColor: '#ffffff',
                        haloRadius: 0,
                        minZoom: -1 / 0,
                        maxZoom: 1 / 0,
                        zIndex: 0,
                        letterSpacing: 0,
                        lineHeight: 1.2,
                        relativeAnchor: [0.5, 0.5],
                        userData: void 0,
                    };
                    class Ah {
                        constructor(e, t) {
                            this.userData = t.userData;
                            const i = Mh(t, Eh);
                            void 0 === t.offset &&
                                void 0 !== t.anchor &&
                                (i.offset = t.anchor.map((e) => -e)),
                                (this._impl = new gd(e._impl, {
                                    coordinates: i.coordinates,
                                    text: i.text,
                                    minZoom: i.minZoom,
                                    maxZoom: i.maxZoom,
                                    color: i.color,
                                    fontSize: i.fontSize,
                                    haloRadius: i.haloRadius,
                                    haloColor: i.haloColor,
                                    letterSpacing: i.letterSpacing,
                                    lineHeight: i.lineHeight,
                                    zIndex: i.zIndex,
                                    offset: i.offset,
                                    anchor: i.relativeAnchor,
                                    image: t.image,
                                    font: 'Noto_Sans',
                                }));
                        }
                        destroy() {
                            this._impl.remove();
                        }
                        show() {
                            return this._impl.show(), this;
                        }
                        hide() {
                            return this._impl.hide(), this;
                        }
                        setCoordinates(e) {
                            return this._impl.setCoordinates(e), this;
                        }
                        getCoordinates() {
                            return this._impl.getCoordinates();
                        }
                    }
                    const zh = {
                        minZoom: -1 / 0,
                        maxZoom: 1 / 0,
                        zIndex: 0,
                        anchor: [-0, -0],
                        preventMapInteractions: !0,
                        userData: void 0,
                        interactive: !0,
                    };
                    class Ch {
                        constructor(e, t) {
                            this.userData = t.userData;
                            const i = Mh(t, zh);
                            this._impl = new Ga(e._impl, {
                                coordinates: i.coordinates,
                                html: i.html,
                                offset: [-i.anchor[0], -i.anchor[1]],
                                minZoom: i.minZoom,
                                maxZoom: i.maxZoom,
                                zIndex: i.zIndex,
                                preventMapInteractions: i.preventMapInteractions,
                                interactive: i.interactive,
                                animate: false,
                            });
                        }
                        destroy() {
                            this._impl.destroy();
                        }
                        setCoordinates(e) {
                            return this._impl.setPosition(e), this;
                        }
                        setAnchor(e) {
                            return this._impl.setOffset([-e[0], -e[1]]), this;
                        }
                        setContent(e) {
                            return this._impl.setContent(e), this;
                        }
                        getCoordinates() {
                            return this._impl.getPosition();
                        }
                        getAnchor() {
                            const e = this._impl.getOffset();
                            return [-e[0], -e[1]];
                        }
                        getContent() {
                            return this._impl.getHtmlElement();
                        }
                    }
                    const Fh = {
                        zIndex: 0,
                        minZoom: -1 / 0,
                        maxZoom: 1 / 0,
                        color: '#3388ff33',
                        strokeColor: '#3388ff',
                        strokeWidth: 1,
                        interactive: !0,
                        userData: void 0,
                    };
                    class Oh extends Fd {
                        constructor(e, t) {
                            super(), (this.userData = t.userData), (this.options = Mh(t, Fh));
                            const i = {
                                coordinates: this.options.coordinates,
                                radius: this.options.radius,
                                minZoom: this.options.minZoom,
                                maxZoom: this.options.maxZoom,
                                interactive: this.options.interactive,
                                color: this.options.color,
                                zIndex: this.options.zIndex,
                                borderWidth: this.options.strokeWidth,
                                borderColor: this.options.strokeColor,
                                segments: 150,
                            };
                            (this._impl = new Qc(e._impl, i)),
                                this._impl
                                    .on('click', (e) => this._emitPointerEvent('click', e))
                                    .on('dblclick', (e) => this._emitPointerEvent('dblclick', e))
                                    .on('mousemove', (e) => this._emitPointerEvent('mousemove', e))
                                    .on('mouseover', (e) => this._emitPointerEvent('mouseover', e))
                                    .on('mouseout', (e) => this._emitPointerEvent('mouseout', e))
                                    .on('mousedown', (e) => this._emitPointerEvent('mousedown', e))
                                    .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                    .on('touchstart', (e) =>
                                        this._emitPointerEvent('touchstart', e),
                                    )
                                    .on('touchend', (e) => this._emitPointerEvent('touchend', e));
                        }
                        destroy() {
                            this._impl.remove();
                        }
                        _emitPointerEvent(e, t) {
                            const { originalEvent: i, lngLat: n, point: o } = t;
                            this.emit(e, {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                targetData: this,
                            });
                        }
                    }
                    const Dh = {
                        interactive: !0,
                        maxZoom: 1 / 0,
                        minZoom: -1 / 0,
                        color: '#ffffff',
                        radius: 20,
                        diameter: NaN,
                        zIndex: 0,
                        strokeWidth: 3,
                        stroke2Width: 0,
                        strokeColor: '#3388ff',
                        stroke2Color: '#00000000',
                        userData: void 0,
                    };
                    class Rh extends Fd {
                        constructor(e, t) {
                            super(), (this.userData = t.userData), (this.options = Mh(t, Dh));
                            const i = {
                                coordinates: this.options.coordinates,
                                interactive: this.options.interactive,
                                maxZoom: this.options.maxZoom,
                                minZoom: this.options.minZoom,
                                color: this.options.color,
                                width: Number.isNaN(this.options.diameter)
                                    ? this.options.radius
                                    : this.options.diameter,
                                zIndex: this.options.zIndex,
                                borderWidth: this.options.strokeWidth,
                                borderColor: this.options.strokeColor,
                                border2Width: this.options.stroke2Width,
                                border2Color: this.options.stroke2Color,
                                draggable: !1,
                            };
                            (this._impl = new X(e._impl, i)),
                                this._impl
                                    .on('click', (e) => this._emitPointerEvent('click', e))
                                    .on('dblclick', (e) => this._emitPointerEvent('dblclick', e))
                                    .on('mousemove', (e) => this._emitPointerEvent('mousemove', e))
                                    .on('mouseover', (e) => this._emitPointerEvent('mouseover', e))
                                    .on('mouseout', (e) => this._emitPointerEvent('mouseout', e))
                                    .on('mousedown', (e) => this._emitPointerEvent('mousedown', e))
                                    .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                    .on('touchstart', (e) =>
                                        this._emitPointerEvent('touchstart', e),
                                    )
                                    .on('touchend', (e) => this._emitPointerEvent('touchend', e));
                        }
                        destroy() {
                            this._impl.remove();
                        }
                        _emitPointerEvent(e, t) {
                            const { originalEvent: i, lngLat: n, point: o } = t;
                            this.emit(e, {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                targetData: this,
                            });
                        }
                    }
                    const jh = {
                        interactive: !0,
                        maxZoom: 1 / 0,
                        minZoom: -1 / 0,
                        width: 3,
                        width2: 0,
                        width3: 0,
                        color: '#3388ff',
                        color2: '#00000000',
                        color3: '#00000000',
                        zIndex: 0,
                        zIndex2: -1,
                        zIndex3: -2,
                        dashLength: 0,
                        gapLength: 0,
                        gapColor: '#ffffff00',
                        userData: void 0,
                        webglState: {},
                    };
                    class Bh extends Fd {
                        constructor(e, t) {
                            if (
                                (super(),
                                (this.userData = t.userData),
                                (this.options = Mh(t, jh)),
                                t.dashLength)
                            ) {
                                const t = {
                                    coordinates: this.options.coordinates,
                                    interactive: this.options.interactive,
                                    maxZoom: this.options.maxZoom,
                                    minZoom: this.options.minZoom,
                                    width: this.options.width,
                                    width2: this.options.width2,
                                    dashColor: this.options.color,
                                    dash2Color: this.options.color,
                                    gapColor: this.options.gapColor,
                                    dashLength: this.options.dashLength,
                                    dash2Length: 0,
                                    zIndex: this.options.zIndex,
                                    zIndex2: this.options.zIndex2,
                                    gapLength:
                                        0 === this.options.gapLength
                                            ? this.options.dashLength
                                            : this.options.gapLength,
                                    displayTileBounds: !1,
                                    showAnimation: { animate: !1 },
                                };
                                (this._impl = new Xc(e._impl, t)),
                                    this._impl
                                        .on('click', (e) => this._emitPointerEvent('click', e))
                                        .on('dblclick', (e) =>
                                            this._emitPointerEvent('dblclick', e),
                                        )
                                        .on('mousemove', (e) =>
                                            this._emitPointerEvent('mousemove', e),
                                        )
                                        .on('mouseover', (e) =>
                                            this._emitPointerEvent('mouseover', e),
                                        )
                                        .on('mouseout', (e) =>
                                            this._emitPointerEvent('mouseout', e),
                                        )
                                        .on('mousedown', (e) =>
                                            this._emitPointerEvent('mousedown', e),
                                        )
                                        .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                        .on('touchstart', (e) =>
                                            this._emitPointerEvent('touchstart', e),
                                        )
                                        .on('touchend', (e) =>
                                            this._emitPointerEvent('touchend', e),
                                        );
                            } else {
                                const t = {
                                    coordinates: this.options.coordinates,
                                    interactive: this.options.interactive,
                                    maxZoom: this.options.maxZoom,
                                    minZoom: this.options.minZoom,
                                    width: this.options.width,
                                    width2: this.options.width2,
                                    width3: this.options.width3,
                                    color: this.options.color,
                                    color2: this.options.color2,
                                    color3: this.options.color3,
                                    zIndex: this.options.zIndex,
                                    zIndex2: this.options.zIndex2,
                                    zIndex3: this.options.zIndex3,
                                    displayTileBounds: !1,
                                    showAnimation: { animate: !1 },
                                    webglState: this.options.webglState,
                                };
                                (this._impl = new qc(e._impl, t)),
                                    this._impl
                                        .on('click', (e) => this._emitPointerEvent('click', e))
                                        .on('dblclick', (e) =>
                                            this._emitPointerEvent('dblclick', e),
                                        )
                                        .on('mousemove', (e) =>
                                            this._emitPointerEvent('mousemove', e),
                                        )
                                        .on('mouseover', (e) =>
                                            this._emitPointerEvent('mouseover', e),
                                        )
                                        .on('mouseout', (e) =>
                                            this._emitPointerEvent('mouseout', e),
                                        )
                                        .on('mousedown', (e) =>
                                            this._emitPointerEvent('mousedown', e),
                                        )
                                        .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                        .on('touchstart', (e) =>
                                            this._emitPointerEvent('touchstart', e),
                                        )
                                        .on('touchend', (e) =>
                                            this._emitPointerEvent('touchend', e),
                                        );
                            }
                        }
                        destroy() {
                            this._impl.remove();
                        }
                        _emitPointerEvent(e, t) {
                            const { originalEvent: i, lngLat: n, point: o } = t;
                            this.emit(e, {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                targetData: this,
                            });
                        }
                    }
                    const Nh = {
                        interactive: !0,
                        maxZoom: 1 / 0,
                        minZoom: -1 / 0,
                        color: '#3388ff33',
                        zIndex: 0,
                        strokeWidth: 3,
                        strokeColor: '#3388ff',
                        userData: void 0,
                    };
                    class Uh extends Fd {
                        constructor(e, t) {
                            super(), (this.userData = t.userData), (this.options = Mh(t, Nh));
                            const i = {
                                coordinates: this.options.coordinates,
                                interactive: this.options.interactive,
                                maxZoom: this.options.maxZoom,
                                minZoom: this.options.minZoom,
                                color: this.options.color,
                                zIndex: this.options.zIndex,
                                strokeWidth: this.options.strokeWidth,
                                strokeColor: this.options.strokeColor,
                            };
                            (this._impl = new Jc(e._impl, i)),
                                this._impl
                                    .on('click', (e) => this._emitPointerEvent('click', e))
                                    .on('dblclick', (e) => this._emitPointerEvent('dblclick', e))
                                    .on('mousemove', (e) => this._emitPointerEvent('mousemove', e))
                                    .on('mouseover', (e) => this._emitPointerEvent('mouseover', e))
                                    .on('mouseout', (e) => this._emitPointerEvent('mouseout', e))
                                    .on('mousedown', (e) => this._emitPointerEvent('mousedown', e))
                                    .on('mouseup', (e) => this._emitPointerEvent('mouseup', e))
                                    .on('touchstart', (e) =>
                                        this._emitPointerEvent('touchstart', e),
                                    )
                                    .on('touchend', (e) => this._emitPointerEvent('touchend', e));
                        }
                        destroy() {
                            this._impl.remove();
                        }
                        _emitPointerEvent(e, t) {
                            const { originalEvent: i, lngLat: n, point: o } = t;
                            this.emit(e, {
                                originalEvent: i,
                                lngLat: n,
                                point: o,
                                targetData: this,
                            });
                        }
                    }
                    const Zh = { minZoom: -1 / 0, maxZoom: 1 / 0, zIndex: 0, opacity: 1 };
                    class Hh {
                        constructor(e, t) {
                            this.options = Mh(t, Zh);
                            const i = {
                                bounds: this.options.bounds,
                                image: { url: this.options.image.url },
                                minZoom: this.options.minZoom,
                                maxZoom: this.options.maxZoom,
                                zIndex: this.options.zIndex,
                                opacity: this.options.opacity,
                            };
                            this._impl = new Pd(e._impl, i);
                        }
                        updateImage(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                yield this._impl.updateImage(e);
                            });
                        }
                        destroy() {
                            this._impl.destroy();
                        }
                    }
                    const Gh = { attributes: {}, maxZoom: 17, dimensions: 2, modelsPath: '' };
                    class Vh {
                        constructor(e, t) {
                            (this.options = Mh(t, Gh)),
                                (this._impl = new no.gs(e._impl, this.options, this));
                        }
                        destroy() {
                            this._impl.destroy();
                        }
                        setAttributes(e) {
                            return this._impl.setAttributes(e), this;
                        }
                        getAttributes() {
                            return this._impl.getAttributes();
                        }
                        setData(e) {
                            return (0, S.mG)(this, void 0, void 0, function* () {
                                yield this._impl.setData(e);
                            });
                        }
                    }
                    var Wh = i(3103),
                        qh = {};
                    (qh.styleTagTransform = Dc()),
                        (qh.setAttributes = zc()),
                        (qh.insert = Ec().bind(null, 'head')),
                        (qh.domAPI = Lc()),
                        (qh.insertStyleElement = Fc());
                    Tc()(Wh.Z, qh);
                    const $h = Wh.Z && Wh.Z.locals ? Wh.Z.locals : void 0;
                    class Xh extends Od {
                        constructor(e, t) {
                            super(
                                e,
                                ((e) =>
                                    `\n    <div class=${$h.container}>\n        <div class=${$h.text}>\n            ${e}\n        </div>\n    </div>\n`)(
                                    t,
                                ),
                                { position: 'bottomLeft' },
                            );
                        }
                    }
                    const Yh = { attributes: {}, attribution: '', minZoom: uh, maxZoom: mh };
                    class Kh {
                        constructor(e, t) {
                            (this.options = Mh(t, Yh)),
                                (this._impl = new kd(e._impl, this.options)),
                                (this._attribution = new Xh(e, this.options.attribution));
                        }
                        destroy() {
                            this._impl.destroy(), this._attribution.destroy();
                        }
                        setAttributes(e) {
                            return this._impl.setAttributes(e), this;
                        }
                        getAttributes() {
                            return this._impl.getAttributes();
                        }
                    }
                    class Jh {
                        constructor(e, t) {
                            (this.options = t), (this._impl = new dc(e._impl, this.options, this));
                        }
                        destroy() {
                            this._impl.destroy();
                        }
                        setAttributes(e) {
                            return this._impl.setAttributes(e), this;
                        }
                        getAttributes() {
                            return this._impl.getAttributes();
                        }
                        setFeatureStateMap(e) {
                            this._impl.setFeatureStateMap(e);
                        }
                        setFeatureStateMapBinary(e) {
                            this._impl.setFeatureStateMapBinary(e);
                        }
                    }
                    setTimeout(() => {
                        const e = Array.from(document.querySelectorAll('script')).find((e) =>
                            e.src.match('https://mapgl.2gis.com/api/js'),
                        );
                        if (!e) return;
                        const t = (function (e) {
                            const t = e.split('?')[1];
                            if (!t) return;
                            const i = t
                                .split('&')
                                .map((e) => e.split('='))
                                .find((e) => 'callback' === e[0]);
                            return i ? i[1] : void 0;
                        })(e.src);
                        if (t) {
                            if ('function' != typeof window[t])
                                throw new Error(`Not found callback function with name "${t}"`);
                            window[t]();
                        }
                    }, 0);
                    i(2205);
                },
                4713: (e, t, i) => {
                    var n;
                    i.d(t, { l: () => o });
                    class o {
                        constructor(e, t, i = !1) {
                            (this.elementsType = null),
                                (this._glBuffer = null),
                                (this._glContext = null),
                                (this._initData = e),
                                (this.byteLength = 'number' == typeof e ? e : e.byteLength),
                                (this.type = i ? o.ElementArrayBuffer : o.ArrayBuffer),
                                (this.options = Object.assign({}, o.defaultOptions, t)),
                                (this.drawType = this.options.instanceDivisor
                                    ? o.DynamicDraw
                                    : o.StaticDraw);
                            const n = [o.UnsignedByte, o.UnsignedShort, o.UnsignedInt];
                            i &&
                                !n.includes(this.options.dataType) &&
                                (console.warn(
                                    'Please provide dataType of one of the following values:Buffer.UnsignedByte, Buffer.UnsignedShort, Buffer.UnsignedInt. Defaulting to UnsignedInt',
                                ),
                                (this.options.dataType = o.UnsignedInt));
                        }
                        bind(e, t, i, n) {
                            if ((this._glBuffer || this.prepare(e), this.type === o.ArrayBuffer)) {
                                e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer),
                                    (t = t || 0),
                                    (i = i || this.options);
                                const o = this._toGlParam(e, i.dataType) || e.FLOAT;
                                e.vertexAttribPointer(
                                    t,
                                    i.itemSize,
                                    o,
                                    i.normalized,
                                    i.stride,
                                    i.offset,
                                ),
                                    this._hasRealWebGLContext() &&
                                        i.instanceDivisor &&
                                        (e instanceof WebGLRenderingContext
                                            ? n
                                                ? n.vertexAttribDivisorANGLE(t, i.instanceDivisor)
                                                : console.error(
                                                      "Can't set up instanced attribute divisor. Missing ANGLE_instanced_arrays extension",
                                                  )
                                            : e.vertexAttribDivisor(t, i.instanceDivisor));
                            } else
                                this.type === o.ElementArrayBuffer &&
                                    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
                            return this;
                        }
                        remove() {
                            return this._unprepare(), this;
                        }
                        subData(e, t, i) {
                            const n = this._toGlParam(e, this.type) || e.ARRAY_BUFFER;
                            return e.bindBuffer(n, this._glBuffer), e.bufferSubData(n, t, i), this;
                        }
                        prepare(e) {
                            (this._glContext = e), (this._glBuffer = e.createBuffer());
                            const t = this._toGlParam(e, this.type) || e.ARRAY_BUFFER,
                                i = this._toGlParam(e, this.drawType) || e.STATIC_DRAW;
                            return (
                                e.bindBuffer(t, this._glBuffer),
                                e.bufferData(t, this._initData, i),
                                (this._initData = null),
                                this
                            );
                        }
                        getGLType(e) {
                            return this._toGlParam(e, this.options.dataType);
                        }
                        _unprepare() {
                            this._glBuffer &&
                                this._glContext &&
                                (this._glContext.deleteBuffer(this._glBuffer),
                                (this._glBuffer = null),
                                (this._glContext = null));
                        }
                        _toGlParam(e, t) {
                            return t === o.ArrayBuffer
                                ? e.ARRAY_BUFFER
                                : t === o.ElementArrayBuffer
                                ? e.ELEMENT_ARRAY_BUFFER
                                : t === o.StaticDraw
                                ? e.STATIC_DRAW
                                : t === o.DynamicDraw
                                ? e.DYNAMIC_DRAW
                                : t === o.Byte
                                ? e.BYTE
                                : t === o.Short
                                ? e.SHORT
                                : t === o.Int
                                ? e.INT
                                : t === o.Float
                                ? e.FLOAT
                                : t === o.UnsignedByte
                                ? e.UNSIGNED_BYTE
                                : t === o.UnsignedShort
                                ? e.UNSIGNED_SHORT
                                : t === o.UnsignedInt
                                ? e.UNSIGNED_INT
                                : null;
                        }
                        _hasRealWebGLContext() {
                            return (
                                'undefined' != typeof window &&
                                ('WebGLRenderingContext' in window ||
                                    'WebGL2RenderingContext' in window)
                            );
                        }
                    }
                    (n = o),
                        (o.ArrayBuffer = 1),
                        (o.ElementArrayBuffer = 2),
                        (o.StaticDraw = 10),
                        (o.DynamicDraw = 11),
                        (o.Float = 20),
                        (o.UnsignedByte = 21),
                        (o.UnsignedShort = 22),
                        (o.UnsignedInt = 23),
                        (o.Byte = 24),
                        (o.Short = 25),
                        (o.Int = 26),
                        (o.defaultOptions = {
                            itemSize: 3,
                            dataType: n.Float,
                            stride: 0,
                            offset: 0,
                            normalized: !1,
                            instanceDivisor: 0,
                        });
                },
                9218: (e, t, i) => {
                    i.r(t),
                        i.d(t, {
                            MAP_DEFAULTS: () => r,
                            analytics: () => g,
                            atlasSize: () => h,
                            buildingAnimation: () => x,
                            camera: () => E,
                            commercialCitySublayers: () => O,
                            commercialPoi: () => a,
                            commercialSublayers: () => D,
                            defaultLang: () => P,
                            defaultMarkerAnchor: () => U,
                            defaultMarkerIcon: () => N,
                            entranceAnimation: () => S,
                            events: () => v,
                            fences: () => z,
                            floors: () => A,
                            fonts: () => f,
                            houseHover: () => b,
                            icons: () => p,
                            identify: () => I,
                            inertia: () => k,
                            labeling: () => M,
                            landmarkPoiSublayers: () => j,
                            landmarkRasterSizes: () => B,
                            loadModelsInfoStyleZoom: () => d,
                            metricsTimeout: () => F,
                            modelCacheSize: () => c,
                            models: () => l,
                            performanceCheck: () => C,
                            personalSublayers: () => R,
                            render: () => T,
                            styles: () => _,
                            tileAnimation: () => w,
                            tiles: () => s,
                            traffic: () => m,
                            urls: () => u,
                            workerResetDebounceTime: () => y,
                            zoom: () => L,
                        });
                    var n = i(1e3),
                        o = i(6849);
                    const r = { minZoom: 2, maxZoom: 20 },
                        s = {
                            protocol: n.X ? '%TILES_PROTOCOL%' : 'https',
                            server: o.X,
                            subdomains: '0123',
                            tileSet: n.X ? '%TILESET%' : 'vector_b',
                            tileKey: 'empty',
                            appId: 'empty',
                            cacheRatio: 2,
                            maxUniverseZoom: 8,
                            maxRegionalZoom: 15,
                            maxDetailLevel: 17,
                        },
                        a = {
                            minZoom: 10,
                            maxZoom: 14,
                            tileSet: 'com_poi_web',
                            rasterSizes: [96, 84, 72, 60, 48, 36, 24],
                        },
                        l = { minZoom: 15, maxZoom: 15, tileSet: 'vector_immersive' },
                        c = 100,
                        d = 13.5,
                        h = [2048, 2048],
                        u = {
                            tiles: '{protocol}://{host}/vt?r={request}&ts={tileSet}&key={tileKey}&appId={appId}&lang={lang}&default_lang={defaultLang}&s={sessionId}',
                            metatile:
                                '{protocol}://{host}/metafiles/{hash}/metatile.json?ts={tileSet}',
                            modelInfo:
                                '{protocol}://{host}/metafiles/{regionId}/models.json?ts={tileSet}',
                            model: '{protocol}://{host}/metafiles/{regionId}/{name}?ts={tileSet}',
                            gltfModel: '{protocol}://{host}/metafiles/{modelSrc}?ts={tileSet}',
                            convertData:
                                '{protocol}://{host}/metafiles/{hash}/convert.json?ts={tileSet}',
                            dynamicPoi:
                                '{protocol}://{host}/metafiles/{regionId}/poi/{id}_{width}_{height}.png?ts={tileSet}',
                            models: '{protocol}://{host}/v2/ald?ts={tileSet}&x={x}&y={y}&z={z}',
                            commercialPoi:
                                '{protocol}://{host}/v2/ald?ts={tileSet}&x={x}&y={y}&z={z}&lang={lang}',
                        },
                        m = {
                            protocol: n.X ? '%TRAFFIC_PROTOCOL%' : 'https',
                            host: o._A,
                            url: '{protocol}://{host}/tiles?tls={tiles}&reg={regions}&tm={time}&fmt=json&z={z}',
                            timestampUrl: '{protocol}://{host}/meta?reg={regions}&time&score',
                            updateInterval: 12e4,
                            minZoom: 10,
                            maxZoom: 16,
                            maxDetailLevel: 17,
                        },
                        f = {
                            defaultUrl: o.hs,
                            gamma: 0.08,
                            baseSize: 24,
                            baseLineHeight: 1.2,
                            bomCharCode: 65279,
                        },
                        p = { defaultUrl: o.R_ },
                        _ = { url: o.k1, path: 'styles/{id}' },
                        v = {
                            doubleClickTime: 185,
                            dragThreshold: 2,
                            pitchWaitingTime: 200,
                            pitchThreshold: 7,
                        },
                        g = { gaCode: 'UA-25529177-4', gaName: 'mapglEngine' },
                        y = 3e3,
                        b = {
                            inAnimationTime: 180,
                            inAnimationType: 'linear',
                            outAnimationTime: 800,
                            outAnimationType: 'linear',
                        },
                        w = { time: 300, type: 'linear' },
                        x = { minStyleZoom: 16, duration: 500, easing: 'easeOutQuint' },
                        S = {
                            bounceType: 'easeOutElastic',
                            bounceTime: 750,
                            growType: 'easeInOutQuad',
                            growTime: 750,
                            stagger: 0,
                        },
                        I = {
                            pixelDensity: 0.5,
                            sceneOpacity: 0,
                            cacheDebounceTime: 400,
                            pickDistance: 3,
                        },
                        M = {
                            interval: 220,
                            animationTime: 200,
                            animationType: 'linear',
                            tileMultiplier: 1.5,
                            axisAngleToleranceDeg: 45,
                            axisCheckDistancePx: 13,
                            commercialMargins: {
                                default: { topBottom: 60, leftRight: 60 },
                                city: { topBottom: 500, leftRight: 500 },
                            },
                            lineLabelsHidePitchDeg: 40,
                            maxLabelLength: 30,
                        },
                        T = { alwaysRerender: !1, autoResizeInterval: 50 },
                        P = 'en',
                        L = {
                            mouseDelta: 0.65,
                            macTouchDelta: 0.0018,
                            animDuration: 400,
                            throttleDelay: 100,
                            mouseRotateDelta: 2.5,
                            mousePitchDelta: 2.5,
                            mobilePinchDelta: 1,
                            mobileTapDelta: 10,
                        },
                        k = { duration: 1300, maxSpeed: 8, minSpeed: 0.02, nonLinearity: 5 },
                        E = {
                            fov: (Math.PI / 180) * 60,
                            near: 1e3,
                            far: Math.pow(2, 34),
                            minCalculationScreenHeight: 1e3,
                            viewportLimitRatio: 2,
                            perspectiveDistanceLimitRatio: 10,
                        },
                        A = {
                            enabled: !0,
                            url: o.kv,
                            displayStyleZoom: 17,
                            wallHeight: 800,
                            islandHeight: 400,
                            wallMinBrightness: 0.8265,
                            wallMaxBrightness: 0.95,
                            viewportPadding: 0.2,
                        },
                        z = { lightIntensity: 0.1 },
                        C = { fpsCaveat: 10 },
                        F = 3e4,
                        O = ['Commercial_poi_city'],
                        D = [
                            'Commercial_poi_default',
                            'Commercial_poi_custom',
                            'Commercial_poi_navi',
                            ...O,
                        ],
                        R = ['s_personal_poi'],
                        j = ['Landmark_poi', 'Landmark_point'],
                        B = [105, 84, 63, 42, 21],
                        N =
                            'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzBweCIgaGVpZ2h0PSI0OHB4IiB2aWV3Qm94PSIwIDAgMzAgNDgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA1MS4yICg1NzUxOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+PHRpdGxlPlBhZ2UgMSBDb3B5PC90aXRsZT48ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjUwJSIgeTE9IjUwJSIgeDI9IjUwJSIgeTI9IjAlIiBpZD0ibGluZWFyR3JhZGllbnQtMSI+PHN0b3Agc3RvcC1jb2xvcj0iIzFCODlFRSIgb2Zmc2V0PSIwJSI+PC9zdG9wPjxzdG9wIHN0b3AtY29sb3I9IiMzMTk4RUMiIG9mZnNldD0iMTAwJSI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxnIGlkPSJSZWNvdmVyeS0wMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTgzOS4wMDAwMDAsIC00MjUuMDAwMDAwKSI+PGcgaWQ9IlBhZ2UtMS1Db3B5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MzkuMDAwMDAwLCA0MjUuMDAwMDAwKSI+PGVsbGlwc2UgaWQ9Ik92YWwtMyIgZmlsbD0iIzAwMDAwMCIgb3BhY2l0eT0iMC4wMzYzODA1OTciIGN4PSIxNSIgY3k9IjQ1LjUiIHJ4PSIzIiByeT0iMS41Ij48L2VsbGlwc2U+PGVsbGlwc2UgaWQ9Ik92YWwtMy1Db3B5IiBmaWxsPSIjMDAwMDAwIiBvcGFjaXR5PSIwLjAzNjM4MDU5NyIgY3g9IjE1IiBjeT0iNDUuNSIgcng9IjQuNSIgcnk9IjIuNSI+PC9lbGxpcHNlPjxwYXRoIGQ9Ik0xNSw0NS44ODM2MzUzIEwxNS44ODIzNTI5LDQ1Ljg4MzYzNTMgQzE1Ljg4MjM1MjksMjkuMjE3NzUyOSAyMC43NzY3NjQ3LDIzLjc5NzQ1ODggMjcuOTg3MzUyOSwyMy43OTc0NTg4IEwyOC4zMjk3MDU5LDIzLjc5NzQ1ODggQzI5LjA3Nzk0MTIsMjEuNTkwNjk0MSAzMCwxNy45OTE1NzY1IDMwLDE1LjAwMDQgQzMwLDcuMTQzOTI5NDEgMjMuNzY3OTQxMiwwLjAwMDQgMTUsMC4wMDA0IEM2LjIzMjA1ODgyLDAuMDAwNCAwLDcuMTQzOTI5NDEgMCwxNS4wMDA0IEMwLDE3Ljk5MTU3NjUgMC45MjIwNTg4MjQsMjEuNTkwNjk0MSAxLjY3MDI5NDEyLDIzLjc5NzQ1ODggTDIuMDEyNjQ3MDYsMjMuNzk3NDU4OCBDOS4yMjQxMTc2NSwyMy43OTc0NTg4IDE0LjExNzY0NzEsMjkuMjE3NzUyOSAxNC4xMTc2NDcxLDQ1Ljg4MzYzNTMgTDE1LDQ1Ljg4MzYzNTMgWiIgaWQ9IkZpbGwtMSIgZmlsbD0idXJsKCNsaW5lYXJHcmFkaWVudC0xKSI+PC9wYXRoPjwvZz48L2c+PC9nPjwvc3ZnPg==',
                        U = [15, 46];
                },
                1e3: (e, t, i) => {
                    i.d(t, { X: () => n });
                    const n = !1;
                },
                6849: (e, t, i) => {
                    i.d(t, {
                        Dd: () => f,
                        LP: () => d,
                        R_: () => c,
                        Sl: () => p,
                        X: () => o,
                        _A: () => r,
                        aT: () => m,
                        hs: () => l,
                        k0: () => u,
                        k1: () => a,
                        kv: () => s,
                        ns: () => h,
                    });
                    var n = i(1e3);
                    const o = n.X ? '%TILESERVER%' : 'tile{subdomain}.maps.2gis.com',
                        r = n.X ? '%TRAFFICSERVER%' : 'jam.api.2gis.com',
                        s = n.X ? '%FLOORSSERVER%' : 'https://floors.api.2gis.ru',
                        a = 'https://styles.api.2gis.com',
                        l = 'https://mapgl.2gis.com/api/fonts',
                        c = 'https://disk.2gis.com/styles/assets/icons',
                        d = 'https://disk.2gis.com/styles/assets/models',
                        h = n.X
                            ? '%KEYSERVER%'
                            : 'https://keys.api.2gis.com/public/v1/keys/{keyID}/services/mapgl-js-api',
                        u = n.X
                            ? '%RTLPLUGIN%'
                            : 'https://mapgl.2gis.com/api/js/plugins/rtl-v1.1.0.js',
                        m = n.X
                            ? '%RTLPLUGINHASH%'
                            : 'sha512-tjMDcrUKh7nDirQujU9fzugiMU5JTlLd/MeeOXm35IK8QVYIt+Fv1lZKEViPQq7wG3nAw6ZcdMVtzas+4mwpGg==',
                        f = 'https://disk.2gis.com/mapgl-api/threejs',
                        p = 'https://mapgl.2gis.com/api/js/plugins/draco_decoder_gltf.js';
                },
                6273: (e, t, i) => {
                    i.d(t, {
                        $U: () => u,
                        Bq: () => a,
                        CW: () => b,
                        Cd: () => S,
                        DL: () => w,
                        Fg: () => T,
                        Fv: () => v,
                        Gt: () => f,
                        Jv: () => P,
                        L2: () => x,
                        LF: () => h,
                        Rw: () => p,
                        Uo: () => y,
                        _9: () => s,
                        _H: () => l,
                        ax: () => m,
                        ed: () => r,
                        gt: () => c,
                        jO: () => d,
                        p7: () => g,
                        rx: () => I,
                        sX: () => o,
                        uC: () => M,
                        vL: () => _,
                        y4: () => n,
                    });
                    const n = 256,
                        o = Math.pow(2, 32),
                        r = o / 2,
                        s = Math.pow(2, 20),
                        a = Math.pow(2, 15),
                        l = Math.pow(2, 16) - 1,
                        c = a / l,
                        d = 16383,
                        h = 2.54,
                        u = 96,
                        m = o / ((n / u) * h),
                        f = 0.7071067811865475,
                        p = 4294967295,
                        _ = 1175494351e-47,
                        v = 3402823466e29,
                        g = [
                            'Arial',
                            'Helvetica',
                            'HelveticaNeueCyr',
                            'Open_Sans',
                            'Open_Sans_Semibold',
                            'Open_Sans_Italic',
                            'Segoe_UI',
                            'PT_Sans_Caption',
                            'PT_Sans',
                            'Verdana',
                            'Verdana_bold',
                            'Noto_Sans',
                            'Noto_Sans_Semibold',
                            'Noto_Sans_Italic',
                            'SuisseIntl_Bold',
                        ],
                        y = 'Noto_Sans',
                        b = 0.5,
                        w = -3,
                        x = -4,
                        S = 2147483647,
                        I = 'eb10e2c3-3c28-4b81-b74b-859c9c4cf47e',
                        M = 5,
                        T = 4,
                        P = 40;
                },
                3249: (e, t, i) => {
                    i.d(t, { FJ: () => p, hX: () => _, jf: () => d });
                    var n = i(6479),
                        o = i(7188),
                        r = i(6273),
                        s = i(7464),
                        a = i(4575),
                        l = i(8450),
                        c = i(412);
                    const d = 0,
                        h = {
                            type: n.f.Loaded,
                            index: -1,
                            key: (0, s.PR)('', 0.5, 0.5),
                            isSvg: !1,
                            name: '',
                            fileName: '',
                            rasters: [],
                        },
                        u = ['default', 'marker', 'markerText', 'htmlLabel'],
                        m = { default: 0, marker: 1, markerText: 2, htmlLabel: 3 },
                        f = {
                            default: { default: !0, marker: !1, markerText: !0, htmlLabel: !0 },
                            marker: { default: !1, marker: !1, markerText: !0, htmlLabel: !1 },
                            markerText: { default: !0, marker: !0, markerText: !0, htmlLabel: !1 },
                            htmlLabel: { default: !0, marker: !1, markerText: !1, htmlLabel: !1 },
                        };
                    function p(e) {
                        const t = [],
                            i = Object.keys(o.Dz).length;
                        for (let e = 0; e < i; e++) t[e] = NaN;
                        for (const i in e) {
                            if (void 0 === o.Dz[i]) throw new Error(`No such tile prop '${i}'`);
                            t[o.Dz[i]] = e[i];
                        }
                        return t;
                    }
                    class _ {
                        constructor() {
                            (this.style = {
                                id: d,
                                revision: 0,
                                background: { color: (0, c.MV)('f6f2de') },
                                light: {
                                    ambientColor: { type: 'color', value: [1, 1, 1] },
                                    direction: [1, 0, 0],
                                },
                                layers: [],
                                layersById: {},
                                layerIdToInnerId: {},
                                groupsById: {},
                                iconBaseUrl: '',
                                fontUrlTemplate: '',
                                modelsBaseUrl: '',
                                rasterSets: { byIndex: {}, byKey: {} },
                                labelingGroups: { indexToGroup: u, groupToIndex: m, table: f },
                                fonts: r.p7,
                                fontNameToIndex: (0, l.PU)(r.p7),
                                icons: {},
                                models: [],
                                modelIndex: {},
                                dem: (0, a.vR)({}),
                                environment: (0, a.kZ)({}),
                            }),
                                (this.needRenderIndexRebuild = !1),
                                (this.zIndexById = {});
                            const e = (0, a.qw)({
                                type: 'line',
                                id: 'debug-tile-bounds',
                                minzoom: -1 / 0,
                                maxzoom: 1 / 0,
                                style: { color: '#ff0000', width: 1 },
                            });
                            e && this.addLayer(e, 0);
                        }
                        getStyle() {
                            return this.style;
                        }
                        appendRasterSet(e, t) {
                            (this.style.rasterSets.byIndex[e.index] = e),
                                void 0 !== t && (this.style.rasterSets.byKey[t] = e);
                        }
                        removeRasterSet(e) {
                            this.style.rasterSets.byIndex[e] = h;
                        }
                        getLabelingGroupIndex(e) {
                            const { groupToIndex: t } = this.style.labelingGroups;
                            return void 0 !== t[e] ? t[e] : t.default;
                        }
                        addLayer(e, t) {
                            this.style.layers.push(e),
                                (this.style.layersById[e.innerId] = e),
                                void 0 !== t && (this.zIndexById[e.innerId] = t),
                                (this.needRenderIndexRebuild = !0);
                        }
                        removeLayer(e) {
                            const t = this.style.layersById[e];
                            if (!t) return;
                            const i = this.style.layers.indexOf(t);
                            -1 !== i && this.style.layers.splice(i, 1),
                                delete this.style.layersById[e];
                        }
                        update() {
                            this.needRenderIndexRebuild &&
                                (this.rebuildRenderIndex(), (this.needRenderIndexRebuild = !1));
                        }
                        updateLayerStyle(e, { style: t, dataKeys: i }) {
                            const n = this.style.layersById[e];
                            n && ((n.style = t), (n.dataKeys = i));
                        }
                        rebuildRenderIndex() {
                            this.style.layers.sort((e, t) => {
                                var i, n;
                                return (
                                    (null !== (i = this.zIndexById[e.innerId]) && void 0 !== i
                                        ? i
                                        : 0) -
                                    (null !== (n = this.zIndexById[t.innerId]) && void 0 !== n
                                        ? n
                                        : 0)
                                );
                            });
                            for (let e = 0; e < this.style.layers.length; e++)
                                this.style.layers[e].renderIndex = e;
                        }
                    }
                },
                7293: (e, t, i) => {
                    i.d(t, { f9: () => r, q$: () => s, uq: () => o });
                    var n = i(314);
                    function o(e, t) {
                        const i = t.dataKeys;
                        return e.map((e, t) => (i[t].usage === n.Z.Uniform ? e : null));
                    }
                    function r(e) {
                        return { 1: n.Z.Uniform, 2: n.Z.Labeling, 3: n.Z.Generator }[e];
                    }
                    function s(e) {
                        return e === n.Z.Uniform
                            ? '1'
                            : e === n.Z.Labeling
                            ? '2'
                            : e === n.Z.Generator
                            ? '3'
                            : '';
                    }
                },
                412: (e, t, i) => {
                    i.d(t, { MV: () => l, RY: () => a, gC: () => s, iL: () => r });
                    var n = i(7464);
                    const o = (0, n.lK)([255, 0, 0, 255]);
                    function r(e) {
                        return (
                            'string' == typeof e &&
                            /(#(?:[0-9a-f]{2}){2,4}|#[0-9a-f]{3}|(?:rgba?|hsla?)\((?:\d+%?(?:,|\s)+){2,3}[\s\/]*[\d\.]+%?\))/i.test(
                                e,
                            )
                        );
                    }
                    function s(e) {
                        return !!e && 'object' == typeof e && 'color' === e.type;
                    }
                    function a(e) {
                        return !!e && 'object' == typeof e && 'gradient-color' === e.type;
                    }
                    function l(e) {
                        const t = e.toLowerCase();
                        let i = o;
                        switch (t[0]) {
                            case '#':
                                i = (function (e) {
                                    if (
                                        !new RegExp(`^#[a-f0-9]{${e.length - 1}}$`).test(e) ||
                                        ![4, 5, 7, 9].includes(e.length)
                                    )
                                        return o;
                                    const t = (function (e) {
                                            if (e.length < 7)
                                                return (
                                                    e[0] +
                                                    e[1] +
                                                    e[1] +
                                                    e[2] +
                                                    e[2] +
                                                    e[3] +
                                                    e[3] +
                                                    (5 === e.length ? e[4] + e[4] : 'ff')
                                                );
                                            if (7 === e.length) return e + 'ff';
                                            return e;
                                        })(e),
                                        i = parseInt(t[1] + t[2], 16),
                                        r = parseInt(t[3] + t[4], 16),
                                        s = parseInt(t[5] + t[6], 16),
                                        a = parseInt(t[7] + t[8], 16);
                                    return (0, n.lK)([i, r, s, a]);
                                })(t);
                                break;
                            case 'h':
                                i = (function (e) {
                                    const t = c(e);
                                    (t[0] /= 360), (t[1] /= 100), (t[2] /= 100);
                                    const [i, o, r] = (function (e, t, i) {
                                            if (0 === t) return [255 * i, 255 * i, 255 * i];
                                            const n = i < 0.5 ? i * (1 + t) : i + t - i * t,
                                                o = 2 * i - n;
                                            return [
                                                255 * d(o, n, e + 1 / 3),
                                                255 * d(o, n, e),
                                                255 * d(o, n, e - 1 / 3),
                                            ];
                                        })(t[0], t[1], t[2]),
                                        s = void 0 !== t[3] ? 255 * t[3] : 255;
                                    return (0, n.lK)([
                                        Math.round(i),
                                        Math.round(o),
                                        Math.round(r),
                                        Math.round(s),
                                    ]);
                                })(t);
                                break;
                            case 'r':
                                i = (function (e) {
                                    const [t, i, o, r] = c(e),
                                        s = void 0 !== r ? 255 * r : 255;
                                    return (0, n.lK)([
                                        Math.round(t),
                                        Math.round(i),
                                        Math.round(o),
                                        Math.round(s),
                                    ]);
                                })(t);
                        }
                        return i;
                    }
                    function c(e) {
                        return e
                            .split('(')[1]
                            .split(')')[0]
                            .split(',')
                            .map((e) => parseFloat(e));
                    }
                    function d(e, t, i) {
                        return (
                            i < 0 && (i += 1),
                            i > 1 && (i -= 1),
                            i < 1 / 6
                                ? e + 6 * (t - e) * i
                                : i < 0.5
                                ? t
                                : i < 2 / 3
                                ? e + (t - e) * (2 / 3 - i) * 6
                                : e
                        );
                    }
                },
                4575: (e, t, i) => {
                    i.d(t, {
                        Jn: () => z,
                        vR: () => D,
                        kZ: () => R,
                        ys: () => k,
                        Wy: () => A,
                        z8: () => E,
                        Cp: () => L,
                        qw: () => O,
                    });
                    var n = i(412),
                        o = i(3754),
                        r = i(7464),
                        s = i(314),
                        a = i(1284),
                        l = i(6273),
                        c = i(6479),
                        d = i(2543);
                    function h(e) {
                        const t = (function (e) {
                                const t = (e.groups || [])
                                        .concat(o.YW.groups)
                                        .reduce((e, t) => (e.includes(t) || e.push(t), e), []),
                                    i = (e.overlay || [])
                                        .concat(o.YW.overlay)
                                        .concat(
                                            t.reduce(
                                                (e, t) => (
                                                    t === o.T_ ||
                                                        t === o.R_ ||
                                                        t === o.n3 ||
                                                        e.push([t, o.R_]),
                                                    e
                                                ),
                                                [],
                                            ),
                                        )
                                        .reduce((e, i) => {
                                            const n = [];
                                            for (const e of i) t.includes(e) && n.push(e);
                                            return (
                                                n.length > 1 && e.push(n),
                                                1 === i.length && 1 === n.length && e.push(n),
                                                e
                                            );
                                        }, []);
                                return { groups: t, overlay: i, intersect: o.YW.intersect };
                            })(e),
                            { groups: i, table: n } = (function (e) {
                                const { groups: t, overlay: i, intersect: n } = e,
                                    o = t.reduce((e, t, i) => ((e[t] = i), e), {}),
                                    r = [];
                                for (let e = 0; e < t.length; e++) {
                                    const e = [];
                                    for (let i = 0; i < t.length; i++) e.push(!0);
                                    r.push(e);
                                }
                                for (let e = 0; e < i.length; e++) {
                                    const t = i[e];
                                    for (let e = 0; e < t.length; e++)
                                        for (let i = e + 1; i < t.length; i++) {
                                            const n = o[t[e]],
                                                s = o[t[i]];
                                            (r[n][s] = !1), (r[s][n] = !1);
                                        }
                                }
                                for (let e = 0; e < n.length; e++) {
                                    const t = n[e];
                                    for (let e = 0; e < t.length; e++)
                                        for (let i = e + 1; i < t.length; i++) {
                                            const n = o[t[e]],
                                                s = o[t[i]];
                                            (r[n][s] = !0), (r[s][n] = !0);
                                        }
                                }
                                return { groups: t, table: r };
                            })(t),
                            r = {};
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e],
                                o = i[e];
                            r[o] = {};
                            for (let s = 0; s < t.length; s++) {
                                const t = i[s];
                                r[o][t] = n[e][s];
                            }
                        }
                        const s = i.reduce((e, t, i) => ((e[t] = i), e), {});
                        return { indexToGroup: i, groupToIndex: s, table: r };
                    }
                    var u = i(8450),
                        m = i(2627),
                        f = i(132),
                        p = i(199);
                    const _ = {
                        verticalScale: ['interpolate', ['linear'], ['zoom'], 11, 0, 12, 1.2],
                        shadingIntensity: ['interpolate', ['linear'], ['zoom'], 13, 0, 14, 0.19],
                    };
                    function v(e) {
                        const t = {};
                        let i = 0;
                        for (const n in e) (t[n] = i), (i += 1);
                        return t;
                    }
                    var g = i(7293);
                    let y = Number.MIN_SAFE_INTEGER;
                    function b() {
                        return y++;
                    }
                    const w = b(),
                        x = b();
                    class S extends Error {
                        constructor(e) {
                            super(`Unknown expression type '${e[0]}' in '${JSON.stringify(e)}'`),
                                (this.name = 'UnknownExpressionTypeError'),
                                Object.setPrototypeOf(this, new.target.prototype);
                        }
                    }
                    function I(e, t, i = s.Z.Uniform) {
                        if ((0, r.aH)(e)) return (0, n.iL)(e) ? (0, n.MV)(e) : e;
                        switch (e[0]) {
                            case 'coalesce':
                                return (function (e, t, i) {
                                    return {
                                        type: 'coalesce',
                                        array: e.slice(1).map((e) => {
                                            try {
                                                return I(e, t, i);
                                            } catch (e) {
                                                return (
                                                    console.debug(
                                                        `Unknown expression in coalesce: ${e}`,
                                                    ),
                                                    null
                                                );
                                            }
                                        }),
                                    };
                                })(e, t, i);
                            case 'all':
                                return (function (e, t, i) {
                                    return {
                                        type: 'all',
                                        array: e.slice(1).map((e) => I(e, t, i)),
                                    };
                                })(e, t, i);
                            case 'any':
                                return (function (e, t, i) {
                                    return {
                                        type: 'any',
                                        array: e.slice(1).map((e) => I(e, t, i)),
                                    };
                                })(e, t, i);
                            case 'match':
                                return (function (e, t, i) {
                                    const n = {
                                            type: 'match',
                                            input: I(e[1], t, i),
                                            cases: [],
                                            defaultOutput: I(e[e.length - 1], t, i),
                                        },
                                        o = e.slice(2, -1);
                                    for (let e = 0; e < o.length; e += 2) {
                                        const r = o[e].reduce(
                                                (e, t) => (
                                                    'boolean' == typeof t && e.push(Number(t)),
                                                    e.push(t),
                                                    e
                                                ),
                                                [],
                                            ),
                                            s = { values: new Set(r), output: I(o[e + 1], t, i) };
                                        n.cases.push(s);
                                    }
                                    return n;
                                })(e, t, i);
                            case 'in':
                                return (function (e, t, i) {
                                    const n = I(e[1], t, i),
                                        o = e[2][0];
                                    if ('get' !== o && 'global' !== o && 'sourceAttr' !== o)
                                        throw new Error(
                                            'InExpression supports only get, global or source attr expression as a second argument',
                                        );
                                    const r = I(e[2], t, i);
                                    return { type: 'in', element: n, array: r };
                                })(e, t, i);
                            case 'interpolate':
                                return T(e, t, i);
                            case 'step':
                                return (function (e, t, i) {
                                    const n = { type: 'step', steps: [], value: I(e[1], t, i) },
                                        o = { key: 0, value: I(e[2], t, i) };
                                    n.steps.push(o);
                                    const r = e.slice(3);
                                    for (let e = 0; e < r.length; e += 2) {
                                        const o = { key: r[e], value: I(r[e + 1], t, i) };
                                        n.steps.push(o);
                                    }
                                    return n;
                                })(e, t, i);
                            case 'featureState':
                                return (function (e, t, i) {
                                    const n = e[0],
                                        o = (0, m.qS)(e[1]);
                                    return {
                                        type: n,
                                        dataIndex: t
                                            ? t.getUniqueIndex(`${(0, g.q$)(i)}:${n}:${o}`)
                                            : NaN,
                                        property: o,
                                    };
                                })(e, t, i);
                            case 'get':
                            case 'sourceAttr':
                            case 'global':
                                return P(e, t, i);
                            case 'zoom':
                                return { type: 'zoom' };
                            case 'height':
                                return { type: 'height' };
                            case 'heatmap-density':
                                return { type: 'heatmap-density' };
                            case 'shading-intensity':
                                return { type: 'shading-intensity' };
                            case 'to-boolean':
                            case 'to-color':
                            case '!':
                            case 'log10':
                                return (function (e, t, i) {
                                    return { type: e[0], value: I(e[1], t, i) };
                                })(e, t, i);
                            case '==':
                            case '!=':
                            case '<':
                            case '<=':
                            case '>':
                            case '>=':
                                return (function (e, t, i) {
                                    const n = I(e[1], t, i),
                                        o = I(e[2], t, i);
                                    return { type: e[0], leftValue: n, rightValue: o };
                                })(e, t, i);
                            case '+':
                                return (function (e, t) {
                                    return { type: '+', array: e.slice(1).map((e) => I(e, t)) };
                                })(e, t);
                            case '*':
                                return (function (e, t) {
                                    return { type: '*', array: e.slice(1).map((e) => I(e, t)) };
                                })(e, t);
                            case '^':
                                return (function (e, t, i) {
                                    const n = I(e[1], t, i),
                                        o = I(e[2], t, i);
                                    return { type: '^', base: n, exponent: o };
                                })(e, t, i);
                            case 'random':
                                return (function (e, t) {
                                    const i = I(e[1], t),
                                        n = I(e[2], t);
                                    return { type: 'random', start: i, end: n };
                                })(e, t);
                            case 'literal':
                                return Array.isArray(e[1])
                                    ? (function (e, t) {
                                          return {
                                              type: 'literalArray',
                                              array: e[1].map((e) => I(e, t)),
                                          };
                                      })(e, t)
                                    : e[1];
                            case 'isBehindObjects':
                                return { type: 'isBehindObjects' };
                            default:
                                throw new S(e);
                        }
                    }
                    function M(e, t, i) {
                        return void 0 === e ? e : I(e, t, i);
                    }
                    function T(e, t, i) {
                        const n = {
                            type: 'interpolate',
                            base: 1,
                            argument: I(e[2], t, i),
                            steps: [],
                        };
                        'exponential' === e[1][0] && void 0 !== e[1][1] && (n.base = e[1][1]);
                        const o = e.slice(3);
                        for (let e = 0; e < o.length; e += 2) {
                            const r = { key: I(o[e], t, i), value: I(o[e + 1], t, i) };
                            n.steps.push(r);
                        }
                        return n;
                    }
                    function P(e, t, i) {
                        const n = e[0],
                            o = (0, m.qS)(e[1]);
                        return {
                            type: n,
                            dataIndex: t ? t.getUniqueIndex(`${(0, g.q$)(i)}:${n}:${o}`) : NaN,
                            property: o,
                        };
                    }
                    function L(e, t, i, o) {
                        var r, s, c, d;
                        const m = o === l.rx ? _ : {},
                            g = D(null !== (r = e.terrain) && void 0 !== r ? r : m),
                            y = R(null !== (s = e.environment) && void 0 !== s ? s : {}),
                            b = {
                                id: t,
                                revision: 0,
                                background: { color: (0, n.MV)(e.background.color) },
                                light: {
                                    ambientColor: { type: 'color', value: [1, 1, 1] },
                                    direction: [1, 0, 0],
                                },
                                layers: [],
                                layersById: { [f.he]: g, [f.t5]: y },
                                layerIdToInnerId: {},
                                groupsById: {},
                                iconBaseUrl: '',
                                fontUrlTemplate: '',
                                modelsBaseUrl: '',
                                fonts: l.p7,
                                fontNameToIndex: (0, u.PU)(l.p7),
                                rasterSets: { byIndex: {}, byKey: {} },
                                icons: e.icons || {},
                                models: Object.values(
                                    null !== (c = e.models) && void 0 !== c ? c : {},
                                ),
                                modelIndex: v(e.models || {}),
                                labelingGroups: h(
                                    null !== (d = e.labelingGroups) && void 0 !== d ? d : {},
                                ),
                                dem: g,
                                environment: y,
                            },
                            w = new a.x();
                        let x = e.layers;
                        i &&
                            (x = (function (e, t) {
                                let i = 0,
                                    n = 0;
                                function o(e, t) {
                                    'custom' !== e.type &&
                                        ((0, u.Kx)(e.filter) && (i = t),
                                        'point' === e.type &&
                                            e.style.iconPriority &&
                                            e.style.iconPriority > n &&
                                            (n = e.style.iconPriority));
                                }
                                return (
                                    e.forEach((e, t) => {
                                        'group' === e.type
                                            ? e.layers.forEach((e) => o(e, t))
                                            : o(e, t);
                                    }),
                                    t.forEach((e) => {
                                        'point' === e.type && (e.style.iconPriority = n);
                                    }),
                                    [...e.slice(0, i + 1), ...t, ...e.slice(i + 1)]
                                );
                            })(e.layers, p.T));
                        for (const e of x) {
                            const t = k(e);
                            if (!t) continue;
                            'group' === t.type &&
                                ((b.groupsById[t.innerId] = t),
                                (b.layerIdToInnerId[t.id] = t.innerId));
                            ('group' === t.type ? t.layers : [t]).forEach((e) => {
                                if (
                                    (b.layers.push(e),
                                    (b.layersById[e.innerId] = e),
                                    (b.layerIdToInnerId[e.id] = e.innerId),
                                    'point' === e.type ||
                                        'polygon' === e.type ||
                                        'roadPointMark' === e.type)
                                ) {
                                    E(e, w).forEach((e) => {
                                        b.rasterSets.byKey[e.key] ||
                                            ((b.rasterSets.byIndex[e.index] = e),
                                            (b.rasterSets.byKey[e.key] = e));
                                    });
                                }
                            });
                        }
                        return b;
                    }
                    function k(e) {
                        return 'group' === e.type
                            ? (function (e) {
                                  var t;
                                  const i = new a.x(),
                                      n =
                                          null === (t = e.orderBy) || void 0 === t
                                              ? void 0
                                              : t.map((e) => P(e, i)),
                                      o = {
                                          id: e.id,
                                          innerId: (0, f.Uv)(),
                                          renderIndex: C.getIndex(),
                                          type: e.type,
                                          layers: [],
                                          orderBy: null != n ? n : [],
                                      };
                                  return (
                                      e.layers.forEach((e, t) => {
                                          const i = O(e, n);
                                          i &&
                                              ((i.groupId = o.innerId),
                                              (i.groupIndex = t),
                                              (i.renderIndex = o.renderIndex),
                                              o.layers.push(i));
                                      }),
                                      o
                                  );
                              })(e)
                            : O(e);
                    }
                    function E(e, t) {
                        const i = [],
                            { image: n, imageType: o, anchor: r } = z(e);
                        return n
                            ? ((0, d.EG)(n).forEach((e) => {
                                  e.length && i.push(A(e, o, t, r));
                              }),
                              i)
                            : i;
                    }
                    function A(e, t, i, n) {
                        const o = 'icon' === t ? (0, r.PR)(e, n[0], n[1]) : (0, r.FD)(e);
                        return {
                            type: c.f.Static,
                            index: i.getUniqueIndex(o),
                            key: o,
                            isSvg: !0,
                            name: e,
                            fileName: e,
                            anchorX: n[0],
                            anchorY: n[1],
                            rasters: [],
                        };
                    }
                    function z(e) {
                        return 'point' === e.type
                            ? {
                                  image: e.style.iconImage,
                                  imageType: 'icon',
                                  anchor: e.style.iconAnchor,
                              }
                            : { image: e.style.textureImage, imageType: 'texture', anchor: [0, 0] };
                    }
                    const C = new a.x();
                    function F(e, t) {
                        return 'appearance' === e.type
                            ? { type: e.type, tipMovementAmplitude: I(e.tipMovementAmplitude, t) }
                            : e;
                    }
                    function O(e, t) {
                        var i;
                        if ('custom' === e.type)
                            return {
                                type: 'custom',
                                id: e.id,
                                innerId: (0, f.Uv)(),
                                renderIndex: C.getIndex(),
                                filter: !1,
                                minzoom: -1 / 0,
                                maxzoom: 1 / 0,
                                dataKeys: [],
                                style: {},
                            };
                        if (!e.style || 'none' === e.style.visibility) return;
                        const n = new a.x(t ? t.length : 0);
                        let l;
                        try {
                            const t = {
                                id: e.id,
                                innerId: (0, f.Uv)(),
                                renderIndex: C.getIndex(),
                                filter: I(e.filter || !1),
                                minzoom: j(e.minzoom, -1 / 0),
                                maxzoom: j(e.maxzoom, 1 / 0),
                                dataKeys: [],
                                farLimit: e.farLimit,
                                webglState: e.webglState,
                            };
                            switch (e.type) {
                                case 'line': {
                                    const i = (0, o.q0)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            width: I(i.width, n),
                                            shift: I(i.shift, n),
                                            zigzag: I(i.zigzag, n),
                                        },
                                    });
                                    break;
                                }
                                case 'lineExtrusion': {
                                    const i = (0, o.l7)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            sideColor: I(i.sideColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                            strokeColor: I(i.strokeColor, n),
                                            height: I(i.height, n),
                                        },
                                    });
                                    break;
                                }
                                case 'polygon': {
                                    const i = (0, o.IJ)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            textureImage: I(i.textureImage, n),
                                            textureSize: i.textureSize,
                                            textureOpacity: I(i.textureOpacity, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                        },
                                    });
                                    break;
                                }
                                case 'roadPolygon': {
                                    const i = (0, o.t7)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                            debug: Boolean(i.debug),
                                        },
                                    });
                                    break;
                                }
                                case 'roadPointMark': {
                                    const i = (0, o.AW)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            textureImage: I(i.textureImage, n),
                                            textureSize: i.textureSize,
                                            markSize: i.markSize,
                                        },
                                    });
                                    break;
                                }
                                case 'polygonExtrusion': {
                                    const i = (0, o.bN)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            topColor: I(i.topColor, n),
                                            sideColor: I(i.sideColor, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                        },
                                    });
                                    break;
                                }
                                case 'dashedLine': {
                                    const i = (0, o.N5)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            gapColor: I(i.gapColor, n),
                                            width: I(i.width, n),
                                            shift: I(i.shift, n),
                                            gapLength: I(i.gapLength, n),
                                            dashLength: I(i.dashLength, n),
                                        },
                                    });
                                    break;
                                }
                                case 'shiftedLine': {
                                    const i = (0, o.sd)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            width: I(i.width, n),
                                            shift: I(i.shift, n),
                                        },
                                    });
                                    break;
                                }
                                case 'oneWayLine': {
                                    const i = (0, o.zn)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            lineWidth: I(i.lineWidth, n),
                                            lineLength: I(i.lineLength, n),
                                            tipWidth: i.tipWidth,
                                            tipHeight: i.tipHeight,
                                            priority: i.priority,
                                            duplicationSpacing: I(i.duplicationSpacing, n),
                                            endingOffsets: i.endingOffsets,
                                            labelingGroup: i.labelingGroup,
                                        },
                                    });
                                    break;
                                }
                                case 'buildingModel': {
                                    const i = (0, o._0)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                        },
                                    });
                                    break;
                                }
                                case 'labelLine': {
                                    const i = (0, o.Ym)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            textField: I(i.textField, n, s.Z.Labeling),
                                            textFont: i.textFont,
                                            textColor: I(i.textColor, n),
                                            textFontSize: I(i.textFontSize, n),
                                            textLetterSpacing: i.textLetterSpacing,
                                            textHaloColor: I(i.textHaloColor, n),
                                            textHaloWidth: i.textHaloWidth,
                                            textPriority: i.textPriority,
                                            textLabelingSideMargin: i.textLabelingSideMargin,
                                            textDuplicationSpacing: I(i.textDuplicationSpacing, n),
                                            labelingGroup: i.labelingGroup,
                                            lineEndingOffsets: i.lineEndingOffsets,
                                        },
                                    });
                                    break;
                                }
                                case 'point': {
                                    const i = (0, o.TI)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            allowOverlap: i.allowOverlap,
                                            allowElevation: i.allowElevation,
                                            elevation: I(i.elevation, n),
                                            iconImage: I(i.iconImage, n),
                                            iconAnchor: i.iconAnchor,
                                            iconOffset: i.iconOffset,
                                            iconWidth: I(i.iconWidth, n),
                                            iconTextField: I(i.iconTextField, n, s.Z.Labeling),
                                            iconTextFont: M(i.iconTextFont, n),
                                            iconTextAnchor: i.iconTextAnchor,
                                            iconTextOffset: i.iconTextOffset,
                                            iconTextColor: I(i.iconTextColor, n),
                                            iconTextFontSize: I(i.iconTextFontSize, n),
                                            iconTextLineHeight: i.iconTextLineHeight,
                                            iconTextLetterSpacing: i.iconTextLetterSpacing,
                                            iconTextPadding: i.iconTextPadding,
                                            iconTextHaloWidth: (0, r.Wx)(i.iconTextHaloWidth),
                                            iconTextHaloColor: I(i.iconTextHaloColor, n),
                                            iconOpacity: I(i.iconOpacity, n),
                                            iconPriority: i.iconPriority,
                                            iconLabelingMargin: i.iconLabelingMargin,
                                            iconLabelingGroup: i.iconLabelingGroup,
                                            iconRotation: I(i.iconRotation, n),
                                            textField: I((0, r.Wx)(i.textField), n, s.Z.Labeling),
                                            textFont: I((0, r.Wx)(i.textFont), n),
                                            textColor: I((0, r.Wx)(i.textColor), n),
                                            textFontSize: I((0, r.Wx)(i.textFontSize), n),
                                            textLineHeight: (0, r.Wx)(i.textLineHeight),
                                            textLetterSpacing: (0, r.Wx)(i.textLetterSpacing),
                                            textField2: M((0, r._e)(i.textField), n, s.Z.Labeling),
                                            textFont2: M((0, r._e)(i.textFont), n),
                                            textColor2:
                                                M((0, r._e)(i.textColor), n) ||
                                                I((0, r.Wx)(i.textColor), n),
                                            textFontSize2:
                                                M((0, r._e)(i.textFontSize), n) ||
                                                I((0, r.Wx)(i.textFontSize), n),
                                            textMaxLengthPerLine: i.textMaxLengthPerLine,
                                            textPlacement: i.textPlacement,
                                            textPriority: i.textPriority,
                                            textOffset: I((0, r.Wx)(i.textOffset), n),
                                            textOffset2: M((0, r._e)(i.textOffset), n),
                                            textHaloColor: I((0, r.Wx)(i.textHaloColor), n),
                                            textHaloColor2:
                                                M((0, r._e)(i.textHaloColor), n) ||
                                                I((0, r.Wx)(i.textHaloColor), n),
                                            textHaloWidth: (0, r.Wx)(i.textHaloWidth),
                                            textHaloWidth2:
                                                (0, r._e)(i.textHaloWidth) ||
                                                (0, r.Wx)(i.textHaloWidth),
                                            textLabelingMargin: (0, r.Wx)(i.textLabelingMargin),
                                            textLabelingMargin2:
                                                (0, r._e)(i.textLabelingMargin) ||
                                                (0, r.Wx)(i.textLabelingMargin),
                                            textLabelingGroup: (0, r.Wx)(i.textLabelingGroup),
                                            textLabelingGroup2:
                                                (0, r._e)(i.textLabelingGroup) ||
                                                (0, r.Wx)(i.textLabelingGroup),
                                            duplicationSpacing: I(i.duplicationSpacing, n),
                                            endingOffsets: i.endingOffsets,
                                        },
                                    });
                                    break;
                                }
                                case 'arrow': {
                                    const i = (0, o.z4)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            strokeColor: I(i.strokeColor, n),
                                            lineWidth: I(i.lineWidth, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                            tipWidth: I(i.tipWidth, n),
                                            tipHeight: I(i.tipHeight, n),
                                            animation: F(i.animation, n),
                                        },
                                    });
                                    break;
                                }
                                case 'raster': {
                                    const i = (0, o.tC)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: { opacity: I(i.opacity, n) },
                                    });
                                    break;
                                }
                                case 'circle': {
                                    const i = (0, o.th)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeColor2: I(i.strokeColor2, n),
                                            width: I(i.width, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                            strokeWidth2: I(i.strokeWidth2, n),
                                        },
                                    });
                                    break;
                                }
                                case 'heatmap': {
                                    const i = (0, o.Mk)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            color: I(i.color, n),
                                            radius: I(i.radius, n),
                                            opacity: I(i.opacity, n),
                                            intensity: I(i.intensity, n),
                                            weight: I(i.weight, n),
                                            downscale: i.downscale,
                                        },
                                        framebufferId: { framebuffer: s.z },
                                    });
                                    break;
                                }
                                case 'model': {
                                    const r = (0, o.M3)(e.style),
                                        s = null === (i = e.interactive) || void 0 === i || i;
                                    l = Object.assign(Object.assign({}, t), {
                                        interactive: s,
                                        type: 'gltfModel',
                                        style: {
                                            modelSrc: I(r.modelSrc, n),
                                            offset: I(r.offset, n),
                                            scale: I(r.scale, n),
                                            rotation: I(r.rotation, n),
                                            color: I(r.color, n),
                                            linkedIds: I(r.linkedIds),
                                            colorTextureUvIndex: r.colorTextureUvIndex,
                                            useThreeJs: r.useThreeJs,
                                        },
                                    });
                                    break;
                                }
                                case 'overpass': {
                                    const i = (0, o.Jb)(e.style);
                                    l = Object.assign(Object.assign({}, t), {
                                        type: e.type,
                                        style: {
                                            debug: i.debug,
                                            sideColor: I(i.sideColor, n),
                                            bottomColor: I(i.bottomColor, n),
                                            topColor: I(i.topColor, n),
                                            shadingValue: I(i.shadingValue, n),
                                            strokeColor: I(i.strokeColor, n),
                                            strokeWidth: I(i.strokeWidth, n),
                                            clearColor: I(i.clearColor, n),
                                            height: I(i.height, n),
                                            outerHeight: I(i.outerHeight, n),
                                            outerWidth: I(i.outerWidth, n),
                                            color: I(i.color, n),
                                        },
                                    });
                                    break;
                                }
                            }
                        } catch (t) {
                            if (t instanceof S)
                                return void console.warn(`Problem with layer #${e.id}: ${t}`);
                            throw t;
                        }
                        if (l) {
                            l.dataKeys = (function (e) {
                                const t = [];
                                for (const i in e) {
                                    const [n, o, ...r] = i.split(':'),
                                        s = e[i],
                                        a = (0, g.f9)(n);
                                    void 0 !== a &&
                                        (t[s] = { type: o, key: r.join(':'), usage: a });
                                }
                                return t;
                            })(n.getIndexedKeys());
                            for (const e of null != t ? t : [])
                                l.dataKeys[e.dataIndex] = {
                                    type: e.type,
                                    key: e.property,
                                    usage: s.Z.Uniform,
                                };
                            const e = l.dataKeys.findIndex((e) => 'selected' === e.key);
                            -1 !== e && (l.selectedIdx = e);
                        }
                        return l;
                    }
                    function D(e) {
                        const t = (0, o.sy)(e);
                        return {
                            id: 'dem',
                            type: 'dem',
                            innerId: f.he,
                            filter: !0,
                            dataKeys: [],
                            minzoom: -1 / 0,
                            maxzoom: 1 / 0,
                            renderIndex: w,
                            style: {
                                lightingDirection: I(t.lightingDirection),
                                shadingIntensity: I(t.shadingIntensity),
                                shadingPalette: T(t.shadingPalette),
                                verticalScale: I(t.verticalScale),
                            },
                            framebufferId: { elevation: s.z, hillshade: s.z, flatBottom: s.z },
                        };
                    }
                    function R(e) {
                        const t = (0, o.p8)(e);
                        return {
                            id: 'sky',
                            type: 'custom',
                            innerId: f.t5,
                            filter: !0,
                            dataKeys: [],
                            minzoom: -1 / 0,
                            maxzoom: 1 / 0,
                            renderIndex: x,
                            style: {
                                skyColor: I(t.skyColor),
                                fogColor: I(t.color),
                                highColor: I(t.highColor),
                            },
                        };
                    }
                    function j(e, t) {
                        return 'number' != typeof e || Number.isNaN(e) ? t : e;
                    }
                },
                3754: (e, t, i) => {
                    i.d(t, {
                        AW: () => a,
                        IJ: () => r,
                        Jb: () => S,
                        M3: () => x,
                        Mk: () => b,
                        N5: () => f,
                        R_: () => M,
                        TI: () => v,
                        T_: () => P,
                        YW: () => L,
                        Ym: () => u,
                        _0: () => d,
                        bN: () => l,
                        l7: () => h,
                        n3: () => T,
                        p8: () => I,
                        q0: () => c,
                        sd: () => p,
                        sy: () => w,
                        t7: () => s,
                        tC: () => y,
                        th: () => _,
                        z4: () => g,
                        zn: () => m,
                    });
                    var n = i(6490);
                    function o(e, t) {
                        for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
                    }
                    function r(e) {
                        const t = {
                            color: '#000000',
                            textureImage: '',
                            textureSize: 16,
                            textureOpacity: 1,
                            strokeColor: '#00000000',
                            strokeWidth: 1,
                            visibility: 'visible',
                        };
                        return (
                            o(t, e),
                            void 0 !== e.strokeColor ||
                                Boolean(t.textureImage) ||
                                (t.strokeColor = t.color),
                            Array.isArray(t.textureSize)
                                ? (t.textureSize.length
                                      ? 1 === t.textureSize.length &&
                                        (t.textureSize = t.textureSize[0])
                                      : (t.textureSize = 16),
                                  t)
                                : t
                        );
                    }
                    function s(e) {
                        const t = {
                            color: '#000000',
                            strokeColor: '#000000',
                            strokeWidth: 1,
                            visibility: 'visible',
                            debug: !1,
                        };
                        return o(t, e), void 0 === e.strokeColor && (t.strokeColor = t.color), t;
                    }
                    function a(e) {
                        const t = {
                            color: '#FFFFFF',
                            textureImage: '',
                            textureSize: 16,
                            markSize: [1.5, 3],
                            visibility: 'visible',
                        };
                        return (
                            o(t, e),
                            Array.isArray(t.textureSize)
                                ? (t.textureSize.length
                                      ? 1 === t.textureSize.length &&
                                        (t.textureSize = t.textureSize[0])
                                      : (t.textureSize = 16),
                                  t)
                                : t
                        );
                    }
                    function l(e) {
                        const t = {
                            topColor: '#000000',
                            strokeColor: '#000000',
                            strokeWidth: 1,
                            sideColor: '#000000',
                            visibility: 'visible',
                        };
                        return (
                            o(t, e),
                            void 0 === e.strokeColor && (t.strokeColor = t.topColor),
                            void 0 === e.sideColor && (t.sideColor = t.topColor),
                            t
                        );
                    }
                    function c(e) {
                        const t = {
                            color: '#000000',
                            width: 1,
                            shift: 0,
                            zigzag: ['literal', [0, 0]],
                            visibility: 'visible',
                        };
                        return o(t, e), t;
                    }
                    function d(e) {
                        const t = {
                            color: '#000000',
                            strokeColor: '#000000',
                            strokeWidth: 1,
                            visibility: 'visible',
                        };
                        return o(t, e), void 0 === e.strokeColor && (t.strokeColor = t.color), t;
                    }
                    function h(e) {
                        const t = {
                            sideColor: '#000000',
                            strokeColor: '#000000',
                            strokeWidth: 1,
                            height: 0,
                            visibility: 'visible',
                        };
                        return (
                            o(t, e), void 0 === e.strokeColor && (t.strokeColor = t.sideColor), t
                        );
                    }
                    function u(e) {
                        const t = {
                            textField: ['get', 'db_label'],
                            textFont: 'Noto_Sans',
                            textColor: '#000000',
                            textFontSize: 16,
                            textLetterSpacing: 0,
                            textHaloColor: 'rgba(0, 0, 0, 0)',
                            textHaloWidth: 0,
                            textPriority: 0,
                            textLabelingSideMargin: 0,
                            textDuplicationSpacing: 0,
                            lineEndingOffsets: 0,
                            visibility: 'visible',
                            labelingGroup: P,
                        };
                        return o(t, e), t;
                    }
                    function m(e) {
                        const t = {
                            color: '#000000',
                            lineWidth: 2,
                            lineLength: 10,
                            tipWidth: 1.5,
                            tipHeight: 2,
                            priority: 0,
                            duplicationSpacing: 0,
                            endingOffsets: 0,
                            visibility: 'visible',
                            labelingGroup: P,
                        };
                        return o(t, e), t;
                    }
                    function f(e) {
                        const t = {
                            color: '#000000',
                            gapColor: '#00000000',
                            width: 1,
                            shift: 0,
                            gapLength: 1,
                            dashLength: 1,
                            visibility: 'visible',
                        };
                        return o(t, e), t;
                    }
                    function p(e) {
                        const t = { color: '#000000', width: 1, shift: 0, visibility: 'visible' };
                        return o(t, e), t;
                    }
                    function _(e) {
                        const t = {
                            color: '#ffffff',
                            strokeColor: '#3388ff',
                            strokeColor2: '#00000000',
                            width: 20,
                            strokeWidth: 3,
                            strokeWidth2: 0,
                            visibility: 'visible',
                        };
                        return o(t, e), t;
                    }
                    function v(e) {
                        const t = {
                            allowOverlap: !1,
                            allowElevation: !1,
                            elevation: 0,
                            iconOpacity: 1,
                            iconImage: '',
                            iconAnchor: [0.5, 0.5],
                            iconOffset: [0, 0],
                            iconWidth: 16,
                            iconTextField: ['get', 'db_label2'],
                            iconTextFont: '',
                            iconTextAnchor: [0.5, 0.5],
                            iconTextOffset: [0, 0],
                            iconTextColor: '#000000',
                            iconTextFontSize: 16,
                            iconTextLineHeight: 1.2,
                            iconTextLetterSpacing: 0,
                            iconTextPadding: [0, 0, 0, 0],
                            iconTextHaloWidth: 0,
                            iconTextHaloColor: 'rgba(0, 0, 0, 0)',
                            iconPriority: 0,
                            iconRotation: 0,
                            iconLabelingGroup: P,
                            iconLabelingMargin: { topBottom: 0, leftRight: 0 },
                            textField: [
                                ['get', 'db_label'],
                                ['get', 'db_label2'],
                            ],
                            textFont: '',
                            textColor: '#000000',
                            textFontSize: 16,
                            textLineHeight: 1.2,
                            textLetterSpacing: 0,
                            textPlacement: 'bottomCenter',
                            textOffset: 0,
                            textHaloColor: 'rgba(0, 0, 0, 0)',
                            textHaloWidth: 0,
                            textLabelingMargin: { topBottom: 0, leftRight: 0 },
                            textPriority: 0,
                            textMaxLengthPerLine: 30,
                            visibility: 'visible',
                            textLabelingGroup: P,
                            duplicationSpacing: 100,
                            endingOffsets: 0,
                        };
                        return o(t, e), t;
                    }
                    function g(e) {
                        const t = {
                            color: '#000000',
                            strokeColor: '#000000',
                            lineWidth: 1,
                            strokeWidth: 0,
                            tipWidth: 1,
                            tipHeight: 1,
                            animation: { type: 'appearance', tipMovementAmplitude: 0 },
                            visibility: 'visible',
                        };
                        return void 0 === e.strokeColor && (t.strokeColor = t.color), o(t, e), t;
                    }
                    function y(e) {
                        const t = { opacity: 1, visibility: 'visible' };
                        return o(t, e), t;
                    }
                    function b(e) {
                        return (0, n.kn)(e, {
                            color: [
                                'interpolate',
                                ['linear'],
                                ['heatmap-density'],
                                0,
                                'rgba(53, 136, 253, 0)',
                                0.2,
                                'rgba(53, 136, 253, 0.2)',
                                0.4,
                                'rgb(255, 201, 77)',
                                0.6,
                                'rgb(255, 202, 20)',
                                0.75,
                                'rgb(245, 0, 7)',
                                1,
                                'rgb(255, 0, 0)',
                            ],
                            radius: 30,
                            opacity: 1,
                            intensity: 1,
                            weight: 1,
                            downscale: 1,
                            visibility: 'visible',
                        });
                    }
                    function w(e) {
                        return (0, n.kn)(e, {
                            lightingDirection: 315,
                            shadingIntensity: 0.15,
                            verticalScale: 1.2,
                            shadingPalette: [
                                'interpolate',
                                ['exponential', 2],
                                ['shading-intensity'],
                                0,
                                0,
                                1,
                                0.95,
                            ],
                        });
                    }
                    function x(e) {
                        return (0, n.kn)(e, {
                            modelSrc: '',
                            offset: 0,
                            scale: 1,
                            rotation: 0,
                            color: '#fff',
                            linkedIds: '',
                            useThreeJs: !1,
                            visibility: 'visible',
                            colorTextureUvIndex: 0,
                        });
                    }
                    function S(e) {
                        const t = {
                            visibility: 'visible',
                            sideColor: '#000000',
                            topColor: '#000000',
                            bottomColor: '#000000',
                            shadingValue: 0.05,
                            strokeColor: '#000000',
                            strokeWidth: 1,
                            clearColor: '#ffffff',
                            debug: !1,
                            height: 1.5,
                            outerHeight: 3,
                            outerWidth: 0.5,
                            color: '#0000000f',
                        };
                        return (
                            o(t, e),
                            void 0 === e.strokeColor && (t.strokeColor = t.topColor),
                            void 0 === e.sideColor && (t.sideColor = t.topColor),
                            void 0 === e.bottomColor && (t.bottomColor = t.topColor),
                            t
                        );
                    }
                    function I(e) {
                        return (0, n.kn)(e, {
                            skyColor: [
                                'interpolate',
                                ['linear'],
                                ['zoom'],
                                10,
                                '#00000000',
                                15,
                                '#5876C0FF',
                            ],
                            color: '#FFFFFF',
                            highColor: '#DDDDFF',
                        });
                    }
                    const M = '__overlapped',
                        T = '__commercial',
                        P = 'default',
                        L = { groups: [P, M, T], overlay: [[P, M]], intersect: [[]] };
                },
                7464: (e, t, i) => {
                    function n(e) {
                        return (
                            'number' == typeof e ||
                            'boolean' == typeof e ||
                            'string' == typeof e ||
                            null === e
                        );
                    }
                    function o(e) {
                        if (Array.isArray(e)) {
                            const t = e;
                            if (!t.length) return !1;
                            if (
                                {
                                    zoom: !0,
                                    height: !0,
                                    coalesce: !0,
                                    'heatmap-density': !0,
                                    'shading-intensity': !0,
                                    step: !0,
                                    interpolate: !0,
                                    all: !0,
                                    get: !0,
                                    sourceAttr: !0,
                                    featureState: !0,
                                    global: !0,
                                    match: !0,
                                    in: !0,
                                    any: !0,
                                    '!': !0,
                                    '==': !0,
                                    '!=': !0,
                                    '>=': !0,
                                    '>': !0,
                                    '<=': !0,
                                    '<': !0,
                                    'to-boolean': !0,
                                    'to-color': !0,
                                    '+': !0,
                                    '*': !0,
                                    '^': !0,
                                    log10: !0,
                                    random: !0,
                                    literal: !0,
                                    isBehindObjects: !0,
                                }[t[0]]
                            )
                                return !0;
                        }
                        return !1;
                    }
                    function r(e) {
                        return (
                            !Array.isArray(e) &&
                            'object' == typeof e &&
                            null !== e &&
                            void 0 !== e.type &&
                            'color' !== e.type
                        );
                    }
                    function s(e, t) {
                        return !!Array.isArray(e) && e.length > 0 && e.every((e) => typeof e === t);
                    }
                    function a(e) {
                        return s(e, 'number');
                    }
                    function l(e) {
                        const t = typeof e;
                        return (
                            null === e ||
                            'string' === t ||
                            'number' === t ||
                            'boolean' === t ||
                            (function (e) {
                                return (
                                    !Array.isArray(e) &&
                                    'object' == typeof e &&
                                    null !== e &&
                                    'color' === e.type
                                );
                            })(e) ||
                            (function (e) {
                                return s(e, 'string');
                            })(e) ||
                            a(e)
                        );
                    }
                    function c(e) {
                        return r(e) && 'get' === e.type;
                    }
                    function d(e) {
                        return { type: 'color', value: e };
                    }
                    function h(e, t, i) {
                        return `${e}_${t}_${i}`;
                    }
                    function u(e) {
                        return `texture-${e}`;
                    }
                    function m(e, t) {
                        return `unique-${e}_${t}`;
                    }
                    function f(e) {
                        return Array.isArray(e) ? (o(e) ? e : e[0]) : e;
                    }
                    function p(e) {
                        if (Array.isArray(e) && !o(e) && void 0 !== e[1]) return e[1];
                    }
                    i.d(t, {
                        FD: () => u,
                        HW: () => l,
                        PR: () => h,
                        Uu: () => r,
                        Wx: () => f,
                        _e: () => p,
                        aH: () => n,
                        lK: () => d,
                        nS: () => a,
                        vB: () => c,
                        zV: () => m,
                    });
                },
                1284: (e, t, i) => {
                    i.d(t, { x: () => n });
                    class n {
                        constructor(e = 0) {
                            (this.index = e), (this.keysMap = {});
                        }
                        getIndex() {
                            const e = this.index;
                            return (this.index += 1), e;
                        }
                        getUniqueIndex(e) {
                            return (
                                void 0 === this.keysMap[e] &&
                                    ((this.keysMap[e] = this.index), (this.index += 1)),
                                this.keysMap[e]
                            );
                        }
                        getIndexedKeys() {
                            return this.keysMap;
                        }
                    }
                },
                132: (e, t, i) => {
                    i.d(t, { Uv: () => o, he: () => r, t5: () => s });
                    let n = 0;
                    function o() {
                        return n++;
                    }
                    const r = o(),
                        s = o();
                },
                2543: (e, t, i) => {
                    i.d(t, {
                        EG: () => S,
                        FR: () => c,
                        Q9: () => p,
                        UP: () => h,
                        Yi: () => y,
                        bs: () => g,
                        jJ: () => v,
                        m2: () => x,
                        o4: () => _,
                        qv: () => m,
                        vn: () => f,
                        zn: () => u,
                    });
                    var n = i(412),
                        o = i(7464),
                        r = i(309),
                        s = i(3672),
                        a = i(173);
                    const l = null;
                    function c(e, t) {
                        if (!(0, o.Uu)(e)) return e;
                        if (t.allowedExpressions && !t.allowedExpressions.has(e.type))
                            return (0, r.cM)(`Expression of type ${e.type} is not allowed here`), l;
                        switch (e.type) {
                            case 'coalesce':
                                return (function (e, t) {
                                    for (const i of e.array) {
                                        const e = c(i, t);
                                        if (null !== e) return e;
                                    }
                                    return null;
                                })(e, t);
                            case 'all':
                                return (function (e, t) {
                                    return e.array.every((e) => !0 === c(e, t));
                                })(e, t);
                            case 'any':
                                return (function (e, t) {
                                    return e.array.some((e) => !0 === c(e, t));
                                })(e, t);
                            case 'featureState':
                                return (function (e, t) {
                                    var i, n;
                                    if ('binder' === t.type || 'labeling' === t.type)
                                        return null !== (i = d(t.tileData[e.dataIndex])) &&
                                            void 0 !== i
                                            ? i
                                            : null;
                                    {
                                        const i =
                                            null !==
                                                (n = t.featureAttrs[t.tileProps[e.property]]) &&
                                            void 0 !== n
                                                ? n
                                                : null;
                                        return Number.isNaN(i) ? null : d(i);
                                    }
                                })(e, t);
                            case 'get':
                                return (function (e, t) {
                                    var i, n, o;
                                    if ('binder' === t.type || 'labeling' === t.type)
                                        return null !== (i = d(t.tileData[e.dataIndex])) &&
                                            void 0 !== i
                                            ? i
                                            : null;
                                    {
                                        const i =
                                            null !==
                                                (o =
                                                    null === (n = t.tileAttrs) || void 0 === n
                                                        ? void 0
                                                        : n[t.tileProps[e.property]]) &&
                                            void 0 !== o
                                                ? o
                                                : null;
                                        return Number.isNaN(i) ? null : d(i);
                                    }
                                })(e, t);
                            case 'global':
                                return (function (e, t) {
                                    var i;
                                    return null !== (i = t.styleState[e.property]) && void 0 !== i
                                        ? i
                                        : null;
                                })(e, t);
                            case 'sourceAttr':
                                return (function (e, t) {
                                    var i, n;
                                    if ('generator' === t.type)
                                        return null !== (i = t.sourceAttrs[e.property]) &&
                                            void 0 !== i
                                            ? i
                                            : null;
                                    if ('binder' === t.type || 'labeling' === t.type)
                                        return null !== (n = d(t.tileData[e.dataIndex])) &&
                                            void 0 !== n
                                            ? n
                                            : null;
                                    return null;
                                })(e, t);
                            case 'in':
                                return (function (e, t) {
                                    const i = c(e.element, t),
                                        n = c(e.array, t);
                                    if (null === n) return !1;
                                    if (!Array.isArray(n))
                                        return (
                                            (0, r.cM)(
                                                `InExpression second argument resolved to non-array value: ${n}`,
                                            ),
                                            null
                                        );
                                    return n.some((e) => e === i);
                                })(e, t);
                            case 'interpolate':
                                return (function (e, t) {
                                    if (0 === e.steps.length)
                                        return (
                                            (0, r.cM)(
                                                'Interpolate expression contains 0 steps, cannot interpolate',
                                            ),
                                            l
                                        );
                                    const i = c(e.steps[0].value, t),
                                        s = c(e.argument, t);
                                    if ('number' != typeof s)
                                        return (
                                            (0, r.cM)(
                                                `Interpolate value resolved to non-number value: ${s} ${e.argument}`,
                                            ),
                                            0
                                        );
                                    if ((0, n.gC)(i)) {
                                        if ((0, o.Uu)(e.argument) && 'height' === e.argument.type) {
                                            const i = {
                                                type: 'gradient-color',
                                                values: [],
                                                steps: [],
                                            };
                                            return (
                                                e.steps.forEach((e) => {
                                                    const o = f(e.key, t),
                                                        r = c(e.value, t);
                                                    (0, n.gC)(r) &&
                                                        !Number.isNaN(o) &&
                                                        (i.values.push({
                                                            type: 'color',
                                                            value: r.value,
                                                        }),
                                                        i.steps.push(o));
                                                }),
                                                2 !== i.steps.length
                                                    ? ((0, r.cM)(
                                                          'Gradient expression must resolve 2 steps',
                                                      ),
                                                      l)
                                                    : i
                                            );
                                        }
                                        return _(e, s, t);
                                    }
                                    return h(e, s, t);
                                })(e, t);
                            case 'match':
                                return (function (e, t) {
                                    var i;
                                    const n = c(e.input, t),
                                        o = e.cases.find((e) => e.values.has(n));
                                    return c(
                                        null !== (i = null == o ? void 0 : o.output) && void 0 !== i
                                            ? i
                                            : e.defaultOutput,
                                        t,
                                    );
                                })(e, t);
                            case 'step':
                                return (function (e, t) {
                                    const i = Number(c(e.value, t)),
                                        n = b(e, i, t) - 1;
                                    return c(e.steps[n].value, t);
                                })(e, t);
                            case 'to-boolean':
                                return (function (e, t) {
                                    return Boolean(c(e.value, t));
                                })(e, t);
                            case 'to-color':
                                return (function (e, t) {
                                    const i = c(e.value, t);
                                    if ((0, n.iL)(i)) return (0, n.MV)(i);
                                    if ((0, n.gC)(i)) return i;
                                    return (
                                        console.warn(
                                            `Can't resolve expression. Must be color, but got ${i}`,
                                        ),
                                        (0, o.lK)([0, 0, 0, 0])
                                    );
                                })(e, t);
                            case '!':
                                return (function (e, t) {
                                    return !c(e.value, t);
                                })(e, t);
                            case '==':
                            case '!=':
                                return (function (e, t) {
                                    const i = c(e.leftValue, t),
                                        n = c(e.rightValue, t);
                                    switch (e.type) {
                                        case '==':
                                            return i === n;
                                        case '!=':
                                            return i !== n;
                                    }
                                })(e, t);
                            case '>':
                            case '<':
                            case '>=':
                            case '<=':
                                return (function (e, t) {
                                    const i = c(e.leftValue, t);
                                    if (null === i) return null;
                                    const n = c(e.rightValue, t);
                                    if (null === n) return null;
                                    switch (e.type) {
                                        case '<':
                                            return i < n;
                                        case '>':
                                            return i > n;
                                        case '<=':
                                            return i <= n;
                                        case '>=':
                                            return i >= n;
                                    }
                                })(e, t);
                            case 'zoom':
                                return 'binder' === t.type || 'labeling' === t.type
                                    ? t.styleZoom
                                    : ((0, r.cM)(
                                          'Zoom expression cannot be used in filter context',
                                      ),
                                      l);
                            case 'height':
                                return 1;
                            case '+':
                                return (function (e, t) {
                                    const i = e.array.map((e) => c(e, t));
                                    if (!(0, o.nS)(i))
                                        return (
                                            (0, r.cM)(
                                                `Resolve AdditionExpression: arguments are not resolved as an array of numbers: ${i}`,
                                            ),
                                            null
                                        );
                                    return i.reduce((e, t) => e + t, 0);
                                })(e, t);
                            case '*':
                                return (function (e, t) {
                                    const i = e.array.map((e) => c(e, t));
                                    if (!(0, o.nS)(i))
                                        return (
                                            (0, r.cM)(
                                                `Resolve MultiplicationExpression: arguments are not resolved as an array of numbers: ${i}`,
                                            ),
                                            null
                                        );
                                    return i.reduce((e, t) => e * t, 1);
                                })(e, t);
                            case '^':
                                return (function (e, t) {
                                    const i = c(e.base, t);
                                    if ('number' != typeof i)
                                        return (
                                            (0, r.cM)(
                                                `Resolve PowExpression: base resolved as non-number value: ${i}`,
                                            ),
                                            null
                                        );
                                    const n = c(e.exponent, t);
                                    if ('number' != typeof n)
                                        return (
                                            (0, r.cM)(
                                                `Resolve PowExpression: exponent resolved as non-number value: ${n}`,
                                            ),
                                            null
                                        );
                                    return Math.pow(i, n);
                                })(e, t);
                            case 'log10':
                                return (function (e, t) {
                                    const i = c(e.value, t);
                                    if ('number' != typeof i)
                                        return (
                                            (0, r.cM)(
                                                `Resolve Log10Expression: value resolved as non-number value: ${i}`,
                                            ),
                                            null
                                        );
                                    return Math.log10(i);
                                })(e, t);
                            case 'random':
                                return (function (e, t) {
                                    const i = c(e.start, t);
                                    if ('number' != typeof i)
                                        return (
                                            (0, r.cM)(
                                                `Resolve RandomizationExpression: start resolved as non-number value: ${i}`,
                                            ),
                                            null
                                        );
                                    const n = c(e.end, t);
                                    if ('number' != typeof n)
                                        return (
                                            (0, r.cM)(
                                                `Resolve RandomizationExpression: end resolved as non-number value: ${n}`,
                                            ),
                                            null
                                        );
                                    if (n < i)
                                        return (
                                            (0, r.cM)(
                                                'Resolve RandomizationExpression: end cannot be less than start.',
                                            ),
                                            null
                                        );
                                    let o;
                                    'generator' === t.type &&
                                        t.getSeededRandomValue &&
                                        (o = t.getSeededRandomValue);
                                    void 0 === o &&
                                        (0, r.cM)(
                                            'Resolve RandomizationExpression: the random function is not present, the mean value between start and end will be used.',
                                        );
                                    return (0, a.f)(o, i, n);
                                })(e, t);
                            case 'literalArray':
                                return (function (e, t) {
                                    return e.array.map((e) => c(e, t));
                                })(e, t);
                            case 'isBehindObjects':
                                return 'binder' === t.type
                                    ? t.isBehind
                                    : ((0, r.cM)(
                                          `isBehindObjects expression cannot be used in ${t.type} context`,
                                      ),
                                      l);
                            default:
                                return (
                                    (0, r.cM)(
                                        `Not supported expression type <<${
                                            e.type
                                        }>> in ${JSON.stringify(e)}`,
                                    ),
                                    l
                                );
                        }
                    }
                    function d(e) {
                        return (0, s.nI)(e) ? (0, s.Ak)(e) : e;
                    }
                    function h(e, t, i) {
                        const n = b(e, t, i);
                        if (0 === n) return Number(c(e.steps[0].value, i));
                        if (n === e.steps.length)
                            return (function (e, t, i) {
                                const n = e.steps[e.steps.length - 1],
                                    o = e.base;
                                if (1 === o) return f(n.value, t);
                                return f(n.value, t) * Math.pow(o, i - f(n.key, t));
                            })(e, i, t);
                        const o = Number(c(e.steps[n - 1].value, i));
                        if ('labeling' === i.type && i.interpolateExpressionAsStep) return o;
                        const r = w(e, t, n, i);
                        return (1 - r) * o + r * Number(c(e.steps[n].value, i));
                    }
                    function u(e, t) {
                        const i = c(e, t);
                        return (0, n.gC)(i)
                            ? i
                            : (0, n.RY)(i)
                            ? i.values[1]
                            : (console.warn(
                                  `Can't resolve expression. Must be color, but got ${i}`,
                              ),
                              (0, o.lK)([0, 0, 0, 0]));
                    }
                    function m(e, t) {
                        const i = c(e, t);
                        return (0, n.RY)(i) ? i : null;
                    }
                    function f(e, t, i = NaN) {
                        const n = c(e, t);
                        return 'number' == typeof n ? n : i;
                    }
                    function p(e, t, i = '') {
                        const n = c(e, t);
                        return 'string' == typeof n ? n : i;
                    }
                    function _(e, t, i) {
                        const n = b(e, t, i);
                        if (0 === n) return u(e.steps[0].value, i);
                        if (n === e.steps.length) return u(e.steps[e.steps.length - 1].value, i);
                        const r = w(e, t, n, i),
                            s = u(e.steps[n - 1].value, i).value,
                            a = u(e.steps[n].value, i).value;
                        return (0, o.lK)([
                            s[0] * (1 - r) + a[0] * r,
                            s[1] * (1 - r) + a[1] * r,
                            s[2] * (1 - r) + a[2] * r,
                            s[3] * (1 - r) + a[3] * r,
                        ]);
                    }
                    function v(e, t, i, n = !1) {
                        return {
                            type: 'binder',
                            styleZoom: e,
                            styleState: t,
                            tileData: i,
                            isBehind: n,
                        };
                    }
                    function g(e, t, i, n) {
                        return {
                            type: 'labeling',
                            styleZoom: e,
                            styleState: t,
                            interpolateExpressionAsStep: i,
                            tileData: n,
                        };
                    }
                    function y(e, t, i, n, o, r) {
                        return {
                            type: 'generator',
                            styleState: e,
                            tileProps: i,
                            tileAttrs: n,
                            featureAttrs: o,
                            sourceAttrs: t,
                            getSeededRandomValue: r,
                        };
                    }
                    function b(e, t, i) {
                        let n = 0;
                        for (; n < e.steps.length && !(t < f(e.steps[n].key, i)); ) n++;
                        return n;
                    }
                    function w(e, t, i, n) {
                        const o = e.base,
                            r = f(e.steps[i].key, n) - f(e.steps[i - 1].key, n),
                            s = t - f(e.steps[i - 1].key, n);
                        return 1 === o ? s / r : (Math.pow(o, s) - 1) / (Math.pow(o, r) - 1);
                    }
                    function x(e) {
                        const [t, i, n, o] = e.value;
                        return [
                            (((t * o + 127) / 255) >>> 0) / 255,
                            (((i * o + 127) / 255) >>> 0) / 255,
                            (((n * o + 127) / 255) >>> 0) / 255,
                            o / 255,
                        ];
                    }
                    function S(e) {
                        const t = new Set();
                        return I(t, e), Array.from(t);
                    }
                    function I(e, t) {
                        if ((0, o.Uu)(t))
                            switch (t.type) {
                                case 'all':
                                    return (function (e, t) {
                                        t.array.forEach((t) => I(e, t));
                                    })(e, t);
                                case 'match':
                                    return (function (e, t) {
                                        I(e, t.defaultOutput),
                                            t.cases.forEach((t) => I(e, t.output));
                                    })(e, t);
                                case 'step':
                                case 'interpolate':
                                    return (function (e, t) {
                                        t.steps.forEach((t) => I(e, t.value));
                                    })(e, t);
                            }
                        else e.add(t);
                    }
                },
                314: (e, t, i) => {
                    var n;
                    i.d(t, { Z: () => n, z: () => o }),
                        (function (e) {
                            (e[(e.Uniform = 1)] = 'Uniform'),
                                (e[(e.Labeling = 2)] = 'Labeling'),
                                (e[(e.Generator = 3)] = 'Generator');
                        })(n || (n = {}));
                    const o = -1;
                },
                8450: (e, t, i) => {
                    function n(e) {
                        return !!e && 'polygon' === e.type;
                    }
                    function o(e) {
                        return !!e && 'line' === e.type;
                    }
                    function r(e) {
                        return e.reduce((e, t, i) => ((e[t] = i), e), {});
                    }
                    function s(e) {
                        if (void 0 === e || 'boolean' == typeof e) return Boolean(e);
                        const t = JSON.stringify(e);
                        return Boolean(t.match(/\["get","(db_)?sublayer"]/));
                    }
                    i.d(t, { Kx: () => s, PU: () => r, nc: () => n, ot: () => o });
                },
                3741: (e, t, i) => {
                    i.r(t),
                        i.d(t, {
                            geoLineDistance: () => o.XV,
                            geoToMapDistance: () => o.a4,
                            getCenterZoomByPoints: () => a,
                            getMetersFromPixels: () => h,
                            getMousePositionInContainer: () => l.yK,
                            projectGeoToMap: () => o.yq,
                            projectGeoToScreen: () => c,
                            projectMapToGeo: () => o.PA,
                            projectMapToScreen: () => u,
                            projectScreenToGeo: () => d,
                        });
                    var n = i(6490),
                        o = i(9073),
                        r = i(4874),
                        s = i(7636);
                    function a(e, t, i) {
                        const n = (0, s.g)(e, t, i);
                        if (n) return { zoom: n.zoom, center: (0, o.PA)(n.center) };
                    }
                    var l = i(1274);
                    function c(
                        e,
                        t,
                        i,
                        s,
                        a,
                        l,
                        c = { top: 0, right: 0, bottom: 0, left: 0 },
                        d = { top: 0, right: 0, bottom: 0, left: 0 },
                    ) {
                        return new r.V({
                            center: (0, o.yq)(e),
                            zoom: t,
                            rotation: (0, n.Id)(i),
                            size: s,
                            pitch: (0, n.Id)(a),
                            viewport: c,
                            padding: d,
                        }).project((0, o.yq)(l));
                    }
                    function d(
                        e,
                        t,
                        i,
                        s,
                        a,
                        l,
                        c = { top: 0, right: 0, bottom: 0, left: 0 },
                        d = { top: 0, right: 0, bottom: 0, left: 0 },
                    ) {
                        const h = new r.V({
                            center: (0, o.yq)(e),
                            zoom: t,
                            rotation: (0, n.Id)(i),
                            size: s,
                            pitch: (0, n.Id)(a),
                            viewport: c,
                            padding: d,
                        });
                        return (0, o.PA)(h.unproject(l));
                    }
                    function h(
                        e,
                        t,
                        i,
                        n,
                        r,
                        s,
                        a = { top: 0, right: 0, bottom: 0, left: 0 },
                        l = { top: 0, right: 0, bottom: 0, left: 0 },
                        c,
                    ) {
                        return (0, o.$X)(e, t, i, n, r, s, a, l, c, c);
                    }
                    function u(e, t) {
                        return new r.V(e).project(t);
                    }
                },
                4874: (e, t, i) => {
                    i.d(t, { V: () => h });
                    var n = i(9450),
                        o = i(127),
                        r = i(9218),
                        s = i(6490),
                        a = i(9073);
                    const l = [0, 0, 1],
                        c = n.Ue(),
                        d = n.Ue();
                    class h {
                        constructor(e) {
                            (this.state = e),
                                (this.position = [0, 0, 0]),
                                (this.projectionMatrix = []),
                                (this.viewMatrix = []),
                                (this.viewMatrixTranspose = []),
                                (this.projectionMatrixInverse = []),
                                (this.viewProjectionMatrix = []),
                                (this.viewProjectionMatrixInverse = []),
                                (this.horizonPixelOffset = 0),
                                (this.horizonPixelOffset = 0),
                                this.update();
                        }
                        setState(e) {
                            (this.state = e), this.update();
                        }
                        update() {
                            this.updatePosition(),
                                this.updateProjectionMatrix(),
                                this.updateViewMatrix(),
                                o.Jp(
                                    this.viewProjectionMatrix,
                                    this.projectionMatrix,
                                    this.viewMatrix,
                                ),
                                o.U_(this.viewProjectionMatrixInverse, this.viewProjectionMatrix),
                                o.U_(this.projectionMatrixInverse, this.projectionMatrix),
                                o.p4(this.viewMatrixTranspose, this.viewMatrix),
                                this.updateHorizonPixelOffset();
                        }
                        putProject(e, t) {
                            const { size: i, viewport: n } = this.state,
                                o = this.viewProjectionMatrix,
                                r = t[0],
                                s = t[1],
                                a = t[2],
                                l = i[0] / 2,
                                c = i[1] / 2,
                                d = o[3] * r + o[7] * s + o[11] * a + o[15];
                            (e[0] = l + n.left + ((o[0] * r + o[4] * s + o[12]) * l) / d),
                                (e[1] =
                                    c + n.top - ((o[1] * r + o[5] * s + o[9] * a + o[13]) * c) / d);
                        }
                        project(e) {
                            const t = [0, 0, 0];
                            return this.putProject(t, e), t;
                        }
                        unproject(e) {
                            const { size: t, viewport: i } = this.state,
                                o = [
                                    ((e[0] - i.left) / t[0]) * 2 - 1,
                                    (-(Math.max(this.horizonPixelOffset, e[1]) - i.top) / t[1]) *
                                        2 +
                                        1,
                                    0,
                                ];
                            n.fF(o, o, this.viewProjectionMatrixInverse),
                                (o[0] -= this.position[0]),
                                (o[1] -= this.position[1]),
                                (o[2] -= this.position[2]),
                                n.Fv(o, o);
                            const r = -this.position[2] / o[2];
                            return (
                                (o[0] = this.position[0] + o[0] * r),
                                (o[1] = this.position[1] + o[1] * r),
                                (o[2] = this.position[2] + o[2] * r),
                                o
                            );
                        }
                        getViewportVertices() {
                            const { size: e, viewport: t } = this.state;
                            return [
                                this.unproject([t.left, e[1] + t.top, 0]),
                                this.unproject([e[0] + t.left, e[1] + t.top, 0]),
                                this.unproject([e[0] + t.left, t.top, 0]),
                                this.unproject([t.left, t.top, 0]),
                            ];
                        }
                        getHorizonPixelOffset() {
                            return this.horizonPixelOffset;
                        }
                        updatePosition() {
                            const {
                                    center: e,
                                    rotation: t,
                                    zoom: i,
                                    pitch: n,
                                    size: o,
                                } = this.state,
                                r = (0, a.r9)(i, o),
                                s = Math.max(r * Math.sin(n), 1);
                            (this.position[0] = e[0] + Math.sin(t) * s),
                                (this.position[1] = e[1] - Math.cos(t) * s),
                                (this.position[2] = r * Math.cos(n));
                        }
                        updateViewMatrix() {
                            o.zB(this.viewMatrix, this.position, this.state.center, l);
                        }
                        updateProjectionMatrix() {
                            const { fov: e, near: t, far: i } = r.camera,
                                { size: n, view: o } = this.correctViewAndSize(),
                                s = n[0] / n[1];
                            let a = t * Math.tan(e / 2),
                                l = 2 * a,
                                c = s * l,
                                d = -c / 2;
                            o &&
                                ((d += (o.x * c) / n[0]),
                                (a -= (o.y * l) / n[1]),
                                (c *= o.width / n[0]),
                                (l *= o.height / n[1]));
                            const h = d + c,
                                u = a - l,
                                m = this.projectionMatrix;
                            (m[0] = (2 * t) / (h - d)),
                                (m[5] = (2 * t) / (a - u)),
                                (m[8] = (h + d) / (h - d)),
                                (m[9] = (a + u) / (a - u)),
                                (m[10] = -(i + t) / (i - t)),
                                (m[11] = -1),
                                (m[14] = (-2 * i * t) / (i - t)),
                                (m[1] =
                                    m[2] =
                                    m[3] =
                                    m[4] =
                                    m[6] =
                                    m[7] =
                                    m[12] =
                                    m[13] =
                                    m[15] =
                                        0);
                        }
                        correctViewAndSize() {
                            const { size: e, pitch: t, padding: i } = this.state,
                                n = Math.max(0, i.top - i.bottom) * Math.tan(t),
                                o = (0, a.pc)(e[1]) + n,
                                r = {
                                    x: (i.right - i.left) / 2,
                                    y: (i.bottom - i.top) / 2,
                                    width: e[0],
                                    height: e[1],
                                };
                            r.y += (o - e[1]) / 2;
                            return { view: r, size: [e[0], o] };
                        }
                        updateHorizonPixelOffset() {
                            const { viewport: e, size: t, zoom: i } = this.state,
                                o = this.unproject([e.left, t[1] + e.top, 0]),
                                l = this.unproject([e.left + t[0] / 2, t[1] + e.top, 0]),
                                h = this.unproject([t[0] + e.left, t[1] + e.top, 0]);
                            n.lu(d, h, o), n.jI(d, d, c, (0, s.Id)(90)), n.Fv(d, d);
                            const u = (0, a.h0)(t[1] * r.camera.perspectiveDistanceLimitRatio, i);
                            n.bA(d, d, u),
                                n.IH(d, l, d),
                                this.putProject(d, d),
                                (this.horizonPixelOffset = Math.max(0, Math.ceil(d[1])));
                        }
                    }
                },
                7231: (e, t, i) => {
                    i.d(t, { n: () => o });
                    var n = i(7731);
                    class o {
                        constructor(e, t, i) {
                            (this.id = e),
                                (this.modules = t),
                                (this.options = i),
                                (this.type = 'geojson'),
                                (this.worker = new this.modules.workers.parser.GeoJsonSource(
                                    this.options,
                                    this.id,
                                )),
                                (this.attributes = i.attributes || {});
                        }
                        fetchTile(e) {
                            return this.worker
                                .fetchTile(e)
                                .then(() => [{ regionId: 0, metatileHash: -2 }]);
                        }
                        generateTile(e, t, i, n, o) {
                            const r = this.options.modelsPath;
                            return this.worker.generateTile(e, t, i, n, o, r);
                        }
                        getObjectAttributes(e, t) {
                            return (0, n.mG)(this, void 0, void 0, function* () {
                                return this.worker.getObjectAttributes(e, t);
                            });
                        }
                        abortTileFetch(e) {
                            this.worker.abortTileFetch(e);
                        }
                        deleteTile(e) {
                            this.worker.deleteTile(e);
                        }
                        setAttributes(e) {
                            this.worker.setSourceAttrs(e), (this.attributes = e);
                        }
                        getAttributes() {
                            return this.attributes;
                        }
                        destroy() {
                            this.worker.destroy();
                        }
                        setData(e) {
                            return (0, n.mG)(this, void 0, void 0, function* () {
                                return (
                                    (this.options = this.options =
                                        'string' == typeof e
                                            ? Object.assign(Object.assign({}, this.options), {
                                                  url: e,
                                              })
                                            : Object.assign(Object.assign({}, this.options), {
                                                  data: e,
                                              })),
                                    yield this.worker.setData(e)
                                );
                            });
                        }
                    }
                },
                4619: (e, t, i) => {
                    i.d(t, { Sj: () => s, X4: () => c, Y0: () => r, fZ: () => l });
                    var n = i(7188);
                    const o = {
                        point: { point: !0, heatmap: !0, gltfModel: !0 },
                        polygon: { polygon: !0, polygonExtrusion: !0, mesh: !0 },
                        line: {
                            line: !0,
                            lineExtrusion: !0,
                            labelLine: !0,
                            dashedLine: !0,
                            oneWayLine: !0,
                            roadPointMark: !0,
                        },
                    };
                    function r(e, t) {
                        return !!o[e][t];
                    }
                    function s(e) {
                        const t = e.vertices[0],
                            i = e.vertices[1];
                        let n = 0;
                        for (let e = 0; e < t.length - 1; e++)
                            n += Math.hypot(t[e] - t[e + 1], i[e] - i[e + 1]);
                        return n;
                    }
                    function a(e, t) {
                        const i = new Set(
                            t[0].map((i, n) => (t[0][n] === e[0] && e[1] === t[1][n] ? n : -1)),
                        );
                        return Array.from(i);
                    }
                    function l(e, t) {
                        const i = a([e[0][0], e[1][0]], t),
                            n = a([e[0][1], e[1][1]], t),
                            o = a([e[0][2], e[1][2]], t);
                        i.forEach((t) =>
                            n.forEach((i) =>
                                o.forEach((n) => {
                                    !(function (e, t, i, n) {
                                        t >= 0 && i >= 0 && 1 === Math.abs(t - i) && (e[2][0] = 1),
                                            i >= 0 &&
                                                n >= 0 &&
                                                1 === Math.abs(i - n) &&
                                                (e[2][1] = 1),
                                            t >= 0 &&
                                                n >= 0 &&
                                                1 === Math.abs(t - n) &&
                                                (e[2][2] = 1);
                                    })(e, t, i, n);
                                }),
                            ),
                        );
                    }
                    function c() {
                        return (0, n.KP)(
                            [
                                'id',
                                'db_label',
                                'db_label2',
                                'selected',
                                'hovered',
                                'componentDistanceStart',
                                'objectLength',
                                'beginningIsCut',
                                'endingIsCut',
                            ],
                            ['Commercial_poi_default', 'Commercial_poi_city'],
                        );
                    }
                },
                5071: (e, t, i) => {
                    i.d(t, { Xm: () => m, f7: () => l, gs: () => u, rR: () => c });
                    var n = i(7731),
                        o = i(3338),
                        r = i(7231),
                        s = i(9218),
                        a = i(9600);
                    const l = 15,
                        c = 17;
                    class d {
                        constructor(e, t, i) {
                            var n, d;
                            (this.type = 'geojson'),
                                (this.id = (0, a.Q)()),
                                (this.modules = e.modules),
                                (this.mapglApiSource = i),
                                (this.identifiedAsDefault = !!t.identifyAsDefaultSource),
                                (this.sourceCore = new r.n(this.id, this.modules, t));
                            const h =
                                    null !== (n = t.minZoom) && void 0 !== n
                                        ? n
                                        : s.MAP_DEFAULTS.minZoom,
                                u = Math.min(null !== (d = t.maxZoom) && void 0 !== d ? d : l, c);
                            (this.layer = new o.I(
                                h,
                                u,
                                h,
                                c,
                                this.modules,
                                e.state,
                                this.sourceCore,
                            )),
                                this.modules.tileManager.addTileLayer(this.layer);
                        }
                        destroy() {
                            this.modules.tileManager.removeTileLayer(this.layer),
                                this.layer.destroy(),
                                this.modules.sourceStorage.removeSource(this.getId()),
                                this.sourceCore.destroy();
                        }
                        setAttributes(e) {
                            this.sourceCore.setAttributes(e), this.layer.redraw();
                        }
                        getAttributes() {
                            return this.sourceCore.getAttributes();
                        }
                        getId() {
                            return this.sourceCore.id;
                        }
                        isIdentifiedAsDefault() {
                            return this.identifiedAsDefault;
                        }
                    }
                    const h = { type: 'FeatureCollection', features: [] };
                    class u extends d {
                        constructor(e, t, i) {
                            super(e, t, i),
                                (this.subtype = 'internal'),
                                (this.data = t.data),
                                this.modules.sourceStorage.addSource(this);
                        }
                        getFeatureById(e) {
                            return 'FeatureCollection' === this.data.type
                                ? this.data.features[e.lo]
                                : this.data;
                        }
                        destroy() {
                            super.destroy(), (this.data = h);
                        }
                        setData(e) {
                            return (0, n.mG)(this, void 0, void 0, function* () {
                                (yield this.sourceCore.setData(e)) &&
                                    ((this.data = e),
                                    this.layer.onSourceDataChange(),
                                    this.modules.identifier.resetCache());
                            });
                        }
                    }
                    class m extends d {
                        constructor(e, t, i) {
                            super(e, t, i),
                                (this.subtype = 'external'),
                                this.modules.sourceStorage.addSource(this);
                        }
                        getObjectAttributes(e, t) {
                            return this.sourceCore.getObjectAttributes(e, t);
                        }
                        setDataUrl(e) {
                            return (0, n.mG)(this, void 0, void 0, function* () {
                                (yield this.sourceCore.setData(e)) &&
                                    (this.layer.onSourceDataChange(),
                                    this.modules.identifier.resetCache());
                            });
                        }
                    }
                },
                2176: (e, t, i) => {
                    i.d(t, { T: () => pe });
                    var n = i(3672),
                        o = i(4372),
                        r = i(6392),
                        s = i(7188),
                        a = i(9981),
                        l = i(7204),
                        c = i(4619),
                        d = i(5071);
                    function h(e, t, i, n, o = 2) {
                        const r = o + 1;
                        let s = n;
                        const a = (i - t) >> 1;
                        let l,
                            c = i - t;
                        const d = e[t],
                            m = e[t + 1],
                            f = e[i],
                            p = e[i + 1];
                        for (let n = t + r; n < i; n += r) {
                            const t = u(e[n], e[n + 1], d, m, f, p);
                            if (t > s) (l = n), (s = t);
                            else if (t === s) {
                                const e = Math.abs(n - a);
                                e < c && ((l = n), (c = e));
                            }
                        }
                        s > n &&
                            (l - t > r && h(e, t, l, n, o),
                            (e[l + 2] = s),
                            i - l > r && h(e, l, i, n, o));
                    }
                    function u(e, t, i, n, o, r) {
                        let s = o - i,
                            a = r - n;
                        if (0 !== s || 0 !== a) {
                            const l = ((e - i) * s + (t - n) * a) / (s * s + a * a);
                            l > 1 ? ((i = o), (n = r)) : l > 0 && ((i += s * l), (n += a * l));
                        }
                        return (s = e - i), (a = t - n), s * s + a * a;
                    }
                    function m(e, t, i, n, o, r = 3) {
                        const s = {
                            id: null == e ? null : e,
                            index: o,
                            type: t,
                            geometry: i,
                            tags: n,
                            minX: 1 / 0,
                            minY: 1 / 0,
                            maxX: -1 / 0,
                            maxY: -1 / 0,
                        };
                        if ('Point' === t || 'MultiPoint' === t || 'LineString' === t) f(s, i, r);
                        else if ('Polygon' === t) f(s, i[0], r);
                        else if ('MultiLineString' === t) for (const e of i) f(s, e, r);
                        else if ('MultiPolygon' === t) for (const e of i) f(s, e[0], r);
                        return s;
                    }
                    function f(e, t, i = 3) {
                        for (let n = 0; n < t.length; n += i)
                            (e.minX = Math.min(e.minX, t[n])),
                                (e.minY = Math.min(e.minY, t[n + 1])),
                                (e.maxX = Math.max(e.maxX, t[n])),
                                (e.maxY = Math.max(e.maxY, t[n + 1]));
                    }
                    function p(e, t, i, n) {
                        if (!t.geometry) return;
                        const o = t.geometry.coordinates,
                            r = t.geometry.type,
                            s = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2);
                        let a = [],
                            l = t.id;
                        if (
                            (i.promoteId
                                ? (l = t.properties[i.promoteId])
                                : i.generateId && (l = n || 0),
                            'Point' === r)
                        )
                            _(o, a, i.dimensions);
                        else if ('MultiPoint' === r) for (const e of o) _(e, a, i.dimensions);
                        else if ('LineString' === r) v(o, a, s, !1, i.dimensions);
                        else if ('MultiLineString' === r) {
                            if (i.lineMetrics) {
                                for (const r of o)
                                    (a = []),
                                        v(r, a, s, !1, i.dimensions),
                                        e.push(
                                            m(
                                                l,
                                                'LineString',
                                                a,
                                                t.properties,
                                                n,
                                                i.dimensions + 1,
                                            ),
                                        );
                                return;
                            }
                            g(o, a, s, !1, i.dimensions);
                        } else if ('Polygon' === r) g(o, a, s, !0, i.dimensions);
                        else {
                            if ('MultiPolygon' !== r) {
                                if ('GeometryCollection' === r) {
                                    for (const o of t.geometry.geometries)
                                        p(
                                            e,
                                            { id: l, geometry: o, properties: t.properties },
                                            i,
                                            n,
                                        );
                                    return;
                                }
                                throw new Error('Input data is not a valid GeoJSON object.');
                            }
                            for (const e of o) {
                                const t = [];
                                g(e, t, s, !0, i.dimensions), a.push(t);
                            }
                        }
                        e.push(m(l, r, a, t.properties, n, i.dimensions + 1));
                    }
                    function _(e, t, i = 2) {
                        t.push(y(e[0]), b(e[1]), 0);
                        for (let n = 2; n < i; n++) t.push(e[n]);
                    }
                    function v(e, t, i, n, o = 2) {
                        let r,
                            s,
                            a = 0;
                        for (let i = 0; i < e.length; i++) {
                            const l = y(e[i][0]),
                                c = b(e[i][1]);
                            t.push(l, c, 0);
                            for (let n = 2; n < o; n++) t.push(e[i][n]);
                            i > 0 &&
                                (a += n
                                    ? (r * c - l * s) / 2
                                    : Math.sqrt(Math.pow(l - r, 2) + Math.pow(c - s, 2))),
                                (r = l),
                                (s = c);
                        }
                        const l = t.length - (o + 1);
                        (t[2] = 1),
                            h(t, 0, l, i, o),
                            (t[l + 2] = 1),
                            (t.size = Math.abs(a)),
                            (t.start = 0),
                            (t.end = t.size);
                    }
                    function g(e, t, i, n, o = 2) {
                        for (let r = 0; r < e.length; r++) {
                            const s = [];
                            v(e[r], s, i, n, o), t.push(s);
                        }
                    }
                    function y(e) {
                        return e / 360 + 0.5;
                    }
                    function b(e) {
                        const t = Math.sin((e * Math.PI) / 180),
                            i = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
                        return i < 0 ? 0 : i > 1 ? 1 : i;
                    }
                    function w(e, t, i, n, o, r, s, a) {
                        const l = (void 0 === a.dimensions ? 2 : a.dimensions) + 1;
                        if (((n /= t), r >= (i /= t) && s < n)) return e;
                        if (s < i || r >= n) return null;
                        const c = [];
                        for (const t of e) {
                            const e = t.geometry;
                            let r = t.type;
                            const s = 0 === o ? t.minX : t.minY,
                                d = 0 === o ? t.maxX : t.maxY;
                            if (s >= i && d < n) {
                                c.push(t);
                                continue;
                            }
                            if (d < i || s >= n) continue;
                            let h = [];
                            if ('Point' === r || 'MultiPoint' === r) x(e, h, i, n, o, l);
                            else if ('LineString' === r) S(e, h, i, n, o, !1, a.lineMetrics, l);
                            else if ('MultiLineString' === r) M(e, h, i, n, o, !1, l);
                            else if ('Polygon' === r) M(e, h, i, n, o, !0, l);
                            else if ('MultiPolygon' === r)
                                for (const t of e) {
                                    const e = [];
                                    M(t, e, i, n, o, !0, l), e.length && h.push(e);
                                }
                            if (h.length) {
                                if (a.lineMetrics && 'LineString' === r) {
                                    for (const e of h) c.push(m(t.id, r, e, t.tags, t.index, l));
                                    continue;
                                }
                                ('LineString' !== r && 'MultiLineString' !== r) ||
                                    (1 === h.length
                                        ? ((r = 'LineString'), (h = h[0]))
                                        : (r = 'MultiLineString')),
                                    ('Point' !== r && 'MultiPoint' !== r) ||
                                        (r = h.length === l ? 'Point' : 'MultiPoint'),
                                    c.push(m(t.id, r, h, t.tags, t.index, l));
                            }
                        }
                        return c.length ? c : null;
                    }
                    function x(e, t, i, n, o, r = 3) {
                        for (let s = 0; s < e.length; s += r) {
                            const a = e[s + o];
                            if (a >= i && a <= n) {
                                T(t, e[s], e[s + 1], e[s + 2]);
                                for (let i = 3; i < r; i++) t.push(e[s + i]);
                            }
                        }
                    }
                    function S(e, t, i, n, o, r, s, a = 3) {
                        let l = I(e);
                        const c = 0 === o ? P : L;
                        let d,
                            h,
                            u = e.start;
                        for (let m = 0; m < e.length - a; m += a) {
                            const f = e[m],
                                p = e[m + 1],
                                _ = e[m + 2],
                                v = e[m + a],
                                g = e[m + a + 1],
                                y = 0 === o ? f : p,
                                b = 0 === o ? v : g;
                            let w = !1;
                            if (
                                (s && (d = Math.sqrt(Math.pow(f - v, 2) + Math.pow(p - g, 2))),
                                y < i)
                            ) {
                                if (b > i) {
                                    h = c(l, f, p, v, g, i);
                                    for (let t = 3; t < a; t++) {
                                        const i = e[m + t];
                                        l.push((e[m + a + t] - i) * h + i);
                                    }
                                    s && (l.start = u + d * h);
                                }
                            } else if (y > n) {
                                if (b < n) {
                                    h = c(l, f, p, v, g, n);
                                    for (let t = 3; t < a; t++) {
                                        const i = e[m + t];
                                        l.push((e[m + a + t] - i) * h + i);
                                    }
                                    s && (l.start = u + d * h);
                                }
                            } else {
                                T(l, f, p, _);
                                for (let t = 3; t < a; t++) l.push(e[m + t]);
                            }
                            if (b < i && y >= i) {
                                h = c(l, f, p, v, g, i);
                                for (let t = 3; t < a; t++) {
                                    const i = e[m + t];
                                    l.push((e[m + a + t] - i) * h + i);
                                }
                                w = !0;
                            }
                            if (b > n && y <= n) {
                                h = c(l, f, p, v, g, n);
                                for (let t = 3; t < a; t++) {
                                    const i = e[m + t];
                                    l.push((e[m + a + t] - i) * h + i);
                                }
                                w = !0;
                            }
                            !r && w && (s && (l.end = u + d * h), t.push(l), (l = I(e))),
                                s && (u += d);
                        }
                        let m = e.length - a;
                        const f = e[m],
                            p = e[m + 1],
                            _ = e[m + 2],
                            v = 0 === o ? f : p;
                        if (v >= i && v <= n) {
                            T(l, f, p, _);
                            for (let t = 3; t < a; t++) l.push(e[m + t]);
                        }
                        if (
                            ((m = l.length - a),
                            r && m >= 3 && (l[m] !== l[0] || l[m + 1] !== l[1]))
                        ) {
                            T(l, l[0], l[1], l[2]);
                            for (let e = 3; e < a; e++) l.push(l[e]);
                        }
                        l.length && t.push(l);
                    }
                    function I(e) {
                        const t = [];
                        return (t.size = e.size), (t.start = e.start), (t.end = e.end), t;
                    }
                    function M(e, t, i, n, o, r, s) {
                        for (const a of e) S(a, t, i, n, o, r, !1, s);
                    }
                    function T(e, t, i, n) {
                        e.push(t, i, n);
                    }
                    function P(e, t, i, n, o, r) {
                        const s = (r - t) / (n - t);
                        return T(e, r, i + (o - i) * s, 1), s;
                    }
                    function L(e, t, i, n, o, r) {
                        const s = (r - i) / (o - i);
                        return T(e, t + (n - t) * s, r, 1), s;
                    }
                    function k(e, t, i = 3) {
                        const n = [];
                        for (let o = 0; o < e.length; o++) {
                            const r = e[o],
                                s = r.type;
                            let a;
                            if ('Point' === s || 'MultiPoint' === s || 'LineString' === s)
                                a = E(r.geometry, t, i);
                            else if ('MultiLineString' === s || 'Polygon' === s) {
                                a = [];
                                for (const e of r.geometry) a.push(E(e, t, i));
                            } else if ('MultiPolygon' === s) {
                                a = [];
                                for (const e of r.geometry) {
                                    const n = [];
                                    for (const o of e) n.push(E(o, t, i));
                                    a.push(n);
                                }
                            }
                            n.push(m(r.id, s, a, r.tags, r.index, i));
                        }
                        return n;
                    }
                    function E(e, t, i = 3) {
                        const n = [];
                        (n.size = e.size),
                            void 0 !== e.start && ((n.start = e.start), (n.end = e.end));
                        for (let o = 0; o < e.length; o += i) {
                            n.push(e[o] + t, e[o + 1], e[o + 2]);
                            for (let t = 3; t < i; t++) n.push(e[o + t]);
                        }
                        return n;
                    }
                    function A(e, t, i = 2) {
                        if (e.transformed) return e;
                        const n = 1 << e.z,
                            o = e.x,
                            r = e.y;
                        for (const s of e.features) {
                            const e = s.geometry,
                                a = s.type;
                            if (((s.geometry = []), 1 === a))
                                for (let a = 0; a < e.length; a += i)
                                    s.geometry.push(C(e, a, i, t, n, o, r));
                            else if (2 === a) s.geometry = z(e, t, n, o, r, i);
                            else
                                for (let a = 0; a < e.length; a++)
                                    s.geometry.push(z(e[a], t, n, o, r, i));
                        }
                        return (e.transformed = !0), e;
                    }
                    function z(e, t, i, n, o, r = 2) {
                        const s = [];
                        for (let a = 0; a < e.length; a++) {
                            const l = [];
                            for (let s = 0; s < e[a].length; s += r)
                                l.push(C(e[a], s, r, t, i, n, o));
                            s.push(l);
                        }
                        return s;
                    }
                    function C(e, t, i, n, o, r, s) {
                        const a = [
                            Math.round(n * (e[t] * o - r)),
                            Math.round(n * (e[t + 1] * o - s)),
                        ];
                        for (let n = 2; n < i; n++) a.push(e[t + n]);
                        return a;
                    }
                    function F(e, t, i, n, o) {
                        const r = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent),
                            s = {
                                features: [],
                                numPoints: 0,
                                numSimplified: 0,
                                numFeatures: e.length,
                                source: null,
                                x: i,
                                y: n,
                                z: t,
                                transformed: !1,
                                minX: 2,
                                minY: 1,
                                maxX: -1,
                                maxY: 0,
                            };
                        for (const t of e) O(s, t, r, o);
                        return s;
                    }
                    function O(e, t, i, n) {
                        const o = t.geometry,
                            r = t.type,
                            s = n.dimensions + 1;
                        let a = [];
                        if (
                            ((e.minX = Math.min(e.minX, t.minX)),
                            (e.minY = Math.min(e.minY, t.minY)),
                            (e.maxX = Math.max(e.maxX, t.maxX)),
                            (e.maxY = Math.max(e.maxY, t.maxY)),
                            'Point' === r || 'MultiPoint' === r)
                        )
                            for (let t = 0; t < o.length; t += s) {
                                a.push(o[t], o[t + 1]);
                                for (let e = 3; e < s; e++) a.push(o[t + e]);
                                e.numPoints++, e.numSimplified++;
                            }
                        else if ('LineString' === r) D(a, o, e, i, !1, !1, s);
                        else if ('MultiLineString' === r || 'Polygon' === r) {
                            for (let t = 0; t < o.length; t++)
                                D(a, o[t], e, i, 'Polygon' === r, 0 === t, s);
                            'Polygon' === r && a.length && (a = [a]);
                        } else if ('MultiPolygon' === r)
                            for (let t = 0; t < o.length; t++) {
                                const n = o[t],
                                    r = [];
                                for (let t = 0; t < n.length; t++) D(r, n[t], e, i, !0, 0 === t, s);
                                r.length && a.push(r);
                            }
                        if (a.length) {
                            let i = t.tags || null;
                            if ('LineString' === r && n.lineMetrics) {
                                i = {};
                                for (const e in t.tags) i[e] = t.tags[e];
                                (i.mapbox_clip_start = o.start / o.size),
                                    (i.mapbox_clip_end = o.end / o.size);
                            }
                            const s = {
                                geometry: a,
                                type:
                                    'Polygon' === r || 'MultiPolygon' === r
                                        ? 3
                                        : 'LineString' === r || 'MultiLineString' === r
                                        ? 2
                                        : 1,
                                tags: i,
                            };
                            null !== t.id && (s.id = t.id),
                                n.generateIndex && (s.index = t.index),
                                e.features.push(s);
                        }
                    }
                    function D(e, t, i, n, o, r, s = 3) {
                        const a = n * n;
                        if (n > 0 && t.size < (o ? a : n))
                            return void (i.numPoints += t.length / s);
                        const l = [];
                        for (let e = 0; e < t.length; e += s) {
                            if (0 === n || t[e + 2] > a) {
                                i.numSimplified++, l.push(t[e], t[e + 1]);
                                for (let i = 3; i < s; i++) l.push(t[e + i]);
                            }
                            i.numPoints++;
                        }
                        o &&
                            (function (e, t, i = 2) {
                                let n = 0;
                                for (let t = 0, o = e.length, r = o - i; t < o; r = t, t += i)
                                    n += (e[t] - e[r]) * (e[t + 1] + e[r + 1]);
                                if (n > 0 === t)
                                    for (let t = 0, n = e.length; t < n / 2; t += i)
                                        for (let o = 0; o < i; o++) {
                                            const r = e[t + o],
                                                s = n - t - (i - o);
                                            (e[t + o] = e[s]), (e[s] = r);
                                        }
                            })(l, r, s - 1),
                            e.push(l);
                    }
                    const R = 1,
                        j = 2,
                        B = 3,
                        N = {
                            maxZoom: 14,
                            indexMaxZoom: 5,
                            indexMaxPoints: 1e5,
                            tolerance: 3,
                            extent: 4096,
                            buffer: 64,
                            lineMetrics: !1,
                            promoteId: null,
                            generateId: !1,
                            generateIndex: !1,
                            debug: 0,
                            dimensions: 2,
                        };
                    class U {
                        constructor(e, t) {
                            const i = (t = this.options =
                                (function (e, t) {
                                    for (const i in t) e[i] = t[i];
                                    return e;
                                })(Object.create(N), t)).debug;
                            if (
                                (i && console.time('preprocess data'),
                                t.maxZoom < 0 || t.maxZoom > 24)
                            )
                                throw new Error('maxZoom should be in the 0-24 range');
                            if (t.promoteId && t.generateId)
                                throw new Error(
                                    'promoteId and generateId cannot be used together.',
                                );
                            let n = (function (e, t) {
                                const i = [];
                                if ('FeatureCollection' === e.type)
                                    for (let n = 0; n < e.features.length; n++)
                                        p(i, e.features[n], t, n);
                                else
                                    'Feature' === e.type
                                        ? p(i, e, t, 0)
                                        : p(i, { geometry: e }, t, 0);
                                return i;
                            })(e, t);
                            (this.tiles = {}),
                                (this.tileCoords = []),
                                i &&
                                    (console.timeEnd('preprocess data'),
                                    console.log(
                                        'index: maxZoom: %d, maxPoints: %d',
                                        t.indexMaxZoom,
                                        t.indexMaxPoints,
                                    ),
                                    console.time('generate tiles'),
                                    (this.stats = {}),
                                    (this.total = 0)),
                                (n = (function (e, t) {
                                    const i = t.buffer / t.extent,
                                        n = t.dimensions + 1;
                                    let o = e;
                                    const r = w(e, 1, -1 - i, i, 0, -1, 2, t),
                                        s = w(e, 1, 1 - i, 2 + i, 0, -1, 2, t);
                                    return (
                                        (r || s) &&
                                            ((o = w(e, 1, -i, 1 + i, 0, -1, 2, t) || []),
                                            r && (o = k(r, 1, n).concat(o)),
                                            s && (o = o.concat(k(s, -1, n)))),
                                        o
                                    );
                                })(n, t)),
                                n.length && this.splitTile(n, 0, 0, 0),
                                i &&
                                    (n.length &&
                                        console.log(
                                            'features: %d, points: %d',
                                            this.tiles[0].numFeatures,
                                            this.tiles[0].numPoints,
                                        ),
                                    console.timeEnd('generate tiles'),
                                    console.log(
                                        'tiles generated:',
                                        this.total,
                                        JSON.stringify(this.stats),
                                    ));
                        }
                        splitTile(e, t, i, n, o, r, s) {
                            const a = [e, t, i, n],
                                l = this.options,
                                c = l.debug;
                            for (; a.length; ) {
                                (n = a.pop()), (i = a.pop()), (t = a.pop()), (e = a.pop());
                                const d = 1 << t,
                                    h = Z(t, i, n);
                                let u = this.tiles[h];
                                if (
                                    !u &&
                                    (c > 1 && console.time('creation'),
                                    (u = this.tiles[h] = F(e, t, i, n, l)),
                                    this.tileCoords.push({ z: t, x: i, y: n }),
                                    c)
                                ) {
                                    c > 1 &&
                                        (console.log(
                                            'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                                            t,
                                            i,
                                            n,
                                            u.numFeatures,
                                            u.numPoints,
                                            u.numSimplified,
                                        ),
                                        console.timeEnd('creation'));
                                    const e = `z${t}`;
                                    (this.stats[e] = (this.stats[e] || 0) + 1), this.total++;
                                }
                                if (((u.source = e), null == o)) {
                                    if (t === l.indexMaxZoom || u.numPoints <= l.indexMaxPoints)
                                        continue;
                                } else {
                                    if (t === l.maxZoom || t === o) continue;
                                    if (null != o) {
                                        const e = o - t;
                                        if (i !== r >> e || n !== s >> e) continue;
                                    }
                                }
                                if (((u.source = null), 0 === e.length)) continue;
                                c > 1 && console.time('clipping');
                                const m = (0.5 * l.buffer) / l.extent,
                                    f = 0.5 - m,
                                    p = 0.5 + m,
                                    _ = 1 + m;
                                let v = null,
                                    g = null,
                                    y = null,
                                    b = null,
                                    x = w(e, d, i - m, i + p, 0, u.minX, u.maxX, l),
                                    S = w(e, d, i + f, i + _, 0, u.minX, u.maxX, l);
                                (e = null),
                                    x &&
                                        ((v = w(x, d, n - m, n + p, 1, u.minY, u.maxY, l)),
                                        (g = w(x, d, n + f, n + _, 1, u.minY, u.maxY, l)),
                                        (x = null)),
                                    S &&
                                        ((y = w(S, d, n - m, n + p, 1, u.minY, u.maxY, l)),
                                        (b = w(S, d, n + f, n + _, 1, u.minY, u.maxY, l)),
                                        (S = null)),
                                    c > 1 && console.timeEnd('clipping'),
                                    a.push(v || [], t + 1, 2 * i, 2 * n),
                                    a.push(g || [], t + 1, 2 * i, 2 * n + 1),
                                    a.push(y || [], t + 1, 2 * i + 1, 2 * n),
                                    a.push(b || [], t + 1, 2 * i + 1, 2 * n + 1);
                            }
                        }
                        getTile(e, t, i) {
                            (e = +e), (t = +t), (i = +i);
                            const n = this.options,
                                { extent: o, debug: r } = n;
                            if (e < 0 || e > 24) return null;
                            const s = 1 << e,
                                a = Z(e, (t = (t + s) & (s - 1)), i);
                            if (this.tiles[a]) return A(this.tiles[a], o, n.dimensions);
                            r > 1 && console.log('drilling down to z%d-%d-%d', e, t, i);
                            let l,
                                c = e,
                                d = t,
                                h = i;
                            for (; !l && c > 0; )
                                c--, (d >>= 1), (h >>= 1), (l = this.tiles[Z(c, d, h)]);
                            return l && l.source
                                ? (r > 1 &&
                                      (console.log('found parent tile z%d-%d-%d', c, d, h),
                                      console.time('drilling down')),
                                  this.splitTile(l.source, c, d, h, e, t, i),
                                  r > 1 && console.timeEnd('drilling down'),
                                  this.tiles[a] ? A(this.tiles[a], o, n.dimensions) : null)
                                : null;
                        }
                    }
                    function Z(e, t, i) {
                        return 32 * ((1 << e) * i + t) + e;
                    }
                    var H = i(9450),
                        G = i(7084),
                        V = i(6273),
                        W = i(6490),
                        q = i(9073);
                    function $(e, t, i) {
                        const n = [];
                        return (
                            e.geometry.forEach((o) => {
                                const r = [],
                                    s = [],
                                    a = [];
                                o.forEach((e) => {
                                    a.push(
                                        ...(function (e, t) {
                                            const i = [];
                                            let n = [];
                                            for (let o = 0; o < e.length; o++) {
                                                const r = e[o];
                                                if ((n.push(J(r, t)), !Q(r, t))) continue;
                                                const s = e[o + 1];
                                                if (!s) break;
                                                ee(r, s, t) &&
                                                    (n.length > 1 && i.push(n), (n = []));
                                            }
                                            n.length > 1 && i.push(n);
                                            return i;
                                        })(e, t),
                                    ),
                                        r.length && s.push(r.length),
                                        r.push(...e);
                                });
                                const l = [];
                                for (let e = 0; e < r.length; e++)
                                    for (let t = 0; t < i; t++) l.push(r[e][t]);
                                const d = G(l, s, i),
                                    h = H.Ue();
                                for (let o = 0; o < d.length; o += 3) {
                                    const s = i > 2 ? [[], [], [], []] : [[], [], []];
                                    for (let e = 0; e < 3; e++)
                                        K(h, r[d[o + 2 - e]], t),
                                            (s[0][e] = h[0]),
                                            (s[1][e] = h[1]),
                                            (s[2][e] = 0),
                                            i > 2 && (s[3][e] = h[2]);
                                    a.forEach((e) => {
                                        const t = [[], [], []];
                                        e.forEach((e, i) => {
                                            (t[0][i] = e[0]), (t[1][i] = e[1]);
                                        }),
                                            (0, c.fZ)(s, t);
                                    }),
                                        n.push({
                                            tags: e.tags,
                                            id: e.id,
                                            index: e.index,
                                            type: 'polygon',
                                            vertices: s,
                                        });
                                }
                            }),
                            n
                        );
                    }
                    function X(e, t, i) {
                        const n = H.Ue();
                        return e.geometry.map((o) => {
                            const r = i > 2 ? [[], [], []] : [[], []];
                            return (
                                o.forEach((e, o) => {
                                    K(n, e, t),
                                        (r[0][o] = n[0]),
                                        (r[1][o] = n[1]),
                                        i > 2 && (r[2][o] = n[2]);
                                }),
                                {
                                    tags: e.tags,
                                    id: e.id,
                                    index: e.index,
                                    type: 'line',
                                    vertices: r,
                                }
                            );
                        });
                    }
                    function Y(e, t, i) {
                        const n = H.Ue();
                        return e.geometry.map(
                            (o) => (
                                K(n, o, t),
                                {
                                    tags: e.tags,
                                    id: e.id,
                                    index: e.index,
                                    type: 'point',
                                    vertices: i > 2 ? [[n[0]], [n[1]], [n[2]]] : [[n[0]], [n[1]]],
                                }
                            ),
                        );
                    }
                    function K(e, t, i) {
                        const n = J(t, i);
                        (e[0] = n[0]), (e[1] = n[1]), (e[2] = void 0 === t[2] ? 0 : t[2] * q.C);
                    }
                    function J(e, t) {
                        return [
                            (0, W.uZ)((e[0] / t) * V.Bq, 0, V.Bq),
                            (0, W.uZ)(((t - e[1]) / t) * V.Bq, 0, V.Bq),
                        ];
                    }
                    function Q(e, t) {
                        return e[0] < 0 || e[0] > t || e[1] < 0 || e[1] > t;
                    }
                    function ee(e, t, i) {
                        return (
                            (e[0] > i && t[0] > i) ||
                            (e[0] < 0 && t[0] < 0) ||
                            (e[1] > i && t[1] > i) ||
                            (e[1] < 0 && t[1] < 0)
                        );
                    }
                    var te = i(4245);
                    const ie = 4096,
                        ne = {
                            maxZoom: d.f7,
                            tolerance: 3,
                            extent: ie,
                            buffer: 1,
                            debug: 0,
                            lineMetrics: !1,
                            promoteId: null,
                            generateId: !1,
                            generateIndex: !0,
                            indexMaxZoom: 0,
                            indexMaxPoints: 1e5,
                            dimensions: 2,
                        };
                    class oe {
                        constructor(e) {
                            this.options = e;
                        }
                        get geoJsonVtInstance() {
                            var e, t, i, n;
                            return (
                                this.geoJsonVT ||
                                    (this.geoJsonVT =
                                        ((i = this.options.data),
                                        (n = Object.assign(Object.assign({}, ne), {
                                            maxZoom:
                                                null !== (e = this.options.maxZoom) && void 0 !== e
                                                    ? e
                                                    : ne.maxZoom,
                                            dimensions:
                                                null !== (t = this.options.dimensions) &&
                                                void 0 !== t
                                                    ? t
                                                    : ne.dimensions,
                                        })),
                                        new U(i, n))),
                                this.geoJsonVT
                            );
                        }
                        fetchTile(e) {
                            var t;
                            const [i, n, o] = (0, r._W)(e),
                                s = { components: [], byId: new te.g() },
                                a = this.geoJsonVtInstance.getTile(o, i, n),
                                l = null !== (t = this.options.dimensions) && void 0 !== t ? t : 2;
                            if (!a) return Promise.resolve(s);
                            for (const e of a.features)
                                switch (e.type) {
                                    case R:
                                        s.components = s.components.concat(Y(e, ie, l));
                                        break;
                                    case j:
                                        s.components = s.components.concat(X(e, ie, l));
                                        break;
                                    case B:
                                        s.components = s.components.concat($(e, ie, l));
                                        break;
                                    default:
                                        console.warn('unsupported type ', a);
                                }
                            return Promise.resolve(s);
                        }
                        destroy() {
                            this.geoJsonVT = void 0;
                        }
                    }
                    function re(e, t) {
                        const i = { components: [], byId: new te.g() };
                        return (
                            e.features.forEach((e, n) => {
                                i.components.push(
                                    ...se(e.geometry, t).map((t) =>
                                        Object.assign(Object.assign({}, t), {
                                            index: n,
                                            id: e.id,
                                            tags: e.properties || {},
                                        }),
                                    ),
                                );
                            }),
                            i
                        );
                    }
                    function se(e, t) {
                        switch (e.type) {
                            case 'GeometryCollection': {
                                let i = [];
                                return (
                                    e.geometries.forEach((e) => {
                                        i = i.concat(se(e, t));
                                    }),
                                    i
                                );
                            }
                            case 'Point':
                            case 'MultiPoint':
                                return (function (e, t) {
                                    if ('Point' === e.type) return [ae(e.coordinates, t)];
                                    return e.coordinates.map((e) => ae(e, t));
                                })(e, t);
                            case 'LineString':
                            case 'MultiLineString':
                                return (function (e, t) {
                                    if ('LineString' === e.type) return [le(e.coordinates, t)];
                                    return e.coordinates.map((e) => le(e, t));
                                })(e, t);
                            case 'Polygon':
                            case 'MultiPolygon':
                                return (function (e, t) {
                                    if ('Polygon' === e.type) return ce(e.coordinates, t);
                                    return e.coordinates.reduce((e, i) => e.concat(ce(i, t)), []);
                                })(e, t);
                        }
                    }
                    function ae(e, t) {
                        const i = [0, 0, 0];
                        return (
                            (0, r.a2)(i, (0, q.yq)(e), t),
                            { type: 'point', vertices: [[i[0]], [i[1]]] }
                        );
                    }
                    function le(e, t) {
                        const i = [[], []],
                            n = [0, 0, 0];
                        return (
                            e.forEach((e, o) => {
                                (0, r.a2)(n, (0, q.yq)(e), t), (i[0][o] = n[0]), (i[1][o] = n[1]);
                            }),
                            { type: 'line', vertices: i }
                        );
                    }
                    function ce(e, t) {
                        const i = [],
                            n = [],
                            o = [],
                            s = [],
                            a = [];
                        e.forEach((e) => {
                            const i = e.map(
                                (e) => (
                                    (0, r.a2)(a, (0, q.yq)(e), t),
                                    [(0, W.uZ)(a[0], 0, V.Bq), (0, W.uZ)(a[1], 0, V.Bq)]
                                ),
                            );
                            s.push(i), n.length && o.push(n.length), n.push(...i);
                        });
                        const l = [];
                        for (let e = 0; e < n.length; e++) l.push(n[e][0]), l.push(n[e][1]);
                        const d = G(l, o);
                        for (let e = 0; e < d.length; e += 3) {
                            const t = [[], [], []];
                            for (let i = 0; i < 3; i++)
                                (t[0][i] = n[d[e + i]][0]),
                                    (t[1][i] = n[d[e + i]][1]),
                                    (t[2][i] = 0);
                            s.forEach((e) => {
                                const i = [[], [], []];
                                e.forEach((e, t) => {
                                    (i[0][t] = e[0]), (i[1][t] = e[1]);
                                }),
                                    (0, c.fZ)(t, i);
                            }),
                                i.push({ type: 'polygon', vertices: t });
                        }
                        return i;
                    }
                    var de = i(2398),
                        he = i(2435);
                    class ue {
                        constructor(e) {
                            (this.tileLoader = new de.U('json', e.ignoreMissingTiles)),
                                (this.options = e),
                                (this.url = (e) => {
                                    const t = this.options.flipY ? e : (0, r._W)(e);
                                    return (0, he.IG)(this.options.url, {
                                        x: t[0].toString(),
                                        y: t[1].toString(),
                                        z: t[2].toString(),
                                        subdomain: (0, r.Kn)(t),
                                    });
                                });
                        }
                        fetchTile(e) {
                            return this.tileLoader
                                .fetch(e, this.url)
                                .then((t) =>
                                    t.data
                                        ? re(t.data, (0, r.Bs)(e))
                                        : { components: [], byId: new te.g() },
                                );
                        }
                        abortTile(e) {
                            this.tileLoader.abortRequest((0, r.gx)(e));
                        }
                        destroy() {
                            this.tileLoader.destroy();
                        }
                    }
                    var me = i(2543),
                        fe = i(173);
                    class pe {
                        constructor(e, t, i) {
                            (this.scope = e),
                                (this.options = t),
                                (this.id = i),
                                (e.sources[i] = this),
                                (this.tileData = {}),
                                (this.styleManager = e.styleManager),
                                (this.collector = e.collector),
                                (this.sourceAttrs = this.options.attributes || {}),
                                (this.metatile = (0, c.X4)()),
                                (this.tileServer = 'url' in t ? new ue(t) : new oe(t));
                        }
                        fetchTile(e) {
                            const t = (0, r.gx)(e);
                            return this.tileData[t]
                                ? Promise.resolve(this.tileData[t])
                                : this.tileServer
                                      .fetchTile(e)
                                      .then((e) => ((this.tileData[t] = e), e));
                        }
                        abortTileFetch(e) {
                            this.tileServer instanceof ue && this.tileServer.abortTile(e);
                        }
                        generateTile(e, t, i, d, h, u) {
                            const m = (0, r.gx)(t),
                                f = this.tileData[m],
                                p = (0, r.Bs)(t),
                                _ = [],
                                v = [],
                                g = this.styleManager.getStyle(i),
                                y = new l.c(),
                                b = new l.c(d),
                                w = (0, fe.O)(t[0] + t[1] + t[2] + 1);
                            if (!g) return Promise.resolve({ results: _, transferable: v });
                            f &&
                                f.components.forEach((t, i) => {
                                    const { tileProps: r } = this.metatile,
                                        d = [];
                                    if (t.tags) {
                                        const e = Object.keys(t.tags);
                                        (0, s.Qy)(this.metatile, e);
                                        for (const i of e) d[r[i]] = t.tags[i];
                                    }
                                    const m = Object.keys(this.sourceAttrs);
                                    (0, s.Qy)(this.metatile, m);
                                    for (const e of m) d[r[e]] = this.sourceAttrs[e];
                                    const _ =
                                            'url' in this.options &&
                                            this.options.preventInteractions,
                                        v = this.options.identifyAsDefaultSource,
                                        x = d[r.db_id] ? d[r.db_id] : d[r.building_id],
                                        S = _
                                            ? NaN
                                            : v
                                            ? x
                                                ? (0, n.IL)(x)
                                                : NaN
                                            : (0, n.Ru)(t.index, this.id);
                                    if ('number' != typeof S) {
                                        const e = b.has(S);
                                        (d[r.selected] = e ? 1 : 0), y.add(S), f.byId.set(S, i);
                                    }
                                    const { coords: I } = p,
                                        M = I[3],
                                        T = (0, a.o1)(h),
                                        P = (0, me.Yi)(
                                            e.styleState,
                                            this.sourceAttrs,
                                            r,
                                            d,
                                            s.wz,
                                            w,
                                        ),
                                        L = this.styleManager
                                            .getLayers(g.id, r, d)
                                            .filter((e) => (0, c.Y0)(t.type, e.type))
                                            .filter((e) => (0, me.FR)(e.filter, P));
                                    (d[r.id] = S),
                                        ('point' !== t.type && 'line' !== t.type) ||
                                            (void 0 === d[r.db_label] && (d[r.db_label] = NaN),
                                            void 0 === d[r.db_label2] && (d[r.db_label2] = NaN)),
                                        'line' === t.type &&
                                            ((d[r.componentDistanceStart] = 0),
                                            (d[r.objectLength] = (0, c.Sj)(t)),
                                            (d[r.beginningIsCut] = 0),
                                            (d[r.endingIsCut] = 0)),
                                        (0, o.PA)(
                                            this.collector,
                                            g,
                                            L,
                                            P,
                                            this.metatile,
                                            M,
                                            this.id,
                                            I,
                                            T,
                                            t.vertices,
                                            new l.c(),
                                            void 0,
                                            u,
                                        );
                                }),
                                this.collector.setGeoIds(new Uint32Array(y.toFlatArray()));
                            const x = this.collector.getAccumulatedData();
                            return (
                                _.push({
                                    regionId: 0,
                                    metatileHash: V.L2,
                                    collectorOutput: x,
                                    styleId: g.id,
                                }),
                                v.push(...x.transferable),
                                this.scope.debouncedResetCollector(),
                                this.scope.syncNewRasterSets(),
                                Promise.resolve({ results: _, transferable: v })
                            );
                        }
                        getObjectAttributes(e, t) {
                            const i = this.tileData[t];
                            if (i) {
                                const t = i.byId.get(e);
                                if (void 0 === t) return;
                                const n = i.components[t];
                                if (void 0 === n) return;
                                return n.tags;
                            }
                        }
                        deleteTile(e) {
                            delete this.tileData[(0, r.gx)(e)];
                        }
                        setSourceAttrs(e) {
                            this.sourceAttrs = e;
                        }
                        destroy() {
                            delete this.scope.sources[this.id],
                                (this.tileData = {}),
                                (this.sourceAttrs = {}),
                                this.tileServer.destroy();
                        }
                        setData(e) {
                            if ('string' == typeof e) {
                                if (this.tileServer instanceof ue)
                                    return (
                                        this.tileServer.destroy(),
                                        (this.options = Object.assign(
                                            Object.assign({}, this.options),
                                            { url: e },
                                        )),
                                        (this.tileServer = new ue(this.options)),
                                        (this.tileData = {}),
                                        Promise.resolve(!0)
                                    );
                            } else if (this.tileServer instanceof oe)
                                return (
                                    this.tileServer.destroy(),
                                    (this.options = Object.assign(Object.assign({}, this.options), {
                                        data: e,
                                    })),
                                    (this.tileServer = new oe(this.options)),
                                    (this.tileData = {}),
                                    Promise.resolve(!0)
                                );
                            return Promise.resolve(!1);
                        }
                    }
                },
                9600: (e, t, i) => {
                    i.d(t, { Q: () => o });
                    let n = 1;
                    function o() {
                        return n++;
                    }
                },
                2627: (e, t, i) => {
                    i.d(t, { dx: () => l, lG: () => u, nt: () => m, qS: () => d });
                    var n = i(6392),
                        o = i(7188),
                        r = i(6490),
                        s = i(2435);
                    const a = {
                            db_id: 'id',
                            tech_db_beginning_is_cut: 'beginningIsCut',
                            tech_db_ending_is_cut: 'endingIsCut',
                            tech_db_previous_point_x: 'previousPointX',
                            tech_db_previous_point_y: 'previousPointY',
                            tech_db_next_point_x: 'nextPointX',
                            tech_db_next_point_y: 'nextPointY',
                            tech_db_object_length: 'objectLength',
                            tech_db_component_distance_start: 'componentDistanceStart',
                            tech_db_component_distance_end: 'componentDistanceEnd',
                        },
                        l = (e) => {
                            var t;
                            return null !== (t = a[e]) && void 0 !== t ? t : e;
                        },
                        c = {
                            objectClass: 'db_object_class',
                            sublayer: 'db_sublayer',
                            db_id: 'id',
                        };
                    function d(e) {
                        var t;
                        return null !== (t = c[e]) && void 0 !== t ? t : e;
                    }
                    const h = {
                            Class: 'db_class',
                            DisputePosition: 'db_dispute_position',
                            ObjectClass: 'db_object_class',
                            ParkingType: 'db_parking_type',
                            Sublayer: 'db_sublayer',
                            Subsublayer: 'db_subsublayer',
                            Icon: 'db_icon',
                        },
                        u = (e) => {
                            var t, i, n;
                            e.enumerationValues
                                ? (e.enumerationValues = Object.keys(e.enumerationValues).reduce(
                                      (t, i) => (
                                          (t[
                                              ((e) => {
                                                  var t;
                                                  return null !== (t = h[e]) && void 0 !== t
                                                      ? t
                                                      : e;
                                              })(i)
                                          ] = e.enumerationValues[i]),
                                          t
                                      ),
                                      {},
                                  ))
                                : (e.enumerationValues = {
                                      db_class: null !== (t = e.classes) && void 0 !== t ? t : {},
                                      db_object_class:
                                          null !== (i = e.objectClasses) && void 0 !== i ? i : {},
                                      db_sublayer:
                                          null !== (n = e.sublayers) && void 0 !== n ? n : {},
                                  });
                        };
                    class m {
                        constructor(e, t, i) {
                            var n;
                            (this.id = e),
                                (this.modules = t),
                                (this.options = i),
                                (this.type = 'zenith'),
                                (this.worker = new t.workers.parser.ZenithSource()),
                                (this.sourceAttrs = (0, r.kn)(
                                    null !== (n = i.sourceAttributes) && void 0 !== n ? n : {},
                                    o.so,
                                ));
                        }
                        fetchTile(e, t) {
                            const { assetManager: i, map: n } = this.modules;
                            return this.worker
                                .fetchTile({
                                    coords: e,
                                    tileServer: this.options.tileServer,
                                    tileSet: this.options.tileSet,
                                    tileProtocol: this.options.tileProtocol,
                                    subdomains: this.options.subdomains,
                                    tileKey: this.options.tileKey,
                                    appId: this.options.appId,
                                    lang: t.lang,
                                    defaultLang: this.options.defaultLang,
                                    sessionId: this.options.sessionId,
                                })
                                .catch(() => Promise.resolve())
                                .then((r) => {
                                    if (!r) return;
                                    const { metadata: a, invalidTileKey: l } = r;
                                    return (
                                        a.forEach((r) => {
                                            const a = (0, s.Gr)('metatile', {
                                                host: this.options.tileServer,
                                                tileSet: this.options.tileSet,
                                                protocol: this.options.tileProtocol,
                                                subdomain: this.options.subdomains[0],
                                                hash: (0, o.GG)(r.metatileHash),
                                            });
                                            i.loadMetatile(a, r.metatileHash, r.regionId),
                                                n.emit('tileload', {
                                                    tileCoords: e,
                                                    regionId: r.regionId,
                                                }),
                                                t.shownRegionIds.add(r.regionId);
                                        }),
                                        l && n.emit('invalidtilekey'),
                                        a
                                    );
                                });
                        }
                        generateTile(e, t, i, o, r, s = {}, a, l = this.id) {
                            return this.worker.generateTile(
                                Object.assign(
                                    {
                                        styleId: i,
                                        tileInfo: (0, n.Bs)(t),
                                        pixelRatio: r,
                                        selectedIds: o,
                                        styleState: e.styleState,
                                        floorsEnabled: e.floorsEnabled,
                                        sourceAttrs: this.sourceAttrs,
                                        hoverId: a,
                                        sourceId: l,
                                        isDefaultSource: this.options.isDefaultSource,
                                        modelsPath: this.options.modelsPath,
                                    },
                                    s,
                                ),
                            );
                        }
                        generateModel(e) {
                            return this.worker.generateModel(e);
                        }
                        abortTileFetch(e) {
                            this.worker.abortTileRequest((0, n.gx)(e));
                        }
                        deleteTile(e) {
                            this.worker.deleteTile((0, n.gx)(e));
                        }
                        setAttributes(e) {
                            this.sourceAttrs = e;
                        }
                        getAttributes() {
                            return this.sourceAttrs;
                        }
                        destroy() {
                            this.worker.destroy(), (this.sourceAttrs = {});
                        }
                        setFeatureStateMap(e) {
                            this.worker.setFeatureStateMap(e);
                        }
                        setFeatureStateMapBinary(e) {
                            this.worker.setFeatureStateMapBinary(e);
                        }
                        appendHiddenObjectIds(e) {
                            this.modules.workers.parser.appendHiddenObjectIds(e);
                        }
                        removeHiddenObjectIds(e) {
                            this.modules.workers.parser.removeHiddenObjectIds(e);
                        }
                    }
                },
                603: (e, t, i) => {
                    i.d(t, { Z: () => se });
                    var n = i(6392),
                        o = i(5095);
                    class r {
                        constructor() {
                            (this.cache = new Map()), (this.pendingRequests = new Map());
                        }
                        fetch({
                            coords: e,
                            tileServer: t,
                            tileSet: i,
                            tileProtocol: r,
                            subdomains: s,
                            tileKey: a,
                            appId: l,
                            lang: c,
                            defaultLang: d,
                            sessionId: h,
                        }) {
                            return new Promise((u) => {
                                const m = (0, n.rL)(t, i, r, s, e, a, l, c, d, h),
                                    f = (0, n.gx)(e),
                                    p = (0, o.n)({ url: m }, (e, t) => {
                                        let i = !1;
                                        if (
                                            (this.pendingRequests.delete(f),
                                            void 0 !== e || 0 === t.byteLength)
                                        )
                                            return (
                                                void 0 !== e &&
                                                    (console.error(e),
                                                    403 === e.status && (i = !0)),
                                                this.cache.set(f, []),
                                                void u({ metadata: [], invalidTileKey: i })
                                            );
                                        const o = (0, n.CJ)(t),
                                            r = (0, n.xH)(o);
                                        this.cache.set(f, o), u({ metadata: r, invalidTileKey: i });
                                    });
                                this.pendingRequests.set(f, { xhr: p, resolve: u });
                            });
                        }
                        get(e) {
                            return this.cache.get(e) || [];
                        }
                        delete(e) {
                            this.cache.delete(e);
                        }
                        abortRequest(e) {
                            const t = this.pendingRequests.get(e);
                            void 0 !== t &&
                                (t.xhr.abort(), t.resolve(), this.pendingRequests.delete(e));
                        }
                        destroy() {
                            this.cache.clear(), this.pendingRequests.clear();
                        }
                    }
                    var s = i(3487);
                    class a extends s.c {
                        constructor(e) {
                            super(e),
                                (this.featureAttrs =
                                    (null == e ? void 0 : e.featureAttrs) || new Set()),
                                (this.clearAttrs = !0);
                        }
                        set(e, t, i) {
                            super.set(e, t, i),
                                Object.keys(i).forEach((e) => this.featureAttrs.add(e));
                        }
                    }
                    var l = i(3249),
                        c = i(1375);
                    const d = {
                        1: function (e) {
                            let t = 0;
                            for (let i = 0; i < e.length; i++) (t = (t + e[i]) & 255), (e[i] = t);
                        },
                        2: function (e) {
                            let t = 0;
                            for (let i = 0; i < e.length; i++) (t = (t + e[i]) & 65535), (e[i] = t);
                        },
                        4: function (e) {
                            let t = 0;
                            for (let i = 0; i < e.length; i++) (t = (t + e[i]) >>> 0), (e[i] = t);
                        },
                        8: function (e) {
                            let t = 0,
                                i = 0,
                                n = 0;
                            for (let o = 0; o < e.length; o += 2)
                                (n = i + e[o]),
                                    (i = n >>> 0),
                                    (e[o] = i),
                                    (t = (t + e[o + 1] + (n > 4294967295 ? 1 : 0)) >>> 0),
                                    (e[o + 1] = t);
                        },
                    };
                    class h {
                        constructor(e) {
                            (this.offset = 0),
                                (this.buffer = e),
                                (this.u8 = new Uint8Array(e)),
                                (this.u16 = new Uint16Array(e)),
                                (this.u32 = new Uint32Array(e)),
                                (this.s8 = new Int8Array(e)),
                                (this.s16 = new Int16Array(e)),
                                (this.s32 = new Int32Array(e)),
                                (this.f32 = new Float32Array(e));
                        }
                        readS8() {
                            return this.s8[this.offset++];
                        }
                        readU16() {
                            const e = this.u16[this.offset >> 1];
                            return (this.offset += 2), e;
                        }
                        readU32() {
                            const e = this.u32[this.offset >> 2];
                            return (this.offset += 4), e;
                        }
                        readF32() {
                            const e = this.f32[this.offset >> 2];
                            return (this.offset += 4), e;
                        }
                        readU8Vector(e = 1) {
                            const t = this.readU32() * e,
                                i = 3 & -t,
                                n = this.u8.subarray(this.offset, this.offset + t);
                            return (this.offset += t + i), n;
                        }
                        readU16Vector(e = 1) {
                            const t = this.readU32() * e * 2,
                                i = 3 & -t,
                                n = this.u16.subarray(this.offset >> 1, (this.offset + t) >> 1);
                            return (this.offset += t + i), n;
                        }
                    }
                    function u(e, t, i, n) {
                        const o = t.BYTES_PER_ELEMENT;
                        e.offset += -e.offset & (o - 1);
                        const r = new t(e.buffer, e.offset, i);
                        return (e.offset += o * i), n && d[o](r), r;
                    }
                    function m(e, t, i) {
                        e.offset += 7 & -e.offset;
                        const n = new Uint32Array(e.buffer, e.offset, 2 * t);
                        return (e.offset += 8 * t), i && d[8](n), n;
                    }
                    function f(e, t, i) {
                        e.offset += 3 & -e.offset;
                        const n = new Uint32Array(e.buffer, e.offset, t),
                            o = new Float32Array(e.buffer, e.offset, t);
                        let r;
                        if (((e.offset += 4 * t), i)) {
                            let e = 0;
                            for (r = 0; r < t; r++) (e = (e + n[r]) >>> 0), (o[r] = e / 1e3);
                        } else for (r = 0; r < t; r++) o[r] = n[r] / 1e3;
                        return o;
                    }
                    function p(e, t, i) {
                        e.offset += 3 & -e.offset;
                        const n = new Int32Array(e.buffer, e.offset, t),
                            o = new Float32Array(e.buffer, e.offset, t);
                        let r;
                        if (((e.offset += 4 * t), i)) {
                            let e = 0;
                            for (r = 0; r < t; r++) (e = (e + n[r]) >>> 0), (o[r] = (0 | e) / 1e3);
                        } else for (r = 0; r < t; r++) o[r] = n[r] / 1e3;
                        return o;
                    }
                    function _(e, t, i) {
                        switch (i) {
                            case 2:
                            case 10:
                                return u(e, Uint8Array, t);
                            case 3:
                                return u(e, Uint8Array, t, !0);
                            case 4:
                                return u(e, Uint16Array, t);
                            case 5:
                                return u(e, Uint16Array, t, !0);
                            case 6:
                            case 25:
                                return u(e, Uint32Array, t);
                            case 7:
                                return u(e, Uint32Array, t, !0);
                            case 8:
                            case 19:
                                return m(e, t);
                            case 9:
                            case 20:
                                return m(e, t, !0);
                            case 11:
                                return (function (e, t) {
                                    let i = e.offset;
                                    const n = e.u8,
                                        o = e.buffer,
                                        r = [];
                                    for (; t--; ) r.push(0 | n[i++]);
                                    const s = [];
                                    for (; ++t < r.length; ) {
                                        let e = r[t];
                                        255 === e &&
                                            (e = n[i++] | (n[i++] << 8) | (n[i++] << 16) | 0),
                                            s.push(new Uint8Array(o, i, e)),
                                            (i += e);
                                    }
                                    return (e.offset = i), s;
                                })(e, t);
                            case 12:
                                return (function (e, t) {
                                    e.offset += 3 & -e.offset;
                                    let i = e.offset;
                                    const n = e.u32,
                                        o = e.buffer,
                                        r = [];
                                    for (let e = 0; e < t; e++) r.push(n[i >> 2]), (i += 4);
                                    const s = [];
                                    for (let e = 0; e < t; e++) {
                                        const t = r[e];
                                        (i += 7 & -i), s.push(new Uint8Array(o, i, t)), (i += t);
                                    }
                                    return (e.offset = i), s;
                                })(e, t);
                            case 13:
                                return u(e, Int8Array, t);
                            case 14:
                                return u(e, Int8Array, t, !0);
                            case 15:
                                return u(e, Int16Array, t);
                            case 16:
                                return u(e, Int16Array, t, !0);
                            case 17:
                                return u(e, Int32Array, t);
                            case 18:
                                return u(e, Int32Array, t, !0);
                            case 21:
                                return f(e, t);
                            case 22:
                                return f(e, t, !0);
                            case 23:
                                return p(e, t);
                            case 24:
                                return p(e, t, !0);
                            default:
                                throw new Error('Unknown stream type ' + i);
                        }
                    }
                    function v(e) {
                        let t = 0;
                        for (let i = 0; i < e.length; i++) t += e[i];
                        return t;
                    }
                    function g(e, t, i) {
                        return new e.constructor(
                            e.buffer,
                            e.byteOffset + t * e.BYTES_PER_ELEMENT,
                            i,
                        );
                    }
                    var y = i(7204),
                        b = i(9218),
                        w = i(4372),
                        x = i(3672),
                        S = i(9981),
                        I = i(2543),
                        M = i(7609),
                        T = i(7999),
                        P = i(7188),
                        L = i(6273),
                        k = i(173);
                    const E = [],
                        A = new Int32Array(256);
                    let z;
                    const C = [],
                        F = [],
                        O = [0, 0, 0, 0, 0];
                    let D = 0,
                        R = 0,
                        j = 0;
                    const B = [];
                    function N(e, t, i, o, r, s, a, l, c) {
                        const {
                                styleState: d,
                                sourceId: m,
                                sourceAttrs: f,
                                tileInfo: p,
                                pixelRatio: g,
                                selectedIds: b,
                                floorsEnabled: w,
                                hoverId: x,
                                generateOnlySelectedPoi: M,
                                generateOnlyHoveredPoi: T,
                                modelsPath: L,
                            } = r,
                            { data: C } = s,
                            O = new y.c(b),
                            j = (0, n.VV)(C);
                        if (j.byteLength < 8) return o.getAccumulatedData();
                        E.length = 0;
                        const B = new h(j);
                        if (1279676242 !== B.readU32()) return o.getAccumulatedData();
                        const N = B.readU16();
                        if (2 !== N && 3 !== N)
                            return (
                                console.error(`Unsupported tile format version: "${N}"`),
                                o.getAccumulatedData()
                            );
                        B.readU16();
                        const { coords: H } = p,
                            G = (0, S.o1)(g);
                        !(function (e) {
                            const t = e.u8;
                            let i = e.offset,
                                n = e.u32[i >> 2];
                            (i += 4), (D = n), (R = i);
                            for (; n--; ) (i = 2 * t[i++] + i), (i = t[i++] + i);
                            e.offset = i + (3 & -i);
                        })(B),
                            (function (e) {
                                const t = e.u32[e.offset >> 2];
                                (e.offset += 4), (z = u(e, Uint8Array, t));
                                const i = u(e, Uint32Array, t);
                                for (let n = 0; n < t; n++) {
                                    const t = z[n];
                                    (E[n] = _(e, i[n], t)), (A[n] = 0);
                                }
                            })(B);
                        return (
                            (function (
                                e,
                                t,
                                i,
                                n,
                                o,
                                r,
                                s,
                                a,
                                l,
                                c,
                                d,
                                h,
                                m,
                                f,
                                p,
                                _,
                                g,
                                y,
                                b,
                                w,
                                x,
                            ) {
                                const S = Array.from(o.featureAttrs);
                                (0, P.Qy)(d, S);
                                const M = D,
                                    T = u(s, Int32Array, M),
                                    L = v(T),
                                    k = u(s, Uint8Array, L, !0),
                                    A = u(s, Uint8Array, v(k), !0),
                                    z = u(s, Uint8Array, L, !0),
                                    C = u(s, Uint8Array, v(z), !0),
                                    O = u(s, Uint16Array, L, !0);
                                let R = 0,
                                    j = 0,
                                    B = 0,
                                    N = 0;
                                for (let u = 0; u < M; u++) {
                                    const v = T[u];
                                    if ((W(s, d, h), 0 === u)) {
                                        const e = E[F[1]];
                                        r.setGeoIds(e);
                                    }
                                    for (let s = 0; s < v; s++) {
                                        const s = k[R];
                                        s > 0 && (N++, U(h, s, A, j, d, e), (j += s));
                                        const u = z[R];
                                        u > 0 && (N++, Z(h, u, C, B), (B += u));
                                        const v = (0, I.Yi)(n, _, d.tileProps, h, [], x),
                                            S = O[R];
                                        S > 0 &&
                                            V(
                                                e,
                                                t,
                                                i,
                                                v,
                                                o,
                                                r,
                                                S,
                                                a,
                                                l,
                                                c,
                                                d,
                                                m,
                                                f,
                                                p,
                                                g,
                                                y,
                                                b,
                                                w,
                                                N,
                                            ),
                                            R++;
                                    }
                                }
                                q();
                            })(
                                N,
                                e,
                                t,
                                d,
                                i,
                                o,
                                B,
                                H,
                                G,
                                O,
                                a,
                                l,
                                c,
                                w,
                                m,
                                f,
                                x,
                                M,
                                T,
                                L,
                                (0, k.O)(H[0] + H[1] + H[2] + 1),
                            ),
                            o.getAccumulatedData()
                        );
                    }
                    function U(e, t, i, n, o, r) {
                        for (var s; t--; ) {
                            const t = i[n++],
                                a = F[t],
                                l = C[t],
                                c = z[a];
                            if (8 === c || 9 === c || 19 === c || 20 === c)
                                (e[l] = (0, x.Ru)(E[a][A[a]], E[a][A[a] + 1])), (A[a] += 2);
                            else {
                                const t = E[a][A[a]];
                                switch (l) {
                                    case o.tileProps.objectLength:
                                    case o.tileProps.db_centroid_x:
                                    case o.tileProps.db_centroid_y:
                                    case o.tileProps.componentDistanceEnd:
                                    case o.tileProps.componentDistanceStart:
                                    case o.tileProps.previousPointX:
                                    case o.tileProps.previousPointY:
                                    case o.tileProps.nextPointX:
                                    case o.tileProps.nextPointY:
                                        e[l] = 2 === r ? t * L.gt : t;
                                        break;
                                    case o.tileProps.db_label:
                                    case o.tileProps.db_label2:
                                        e[l] = (0, T.zT)(t);
                                        break;
                                    default: {
                                        const i = o.tilePropsByIndex[l];
                                        i && o.reverseDictionaries[i]
                                            ? (e[l] =
                                                  null !== (s = o.reverseDictionaries[i][t]) &&
                                                  void 0 !== s
                                                      ? s
                                                      : t)
                                            : (e[l] = t);
                                    }
                                }
                                A[a]++;
                            }
                        }
                    }
                    function Z(e, t, i, n) {
                        for (; t--; ) {
                            const t = i[n++];
                            e[C[t]] = NaN;
                        }
                    }
                    let H = -1,
                        G = [];
                    function V(e, t, i, n, o, r, s, a, l, c, d, h, u, m, f, p, _, v, y) {
                        const { tileProps: S, defaultProps: T } = d,
                            { tileAttrs: P, featureAttrs: L } = n,
                            k = a[3];
                        if (H === y && 0 === G.length) {
                            for (let e = 0; e < j; e++) {
                                const t = O[e];
                                A[t] = A[t] + s;
                            }
                            return;
                        }
                        for (let t = 0; t < j; t++) {
                            const i = O[t];
                            (B[t] = $(g(E[i], A[i], s), t, e)), (A[i] = A[i] + s);
                        }
                        if (
                            void 0 !== S.db_sublayer &&
                            !Number.isNaN(P[S.db_sublayer]) &&
                            (0, M.Ty)(P[S.db_sublayer])
                        )
                            return;
                        const z = P[S.id];
                        let C = 'number' != typeof z && c.has(z);
                        p && (C = !0);
                        let F = !!_;
                        if (!F && void 0 !== f) {
                            if ('number' == typeof z || !(0, x.v7)(f, z)) return;
                            F = !0;
                        }
                        (P[S.selected] = C ? 1 : 0), (P[S.hovered] = F ? 1 : 0);
                        for (const e in T) {
                            const t = T[e];
                            Number.isNaN(P[t.index]) && (P[t.index] = t.value);
                        }
                        if (
                            ('number' != typeof z &&
                                u &&
                                P[S.db_hidden_by_plan_building_id] &&
                                k >= Math.floor(b.floors.displayStyleZoom) &&
                                (h.add(z),
                                r.addFloorHidingMap(z, P[S.db_hidden_by_plan_building_id])),
                            o.featureAttrs.size > 0)
                        ) {
                            const e = 'number' != typeof z && o.get(z.hi, z.lo);
                            if (e)
                                for (const t of o.featureAttrs)
                                    (o.clearAttrs = !1), (L[S[t]] = e[t]);
                            else if (!1 === o.clearAttrs) {
                                o.clearAttrs = !0;
                                for (const e in S) void 0 !== L[S[e]] && (L[S[e]] = void 0);
                            }
                        }
                        H !== y &&
                            ((G = i.getLayers(t.id, S, P).filter((e) => (0, I.FR)(e.filter, n))),
                            (H = y)),
                            (0, w.PA)(r, t, G, n, d, k, m, a, l, B, h, p || _, v);
                    }
                    function W(e, t, i) {
                        const n = Object.keys(t.tileProps).length,
                            o = e.u8;
                        let r,
                            s,
                            a = R;
                        for (s = 1; s < n; s++) i[s] = NaN;
                        for (r = o[a++], s = 0; s < r; s++) (C[s] = o[a++]), (F[s] = o[a++]);
                        for (r = o[a++], s = 0; s < r; s++) O[s] = o[a++];
                        (j = r), (R = a), q();
                    }
                    function q() {
                        B.length = 0;
                    }
                    function $(e, t, i) {
                        if (2 === i && t < 3 && e instanceof Uint16Array)
                            for (let t = 0; t < e.length; t++) e[t] *= L.gt;
                        return e;
                    }
                    var X = i(9450),
                        Y = i(127),
                        K = i(1678),
                        J = i(4922),
                        Q = i(4091),
                        ee = i(8183);
                    const te = [[0], [0], [0]],
                        ie = [];
                    function ne(e, t, i, n, o, r, s, a) {
                        const { matrix: l, offset: c, id: d, selected: u } = o,
                            m = new h(n),
                            f = [];
                        if (!e) return { objects: i.getAccumulatedData(), textures: f };
                        if (1296191066 !== m.readU32() || 1 !== m.readU16())
                            return { objects: i.getAccumulatedData(), textures: [] };
                        m.readU16();
                        const p = m.readU32();
                        for (let e = 0; e < p; e++) f.push(m.readU8Vector());
                        const { tileProps: _ } = r,
                            v = [],
                            g = Object.keys(_).length;
                        for (let e = 0; e < g; e++) v[e] = NaN;
                        if (
                            ((v[_.db_sublayer] = 'Building_model'),
                            (v[_.id] = d),
                            (v[_.selected] = u ? 1 : 0),
                            (v[_.db_region] = s),
                            a.featureAttrs.size > 0)
                        ) {
                            const e = Array.from(a.featureAttrs);
                            (0, P.Qy)(r, e);
                        }
                        const y = [],
                            b = 'number' != typeof d && a.get(d.hi, d.lo);
                        if (b)
                            for (const e of a.featureAttrs) (a.clearAttrs = !1), (y[_[e]] = b[e]);
                        else if (!1 === a.clearAttrs) {
                            a.clearAttrs = !0;
                            for (const e in _) void 0 !== y[_[e]] && (y[_[e]] = void 0);
                        }
                        i.setGeoIds(new Uint32Array([d.lo, d.hi]));
                        const w = m.offset,
                            x = (0, I.Yi)(t, P.i4, _, v, y);
                        return (
                            e.layers.forEach((t) => {
                                if ('buildingModel' !== t.type) return;
                                (0, I.FR)(t.filter, x) &&
                                    ((m.offset = w),
                                    (function (e, t, i, n, o, r, s) {
                                        const a = o.readU32();
                                        for (let l = 0; l < a; l++) {
                                            const a = o.readU32(),
                                                l = X.al(o.readF32(), o.readF32(), o.readF32()),
                                                c = X.al(o.readF32(), o.readF32(), o.readF32()),
                                                d = X.lu(X.Ue(), c, l),
                                                h = [];
                                            Y.Iu(h, r, l),
                                                Y.bA(h, h, d),
                                                (h[12] += s[0]),
                                                (h[13] += s[1]);
                                            const u = o.readU16Vector(5),
                                                m = o.readU32();
                                            for (let r = 0; r < m; r++) {
                                                const r = 1 === o.readU32() ? L.uC : L.Fg,
                                                    s = o.readU16Vector();
                                                do {
                                                    K.X.processSubmesh(
                                                        e.id,
                                                        t,
                                                        i,
                                                        n,
                                                        u,
                                                        s,
                                                        r,
                                                        a,
                                                        h,
                                                    );
                                                } while (n.isOverloaded());
                                            }
                                            const f = o.readU16Vector();
                                            do {
                                                K.X.processOuterEdge(e.id, t, i, n, u, f, h);
                                            } while (n.isOverloaded());
                                            const p = (0, Q.qt)(oe(u)),
                                                _ = (0, ee.y)(p);
                                            for (let t = 0; t < p.length - 2; t++) {
                                                for (let e = 0; e < 3; e++) {
                                                    const i = re(t + e, p.length);
                                                    (te[0][e] = p[i][0]),
                                                        (te[1][e] = p[i][1]),
                                                        (te[2][e] = 0),
                                                        (ie[e] = _[i]);
                                                }
                                                do {
                                                    J._.generateFloorsBottomFill(
                                                        n,
                                                        e.id,
                                                        te,
                                                        ie,
                                                        K.d,
                                                        h,
                                                    );
                                                } while (n.isOverloaded());
                                            }
                                        }
                                    })(e, t, x, i, m, l, c));
                            }),
                            { objects: i.getAccumulatedData(), textures: f }
                        );
                    }
                    function oe(e) {
                        const t = [];
                        for (let i = 0; i < e.length; i += 5) t.push([e[i], e[i + 1]]);
                        return t;
                    }
                    function re(e, t) {
                        return 0 === e ? 0 : e % 2 ? (e + 1) / 2 : t - e / 2;
                    }
                    class se {
                        constructor(e) {
                            (this.scope = e),
                                (this.tileLoader = new r()),
                                (this.tileAttrs = []),
                                (this.models = {}),
                                (this.featureStateMap = new a());
                        }
                        fetchTile(e) {
                            return this.tileLoader.fetch(e);
                        }
                        abortTileRequest(e) {
                            this.tileLoader.abortRequest(e);
                        }
                        generateTile(e) {
                            const {
                                    styleManager: t,
                                    collector: i,
                                    hiddenObjectIds: o,
                                    metatiles: r,
                                } = this.scope,
                                { tileInfo: s } = e,
                                a = (0, n.gx)(s.coords),
                                d = this.tileLoader.get(a),
                                h = [],
                                u = [];
                            return (
                                d.forEach((n) => {
                                    const { regionId: s, metatileHash: a } = n,
                                        d = this.scope.styleManager.getStyle(e.styleId);
                                    if (!d) return;
                                    if (e.areTileBoundsVisible && e.isDefaultSource) {
                                        const n = t
                                            .getStyle(l.jf)
                                            .layers.find((e) => 'debug-tile-bounds' === e.id);
                                        (0, c.cX)(i, n, e.styleState);
                                    }
                                    const m = N(
                                        d,
                                        t,
                                        this.featureStateMap,
                                        i,
                                        e,
                                        n,
                                        r[a],
                                        this.tileAttrs,
                                        o,
                                    );
                                    h.push({
                                        regionId: s,
                                        metatileHash: a,
                                        collectorOutput: m,
                                        styleId: d.id,
                                    }),
                                        u.push(...m.transferable);
                                }),
                                this.scope.resetCollector(),
                                this.scope.syncRasterSets(),
                                Promise.resolve({ results: h, transferable: u })
                            );
                        }
                        deleteTile(e) {
                            this.tileLoader.delete(e);
                        }
                        setFeatureStateMap(e) {
                            this.featureStateMap = this.buildFeatureState(e);
                        }
                        setFeatureStateMapBinary(e) {
                            this.featureStateMap = this.buildFeatureStateFromBinary(e);
                        }
                        generateModel(e) {
                            const { regionId: t, metatileHash: i, styleId: n, url: r, id: s } = e,
                                a = (0, x.Ak)(s);
                            return new Promise((s) => {
                                const l = this.models[a];
                                (l
                                    ? Promise.resolve(l)
                                    : new Promise((e) => {
                                          (0, o.n)({ url: r }, (t, i) => {
                                              if (t || 0 === i.byteLength) {
                                                  const t = (this.models[a] = new ArrayBuffer(0));
                                                  e(t);
                                              } else (this.models[a] = i), e(i);
                                          });
                                      })
                                ).then((o) => {
                                    if (0 === o.byteLength)
                                        return void s({
                                            objects: this.scope.collector.getAccumulatedData(),
                                            textures: { isBitmap: !1, data: [] },
                                        });
                                    const r = this.scope.styleManager.getStyle(n);
                                    if (!r)
                                        return void s({
                                            objects: this.scope.collector.getAccumulatedData(),
                                            textures: { isBitmap: !1, data: [] },
                                        });
                                    const { objects: a, textures: l } = ne(
                                        r,
                                        e.styleState,
                                        this.scope.collector,
                                        o,
                                        e,
                                        this.scope.metatiles[i],
                                        t,
                                        this.featureStateMap,
                                    );
                                    if (this.scope.createImageBitmap) {
                                        const e = l.map((e) => {
                                            const t = new Blob([e], { type: 'image/png' });
                                            return createImageBitmap(t);
                                        });
                                        Promise.all(e).then((e) => {
                                            s({
                                                objects: a,
                                                textures: { isBitmap: !0, data: e },
                                                transferable: [...a.transferable, ...e],
                                            }),
                                                this.scope.resetCollector();
                                        });
                                    } else
                                        s({
                                            objects: a,
                                            textures: { isBitmap: !1, data: l },
                                            transferable: [...a.transferable, o],
                                        }),
                                            this.scope.resetCollector();
                                });
                            });
                        }
                        destroy() {
                            this.tileLoader.destroy(), (this.tileAttrs = []), (this.models = {});
                        }
                        buildFeatureState(e) {
                            const t = new a();
                            for (const i in e) {
                                const n = (0, x.IL)(i);
                                t.set(n.hi, n.lo, e[i]);
                            }
                            return t;
                        }
                        buildFeatureStateFromBinary(e) {
                            return (function (e) {
                                const t = new a(),
                                    { attributes: i, size: n } = e,
                                    o = {
                                        stride: i.id.stride,
                                        view: new Uint32Array(i.id.buffer, i.id.offset),
                                    },
                                    r = [];
                                for (const t in e.attributes)
                                    if ('id' !== t) {
                                        const { stride: i, buffer: n, offset: o } = e.attributes[t];
                                        r.push({
                                            name: t,
                                            stride: i,
                                            view: new Float32Array(n, o),
                                        });
                                    }
                                for (let e = 0; e < n; e++) {
                                    const i = o.view[(e * o.stride) / 4],
                                        n = o.view[(e * o.stride) / 4 + 1],
                                        s = {};
                                    for (const t of r) {
                                        const i = t.view[(e * t.stride) / 4];
                                        s[t.name] = Number.isNaN(i) ? null : i;
                                    }
                                    t.set(n, i, s);
                                }
                                return t;
                            })(e);
                        }
                    }
                },
                199: (e, t, i) => {
                    i.d(t, { T: () => n });
                    const n = [
                        {
                            id: '__2gis_comm_poi',
                            type: 'point',
                            style: {
                                textFont: [
                                    'Noto_Sans_Semibold',
                                    ['step', ['zoom'], 'Noto_Sans', 16, 'Noto_Sans'],
                                ],
                                iconImage: 'peak',
                                iconWidth: ['interpolate', ['linear'], ['zoom'], 15, 22, 16.8, 30],
                                textColor: '#3A3A3A',
                                visibility: 'visible',
                                textFontSize: [
                                    ['interpolate', ['linear'], ['zoom'], 15.5, 11, 18, 13],
                                    ['interpolate', ['linear'], ['zoom'], 15.5, 10, 18, 12],
                                ],
                                textHaloColor: 'rgba(255,255,255,0.5)',
                                textHaloWidth: 0.9,
                                iconLabelingGroup: i(3754).n3,
                                iconLabelingMargin: { leftRight: 6, topBottom: 6 },
                            },
                            filter: [
                                'all',
                                [
                                    'match',
                                    ['get', 'db_sublayer'],
                                    ['Commercial_poi_default', 'Commercial_poi_city'],
                                    !0,
                                    !1,
                                ],
                                [
                                    'any',
                                    [
                                        '==',
                                        [
                                            'in',
                                            ['get', 'db_building_id'],
                                            ['global', '_activeFloorBuildingIds'],
                                        ],
                                        !1,
                                    ],
                                    ['in', ['get', 'db_plan_id'], ['global', '_activeFloorIds']],
                                ],
                            ],
                        },
                    ];
                },
                7436: (e, t, i) => {
                    i.d(t, { h: () => d });
                    var n = i(7464);
                    function o(e) {
                        return 'boolean' != typeof e && 'attrs' === e.type;
                    }
                    function r(e) {
                        return 'boolean' != typeof e && 'unextractable' === e.type;
                    }
                    function s(e) {
                        if (!(0, n.Uu)(e)) return [Boolean(e)];
                        let t = [];
                        const i = [];
                        switch (e.type) {
                            case 'all':
                                const l = e.array.map(s);
                                for (const e of l) {
                                    const n = [];
                                    for (const t of e) {
                                        if (!1 === t) return [!1];
                                        o(t) ? n.push(t) : r(t) && i.push(t);
                                    }
                                    n.length > 0 && (t = 0 === t.length ? n : a(t, n));
                                }
                                break;
                            case 'match':
                                if (!(0, n.vB)(e.input)) return [{ type: 'unextractable', exp: e }];
                                const c = e.input.property,
                                    d = e.defaultOutput;
                                for (const n of e.cases) {
                                    const e = s(n.output),
                                        l = [];
                                    n.values.forEach((e) => {
                                        l.push({ type: 'attrs', attrs: { [c]: e } });
                                    });
                                    for (const n of e)
                                        if (o(n)) for (const e of a([n], l)) t.push(e);
                                        else if (r(n)) {
                                            i.push(n);
                                            for (const e of l) t.push(e);
                                        } else if (!0 === n && !d) for (const e of l) t.push(e);
                                }
                                break;
                            case '==': {
                                let i, o;
                                if ((0, n.vB)(e.leftValue) && (0, n.HW)(e.rightValue))
                                    (i = e.leftValue.property), (o = e.rightValue);
                                else {
                                    if (!(0, n.vB)(e.rightValue) || !(0, n.HW)(e.leftValue))
                                        return [{ type: 'unextractable', exp: e }];
                                    (i = e.rightValue.property), (o = e.leftValue);
                                }
                                t.push({ type: 'attrs', attrs: { [i]: o } });
                                break;
                            }
                            default:
                                return [{ type: 'unextractable', exp: e }];
                        }
                        return t.concat(i);
                    }
                    function a(e, t) {
                        const i = [];
                        for (const n of e)
                            for (const e of t)
                                i.push({
                                    type: 'attrs',
                                    attrs: Object.assign(Object.assign({}, n.attrs), e.attrs),
                                });
                        return i;
                    }
                    var l = i(3672);
                    class c {
                        constructor() {
                            (this.layers = []),
                                (this.keyStat = {}),
                                (this.orderedKeys = []),
                                (this.tree = null),
                                (this.treeNodesCount = 0),
                                (this.traverseCount = 0),
                                (this.traverseIterations = 0);
                        }
                        addLayers(e) {
                            for (const t of e)
                                'custom' !== t.type &&
                                    t.filter &&
                                    (this.layers.push(t), this.statLayerKeys(t));
                            this.buildTree();
                        }
                        getLayers(e, t) {
                            const i = [],
                                n = (o, r) => {
                                    if (((this.traverseIterations += 1), !o)) return;
                                    for (const e of o.leafs) i.push(e);
                                    const s = this.orderedKeys[r];
                                    if (!s) return;
                                    const a = t[e[s]],
                                        c = (0, l.nI)(a) ? (0, l.Ak)(a) : a;
                                    void 0 !== c
                                        ? (n(o.children[c], r + 1), n(o.novalue, r + 1))
                                        : n(o.novalue, r + 1);
                                };
                            return (this.traverseCount += 1), n(this.tree, 0), i;
                        }
                        stat() {
                            const e = this.traverseIterations / this.traverseCount || 0;
                            return {
                                tree: this.tree,
                                treeNodes: this.treeNodesCount,
                                layers: this.layers.length,
                                keyStat: this.keyStat,
                                itersPerTraverse: e,
                            };
                        }
                        statLayerKeys(e) {
                            const t = s(e.filter).filter((e) => o(e))[0];
                            if (t && o(t))
                                for (const e in t.attrs)
                                    void 0 === this.keyStat[e] && (this.keyStat[e] = 0),
                                        (this.keyStat[e] += 1);
                        }
                        getOrderedKeys() {
                            return Object.entries(this.keyStat)
                                .sort(([e, t], [i, n]) => n - t)
                                .map(([e, t]) => e);
                        }
                        buildTree() {
                            this.orderedKeys = this.getOrderedKeys();
                            const e = [];
                            for (const t of this.layers) {
                                const i = s(t.filter).filter(o);
                                0 === i.length && e.push(t);
                                for (const e of i) {
                                    const i = new Set(Object.keys(e.attrs));
                                    let n = 0;
                                    const o = e.attrs;
                                    let r = this.tree;
                                    for (let e = 0; e <= this.orderedKeys.length; e++) {
                                        if (n === i.size) {
                                            null == r || r.leafs.push(t);
                                            break;
                                        }
                                        const s = this.orderedKeys[e],
                                            a = this.orderedKeys[e + 1] || '';
                                        if (
                                            (r ||
                                                ((r = this.makeTreeNode(s)),
                                                null === this.tree && (this.tree = r)),
                                            i.has(s))
                                        ) {
                                            const e = o[s];
                                            r.children[e] || (r.children[e] = this.makeTreeNode(a)),
                                                (r = r.children[e]),
                                                (n += 1);
                                        } else
                                            r.novalue || (r.novalue = this.makeTreeNode(a)),
                                                (r = r.novalue);
                                    }
                                }
                            }
                            e.length > 0 &&
                                (this.tree || (this.tree = this.makeTreeNode('')),
                                (this.tree.leafs = e));
                        }
                        makeTreeNode(e) {
                            return (
                                (this.treeNodesCount += 1),
                                { key: e, children: {}, novalue: null, leafs: [] }
                            );
                        }
                    }
                    class d {
                        constructor() {
                            (this.metaStyles = new Map()), (this.layerTrees = new Map());
                        }
                        proxySyncStyle(e) {
                            const t = new c();
                            t.addLayers(e.layers),
                                this.layerTrees.set(e.id, t),
                                this.metaStyles.set(e.id, e);
                        }
                        getStyle(e) {
                            return this.metaStyles.get(e);
                        }
                        getLayers(e, t, i) {
                            const n = this.layerTrees.get(e);
                            return n ? n.getLayers(t, i) : [];
                        }
                    }
                },
                4389: (e, t, i) => {
                    i.d(t, { l: () => f });
                    var n = i(6273),
                        o = i(378),
                        r = i(9090),
                        s = i(8352),
                        a = i(5600),
                        l = i(159),
                        c = i(2702);
                    const d = o.Ue(),
                        h = o.Ue(),
                        u = {
                            type: l.SP.Entrance,
                            offsetMultiplier: 18,
                            cDist: 0,
                            oLen: 0,
                            px: [],
                            py: [],
                            count: 0,
                            localID: 0,
                        };
                    function m(e, t, i, o) {
                        return (
                            (u.px = e[0]),
                            (u.py = e[1]),
                            (u.oLen = i / n.Bq),
                            (u.count = t),
                            (u.localID = o),
                            u
                        );
                    }
                    const f = (0, a.D)({
                        symbol: 'arrow',
                        sinks: {
                            stroke: {
                                stride: 36,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.segmentEnd = new Uint16Array(t, 4)),
                                        (e.views.texExtender = new Int8Array(t, 8)),
                                        (e.views.arrowExtender = new Int8Array(t, 10)),
                                        (e.views.extender = new Int16Array(t, 12)),
                                        (e.views.direction = new Int16Array(t, 16)),
                                        (e.views.vertexDistance = new Float32Array(t, 20)),
                                        (e.views.objectLength = new Float32Array(t, 24)),
                                        (e.views.type = new Float32Array(t, 28)),
                                        (e.views.localID = new Uint32Array(t, 32));
                                },
                                packObjectAttributes: (e, t, i, n, o) =>
                                    (0, c.v$)([e, t, i > 2 ? 1 : 0], n, o),
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    isLongArrow: e[2],
                                    tileData: e.slice(3),
                                }),
                            },
                        },
                        generate: (e, t, i, n, o) => {
                            const r = o[0],
                                a = o[1],
                                c = o[0].length,
                                d = (function (e, t, i) {
                                    let n = 0;
                                    for (let o = 1; o < i; o++) {
                                        const i = e[o] - e[o - 1],
                                            r = t[o] - t[o - 1];
                                        n += Math.sqrt(i * i + r * r);
                                    }
                                    return n;
                                })(r, a, c),
                                h = e.getBucket(
                                    i.type,
                                    'stroke',
                                    f.sinks.stroke.packObjectAttributes(
                                        t,
                                        i.innerId,
                                        c,
                                        i.dataKeys,
                                        n,
                                    ),
                                    f.sinks.stroke.binder,
                                ),
                                u = e.idIndexer.getIndex({
                                    id: n.tileAttrs[n.tileProps.id],
                                    styleId: t,
                                    layer: i,
                                    sublayer: n.tileAttrs[n.tileProps.db_sublayer],
                                }),
                                _ = m(o, c, d, u);
                            (0, s.W)(
                                o[0],
                                o[1],
                                c,
                                l.CJ.Flat,
                                l.kU.ObjectEnding,
                                l.kU.ObjectEnding,
                                0,
                                0,
                                0,
                                0,
                                _,
                                h,
                            );
                            let v = 0;
                            p(h, l.gD.StartBorder, r[0], a[0], r[1], a[1], 0, 0, v, d, u);
                            for (let e = 0; e < c - 1; e++) {
                                if (0 !== e) {
                                    const t = r[e] - r[e - 1],
                                        i = a[e] - a[e - 1];
                                    v += Math.sqrt(t * t + i * i);
                                }
                                p(h, l.gD.Arrow, r[e], a[e], r[e + 1], a[e + 1], -1, 0, v, d, u);
                            }
                        },
                    });
                    function p(e, t, i, n, o, r, s, a, l, c, d) {
                        !(function (e, t, i, n, o, r, s) {
                            const { elements: a, indices: l } = e,
                                { buffer: c, offset: d } = l,
                                h = a.offset;
                            (c[d] = h + t),
                                (c[d + 1] = h + i),
                                (c[d + 2] = h + n),
                                (c[d + 3] = h + o),
                                (c[d + 4] = h + r),
                                (c[d + 5] = h + s),
                                (l.offset = d + 6);
                        })(e, 1, 2, 0, 0, 2, 3),
                            _(e, t, i, n, o, r, s, a, -1, -1, l, c, !0, d),
                            _(e, t, i, n, o, r, s, a, 1, -1, l, c, !1, d),
                            _(e, t, i, n, o, r, s, a, 1, 1, l, c, !1, d),
                            _(e, t, i, n, o, r, s, a, -1, 1, l, c, !0, d);
                    }
                    function _(e, t, i, o, s, a, l, c, u, m, f, p, _, v) {
                        const g = e.elements,
                            y = g.stride * g.offset,
                            b = y >> 1,
                            w = b >> 1;
                        (0, r.uI)(d, i, o, s, a),
                            (0, r.fN)(h, d),
                            (e.views.position[b] = n.jO + i),
                            (e.views.position[b + 1] = n.jO + o),
                            (e.views.segmentEnd[b] = n.jO + s),
                            (e.views.segmentEnd[b + 1] = n.jO + a),
                            (e.views.texExtender[y] = (0, r.i7)(h[0] * m * (_ ? -1 : 1) * n.Gt)),
                            (e.views.texExtender[y + 1] = (0, r.i7)(
                                h[1] * m * (_ ? -1 : 1) * n.Gt,
                            )),
                            (e.views.arrowExtender[y] = (0, r.i7)(u * n.Gt)),
                            (e.views.arrowExtender[y + 1] = (0, r.i7)(m * n.Gt));
                        const x = u + l,
                            S = m + c,
                            I = d[0] * x + h[0] * S,
                            M = d[1] * x + h[1] * S;
                        (e.views.extender[b] = Math.round(I * n.Gt * 127)),
                            (e.views.extender[b + 1] = Math.round(M * n.Gt * 127)),
                            (e.views.direction[b] = Math.round(127 * d[0])),
                            (e.views.direction[b + 1] = Math.round(127 * d[1])),
                            (e.views.vertexDistance[w] = f / n._H),
                            (e.views.objectLength[w] = p / n._H),
                            (e.views.type[w] = t),
                            (e.views.localID[w] = v),
                            e.elements.offset++;
                    }
                },
                1678: (e, t, i) => {
                    i.d(t, { X: () => c, d: () => l });
                    var n = i(5600),
                        o = i(2682),
                        r = i(3672),
                        s = i(2702),
                        a = i(6273);
                    const l = [a._H / 2, a._H / 2],
                        c = (0, n.D)({
                            symbol: 'buildingModel',
                            sinks: {
                                fill: {
                                    stride: 24,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.texCoords = new Uint16Array(t, 8)),
                                            (e.views.localID = new Uint32Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 20));
                                    },
                                    packObjectAttributes: (e, t, i, n, o, r, a) =>
                                        (0, s.v$)([e, t, i, o, n], r, a),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        texture: e[2],
                                        id: Number.isNaN(e[3]) ? void 0 : (0, r.Ak)(e[3]),
                                        matrix: e[4],
                                        tileData: e.slice(5),
                                    }),
                                },
                                stroke: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.directionDistance = new Int8Array(t, 8)),
                                            (e.views.demPosition = new Int16Array(t, 12));
                                    },
                                    packObjectAttributes: (e, t, i, n, o, r) =>
                                        (0, s.v$)([e, t, n, i], o, r),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        id: Number.isNaN(e[2]) ? void 0 : (0, r.Ak)(e[2]),
                                        matrix: e[3],
                                        tileData: e.slice(4),
                                    }),
                                },
                            },
                            processSubmesh(e, t, i, n, o, r, s, a, l) {
                                const { tileProps: h, tileAttrs: u } = i,
                                    m = u[h.id],
                                    f = n.idIndexer.getIndex({
                                        id: m,
                                        styleId: e,
                                        layer: t,
                                        sublayer: u[h.db_sublayer],
                                    }),
                                    p = n.buildingPointIndexer.getIndex(m),
                                    _ = n.getBucket(
                                        t.type,
                                        'fill',
                                        c.sinks.fill.packObjectAttributes(
                                            e,
                                            t.innerId,
                                            a,
                                            l,
                                            m,
                                            t.dataKeys,
                                            i,
                                        ),
                                        c.sinks.fill.binder,
                                        s,
                                    );
                                !(function (e, t) {
                                    const i = e.elements.offset;
                                    let n = e.indices.offset;
                                    for (let o = 0; o < t.length; o++)
                                        e.indices.buffer[n++] = i + t[o];
                                    e.indices.offset = n;
                                })(_, r);
                                for (let e = 0; e < o.length; e++) d(_, o, e, f, p);
                            },
                            processOuterEdge(e, t, i, n, r, s, a) {
                                const { tileProps: d, tileAttrs: h } = i,
                                    u = h[d.id],
                                    m = n.getBucket(
                                        t.type,
                                        'stroke',
                                        c.sinks.stroke.packObjectAttributes(
                                            e,
                                            t.innerId,
                                            a,
                                            u,
                                            t.dataKeys,
                                            i,
                                        ),
                                        c.sinks.stroke.binder,
                                    );
                                for (let e = 0; e < s.length; e += 2) {
                                    const t = 5 * s[e],
                                        i = 5 * s[e + 1];
                                    (0, o.n)(
                                        m,
                                        r[t],
                                        r[t + 1],
                                        r[t + 2],
                                        r[i],
                                        r[i + 1],
                                        r[i + 2],
                                        l,
                                        !0,
                                    );
                                }
                            },
                        });
                    function d(e, t, i, n, o) {
                        const r = e.elements.offset,
                            s = c.sinks.fill.stride,
                            a = 5 * i,
                            d = r * (s / e.views.position.BYTES_PER_ELEMENT),
                            h = r * (s / e.views.localID.BYTES_PER_ELEMENT);
                        (e.views.position[d] = t[a]),
                            (e.views.position[d + 1] = t[a + 1]),
                            (e.views.position[d + 2] = t[a + 2]),
                            (e.views.texCoords[d] = t[a + 3]),
                            (e.views.texCoords[d + 1] = t[a + 4]),
                            (e.views.localID[h] = n),
                            (e.views.demPosition[d] = l[0] / 8),
                            (e.views.demPosition[d + 1] = l[1] / 8),
                            (e.views.labelingTextureID[h] = o),
                            e.elements.offset++;
                    }
                },
                871: (e, t, i) => {
                    i.d(t, { p: () => s });
                    var n = i(5600),
                        o = i(2702),
                        r = i(6273);
                    const s = (0, n.D)({
                        symbol: 'circle',
                        sinks: {
                            fill: {
                                stride: 12,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.extender = new Int16Array(t, 4)),
                                        (e.views.localID = new Uint32Array(t, 8));
                                },
                                packObjectAttributes: (e, t, i, n) => (0, o.v$)([e, t], i, n),
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    tileData: e.slice(2),
                                }),
                            },
                        },
                        generate(e, t, i, n, o) {
                            const r = e.getBucket(
                                    i.type,
                                    'fill',
                                    s.sinks.fill.packObjectAttributes(t, i.innerId, i.dataKeys, n),
                                    s.sinks.fill.binder,
                                ),
                                l = e.idIndexer.getIndex({
                                    id: n.tileAttrs[n.tileProps.id],
                                    styleId: t,
                                    layer: i,
                                    sublayer: n.tileAttrs[n.tileProps.db_sublayer],
                                }),
                                c = o[0][0],
                                d = o[1][0];
                            !(function (e, t, i, n, o, r, s) {
                                const { elements: a, indices: l } = e,
                                    { buffer: c, offset: d } = l,
                                    h = a.offset;
                                (c[d] = h + t),
                                    (c[d + 1] = h + i),
                                    (c[d + 2] = h + n),
                                    (c[d + 3] = h + o),
                                    (c[d + 4] = h + r),
                                    (c[d + 5] = h + s),
                                    (l.offset = d + 6);
                            })(r, 0, 2, 1, 0, 3, 2),
                                a(r, c, d, -1, -1, l),
                                a(r, c, d, -1, 1, l),
                                a(r, c, d, 1, 1, l),
                                a(r, c, d, 1, -1, l);
                        },
                    });
                    function a(e, t, i, n, o, s) {
                        const a = (e.elements.offset * e.elements.stride) >> 1,
                            l = a >> 1;
                        (e.views.position[a] = r.jO + t),
                            (e.views.position[a + 1] = r.jO + i),
                            (e.views.extender[a] = n),
                            (e.views.extender[a + 1] = o),
                            (e.views.localID[l] = s),
                            e.elements.offset++;
                    }
                },
                3097: (e, t, i) => {
                    i.d(t, { L: () => f });
                    var n = i(8352),
                        o = i(159),
                        r = i(5600),
                        s = i(2702),
                        a = i(6273),
                        l = i(1573),
                        c = i(949),
                        d = i(9520),
                        h = i(2213);
                    const u = {
                        type: o.SP.Striped,
                        cDist: 0,
                        oLen: 0,
                        localID: 0,
                        offsetMultiplier: 14,
                    };
                    function m(e, t, i) {
                        return (u.cDist = e), (u.oLen = t), (u.localID = i), u;
                    }
                    const f = (0, r.D)({
                        symbol: 'dashedLine',
                        sinks: {
                            stroke: {
                                stride: 28,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.extender = new Int16Array(t, 4)),
                                        (e.views.texExtender = new Int8Array(t, 8)),
                                        (e.views.vertexDistance = new Float32Array(t, 12)),
                                        (e.views.componentDistance = new Float32Array(t, 16)),
                                        (e.views.objectLength = new Float32Array(t, 20)),
                                        (e.views.localID = new Uint32Array(t, 24));
                                },
                                packObjectAttributes(e, t, i, n) {
                                    var o;
                                    const r =
                                        null !== (o = (0, l.tp)(n.tileProps, n.tileAttrs)) &&
                                        void 0 !== o
                                            ? o
                                            : n.tileAttrs[n.tileProps.drawLevel];
                                    return (0, s.v$)([e, t, r], i, n);
                                },
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    drawLevel: e[2],
                                    tileData: e.slice(3),
                                }),
                            },
                        },
                        generate(e, t, i, r, s, l) {
                            const u = (0, h.q)(c.m, d.O)(i, r, s, l);
                            if (null === u) return;
                            const { tileAttrs: p, tileProps: _ } = r,
                                v = e.getBucket(
                                    i.type,
                                    'stroke',
                                    f.sinks.stroke.packObjectAttributes(
                                        t,
                                        i.innerId,
                                        i.dataKeys,
                                        r,
                                    ),
                                    f.sinks.stroke.binder,
                                ),
                                g = e.idIndexer.getIndex({
                                    id: p[_.id],
                                    styleId: t,
                                    layer: i,
                                    sublayer: p[_.db_sublayer],
                                }),
                                y = m(
                                    p[_.componentDistanceStart] / a.Bq,
                                    p[_.objectLength] / a.Bq,
                                    g,
                                ),
                                b = !Number.isNaN(p[_.beginningIsCut]) && 0 !== p[_.beginningIsCut],
                                w = !Number.isNaN(p[_.endingIsCut]) && 0 !== p[_.endingIsCut];
                            (0, n.W)(
                                u[0],
                                u[1],
                                u[0].length,
                                o.CJ.Flat,
                                b ? o.kU.TileCut : o.kU.ObjectEnding,
                                w ? o.kU.TileCut : o.kU.ObjectEnding,
                                p[_.previousPointX],
                                p[_.previousPointY],
                                p[_.nextPointX],
                                p[_.nextPointY],
                                y,
                                v,
                            );
                        },
                    });
                },
                4922: (e, t, i) => {
                    i.d(t, { _: () => l });
                    var n = i(5600),
                        o = i(3698),
                        r = i(6273),
                        s = i(132);
                    const a = {
                            stride: 4,
                            binder: (e, t) => {},
                            packObjectAttributes: (e, t) => [e, t],
                            unpackObjectAttributes: (e) => ({
                                styleId: e[0],
                                layerId: e[1],
                                tileData: e.slice(3),
                            }),
                        },
                        l = (0, n.D)({
                            symbol: 'dem',
                            sinks: {
                                mesh: a,
                                ground: a,
                                elevation: {
                                    stride: 8,
                                    binder: (e, t) => {},
                                    packObjectAttributes: (e, t, i) => [e, t, i],
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        textureIndex: e[2],
                                        tileData: e.slice(4),
                                    }),
                                },
                                hillshade: {
                                    stride: 8,
                                    binder: (e, t) => {},
                                    packObjectAttributes: (e, t) => [e, t],
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        tileData: e.slice(2),
                                    }),
                                },
                                flatBottom: {
                                    stride: 12,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.demPosition = new Int16Array(t, 4)),
                                            (e.views.extender = new Int8Array(t, 8));
                                    },
                                    packObjectAttributes: (e, t, i) => (i ? [e, t, i] : [e, t]),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        matrix: e[2] ? e[2] : void 0,
                                        tileData: e.slice(3),
                                    }),
                                },
                            },
                            generateElevation(e, t, i, n, s) {
                                const a = new Uint16Array(
                                    t.reduce((e, t) => {
                                        const [i, n, s, a] = t;
                                        return (
                                            e.push(
                                                r.jO + i * r.Bq,
                                                r.jO + n * r.Bq,
                                                (0, o.Bb)(s),
                                                (0, o.Bb)(a),
                                            ),
                                            e
                                        );
                                    }, []),
                                );
                                return {
                                    symbol: l.symbol,
                                    sink: 'elevation',
                                    buffer: a.buffer,
                                    generatedObjects: [
                                        {
                                            attributes: l.sinks.elevation.packObjectAttributes(
                                                i,
                                                n,
                                                s,
                                            ),
                                            drawMode: r.Fg,
                                            rangeStart: 0,
                                            rangeEnd: a.buffer.byteLength,
                                        },
                                    ],
                                };
                            },
                            generateHillshade(e, t, i, n) {
                                const s = new Uint16Array(
                                    t.reduce((e, t) => {
                                        const [i, n, s, a] = t;
                                        return (
                                            e.push(i * r.Bq, n * r.Bq, (0, o.Bb)(s), (0, o.Bb)(a)),
                                            e
                                        );
                                    }, []),
                                );
                                return {
                                    symbol: l.symbol,
                                    sink: 'hillshade',
                                    buffer: s.buffer,
                                    generatedObjects: [
                                        {
                                            drawMode: r.Fg,
                                            attributes: l.sinks.hillshade.packObjectAttributes(
                                                i,
                                                n,
                                            ),
                                            rangeStart: 0,
                                            rangeEnd: s.buffer.byteLength,
                                        },
                                    ],
                                };
                            },
                            generateFloorsBottomFill(e, t, i, n, o, r) {
                                const a = i[0],
                                    h = i[1],
                                    u = i[0].length,
                                    m = l.sinks.flatBottom.packObjectAttributes(t, s.he, r);
                                !(function (e, t, i, n, o, r, s) {
                                    let a = e.elements.offset;
                                    const l = a;
                                    if (t < 3) return;
                                    c(e, a++, i[0], n[0], r, o[0], s),
                                        c(e, a++, i[1], n[1], r, o[1], s);
                                    for (let h = 2; h < t; h++)
                                        d(e, l, h), c(e, a++, i[h], n[h], r, o[h], s);
                                    e.elements.offset = a;
                                })(
                                    e.getBucket('dem', 'flatBottom', m, l.sinks.flatBottom.binder),
                                    u,
                                    a,
                                    h,
                                    n,
                                    o,
                                    !!r,
                                );
                            },
                        });
                    function c(e, t, i, n, o, s, a) {
                        const l = t * (e.elements.stride / e.views.position.BYTES_PER_ELEMENT),
                            c = t * (e.elements.stride / e.views.extender.BYTES_PER_ELEMENT);
                        (e.views.position[l] = a ? i : r.jO + i),
                            (e.views.position[l + 1] = a ? n : r.jO + n),
                            (e.views.demPosition[l] = (a ? o[0] : r.jO + o[0]) / 8),
                            (e.views.demPosition[l + 1] = (a ? o[1] : r.jO + o[1]) / 8),
                            (e.views.extender[c] = 127 * s[0]),
                            (e.views.extender[c + 1] = 127 * s[1]);
                    }
                    function d(e, t, i) {
                        const n = e.indices.buffer;
                        let o = e.indices.offset;
                        i % 2 == 0
                            ? ((n[o++] = t + i - 2), (n[o++] = t + i - 1), (n[o++] = t + i))
                            : ((n[o++] = t + i - 1), (n[o++] = t + i - 2), (n[o++] = t + i)),
                            (e.indices.offset = o);
                    }
                },
                2213: (e, t, i) => {
                    function n(...e) {
                        return function (t, i, n, o) {
                            let r = o;
                            for (const o of e) if (((r = o(t, i, n, r)), null === r)) return null;
                            return r;
                        };
                    }
                    i.d(t, { q: () => n });
                },
                9520: (e, t, i) => {
                    i.d(t, { O: () => s });
                    var n = i(378),
                        o = i(2743),
                        r = i(1797);
                    function s(e, t, i, s) {
                        let a = t.tileAttrs[t.tileProps.linear_reference_start],
                            l = t.tileAttrs[t.tileProps.linear_reference_finish];
                        return (
                            isNaN(a) && (a = 0),
                            isNaN(l) && (l = 1),
                            l < a
                                ? (console.log('end < start'), null)
                                : (0 === a && 1 === l) || a === l
                                ? s
                                : (function (e, t, i) {
                                      const o = [],
                                          [s, a] = e,
                                          l = s.length;
                                      for (let t = 0; t < e.length; t++) o.push([]);
                                      let c = 0;
                                      const d = [c];
                                      for (let e = 1; e < l; e++)
                                          (c += (0, n.TK)([s[e - 1], a[e - 1]], [s[e], a[e]])),
                                              d.push(c);
                                      if (t <= 0) {
                                          const i = d[1] / c,
                                              n = d[0] / c,
                                              s = (t - n) / (i - n);
                                          (0, r.UW)(o, e, 0, 1, s);
                                      }
                                      for (let n = 1; n < l; n++) {
                                          const s = d[n] / c,
                                              a = d[n - 1] / c;
                                          if (a <= t && s >= t) {
                                              const i = (t - a) / (s - a);
                                              (0, r.UW)(o, e, n - 1, n, i);
                                          }
                                          if (s >= i && a <= i) {
                                              const t = (i - a) / (s - a);
                                              (0, r.UW)(o, e, n - 1, n, t);
                                          }
                                          a > t && a < i && (0, r.JG)(o, e, n - 1),
                                              s > t && s < i && (0, r.JG)(o, e, n);
                                      }
                                      if (i >= 1) {
                                          const t = l - 1,
                                              n = d[t] / c,
                                              s = d[t - 1] / c,
                                              a = (i - s) / (n - s);
                                          (0, r.UW)(o, e, t - 1, t, a);
                                      }
                                      return o;
                                  })(s.map(o.O), a, l)
                        );
                    }
                },
                949: (e, t, i) => {
                    i.d(t, { m: () => d });
                    var n = i(378),
                        o = i(9090),
                        r = i(2743),
                        s = i(6392),
                        a = i(6273),
                        l = i(9073),
                        c = i(2543);
                    function d(e, t, i, d) {
                        let h = (0, c.vn)(e.style.shift, t);
                        if ((isNaN(h) && (h = 0), 0 === h)) return d;
                        const u = (0, s.iq)(i, [0, 0]),
                            m = (a.Bq / (0, s.aq)(i.coords[2])) * l.C * u;
                        return (function (e, t) {
                            const [i, r] = e,
                                s = i.length,
                                a = n.Ue(),
                                l = n.Ue(),
                                c = s - 1;
                            for (let e = 0; e < c; e++)
                                (0, o.uI)(a, i[e], r[e], i[e + 1], r[e + 1]),
                                    (0, o.fN)(l, a),
                                    n.bA(l, l, t),
                                    (i[e] += l[0]),
                                    (r[e] += l[1]);
                            return (i[c] += l[0]), (r[c] += l[1]), e;
                        })(d.map(r.O), h * m);
                    }
                },
                1797: (e, t, i) => {
                    function n(e, t, i) {
                        for (let n = 0; n < t.length; n++) e[n].push(t[n][i]);
                    }
                    function o(e, t) {
                        var i;
                        for (let n = 0; n < e.length; n++)
                            e[n].push(null !== (i = t[n]) && void 0 !== i ? i : 0);
                    }
                    function r(e, t, i, n, o) {
                        for (let r = 0; r < t.length; r++) {
                            const s = t[r][i],
                                a = t[r][n];
                            'number' == typeof s && 'number' == typeof a
                                ? e[r].push(s + o * (a - s))
                                : e[r].push(NaN);
                        }
                    }
                    i.d(t, { JG: () => n, UW: () => r, gs: () => o });
                },
                8394: (e, t, i) => {
                    i.d(t, { m: () => S });
                    var n = i(378),
                        o = i(3287);
                    var r = i(9450),
                        s = i(1245);
                    function a() {
                        let e = new o.WT(4);
                        return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), e;
                    }
                    function l(e, t, i) {
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = t[3],
                            a = i[0],
                            l = i[1],
                            c = i[2],
                            d = i[3];
                        return (
                            (e[0] = n * d + s * a + o * c - r * l),
                            (e[1] = o * d + s * l + r * a - n * c),
                            (e[2] = r * d + s * c + n * l - o * a),
                            (e[3] = s * d - n * a - o * l - r * c),
                            e
                        );
                    }
                    function c(e, t, i) {
                        i *= 0.5;
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = t[3],
                            a = Math.sin(i),
                            l = Math.cos(i);
                        return (
                            (e[0] = n * l + s * a),
                            (e[1] = o * l + r * a),
                            (e[2] = r * l - o * a),
                            (e[3] = s * l - n * a),
                            e
                        );
                    }
                    function d(e, t, i) {
                        i *= 0.5;
                        let n = t[0],
                            o = t[1],
                            r = t[2],
                            s = t[3],
                            a = Math.sin(i),
                            l = Math.cos(i);
                        return (
                            (e[0] = n * l - r * a),
                            (e[1] = o * l + s * a),
                            (e[2] = r * l + n * a),
                            (e[3] = s * l - o * a),
                            e
                        );
                    }
                    function h(e, t, i, n) {
                        let o,
                            r,
                            s,
                            a,
                            l,
                            c = t[0],
                            d = t[1],
                            h = t[2],
                            u = t[3],
                            m = i[0],
                            f = i[1],
                            p = i[2],
                            _ = i[3];
                        return (
                            c * m + d * f + h * p + u * _,
                            r < 0 && (-r, -m, -f, -p, -_),
                            1 - r > 1e-6
                                ? (Math.acos(r),
                                  Math.sin(o),
                                  Math.sin((1 - n) * o) / s,
                                  Math.sin(n * o) / s)
                                : (1 - n, n),
                            (e[0] = a * c + l * m),
                            (e[1] = a * d + l * f),
                            (e[2] = a * h + l * p),
                            (e[3] = a * u + l * _),
                            e
                        );
                    }
                    s.d9, s.al, s.JG, s.t8, s.IH, s.bA, s.AK, s.t7, s.kE, s.we;
                    const u = s.Fv;
                    s.I6,
                        s.fS,
                        (function () {
                            let e = r.Ue(),
                                t = r.al(1, 0, 0),
                                i = r.al(0, 1, 0);
                        })(),
                        (function () {
                            let e = a(),
                                t = a();
                        })(),
                        (function () {
                            let e = (function () {
                                let e = new o.WT(9);
                                return (
                                    (e[0] = 1),
                                    (e[1] = 0),
                                    (e[2] = 0),
                                    (e[3] = 0),
                                    (e[4] = 1),
                                    (e[5] = 0),
                                    (e[6] = 0),
                                    (e[7] = 0),
                                    (e[8] = 1),
                                    e
                                );
                            })();
                        })();
                    var m = i(5600),
                        f = i(2702),
                        p = i(2543),
                        _ = i(6273),
                        v = i(6392),
                        g = i(3741),
                        y = i(9073),
                        b = i(2618),
                        w = i(7966),
                        x = i(2435);
                    const S = (0, m.D)({
                        symbol: 'gltfModel',
                        sinks: {
                            anchor: {
                                stride: 8,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.localID = new Uint32Array(t, 4));
                                },
                                packObjectAttributes(e, t, i, n, o) {
                                    const r = o,
                                        s = n.tileAttrs[n.tileProps.model_name],
                                        a = n.tileAttrs[n.tileProps.model_src],
                                        l = n.tileAttrs[n.tileProps.building_id],
                                        c = n.tileAttrs[n.tileProps.direction].coordinates;
                                    return (0, f.v$)([e, t, s, a, l, r, c], i, n);
                                },
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    name: e[2],
                                    modelSrc: e[3],
                                    buildingId: e[4],
                                    lngLat: e[5],
                                    lngLatDirection: e[6],
                                    tileData: e.slice(2),
                                }),
                            },
                            instances: {
                                stride: 44,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.scale = new Float32Array(t, 8)),
                                        (e.views.rotate = new Float32Array(t, 20)),
                                        (e.views.localID = new Uint32Array(t, 36)),
                                        (e.views.labelingTextureID = new Uint32Array(t, 40));
                                },
                                packObjectAttributes: (e, t, i, n, o, r) =>
                                    (0, f.v$)([e, t, i, [], r], n, o),
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    modelId: e[2],
                                    placeholder: e[3],
                                    buildingId: e[4],
                                    tileData: e.slice(5),
                                }),
                            },
                            fill: {
                                stride: 0,
                                binder: (e, t) => {},
                                packObjectAttributes: (e, t, i, n) => (0, f.v$)([e, t], i, n),
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    tileData: e.slice(2),
                                }),
                            },
                        },
                        generate(e, t, i, n, o, r) {
                            const s = o[0][0],
                                a = o[1][0],
                                l = [0, 0, 0];
                            (0, v.Z$)(l, [o[0][0], o[1][0]], (0, v.Bs)(r));
                            const c = (0, g.projectMapToGeo)([l[0], l[1]]),
                                d = e.getBucket(
                                    i.type,
                                    'anchor',
                                    S.sinks.anchor.packObjectAttributes(
                                        t.id,
                                        i.innerId,
                                        i.dataKeys,
                                        n,
                                        c,
                                    ),
                                    S.sinks.anchor.binder,
                                ),
                                h = d.elements.offset,
                                u = d.indices.buffer,
                                m = d.indices.offset;
                            (u[m] = h), (d.indices.offset = m + 1);
                            const f = 4 * h;
                            (d.views.position[f] = s),
                                (d.views.position[f + 1] = a),
                                (d.elements.offset = h + 1);
                        },
                        generateInstanced(e, t, i, o, r, s, h) {
                            var u, m;
                            const f = r[0][0],
                                M = r[1][0],
                                T = (0, p.FR)(i.style.linkedIds, o),
                                P = T && T.length > 0 ? (Array.isArray(T) ? T : [T]) : [];
                            let L,
                                k = (0, p.Q9)(i.style.modelSrc, o),
                                E = t.modelIndex[k];
                            const { tileProps: A, tileAttrs: z } = o,
                                C = (function (e, t) {
                                    const i = e[t.tileProps.direction];
                                    if (void 0 === i) return null;
                                    if (i instanceof Array) return i;
                                    return i.coordinates;
                                })(z, o);
                            if (C) {
                                const e = [0, 0, 0];
                                (0, v.Z$)(e, [f, M], (0, v.Bs)(s)),
                                    (L = [e, (0, g.projectGeoToMap)(C)]);
                            }
                            void 0 === E &&
                                (!(0, w.sD)(k) &&
                                    h &&
                                    (k = (0, w.i8)(h)
                                        ? (0, x.XK)(h, { modelSrc: k, subdomain: (0, v.Kn)(s) })
                                        : (0, w.pv)(h, k)),
                                (E = e.addModelToLoadByUrl(k))),
                                e.addModelToLoad(E);
                            const F = null === (u = i.interactive) || void 0 === u || u;
                            let O = b.gl;
                            !z[A.hovered] &&
                                F &&
                                (O = e.idIndexer.getIndex({
                                    id: z[A.id],
                                    styleId: t.id,
                                    layer: i,
                                    sublayer: z[A.db_sublayer],
                                }));
                            const D = e.buildingPointIndexer.getIndex(z[A.id]),
                                R = null !== (m = z[A.building_id]) && void 0 !== m ? m : '-1',
                                j = e.getBucket(
                                    i.type,
                                    'instances',
                                    S.sinks.instances.packObjectAttributes(
                                        t.id,
                                        i.innerId,
                                        E,
                                        i.dataKeys,
                                        o,
                                        R,
                                    ),
                                    S.sinks.instances.binder,
                                ),
                                B = j.meta;
                            B
                                ? B.linkedIds instanceof Array
                                    ? B.linkedIds.push(...P)
                                    : (B.linkedIds = P)
                                : (j.meta = { linkedIds: P }),
                                (function (e, t, i, o, r, s, h, u, m, f) {
                                    const b = 2,
                                        w = 4,
                                        x = (e.elements.offset * S.sinks.instances.stride) / w,
                                        M = (e.elements.offset * S.sinks.instances.stride) / b,
                                        T = [t, i, o],
                                        P = [],
                                        L = (0, v.Bs)(f);
                                    (0, v.Z$)(P, T, L);
                                    const k = (0, g.projectMapToGeo)(P),
                                        E = (0, y.Xg)(k[1]),
                                        A = I((0, p.FR)(r.style.offset, s), [0, 0, 0]),
                                        z = I((0, p.FR)(r.style.rotation, s), [0, 0, 0]),
                                        C = I((0, p.FR)(r.style.scale, s), [1, 1, 1]),
                                        F = a();
                                    h
                                        ? (function (e, t, i, o) {
                                              const r = o[0] - i[0],
                                                  s = o[1] - i[1];
                                              c(e, e, Math.PI / 2), d(e, e, Math.atan2(s, r));
                                              const a = n.TE(i, o);
                                              (t[0] *= a), (t[1] *= a), (t[2] *= a);
                                          })(F, C, h[0], h[1])
                                        : ((D = C),
                                          c((O = F), O, Math.PI / 2),
                                          (D[0] *= y.C),
                                          (D[1] *= y.C),
                                          (D[2] *= y.C),
                                          (C[0] *= E),
                                          (C[1] *= E),
                                          (C[2] *= E));
                                    var O, D;
                                    const R = (function (e, t, i, n) {
                                        const o = i[0] * y.C * t,
                                            r = i[1] * y.C * t,
                                            s = i[2] * y.C * t,
                                            a = [e[0] + o, e[1] + r, e[2] + s],
                                            l = [];
                                        return (0, v.a2)(l, a, n), l;
                                    })(P, E, A, L);
                                    (e.views.position[M] = _.jO + R[0]),
                                        (e.views.position[M + 1] = _.jO + R[1]),
                                        (e.views.position[M + 2] = R[2]),
                                        (e.views.scale[x] = C[0]),
                                        (e.views.scale[x + 1] = C[1]),
                                        (e.views.scale[x + 2] = C[2]);
                                    const j = a();
                                    c(j, j, (z[0] * Math.PI) / 180);
                                    const B = a();
                                    d(B, B, (z[1] * Math.PI) / 180);
                                    const N = a();
                                    !(function (e, t, i) {
                                        i *= 0.5;
                                        let n = t[0],
                                            o = t[1],
                                            r = t[2],
                                            s = t[3],
                                            a = Math.sin(i),
                                            l = Math.cos(i);
                                        (e[0] = n * l + o * a),
                                            (e[1] = o * l - n * a),
                                            (e[2] = r * l + s * a),
                                            (e[3] = s * l - r * a);
                                    })(N, N, (z[2] * Math.PI) / 180);
                                    const U = a();
                                    l(U, j, F),
                                        l(U, B, U),
                                        l(U, N, U),
                                        (e.views.rotate[x] = U[0]),
                                        (e.views.rotate[x + 1] = U[1]),
                                        (e.views.rotate[x + 2] = U[2]),
                                        (e.views.rotate[x + 3] = U[3]),
                                        (e.views.localID[x] = u),
                                        (e.views.labelingTextureID[x] = m);
                                    const Z = e.indices;
                                    (Z.buffer[Z.offset] = e.elements.offset),
                                        Z.offset++,
                                        e.elements.offset++;
                                })(j, f, M, 0, i, o, L, O, D, s);
                        },
                    });
                    function I(e, t) {
                        const i = t;
                        return (
                            'number' == typeof e
                                ? i.fill(e)
                                : e instanceof Array &&
                                  'number' == typeof e[0] &&
                                  'number' == typeof e[1] &&
                                  'number' == typeof e[2] &&
                                  ((i[0] = e[0]), (i[1] = e[1]), (i[2] = e[2])),
                            i
                        );
                    }
                },
                749: (e, t, i) => {
                    i.d(t, { B: () => s });
                    var n = i(5600),
                        o = i(2543),
                        r = i(6273);
                    const s = (0, n.D)({
                        symbol: 'heatmap',
                        sinks: {
                            fill: {
                                stride: 8,
                                binder: (e, t) => {
                                    e.views.position = new Float32Array(t);
                                },
                                packObjectAttributes: (e, t, i, n) => [e, t, i, n],
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    textureIndex: e[2],
                                    rampTextureIndex: e[3],
                                    tileData: e.slice(4),
                                }),
                            },
                            framebuffer: {
                                stride: 12,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.weight = new Float32Array(t, 4)),
                                        (e.views.widen = new Int8Array(t, 8));
                                },
                                packObjectAttributes: (e, t) => [e, t],
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    tileData: e.slice(2),
                                }),
                            },
                        },
                        generate(e, t, i, n, r) {
                            const a = n[0],
                                d = n[1],
                                h = Number((0, o.FR)(i.style.weight, r));
                            if (Number.isNaN(h))
                                return void console.error("Can't resolve style.weight to number");
                            const u = e.getBucket(
                                i.type,
                                'framebuffer',
                                s.sinks.framebuffer.packObjectAttributes(t, i.innerId),
                                s.sinks.framebuffer.binder,
                            );
                            for (let e = 0; e < a.length; e++)
                                c(u, 0, 1, 2, 2, 1, 3),
                                    l(u, a[e], d[e], -1, -1, h),
                                    l(u, a[e], d[e], 1, -1, h),
                                    l(u, a[e], d[e], -1, 1, h),
                                    l(u, a[e], d[e], 1, 1, h);
                        },
                        generateTexture(e, t, i, n, o) {
                            const r = [-1, 1, 1, -1],
                                l = [-1, -1, 1, 1],
                                c = e.getBucket(
                                    i.type,
                                    'fill',
                                    s.sinks.fill.packObjectAttributes(t, i.innerId, n, o),
                                    s.sinks.fill.binder,
                                );
                            let d = c.elements.offset;
                            !(function (e, t, i, n, o, r, s, a) {
                                const l = e.buffer,
                                    c = e.offset;
                                (l[c] = t + i),
                                    (l[c + 1] = t + n),
                                    (l[c + 2] = t + o),
                                    (l[c + 3] = t + r),
                                    (l[c + 4] = t + s),
                                    (l[c + 5] = t + a),
                                    (e.offset = c + 6);
                            })(c.indices, d, 0, 1, 2, 0, 2, 3),
                                a(c, d++, r[0], l[0]),
                                a(c, d++, r[1], l[1]),
                                a(c, d++, r[2], l[2]),
                                a(c, d++, r[3], l[3]),
                                (c.elements.offset = d);
                        },
                    });
                    function a(e, t, i, n) {
                        const o = 2 * t;
                        (e.views.position[o] = i), (e.views.position[o + 1] = n);
                    }
                    function l(e, t, i, n, o, s) {
                        const a = e.elements.offset * e.elements.stride,
                            l = a >> 1,
                            c = l >> 1;
                        (e.views.position[l] = r.jO + t),
                            (e.views.position[l + 1] = r.jO + i),
                            (e.views.weight[c] = s),
                            (e.views.widen[a] = n),
                            (e.views.widen[a + 1] = o),
                            e.elements.offset++;
                    }
                    function c(e, t, i, n, o, r, s) {
                        const { elements: a, indices: l } = e,
                            { buffer: c, offset: d } = l,
                            h = a.offset;
                        (c[d] = h + t),
                            (c[d + 1] = h + i),
                            (c[d + 2] = h + n),
                            (c[d + 3] = h + o),
                            (c[d + 4] = h + r),
                            (c[d + 5] = h + s),
                            (l.offset = d + 6);
                    }
                },
                143: (e, t, i) => {
                    function n(e, t) {
                        return 0 === e ? 0 : Math.min(2 * e - 1, 2 * (t - e));
                    }
                    i.d(t, { X: () => n });
                },
                8183: (e, t, i) => {
                    i.d(t, { y: () => s });
                    var n = i(378),
                        o = i(9090),
                        r = i(4091);
                    function s(e) {
                        const t = [],
                            i = (0, r.bu)(e),
                            s = n.I6(e[0], e[e.length - 1]),
                            a = s ? e.length - 1 : e.length;
                        for (let n = a - 1, r = 0, s = 1; r < a; r++, n = r - 1, s = (r + 1) % a) {
                            const a = [];
                            (0, o.tG)(a, e[n], e[r], e[s], i), t.push(a);
                        }
                        return s && t.push(t[0]), t;
                    }
                },
                4999: (e, t, i) => {
                    i.d(t, { $Y: () => l, MD: () => d, Uu: () => h, k8: () => u });
                    var n = i(9218),
                        o = i(7840),
                        r = i(6273),
                        s = i(9090);
                    const a = [0, 0];
                    function l(e, t, i, r, s, l, c) {
                        let { textLineHeight: d, textLetterSpacing: h } = s.style;
                        l === o.bR.Icon &&
                            ((d = s.style.iconTextLineHeight), (h = s.style.iconTextLetterSpacing));
                        const { identifyPoiLabelIndex: u, labelingTextureIndex: p } = t,
                            { lines: _, maxWidth: v } = r,
                            g = d * n.fonts.baseSize;
                        let y = m(1, g, _.length);
                        for (let t = 0; t < _.length; t++) {
                            const o = _[t].width;
                            let r = 0;
                            (r = -o / 2), (a[0] = r), (a[1] = y);
                            const s = _[t].glyphs;
                            for (let t = 0; t < s.length; t++) {
                                const o = s[t];
                                void 0 !== o.bitmap && f(e[o.range], i, a, o, u, p, c),
                                    (a[0] += o.advance + n.fonts.baseSize * h);
                            }
                            y -= g;
                        }
                    }
                    const c = [0, 0];
                    function d(e, t, i, o, s, a) {
                        const { lines: l, maxWidth: d } = i;
                        if (!l.length) return (c[0] = 0), (c[1] = 0), c;
                        const { textLineHeight: h } = o.style,
                            u = h * n.fonts.baseSize,
                            f = -d / 2,
                            p = m(1, u, l.length),
                            v = d / 2,
                            g = p - (l.length - 1) * u;
                        (c[0] = (s * (f + v)) / 2), (c[1] = (s * (p + g)) / 2);
                        const b = (s * r.Jv) / 2,
                            w = c[0] - b,
                            x = c[0] + b,
                            S = c[1] + b,
                            I = c[1] - b,
                            M = e.elements.offset;
                        return (
                            y(e.indices, M, 1, 0, 3, 2, 3, 0),
                            _(e, t, w, S, a),
                            _(e, t, x, S, a),
                            _(e, t, w, I, a),
                            _(e, t, x, I, a),
                            c
                        );
                    }
                    function h(e, t, i, n, o, r, s) {
                        const a = i[1] + n.top,
                            l = i[0] + n.left,
                            c = a - n.height,
                            d = l + n.width,
                            h = Math.sin(o),
                            u = Math.cos(o),
                            m = l * u - a * h,
                            f = l * h + a * u,
                            p = d * u - a * h,
                            _ = d * h + a * u,
                            g = l * u - c * h,
                            b = l * h + c * u,
                            w = d * u - c * h,
                            x = d * h + c * u,
                            S = e.elements.offset;
                        v(e, t, m, f, n.texLeft, n.texTop, r, s),
                            v(e, t, p, _, n.texRight, n.texTop, r, s),
                            v(e, t, g, b, n.texLeft, n.texBottom, r, s),
                            v(e, t, w, x, n.texRight, n.texBottom, r, s),
                            y(e.indices, S, 1, 0, 3, 2, 3, 0);
                    }
                    function u(e, t, i) {
                        const n = e.elements.offset,
                            o = (0, s.i7)(Math.cos(i)),
                            r = (0, s.i7)(Math.sin(i));
                        g(e, t, o, r, -1, -1),
                            g(e, t, o, r, 1, -1),
                            g(e, t, o, r, 1, 1),
                            g(e, t, o, r, -1, 1),
                            y(e.indices, n, 0, 1, 2, 2, 3, 0);
                    }
                    function m(e, t, i) {
                        let n;
                        switch (e) {
                            case 0:
                                n = t / 2 + t * (i - 1);
                                break;
                            case 2:
                                n = -t / 2;
                                break;
                            default:
                                n = 1 & i ? t * (i >> 1) : t / 2 + t * ((i - 1) >> 1);
                        }
                        return n;
                    }
                    function f(e, t, i, n, o, r, s) {
                        const a = i[1] + n.top,
                            l = i[0] + n.left,
                            c = a - n.height,
                            d = l + n.width,
                            [h, u] = s,
                            m = e.elements.offset;
                        p(e, t, l, a, n.texLeft, n.texTop, h, u, o, r),
                            p(e, t, d, a, n.texRight, n.texTop, h, u, o, r),
                            p(e, t, l, c, n.texLeft, n.texBottom, h, u, o, r),
                            p(e, t, d, c, n.texRight, n.texBottom, h, u, o, r),
                            y(e.indices, m, 1, 0, 3, 2, 3, 0);
                    }
                    function p(e, t, i, n, o, s, a, l, c, d) {
                        const h = e.elements,
                            u = (h.stride * h.offset) >> 1,
                            m = u >> 1;
                        (e.views.position[u] = r.jO + t[0]),
                            (e.views.position[u + 1] = r.jO + t[1]),
                            (e.views.position[u + 2] = t[2]),
                            (e.views.cornerOffset[u] = i),
                            (e.views.cornerOffset[u + 1] = n),
                            (e.views.checkPointOffset[u] = a),
                            (e.views.checkPointOffset[u + 1] = l),
                            (e.views.texCoords[u] = o),
                            (e.views.texCoords[u + 1] = s),
                            (e.views.localID[m] = c),
                            (e.views.labelingTextureID[m] = d),
                            h.offset++;
                    }
                    function _(e, t, i, n, o) {
                        const s = e.elements,
                            a = (s.stride * s.offset) >> 1;
                        (e.views.position[a] = r.jO + t[0]),
                            (e.views.position[a + 1] = r.jO + t[1]),
                            (e.views.position[a + 2] = t[2]),
                            (e.views.cornerOffset[a] = i),
                            (e.views.cornerOffset[a + 1] = n),
                            (e.views.labelingTextureID[a >> 1] = o),
                            s.offset++;
                    }
                    function v(e, t, i, n, o, s, a, l) {
                        const c = e.elements;
                        let d = (c.stride * c.offset) >> 1;
                        (e.views.position[d] = r.jO + t[0]),
                            (e.views.position[d + 1] = r.jO + t[1]),
                            (e.views.position[d + 2] = t[2]),
                            (e.views.texCoords[d] = o),
                            (e.views.texCoords[d + 1] = s),
                            (d >>= 1),
                            (e.views.cornerOffset[d] = i),
                            (e.views.cornerOffset[d + 1] = n),
                            (e.views.styleZoomLimits[d] = a),
                            (e.views.styleZoomLimits[d + 1] = l),
                            c.offset++;
                    }
                    function g(e, t, i, n, o, s) {
                        const a = e.elements.stride * e.elements.offset,
                            l = a / e.views.position.BYTES_PER_ELEMENT,
                            c = a / e.views.direction.BYTES_PER_ELEMENT;
                        (e.views.position[l] = r.jO + t[0]),
                            (e.views.position[l + 1] = r.jO + t[1]),
                            (e.views.direction[c] = i),
                            (e.views.direction[c + 1] = n),
                            (e.views.widenDirection[c] = o),
                            (e.views.widenDirection[c + 1] = s),
                            e.elements.offset++;
                    }
                    function y(e, t, i, n, o, r, s, a) {
                        const l = e.buffer,
                            c = e.offset;
                        (l[c] = t + i),
                            (l[c + 1] = t + n),
                            (l[c + 2] = t + o),
                            (l[c + 3] = t + r),
                            (l[c + 4] = t + s),
                            (l[c + 5] = t + a),
                            (e.offset = c + 6);
                    }
                },
                159: (e, t, i) => {
                    var n, o, r, s;
                    i.d(t, { CJ: () => s, SP: () => n, gD: () => o, kU: () => r }),
                        (function (e) {
                            (e.Striped = 'Striped'), (e.Entrance = 'Entrance');
                        })(n || (n = {})),
                        (function (e) {
                            (e[(e.Line = 0)] = 'Line'),
                                (e[(e.Arrow = 1)] = 'Arrow'),
                                (e[(e.StartBorder = 2)] = 'StartBorder'),
                                (e[(e.LineEnding = 3)] = 'LineEnding');
                        })(o || (o = {})),
                        (function (e) {
                            (e[(e.TileCut = 0)] = 'TileCut'),
                                (e[(e.ObjectEnding = 1)] = 'ObjectEnding');
                        })(r || (r = {})),
                        (function (e) {
                            (e[(e.Flat = 0)] = 'Flat'), (e[(e.Circle = 1)] = 'Circle');
                        })(s || (s = {}));
                },
                8352: (e, t, i) => {
                    i.d(t, { W: () => y });
                    var n = i(9090),
                        o = i(159),
                        r = i(6273);
                    const s = [0.5, 0.5],
                        a = [0.5, 0.5],
                        l = [0.5, 0.5],
                        c = [0.5, 0.5],
                        d = [0, 0];
                    let h,
                        u,
                        m,
                        f = 0,
                        p = 0,
                        _ = 0,
                        v = 0;
                    const g = {
                        x: 0,
                        y: 0,
                        xn2: 0,
                        yn2: 0,
                        xn1: 0,
                        yn1: 0,
                        noTurn: !0,
                        leftTurn: !1,
                        sharpTurn: !1,
                        reverseTurn: !1,
                        extender: [0.5, 0.5],
                        faExtender: [0.5, 0.5],
                        saExtender: [0.5, 0.5],
                    };
                    function y(e, t, i, a, c, d, g, y, w, P, k, E) {
                        let A, z, C, F, O, D, R, j, B, N;
                        if (0 !== i)
                            if (
                                ((m = k),
                                (u = E),
                                (h = u.indices),
                                (p = u.elements.offset),
                                (f = 0),
                                (_ = 0),
                                (v = 0),
                                1 === i)
                            )
                                (A = e[0]),
                                    (z = t[0]),
                                    (N = 0),
                                    L(h, p, 0, 2, 1, 1, 2, 3),
                                    T(u, m, 0, A, z, 1, -1, 1, -1, N, !1),
                                    T(u, m, 0, A, z, -1, -1, -1, -1, N, !1),
                                    T(u, m, 0, A, z, 1, 1, 1, 1, N, !1),
                                    T(u, m, 0, A, z, -1, 1, -1, 1, N, !1),
                                    (f += 4);
                            else {
                                switch (
                                    ((C = e[0]), (F = t[0]), (O = e[1]), (D = t[1]), (N = 0), c)
                                ) {
                                    case o.kU.TileCut:
                                        (0, n.AE)(s, C, F, g, y),
                                            (0, n.AE)(l, O, D, C, F),
                                            (B = b(O, D, s[0], s[1], l[0], l[1])),
                                            B.noTurn
                                                ? S(C, F, l[0], l[1], N)
                                                : x(0, C, F, s[0], s[1], l[0], l[1], N);
                                        break;
                                    case o.kU.ObjectEnding:
                                        (0, n.AE)(l, O, D, C, F),
                                            a === o.CJ.Flat
                                                ? S(C, F, l[0], l[1], N)
                                                : (S(C, F, -l[0], -l[1], N),
                                                  x(0, C, F, -l[0], -l[1], l[0], l[1], N));
                                        break;
                                    default:
                                        throw new Error('LoftedLine: unknown Ending Type');
                                }
                                const h = i - 1;
                                for (let i = 1; i < h; i++) {
                                    (C = e[i - 1]),
                                        (F = t[i - 1]),
                                        (O = e[i]),
                                        (D = t[i]),
                                        (R = e[i + 1]),
                                        (j = t[i + 1]);
                                    const o = O - C,
                                        a = D - F;
                                    (N += Math.sqrt(o * o + a * a) / r.Bq),
                                        (0, n.AE)(s, O, D, C, F),
                                        (0, n.AE)(l, R, j, O, D),
                                        x(i, O, D, s[0], s[1], l[0], l[1], N);
                                }
                                (C = e[i - 2]), (F = t[i - 2]), (O = e[h]), (D = t[h]);
                                const u = O - C,
                                    m = D - F;
                                switch (((N += Math.sqrt(u * u + m * m) / r.Bq), d)) {
                                    case o.kU.TileCut:
                                        (0, n.AE)(s, O, D, C, F),
                                            (0, n.AE)(l, w, P, O, D),
                                            (B = b(O, D, s[0], s[1], l[0], l[1])),
                                            B.noTurn ? I(h, O, D, l[0], l[1], N) : M(h, N, B);
                                        break;
                                    case o.kU.ObjectEnding:
                                        (0, n.AE)(l, O, D, C, F),
                                            I(h, O, D, l[0], l[1], N),
                                            a === o.CJ.Circle &&
                                                x(h, O, D, l[0], l[1], -l[0], -l[1], N);
                                        break;
                                    default:
                                        throw new Error('LoftedLine: unknown Ending Type');
                                }
                            }
                    }
                    function b(e, t, i, o, r, s) {
                        const l = (function (e, t, i, n, o, r) {
                            const s = g;
                            (s.x = e),
                                (s.y = t),
                                (s.xn2 = i),
                                (s.yn2 = n),
                                (s.xn1 = o),
                                (s.yn1 = r);
                            const a = i * o + n * r;
                            return (
                                (s.noTurn = a > 0.9999),
                                (s.leftTurn = i * -r + n * o < 0),
                                (s.sharpTurn = a < 0),
                                (s.reverseTurn = a < -0.9999),
                                s
                            );
                        })(e, t, i, o, r, s);
                        if (l.noTurn || l.reverseTurn)
                            (l.extender[0] = 0),
                                (l.extender[1] = 0),
                                (l.faExtender[0] = 0),
                                (l.faExtender[1] = 0),
                                (l.saExtender[0] = 0),
                                (l.saExtender[1] = 0);
                        else {
                            (0, n.ax)(a, i, o, r, s);
                            const e = a[0],
                                t = a[1];
                            (l.extender[0] = e),
                                (l.extender[1] = t),
                                (l.faExtender[0] = e - 2 * i),
                                (l.faExtender[1] = t - 2 * o),
                                (l.saExtender[0] = e - 2 * r),
                                (l.saExtender[1] = t - 2 * s);
                        }
                        return l;
                    }
                    function w(e, t, i, o, r, s, l, c) {
                        (0, n.ax)(a, o, r, s, l);
                        o * -l + r * s < 0
                            ? T(u, m, e, t, i, -a[0], -a[1], -a[0], -a[1], c, !1)
                            : T(u, m, e, t, i, a[0], a[1], a[0], a[1], c, !1),
                            f++;
                    }
                    function x(e, t, i, o, r, s, a, l) {
                        const d = b(t, i, o, r, s, a);
                        M(e, l, d),
                            (function (e, t, i) {
                                if (i.noTurn) return;
                                const o = i.sharpTurn ? 2 : 1;
                                let r, s;
                                i.reverseTurn
                                    ? ((r = v), (s = _))
                                    : i.leftTurn
                                    ? ((r = _), (s = f + o))
                                    : ((r = f + o), (s = v));
                                const a = f;
                                i.leftTurn, P(h, p, _, v, a);
                                if (i.sharpTurn) {
                                    const e = f + 1;
                                    i.leftTurn
                                        ? L(h, p, a, e, r, r, e, s)
                                        : L(h, p, a, s, e, e, s, r);
                                } else i.leftTurn, P(h, p, a, s, r);
                                i.sharpTurn
                                    ? (i.leftTurn
                                          ? (0, n.AE)(c, i.xn2, i.yn2, i.xn1, i.yn1)
                                          : (0, n.AE)(c, i.xn1, i.yn1, i.xn2, i.yn2),
                                      w(e, i.x, i.y, i.xn2, i.yn2, c[0], c[1], t),
                                      w(e, i.x, i.y, c[0], c[1], i.xn1, i.yn1, t))
                                    : w(e, i.x, i.y, i.xn2, i.yn2, i.xn1, i.yn1, t);
                                i.reverseTurn ||
                                    (i.leftTurn
                                        ? T(
                                              u,
                                              m,
                                              e,
                                              i.x,
                                              i.y,
                                              -i.xn1,
                                              -i.yn1,
                                              -i.xn1,
                                              -i.yn1,
                                              t,
                                              !1,
                                          )
                                        : T(u, m, e, i.x, i.y, i.xn1, i.yn1, i.xn1, i.yn1, t, !1),
                                    f++);
                                (v = s), (_ = r);
                            })(e, l, d),
                            (function (e, t, i) {
                                if (i.noTurn || i.reverseTurn) return;
                                const n = f + 1,
                                    o = f;
                                i.leftTurn
                                    ? (T(
                                          u,
                                          m,
                                          e,
                                          i.x,
                                          i.y,
                                          -i.xn1,
                                          -i.yn1,
                                          i.saExtender[0],
                                          i.saExtender[1],
                                          t,
                                          !1,
                                      ),
                                      T(
                                          u,
                                          m,
                                          e,
                                          i.x,
                                          i.y,
                                          i.xn1,
                                          i.yn1,
                                          i.extender[0],
                                          i.extender[1],
                                          t,
                                          !1,
                                      ))
                                    : (T(
                                          u,
                                          m,
                                          e,
                                          i.x,
                                          i.y,
                                          -i.xn1,
                                          -i.yn1,
                                          -i.extender[0],
                                          -i.extender[1],
                                          t,
                                          !1,
                                      ),
                                      T(
                                          u,
                                          m,
                                          e,
                                          i.x,
                                          i.y,
                                          i.xn1,
                                          i.yn1,
                                          -i.saExtender[0],
                                          -i.saExtender[1],
                                          t,
                                          !1,
                                      ));
                                (f += 2),
                                    i.leftTurn
                                        ? L(h, p, v, o, _, _, o, n)
                                        : L(h, p, _, v, n, n, v, o);
                                (v = o), (_ = n);
                            })(e, l, d);
                    }
                    function S(e, t, i, n, o) {
                        T(u, m, 0, e, t, -i, -n, -i, -n, o, !1),
                            T(u, m, 0, e, t, i, n, i, n, o, !1),
                            (f += 2),
                            (_ = 1),
                            (v = 0);
                    }
                    function I(e, t, i, n, o, r) {
                        const s = f + 1,
                            a = f;
                        T(u, m, e, t, i, -n, -o, -n, -o, r, !1),
                            T(u, m, e, t, i, n, o, n, o, r, !1),
                            (f += 2),
                            L(h, p, v, a, _, _, a, s),
                            (_ = s),
                            (v = a);
                    }
                    function M(e, t, i) {
                        if (i.noTurn) return;
                        const n = f + 1,
                            o = f;
                        if (
                            (i.reverseTurn
                                ? (T(u, m, e, i.x, i.y, -i.xn2, -i.yn2, -i.xn2, -i.yn2, t, !1),
                                  T(u, m, e, i.x, i.y, i.xn2, i.yn2, i.xn2, i.yn2, t, !1))
                                : i.leftTurn
                                ? (T(
                                      u,
                                      m,
                                      e,
                                      i.x,
                                      i.y,
                                      -i.xn2,
                                      -i.yn2,
                                      i.faExtender[0],
                                      i.faExtender[1],
                                      t,
                                      !0,
                                  ),
                                  T(
                                      u,
                                      m,
                                      e,
                                      i.x,
                                      i.y,
                                      i.xn2,
                                      i.yn2,
                                      i.extender[0],
                                      i.extender[1],
                                      t,
                                      !0,
                                  ))
                                : (T(
                                      u,
                                      m,
                                      e,
                                      i.x,
                                      i.y,
                                      -i.xn2,
                                      -i.yn2,
                                      -i.extender[0],
                                      -i.extender[1],
                                      t,
                                      !0,
                                  ),
                                  T(
                                      u,
                                      m,
                                      e,
                                      i.x,
                                      i.y,
                                      i.xn2,
                                      i.yn2,
                                      -i.faExtender[0],
                                      -i.faExtender[1],
                                      t,
                                      !0,
                                  )),
                            (f += 2),
                            L(h, p, v, o, _, _, o, n),
                            (v = o),
                            (_ = n),
                            !i.reverseTurn)
                        ) {
                            const r = f + 1,
                                s = f;
                            i.leftTurn
                                ? (T(u, m, e, i.x, i.y, -i.xn2, -i.yn2, -i.xn2, -i.yn2, t, !1),
                                  T(u, m, e, i.x, i.y, 0, 0, 0, 0, t, !1),
                                  L(h, p, n, o, r, r, o, s))
                                : (T(u, m, e, i.x, i.y, 0, 0, 0, 0, t, !1),
                                  T(u, m, e, i.x, i.y, i.xn2, i.yn2, i.xn2, i.yn2, t, !1),
                                  L(h, p, o, s, n, n, s, r)),
                                (f += 2),
                                (v = s),
                                (_ = r);
                        }
                    }
                    function T(e, t, i, s, a, l, c, h, u, m, f) {
                        const p = e.elements.offset * t.offsetMultiplier,
                            _ = p >> 1,
                            v = p << 1;
                        if (
                            ((e.views.position[p] = r.jO + s),
                            (e.views.position[p + 1] = r.jO + a),
                            (e.views.extender[p] = Math.floor(h * r.Gt * 127 + 0.5)),
                            (e.views.extender[p + 1] = Math.floor(u * r.Gt * 127 + 0.5)),
                            t.type === o.SP.Striped)
                        )
                            (e.views.texExtender[v] = (0, n.i7)(l * r.Gt)),
                                (e.views.texExtender[v + 1] = (0, n.i7)(c * r.Gt)),
                                'componentDistance' in e.views &&
                                    (e.views.componentDistance[_] = t.cDist);
                        else if (t.type === o.SP.Entrance) {
                            const { px: s, py: a, count: h } = t,
                                u = 0 === i,
                                m = i === h - 1,
                                g = u ? i : i - 1,
                                y = u ? i + 1 : i;
                            (0, n.uI)(d, s[g], a[g], s[y], a[y]),
                                'direction' in e.views &&
                                    ((e.views.direction[p] = Math.round(127 * d[0])),
                                    (e.views.direction[p + 1] = Math.round(127 * d[1])),
                                    (e.views.type[_] = m ? o.gD.LineEnding : o.gD.Line)),
                                (e.views.texExtender[v] = (0, n.i7)(l * (f || m ? -1 : 1) * r.Gt)),
                                (e.views.texExtender[v + 1] = (0, n.i7)(
                                    c * (f || m ? -1 : 1) * r.Gt,
                                ));
                        }
                        (e.views.vertexDistance[_] = m),
                            (e.views.objectLength[_] = t.oLen),
                            (e.views.localID[_] = t.localID),
                            e.elements.offset++;
                    }
                    function P(e, t, i, n, o) {
                        const r = e.buffer,
                            s = e.offset;
                        (r[s] = t + i), (r[s + 1] = t + n), (r[s + 2] = t + o), (e.offset = s + 3);
                    }
                    function L(e, t, i, n, o, r, s, a) {
                        const l = e.buffer,
                            c = e.offset;
                        (l[c] = t + i),
                            (l[c + 1] = t + n),
                            (l[c + 2] = t + o),
                            (l[c + 3] = t + r),
                            (l[c + 4] = t + s),
                            (l[c + 5] = t + a),
                            (e.offset = c + 6);
                    }
                },
                2682: (e, t, i) => {
                    i.d(t, { n: () => l });
                    var n = i(9450),
                        o = i(6273);
                    const r = n.Ue(),
                        s = n.Ue(),
                        a = n.Ue();
                    function l(e, t, i, o, l, d, h, u, m) {
                        n.t8(r, t, i, o),
                            n.t8(s, l, d, h),
                            n.lu(a, s, r),
                            n.fS(s, r) || (n.Fv(a, a), n.bA(a, a, 127)),
                            (function (e, t, i, n, o, r, s) {
                                const a = e.indices.buffer,
                                    l = e.indices.offset,
                                    c = e.elements.offset;
                                (a[l] = c + t),
                                    (a[l + 1] = c + i),
                                    (a[l + 2] = c + n),
                                    (a[l + 3] = c + o),
                                    (a[l + 4] = c + r),
                                    (a[l + 5] = c + s),
                                    (e.indices.offset = l + 6);
                            })(e, 0, 1, 3, 3, 1, 2),
                            c(e, r, a, 1, u, m),
                            c(e, r, a, -1, u, m),
                            c(e, s, a, -1, u, m),
                            c(e, s, a, 1, u, m);
                    }
                    function c(e, t, i, n, r, s) {
                        const a = e.elements.offset * e.elements.stride,
                            l = a >> 1;
                        (e.views.position[l] = s ? t[0] : o.jO + t[0]),
                            (e.views.position[l + 1] = s ? t[1] : o.jO + t[1]),
                            (e.views.position[l + 2] = t[2]),
                            (e.views.directionDistance[a] = i[0]),
                            (e.views.directionDistance[a + 1] = i[1]),
                            (e.views.directionDistance[a + 2] = i[2]),
                            (e.views.directionDistance[a + 3] = n),
                            'demPosition' in e.views &&
                                ((r = null != r ? r : t),
                                (e.views.demPosition[l] = (s ? r[0] : o.jO + r[0]) / 8),
                                (e.views.demPosition[l + 1] = (s ? r[1] : o.jO + r[1]) / 8)),
                            e.elements.offset++;
                    }
                },
                6563: (e, t, i) => {
                    i.d(t, { e: () => v });
                    var n = i(6273),
                        o = i(378),
                        r = i(6490),
                        s = i(9090);
                    const a = o.Ue(),
                        l = o.Ue(),
                        c = o.Ue(),
                        d = o.Ue(),
                        h = o.Ue(),
                        u = o.Ue(),
                        m = o.Ue(),
                        f = o.Ue();
                    let p = 0,
                        _ = 0;
                    function v(e, t, i, n, o, r, l, c, d) {
                        if (!(n < 2)) {
                            if (((0, s.uI)(a, t[0], i[0], t[1], i[1]), (p = 0), o)) {
                                const n = void 0 !== c ? c[0] : 0,
                                    o = void 0 !== d ? d[0] : 0;
                                y(e, t[0], i[0], -a[0], -a[1], n, o, l);
                            }
                            for (let o = 1; o < n; o++) g(e, t, i, o, n, l, c, d);
                            if (r) {
                                const o = void 0 !== c ? c[n - 1] : 0,
                                    r = void 0 !== d ? d[n - 1] : 0;
                                y(e, t[n - 1], i[n - 1], a[0], a[1], o, r, l);
                            }
                        }
                    }
                    function g(e, t, i, v, g, w, x, S) {
                        const I = v === g - 1;
                        if (
                            (o.t8(h, t[v - 1], i[v - 1]),
                            o.t8(u, t[v], i[v]),
                            void 0 !== x && void 0 !== S
                                ? (o.t8(c, x[v - 1], S[v - 1]), o.t8(d, x[v], S[v]))
                                : (o.t8(c, 0, 0), o.t8(d, 0, 0)),
                            (0, s.fN)(f, a),
                            I)
                        )
                            _ = 0;
                        else {
                            o.t8(m, t[v + 1], i[v + 1]), (0, s.uI)(l, u[0], u[1], m[0], m[1]);
                            const n = (0, r.uZ)(o.AK(a, l), -1, 1);
                            if (n <= 0) (_ = 0), y(e, u[0], u[1], a[0], a[1], d[0], d[1], w);
                            else {
                                const e = Math.sqrt((1 - n) / (1 + n)),
                                    t = (0, r.Xx)(o.AK(f, l));
                                _ = e * t;
                            }
                        }
                        !(function (e, t, i, n, o, r, s) {
                            const a = e.indices.buffer,
                                l = e.indices.offset,
                                c = e.elements.offset;
                            (a[l] = c + t),
                                (a[l + 1] = c + i),
                                (a[l + 2] = c + n),
                                (a[l + 3] = c + o),
                                (a[l + 4] = c + r),
                                (a[l + 5] = c + s),
                                (e.indices.offset = l + 6);
                        })(e, 0, 1, 3, 3, 1, 2);
                        const M = f[0] * n.Gt,
                            T = f[1] * n.Gt;
                        b(
                            e,
                            h[0],
                            h[1],
                            (f[0] + a[0] * p) * n.Gt,
                            (f[1] + a[1] * p) * n.Gt,
                            M,
                            T,
                            c[0],
                            c[1],
                            w,
                        ),
                            b(
                                e,
                                h[0],
                                h[1],
                                (-f[0] - a[0] * p) * n.Gt,
                                (-f[1] - a[1] * p) * n.Gt,
                                -M,
                                -T,
                                c[0],
                                c[1],
                                w,
                            ),
                            b(
                                e,
                                u[0],
                                u[1],
                                (-f[0] + a[0] * _) * n.Gt,
                                (-f[1] + a[1] * _) * n.Gt,
                                -M,
                                -T,
                                d[0],
                                d[1],
                                w,
                            ),
                            b(
                                e,
                                u[0],
                                u[1],
                                (f[0] - a[0] * _) * n.Gt,
                                (f[1] - a[1] * _) * n.Gt,
                                M,
                                T,
                                d[0],
                                d[1],
                                w,
                            ),
                            I || (o.JG(a, l), (p = _));
                    }
                    function y(e, t, i, n, o, r, s, a) {
                        !(function (e, t, i, n) {
                            const o = e.indices.buffer,
                                r = e.indices.offset,
                                s = e.elements.offset;
                            (o[r] = s + t),
                                (o[r + 1] = s + i),
                                (o[r + 2] = s + n),
                                (e.indices.offset = r + 3);
                        })(e, 0, 1, 2);
                        const l = 0.01 * -n,
                            c = 0.01 * -o;
                        b(e, t, i, n + l, o + c, n, o, r, s, a),
                            b(e, t, i, -o + l, n + c, -o, n, r, s, a),
                            b(e, t, i, o + l, -n + c, o, -n, r, s, a);
                    }
                    function b(e, t, i, o, r, s, a, l, c, d) {
                        const h = e.elements.offset * e.elements.stride,
                            u = h >> 1,
                            m = h >> 2;
                        (e.views.position[u] = n.jO + t),
                            (e.views.position[u + 1] = n.jO + i),
                            (e.views.extender[h] = 127 * o),
                            (e.views.extender[h + 1] = 127 * r),
                            (e.views.normal[h] = 127 * s),
                            (e.views.normal[h + 1] = 127 * a),
                            'shift' in e.views &&
                                ((e.views.shift[m] = l), (e.views.shift[m + 1] = c)),
                            'localID' in e.views && (e.views.localID[m] = d),
                            e.elements.offset++;
                    }
                },
                3376: (e, t, i) => {
                    function n(e, t) {
                        return void 0 === e || Number.isNaN(e) ? t : e;
                    }
                    function o(e) {
                        const t = [];
                        return (
                            e.forEach((e, i) => {
                                t.push([]);
                                for (let n = 0; n < e.length - 1; n += 2)
                                    (t[i][n] = e[n + 1]), (t[i][n + 1] = e[n]);
                            }),
                            t
                        );
                    }
                    i.d(t, { P: () => n, y: () => o });
                },
                8308: (e, t, i) => {
                    i.d(t, { C: () => l, b: () => c });
                    var n = i(143),
                        o = i(9090),
                        r = i(6273);
                    const s = [0.5, 0.5],
                        a = [0.5, 0.5];
                    function l(e, t, i, r, s, l) {
                        let c = e.elements.offset;
                        const d = (0, n.X)(t - 1, t);
                        let p = i[d],
                            _ = r[d],
                            v = s ? s[d] : 0;
                        const y = c;
                        for (let d = 0; d < t; d++) {
                            const b = (0, n.X)(d, t),
                                w = d === t - 1,
                                x = i[b],
                                S = r[b],
                                I = s ? s[b] : w ? 0 : 1;
                            0 !== v &&
                                ((0, o.uI)(a, p, _, x, S),
                                g(e, c, I, w ? y : c + 4),
                                u(e, c, p, _, x, S),
                                l ? h(e, c, l[0], l[1], l[0], l[1]) : h(e, c, p, _, x, S),
                                (0, o.af)(a),
                                m(e, c, a),
                                f(e, c, a),
                                (c += 4)),
                                (p = x),
                                (_ = S),
                                (v = I);
                        }
                        e.elements.offset = c;
                    }
                    function c(e, t, i, r, l, c, h) {
                        let u = e.elements.offset;
                        const m = (0, n.X)(t - 2, t),
                            f = (0, n.X)(t - 1, t);
                        let y = i[f],
                            b = r[f],
                            w = l ? l[m] : 1,
                            x = l ? l[f] : 0;
                        (0, o.AE)(s, i[m], r[m], y, b);
                        let S = s[0],
                            I = s[1];
                        for (let m = 0; m < t; m++) {
                            const f = (0, n.X)(m, t),
                                M = m === t - 1,
                                T = i[f],
                                P = r[f],
                                L = l ? l[f] : M ? 0 : 1;
                            (0, o.uI)(a, y, b, T, P);
                            const k = a[1],
                                E = -a[0];
                            0 !== w &&
                                (0 === x ? ((s[0] = S), (s[1] = I)) : d(s, S, I, k, E),
                                (0, o.m2)(a, S, I, s[0], s[1]),
                                g(e, u, 0, 0),
                                p(e, u, y, b, c, null != h ? h : [y, b]),
                                _(e, u, (0, o.af)(s), (0, o.af)(a)),
                                v(e, u),
                                (u += 4)),
                                (y = T),
                                (b = P),
                                (w = x),
                                (x = L),
                                (S = k),
                                (I = E);
                        }
                        e.elements.offset = u;
                    }
                    function d(e, t, i, n, o) {
                        let r, s, a;
                        t * n + i * o > 0
                            ? ((r = t + n),
                              (s = i + o),
                              (a = 1 / Math.sqrt(r * r + s * s)),
                              (e[0] = r * a),
                              (e[1] = s * a))
                            : ((r = o - i),
                              (s = t - n),
                              0 !== r && 0 !== s
                                  ? ((a = 1 / Math.sqrt(r * r + s * s)),
                                    (e[0] = r * a),
                                    (e[1] = s * a))
                                  : ((e[0] = 0), (e[1] = 0)));
                    }
                    function h(e, t, i, n, o, s) {
                        const a = e.views.demPosition,
                            l = e.elements.stride / a.BYTES_PER_ELEMENT;
                        (t *= l),
                            (i = (i + r.jO) / 8),
                            (n = (n + r.jO) / 8),
                            (o = (o + r.jO) / 8),
                            (s = (s + r.jO) / 8),
                            (a[t] = i),
                            (a[t + 1] = n),
                            (a[(t += l)] = i),
                            (a[t + 1] = n),
                            (a[(t += l)] = o),
                            (a[t + 1] = s),
                            (a[(t += l)] = o),
                            (a[t + 1] = s);
                    }
                    function u(e, t, i, n, o, s) {
                        const { position: a, distance: l } = e.views,
                            c = e.elements.stride / a.BYTES_PER_ELEMENT;
                        (a[(t *= c)] = r.jO + i),
                            (a[t + 1] = r.jO + n),
                            (a[t + 2] = 0),
                            (l[t] = 0),
                            (a[(t += c)] = r.jO + i),
                            (a[t + 1] = r.jO + n),
                            (a[t + 2] = 0),
                            (l[t] = -32767),
                            (a[(t += c)] = r.jO + o),
                            (a[t + 1] = r.jO + s),
                            (a[t + 2] = 0),
                            (l[t] = -32767),
                            (a[(t += c)] = r.jO + o),
                            (a[t + 1] = r.jO + s),
                            (a[t + 2] = 0),
                            (l[t] = 0);
                    }
                    function m(e, t, i) {
                        const n = e.elements.stride / e.views.normals.BYTES_PER_ELEMENT;
                        t *= n;
                        for (let o = 0; o < 4; o++)
                            (e.views.normals[t] = i[0]),
                                (e.views.normals[t + 1] = i[1]),
                                (e.views.normals[t + 2] = 0),
                                (e.views.normals[t + 3] = 0),
                                (t += n);
                    }
                    function f(e, t, i) {
                        const n = e.elements.stride / e.views.direction.BYTES_PER_ELEMENT;
                        t *= n;
                        for (let o = 0; o < 4; o++)
                            (e.views.direction[t] = i[0]),
                                (e.views.direction[t + 1] = i[1]),
                                (e.views.direction[t + 2] = 0),
                                (e.views.direction[t + 3] = 0),
                                (t += n);
                    }
                    function p(e, t, i, n, o, s) {
                        const a = e.elements.stride / e.views.position.BYTES_PER_ELEMENT;
                        (t *= a),
                            (e.views.position[t] = r.jO + i),
                            (e.views.position[t + 1] = r.jO + n),
                            (e.views.position[t + 2] = 0),
                            (e.views.distance[t] = 32767),
                            (e.views.demPosition[t] = (r.jO + s[0]) / 8),
                            (e.views.demPosition[t + 1] = (r.jO + s[1]) / 8),
                            (t += a),
                            (e.views.position[t] = r.jO + i),
                            (e.views.position[t + 1] = r.jO + n),
                            (e.views.position[t + 2] = 0),
                            (e.views.distance[t] = -32767),
                            (e.views.demPosition[t] = (r.jO + s[0]) / 8),
                            (e.views.demPosition[t + 1] = (r.jO + s[1]) / 8),
                            (t += a),
                            (e.views.position[t] = r.jO + i),
                            (e.views.position[t + 1] = r.jO + n),
                            (e.views.position[t + 2] = o),
                            (e.views.distance[t] = -32767),
                            (e.views.demPosition[t] = (r.jO + s[0]) / 8),
                            (e.views.demPosition[t + 1] = (r.jO + s[1]) / 8),
                            (t += a),
                            (e.views.position[t] = r.jO + i),
                            (e.views.position[t + 1] = r.jO + n),
                            (e.views.position[t + 2] = o),
                            (e.views.distance[t] = 32767),
                            (e.views.demPosition[t] = (r.jO + s[0]) / 8),
                            (e.views.demPosition[t + 1] = (r.jO + s[1]) / 8);
                    }
                    function _(e, t, i, n) {
                        const o = e.elements.stride / e.views.normals.BYTES_PER_ELEMENT;
                        t *= o;
                        for (let r = 0; r < 4; r++)
                            (e.views.normals[t] = i[0]),
                                (e.views.normals[t + 1] = i[1]),
                                (e.views.normals[t + 2] = n[0]),
                                (e.views.normals[t + 3] = n[1]),
                                (t += o);
                    }
                    function v(e, t) {
                        const i = e.elements.stride / e.views.direction.BYTES_PER_ELEMENT;
                        t *= i;
                        for (let n = 0; n < 4; n++)
                            (e.views.direction[t] = 0), (e.views.direction[t + 1] = 127), (t += i);
                    }
                    function g(e, t, i, n) {
                        const o = e.indices.buffer;
                        let r = e.indices.offset;
                        (o[r++] = t),
                            (o[r++] = t + 1),
                            (o[r++] = t + 3),
                            (o[r++] = t + 3),
                            (o[r++] = t + 1),
                            (o[r++] = t + 2),
                            0 !== i && ((o[r++] = t + 2), (o[r++] = n + 1), (o[r++] = n + 0)),
                            (e.indices.offset = r);
                    }
                },
                1558: (e, t, i) => {
                    i.d(t, { y: () => a });
                    var n = i(9090),
                        o = i(143),
                        r = i(6273);
                    const s = [0, 0];
                    function a(e, t, i, r, a, m, f, p, _) {
                        let v = e.elements.offset;
                        for (let g = 0; g < t; g++) {
                            const y = (0, o.X)(g, t),
                                b = g === t - 1;
                            if ((a && 1 === a[y]) || (!a && !b)) {
                                const a = i[y],
                                    b = r[y],
                                    w = (g + 1) % t,
                                    x = (0, o.X)(w, t),
                                    S = i[x],
                                    I = r[x];
                                u(e, v),
                                    l(e, v, a, b, S, I, m),
                                    _ ? c(e, v, _[0], _[1], _[0], _[1]) : c(e, v, a, b, S, I),
                                    (0, n.AE)(s, a, b, S, I),
                                    d(e, v, s),
                                    void 0 !== f &&
                                        'localID' in e.views &&
                                        void 0 !== e.views.localID &&
                                        h(e.views.localID, v, f, e.elements.stride),
                                    void 0 !== p &&
                                        'labelingTextureID' in e.views &&
                                        void 0 !== e.views.labelingTextureID &&
                                        h(e.views.labelingTextureID, v, p, e.elements.stride),
                                    (v += 4);
                            }
                        }
                        e.elements.offset = v;
                    }
                    function l(e, t, i, n, o, s, a) {
                        const l = e.views.position,
                            c = e.elements.stride / l.BYTES_PER_ELEMENT;
                        (l[(t *= c)] = r.jO + i),
                            (l[t + 1] = r.jO + n),
                            (l[t + 2] = 0),
                            (l[(t += c)] = r.jO + i),
                            (l[t + 1] = r.jO + n),
                            (l[t + 2] = a),
                            (l[(t += c)] = r.jO + o),
                            (l[t + 1] = r.jO + s),
                            (l[t + 2] = 0),
                            (l[(t += c)] = r.jO + o),
                            (l[t + 1] = r.jO + s),
                            (l[t + 2] = a);
                    }
                    function c(e, t, i, n, o, s) {
                        const a = e.views.demPosition,
                            l = e.elements.stride / a.BYTES_PER_ELEMENT;
                        (t *= l),
                            (i = (i + r.jO) / 8),
                            (n = (n + r.jO) / 8),
                            (o = (o + r.jO) / 8),
                            (s = (s + r.jO) / 8),
                            (a[t] = i),
                            (a[t + 1] = n),
                            (a[(t += l)] = i),
                            (a[t + 1] = n),
                            (a[(t += l)] = o),
                            (a[t + 1] = s),
                            (a[(t += l)] = o),
                            (a[t + 1] = s);
                    }
                    function d(e, t, i) {
                        const o = e.elements.stride / e.views.normal.BYTES_PER_ELEMENT;
                        t *= o;
                        for (let r = 0; r < 4; r++)
                            (e.views.normal[t] = (0, n.i7)(i[0])),
                                (e.views.normal[t + 1] = (0, n.i7)(i[1])),
                                (e.views.normal[t + 2] = 0),
                                (e.views.normal[t + 3] = 0),
                                (t += o);
                    }
                    function h(e, t, i, n) {
                        const o = n / e.BYTES_PER_ELEMENT;
                        (e[(t *= o)] = i), (e[(t += o)] = i), (e[(t += o)] = i), (e[(t += o)] = i);
                    }
                    function u(e, t) {
                        const i = e.indices.buffer;
                        let n = e.indices.offset;
                        (i[n++] = t),
                            (i[n++] = t + 3),
                            (i[n++] = t + 1),
                            (i[n++] = t),
                            (i[n++] = t + 2),
                            (i[n++] = t + 3),
                            (e.indices.offset = n);
                    }
                },
                4372: (e, t, i) => {
                    i.d(t, {
                        PA: () => le,
                        XI: () => oe,
                        kF: () => re,
                        Pn: () => de,
                        SV: () => ce,
                        vP: () => ae,
                    });
                    var n = i(8799),
                        o = i(5600),
                        r = i(6563),
                        s = i(2702),
                        a = i(1573);
                    const l = (0, o.D)({
                        symbol: 'shiftedLine',
                        sinks: {
                            solid: {
                                stride: 16,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.extender = new Int8Array(t, 4)),
                                        (e.views.normal = new Int8Array(t, 6)),
                                        (e.views.shift = new Float32Array(t, 8));
                                },
                                packObjectAttributes(e, t, i, n) {
                                    var o;
                                    const r =
                                        null !== (o = (0, a.tp)(n.tileProps, n.tileAttrs)) &&
                                        void 0 !== o
                                            ? o
                                            : n.tileAttrs[n.tileProps.drawLevel];
                                    return (0, s.v$)([e, t, r], i, n);
                                },
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    drawLevel: e[2],
                                    tileData: e.slice(3),
                                }),
                            },
                        },
                        generate(e, t, i, n, o) {
                            const { tileAttrs: s, tileProps: a } = n,
                                c = !Number.isNaN(s[a.beginningIsCut]) && 0 !== s[a.beginningIsCut],
                                d = !Number.isNaN(s[a.endingIsCut]) && 0 !== s[a.endingIsCut],
                                h = e.getBucket(
                                    i.type,
                                    'solid',
                                    l.sinks.solid.packObjectAttributes(t, i.innerId, i.dataKeys, n),
                                    l.sinks.solid.binder,
                                );
                            (0, r.e)(h, o[0], o[1], o[0].length, !c, !d, 0, o[2], o[3]);
                        },
                    });
                    var c = i(5970),
                        d = i(3097),
                        h = i(1678),
                        u = i(4389),
                        m = i(871),
                        f = i(378),
                        p = i(1558),
                        _ = i(2682),
                        v = i(8308);
                    const g = f.Ue(),
                        y = f.Ue(),
                        b = f.Ue(),
                        w = f.Ue(),
                        x = (e, t, i, n) => (0, s.v$)([e, t], i, n),
                        S = (e) => ({ styleId: e[0], layerId: e[1], tileData: e.slice(2) }),
                        I = (0, o.D)({
                            symbol: 'lineExtrusion',
                            sinks: {
                                fill: {
                                    stride: 20,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.normal = new Int8Array(t, 8)),
                                            (e.views.demPosition = new Int16Array(t, 16));
                                    },
                                    packObjectAttributes: x,
                                    unpackObjectAttributes: S,
                                },
                                topStroke: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.directionDistance = new Int8Array(t, 8)),
                                            (e.views.demPosition = new Int16Array(t, 12));
                                    },
                                    packObjectAttributes: x,
                                    unpackObjectAttributes: S,
                                },
                                sideStroke: {
                                    stride: 20,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.distance = new Int16Array(t, 6)),
                                            (e.views.normals = new Int8Array(t, 8)),
                                            (e.views.direction = new Int8Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16));
                                    },
                                    packObjectAttributes: x,
                                    unpackObjectAttributes: S,
                                },
                            },
                            generate(e, t, i, n, o) {
                                const r = o[0],
                                    s = o[1],
                                    a = r.length,
                                    l = e.getBucket(
                                        i.type,
                                        'fill',
                                        I.sinks.fill.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            i.dataKeys,
                                            n,
                                        ),
                                        I.sinks.fill.binder,
                                    ),
                                    c = e.getBucket(
                                        i.type,
                                        'topStroke',
                                        I.sinks.topStroke.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            i.dataKeys,
                                            n,
                                        ),
                                        I.sinks.topStroke.binder,
                                    ),
                                    d = e.getBucket(
                                        i.type,
                                        'sideStroke',
                                        I.sinks.sideStroke.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            i.dataKeys,
                                            n,
                                        ),
                                        I.sinks.sideStroke.binder,
                                    );
                                for (let e = 0; e < a - 1; e++) {
                                    const t = r[e],
                                        i = s[e],
                                        n = r[e + 1],
                                        o = s[e + 1];
                                    f.t8(g, t, n),
                                        f.t8(y, i, o),
                                        f.t8(b, n, t),
                                        f.t8(w, o, i),
                                        (0, p.y)(l, 2, g, y, void 0, 1),
                                        (0, _.n)(c, t, i, 1, n, o, 1),
                                        (0, v.C)(d, 2, g, y, void 0),
                                        (0, v.C)(d, 2, b, w, void 0),
                                        (0, v.b)(d, 2, g, y, void 0, 1);
                                }
                                f.t8(g, r[a - 1], r[0]),
                                    f.t8(y, s[a - 1], s[0]),
                                    (0, v.b)(d, 2, g, y, void 0, 1);
                            },
                        });
                    var M = i(6263),
                        T = i(2097),
                        P = i(6392),
                        L = i(9073),
                        k = i(4999),
                        E = i(9218),
                        A = i(6490),
                        z = i(2543),
                        C = i(6273),
                        F = i(7293);
                    const O = [0, 0, 0],
                        D = [0, 0],
                        R = (0, o.D)({
                            symbol: 'labelLine',
                            sinks: {
                                raster: {
                                    stride: 28,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.texCoords = new Uint16Array(t, 8)),
                                            (e.views.cornerOffset = new Float32Array(t, 12)),
                                            (e.views.styleZoomLimits = new Float32Array(t, 20));
                                    },
                                    packObjectAttributes: (e, t, i, n, o) => {
                                        var r;
                                        return (0, s.LY)(
                                            [
                                                e.styleId,
                                                e.layer.innerId,
                                                t,
                                                i,
                                                n,
                                                null !== (r = e.drawLevel) && void 0 !== r ? r : 0,
                                            ],
                                            o,
                                        );
                                    },
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        animDirection: e[2],
                                        range: e[3],
                                        fontIndex: e[4],
                                        drawLevel: e[5],
                                        tileData: e.slice(6),
                                    }),
                                },
                            },
                            processElement(e, t, i, n, o, r, s) {
                                var a;
                                const {
                                    label: l,
                                    anchorPosition: c,
                                    anchorSegmentIndex: d,
                                    halfLabelWidth: h,
                                    layer: u,
                                } = i;
                                if ('labelLine' !== u.type) return;
                                const { axis: m } = l,
                                    { center: f, styleZoom: p } = r,
                                    _ = (0, z.bs)(p, r.styleState, !1, l.tileData),
                                    v = (0, z.Q9)(u.style.textFont, _),
                                    g =
                                        null !== (a = e.fontNameToIndex[v]) && void 0 !== a
                                            ? a
                                            : e.fontNameToIndex[C.Uo],
                                    y = {};
                                for (const e of l.ranges)
                                    y[e] = t.getBucket(
                                        'labelLine',
                                        'raster',
                                        R.sinks.raster.packObjectAttributes(
                                            l,
                                            n,
                                            e,
                                            g,
                                            (0, F.uq)(l.tileData, u),
                                        ),
                                        R.sinks.raster.binder,
                                    );
                                const b = l.textMetrics.lines[0],
                                    w = (0, z.vn)(u.style.textFontSize, _) / E.fonts.baseSize,
                                    x = b.glyphs,
                                    S = (function (e, t, i, n) {
                                        const o = e.interpolate(t - i, e.getSegmentIndex(t - i)),
                                            r = e.interpolate(t + i, e.getSegmentIndex(t + i)),
                                            s = Math.atan2(r[1] - o[1], r[0] - o[0]) - n;
                                        return Math.cos(s) < 0;
                                    })(m, c, h, r.rotation);
                                (D[0] = -b.width / 2), (D[1] = 0);
                                for (let e = 0; e < x.length; e++) {
                                    const t = x[e],
                                        n = (D[0] + t.left + t.width / 2) * w * (S ? -1 : 1),
                                        o = (0, A.Xx)(n) || 1;
                                    let r = -1 / 0,
                                        a = 1 / 0;
                                    for (
                                        let e = d;
                                        e >= 1 && e < m.vertexCount && !(a < i.overflowStyleZoom);
                                        e += o, a = r
                                    ) {
                                        const l = 1 === o ? e : e - 1;
                                        r = (0, L.X$)((0, L.to)(n, m.lengths[l] - c), f);
                                        const d = m.interpolate(c, e);
                                        (0, P.a2)(O, d, s),
                                            (0, P.hm)(O) &&
                                                void 0 !== t.bitmap &&
                                                (0, k.Uu)(
                                                    y[t.range],
                                                    O,
                                                    D,
                                                    t,
                                                    d[3] + (S ? Math.PI : 0),
                                                    Math.max(r, i.overflowStyleZoom),
                                                    a,
                                                );
                                    }
                                    D[0] +=
                                        t.advance + E.fonts.baseSize * u.style.textLetterSpacing;
                                }
                            },
                            getLabelingInfo() {},
                        });
                    const j = [0, 0, 0],
                        B = (0, o.D)({
                            symbol: 'oneWayLine',
                            sinks: {
                                raster: {
                                    stride: 12,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.direction = new Int8Array(t, 8)),
                                            (e.views.widenDirection = new Int8Array(t, 10));
                                    },
                                    packObjectAttributes: (e, t) => {
                                        var i;
                                        return (0, s.LY)(
                                            [
                                                e.styleId,
                                                e.layer.innerId,
                                                t,
                                                null !== (i = e.drawLevel) && void 0 !== i ? i : 0,
                                            ],
                                            e.tileData,
                                        );
                                    },
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        animDirection: e[2],
                                        drawLevel: e[3],
                                        tileData: e.slice(4),
                                    }),
                                },
                            },
                            processElement(e, t, i, n, o, r, s) {
                                const { label: a, anchorWorld: l } = i;
                                if (((0, P.a2)(j, l, s), !(0, P.hm)(j))) return;
                                const c = t.getBucket(
                                    'oneWayLine',
                                    'raster',
                                    B.sinks.raster.packObjectAttributes(a, n),
                                    B.sinks.raster.binder,
                                );
                                (0, k.k8)(c, j, l[3]);
                            },
                            getLabelingInfo() {},
                        });
                    var N = i(7840),
                        U = i(749),
                        Z = i(4922),
                        H = i(4333),
                        G = i(6201);
                    const V = (e, t, i, n, o, r, a) => {
                            const l = {
                                type: G.R2.Line,
                                styleId: t,
                                layerId: i.innerId,
                                sourceId: o,
                                tileCoords: n,
                                id: r.tileAttrs[r.tileProps.id],
                                componentDistanceStart: (0, G.hs)(
                                    r.tileAttrs[r.tileProps.componentDistanceStart],
                                    0,
                                ),
                                componentDistanceEnd: (0, G.hs)(
                                    r.tileAttrs[r.tileProps.componentDistanceEnd],
                                    0,
                                ),
                                objectLength: (0, G.hs)(r.tileAttrs[r.tileProps.objectLength], 0),
                                labelPriority: (0, G.hs)(
                                    r.tileAttrs[r.tileProps.db_label_priority],
                                    0,
                                ),
                                vertices: [a[0], a[1]],
                                tileData: (0, s.v$)([], i.dataKeys, r),
                                drawLevel: r.tileAttrs[r.tileProps.drawLevel],
                            };
                            e.addLabel(l);
                        },
                        W = (e, t, i, n, o, r, l) => {
                            var c;
                            const { tileProps: d, tileAttrs: h } = r,
                                u =
                                    null !== (c = (0, a.tp)(d, h)) && void 0 !== c
                                        ? c
                                        : h[d.drawLevel],
                                m = {
                                    type: G.R2.OneWayLine,
                                    styleId: t,
                                    layerId: i.innerId,
                                    sourceId: o,
                                    tileCoords: n,
                                    id: r.tileAttrs[r.tileProps.id],
                                    componentDistanceStart: (0, G.hs)(
                                        r.tileAttrs[r.tileProps.componentDistanceStart],
                                        0,
                                    ),
                                    componentDistanceEnd: (0, G.hs)(
                                        r.tileAttrs[r.tileProps.componentDistanceEnd],
                                        0,
                                    ),
                                    objectLength: (0, G.hs)(
                                        r.tileAttrs[r.tileProps.objectLength],
                                        0,
                                    ),
                                    labelPriority: (0, G.hs)(
                                        r.tileAttrs[r.tileProps.db_label_priority],
                                        0,
                                    ),
                                    vertices: [l[0], l[1]],
                                    tileData: (0, s.v$)([], i.dataKeys, r),
                                    drawLevel: u,
                                };
                            e.addLabel(m);
                        };
                    var q = i(8394),
                        $ = i(8965),
                        X = i(6829),
                        Y = i(3642),
                        K = i(3698),
                        J = i(9981),
                        Q = i(7464),
                        ee = i(3741);
                    function te(e, t, i, n, o) {
                        const { tileProps: r, tileAttrs: s } = n,
                            a = s[r.linear_reference_start],
                            { markCenter: l, markAngle: c } = (function (e, t) {
                                let i = t,
                                    n = [e[0][0], e[1][0]],
                                    o = [e[0][1], e[1][1]];
                                const r = e[0].length;
                                if (r > 2) {
                                    let s = 0;
                                    const a = [];
                                    for (let t = 0; t < r - 1; t++) {
                                        const i = e[0][t + 1] - e[0][t],
                                            n = e[1][t + 1] - e[1][t];
                                        (s += Math.sqrt(Math.pow(i, 2) + Math.pow(n, 2))),
                                            a.push(s);
                                    }
                                    const l = s * t;
                                    for (let t = 0; t < a.length; t++) {
                                        const r = a[t];
                                        if (l <= r) {
                                            (n = [e[0][t], e[1][t]]),
                                                (o = [e[0][t + 1], e[1][t + 1]]);
                                            const s = t > 0 ? a[t - 1] : 0;
                                            i = (l - s) / (r - s);
                                        }
                                    }
                                }
                                const s = o[0] - n[0],
                                    a = o[1] - n[1];
                                return {
                                    markCenter: [n[0] + s * i, n[1] + a * i],
                                    markAngle: Math.atan2(a, s),
                                };
                            })(e, a),
                            d = [],
                            h = (0, P.Bs)(o);
                        (0, P.Z$)(d, l, h);
                        const u = (0, ee.projectMapToGeo)(d),
                            m = s[r.geometry_offset],
                            f = (0, ee.geoToMapDistance)(u, m),
                            p = Math.sign(f);
                        (d[0] += Math.abs(f) * Math.cos(c + (-p * Math.PI) / 2)),
                            (d[1] += Math.abs(f) * Math.sin(c + (-p * Math.PI) / 2));
                        const _ = (0, ee.geoToMapDistance)(u, t),
                            v = (0, ee.geoToMapDistance)(u, i),
                            g = Math.sqrt(Math.pow(_, 2) + Math.pow(v, 2)) / 2,
                            y = Math.atan(_ / -v) + Math.PI + c,
                            b = g * Math.cos(y),
                            w = g * Math.sin(y),
                            x = Math.atan(-_ / -v) + Math.PI + c,
                            S = g * Math.cos(x),
                            I = g * Math.sin(x),
                            M = Math.atan(-_ / v) + 2 * Math.PI + c,
                            T = g * Math.cos(M),
                            L = g * Math.sin(M),
                            k = Math.atan(_ / v) + c,
                            E = g * Math.cos(k),
                            A = g * Math.sin(k),
                            z = [],
                            C = [],
                            F = [],
                            O = [];
                        return (
                            (0, P.a2)(z, [d[0] + b, d[1] + w], h),
                            (0, P.a2)(C, [d[0] + S, d[1] + I], h),
                            (0, P.a2)(F, [d[0] + T, d[1] + L], h),
                            (0, P.a2)(O, [d[0] + E, d[1] + A], h),
                            [
                                [z[0], C[0], F[0], O[0]],
                                [z[1], C[1], F[1], O[1]],
                            ]
                        );
                    }
                    const ie = (0, o.D)({
                        symbol: 'roadPointMark',
                        sinks: {
                            fill: {
                                stride: 8,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.texCoords = new Uint16Array(t, 4));
                                },
                                packObjectAttributes: function (e, t) {
                                    return [e, t];
                                },
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    tileData: e.slice(2),
                                }),
                            },
                        },
                        generate(e, t, i, n, o, r, s) {
                            !(function (e, t, i, n) {
                                const { rasterSets: o } = t,
                                    r = (0, J.fL)(n);
                                (0, z.EG)(i.style.textureImage).forEach((n) => {
                                    if (!n.length) return;
                                    const s = o.byKey[(0, Q.FD)(n)];
                                    if (!s)
                                        return void console.error(
                                            `Not found raster set with texture ${n}`,
                                        );
                                    if (!s.isSvg) return;
                                    const a = i.style.textureSize,
                                        [l, c] = Array.isArray(a) ? a : [a, a];
                                    e.atlasPacker.packSvg(s, [{ w: l, h: c }], r),
                                        s.rasters.forEach((i) =>
                                            e.atlasPacker.addRastersToLoad(t.id, i),
                                        );
                                });
                            })(e, n, o, i);
                            const a = o.style.markSize,
                                [l, c] = Array.isArray(a) ? a : [a, a],
                                [d, h] = te(t, l, c, r, s),
                                u = e.getBucket(
                                    'roadPointMark',
                                    'fill',
                                    ie.sinks.fill.packObjectAttributes(n.id, o.innerId),
                                    ie.sinks.fill.binder,
                                );
                            let m = u.elements.offset;
                            !(function (e, t, i, n, o, r, s, a) {
                                const l = e.buffer,
                                    c = e.offset;
                                (l[c] = t + i),
                                    (l[c + 1] = t + n),
                                    (l[c + 2] = t + o),
                                    (l[c + 3] = t + r),
                                    (l[c + 4] = t + s),
                                    (l[c + 5] = t + a),
                                    (e.offset = c + 6);
                            })(u.indices, m, 0, 1, 2, 0, 2, 3),
                                ne(u, m++, d[0], h[0], 0, 0),
                                ne(u, m++, d[1], h[1], 1, 0),
                                ne(u, m++, d[2], h[2], 1, 1),
                                ne(u, m++, d[3], h[3], 0, 1),
                                (u.elements.offset = m);
                        },
                    });
                    function ne(e, t, i, n, o, r) {
                        (t *= 4),
                            (e.views.position[t] = C.jO + i),
                            (e.views.position[t + 1] = C.jO + n),
                            (e.views.texCoords[t] = (0, K.Bb)(o)),
                            (e.views.texCoords[t + 1] = (0, K.Bb)(r));
                    }
                    function oe({ collector: e, generator: t, args: i }) {
                        do {
                            t(e, ...i);
                        } while (e.isOverloaded());
                    }
                    const re = {
                            arrow: u.l,
                            line: n.z,
                            polygon: T.a,
                            roadPolygon: X.tX,
                            roadPointMark: ie,
                            labelLine: R,
                            lineExtrusion: I,
                            polygonExtrusion: c.p,
                            oneWayLine: B,
                            dashedLine: d.L,
                            shiftedLine: l,
                            circle: m.p,
                            buildingModel: h.X,
                            gltfModel: q.m,
                            point: N.uF,
                            raster: M.h,
                            heatmap: U.B,
                            dem: Z._,
                            mesh: $.j,
                            mapMesh: Y._,
                            overpass: a.tw,
                        },
                        se = { labelLine: R, oneWayLine: B, point: N.uF };
                    function ae(e, t) {
                        const i = re[e];
                        return i ? i.sinks[t].stride : 0;
                    }
                    function le(e, t, i, o, r, s, h, m, f, p, _, v, g) {
                        i.forEach((i) => {
                            if (
                                (void 0 === s ||
                                    !(
                                        i.maxzoom <= s ||
                                        (i.minzoom >= s + 1 && s !== E.tiles.maxDetailLevel)
                                    )) &&
                                (!o.tileProps.hovered ||
                                    Number.isNaN(o.tileAttrs[o.tileProps.hovered]) ||
                                    1 !== o.tileAttrs[o.tileProps.hovered] ||
                                    'polygon' === i.type ||
                                    'polygonExtrusion' === i.type ||
                                    'point' === i.type)
                            )
                                do {
                                    switch (i.type) {
                                        case 'line':
                                            n.z.generate(e, t.id, i, o, (0, P.Bs)(m), p);
                                            break;
                                        case 'dashedLine':
                                            d.L.generate(e, t.id, i, o, (0, P.Bs)(m), p);
                                            break;
                                        case 'shiftedLine':
                                            l.generate(e, t.id, i, o, p);
                                            break;
                                        case 'polygon':
                                            T.a.generate(e, t.id, i, o, p, f, t.rasterSets, _);
                                            break;
                                        case 'roadPolygon':
                                            X.tX.generate(e, t, i, o, p, m, f);
                                            break;
                                        case 'roadPointMark':
                                            ie.generate(e, p, f, t, i, o, m);
                                            break;
                                        case 'polygonExtrusion':
                                            c.p.generate(e, t.id, i, o, p, !0, _);
                                            break;
                                        case 'labelLine':
                                            V(e, t.id, i, m, h, o, p);
                                            break;
                                        case 'oneWayLine':
                                            W(e, t.id, i, m, h, o, p);
                                            break;
                                        case 'point':
                                            (0, H.p)(e, t, i, o, r, m, h, p, f, v, void 0);
                                            break;
                                        case 'lineExtrusion':
                                            I.generate(e, t.id, i, o, p);
                                            break;
                                        case 'arrow':
                                            u.l.generate(e, t.id, i, o, p);
                                            break;
                                        case 'heatmap':
                                            U.B.generate(e, t.id, i, p, o);
                                            break;
                                        case 'gltfModel':
                                            i.style.useThreeJs
                                                ? q.m.generate(e, t, i, o, p, m)
                                                : q.m.generateInstanced(e, t, i, o, p, m, g);
                                            break;
                                        case 'overpass':
                                            a.tw.generate(e, t.id, i, o, p, m, f);
                                    }
                                } while (e.isOverloaded());
                        });
                    }
                    function ce(e, t, i, n, o, r, s, a) {
                        const l = se[t.type];
                        if (l)
                            do {
                                l.processElement(e, i, n, o, r, s, a);
                            } while (i.isOverloaded());
                    }
                    function de(e, t, i, n, o, r, s) {
                        const a = se[n.type];
                        a && a.getLabelingInfo(e, t, i, o, r, s);
                    }
                },
                8799: (e, t, i) => {
                    i.d(t, { z: () => y });
                    var n = i(5600),
                        o = i(6563),
                        r = i(2702),
                        s = i(1573),
                        a = i(949),
                        l = i(9520),
                        c = i(2213),
                        d = i(378),
                        h = i(9090),
                        u = i(2743),
                        m = i(1797),
                        f = i(2543),
                        p = i(6392),
                        _ = i(6273),
                        v = i(9073);
                    function g(e, t, i, n) {
                        const o = (0, f.FR)(e.style.zigzag, t);
                        if (!o || isNaN(o[0]) || !o[0] || isNaN(o[1]) || !o[1]) return n;
                        const r = (0, p.iq)(i, [0, 0]),
                            s = (_.Bq / (0, p.aq)(i.coords[2])) * v.C * r;
                        let a = o[0] * s;
                        if ((isNaN(a) && (a = 0), 0 === a)) return n;
                        const l = o[1] * s,
                            c = n.map(u.O),
                            g = [],
                            [y, b] = c,
                            w = y.length;
                        for (let e = 0; e < c.length; e++) g.push([]);
                        let x = 0;
                        const S = [x];
                        for (let e = 1; e < w; e++)
                            (x += d.TK([y[e - 1], b[e - 1]], [y[e], b[e]])), S.push(x);
                        const I = d.Ue(),
                            M = d.Ue(),
                            T = d.Ue(),
                            P = Math.abs(x / Math.trunc(x / a)),
                            L = [y[0], b[0]];
                        let k = 1;
                        for (let e = 0; e < y.length - 1; e++) {
                            (0, h.uI)(I, y[e], b[e], y[e + 1], b[e + 1]),
                                (0, h.fN)(M, I),
                                0 === e &&
                                    ((0, m.JG)(g, c, 0),
                                    d.bA(T, M, k * l),
                                    d.IH(L, L, T),
                                    (0, m.gs)(g, L),
                                    (k = -k));
                            let t = 0;
                            for (; t < S[e + 1]; )
                                d.bA(T, M, k * l),
                                    d.IH(L, L, T),
                                    d.bA(T, I, P),
                                    d.IH(L, L, T),
                                    (0, m.gs)(g, L),
                                    (k = -k),
                                    (t += P);
                        }
                        return d.bA(T, M, k * l), d.IH(L, L, T), (0, m.gs)(g, L), g;
                    }
                    const y = (0, n.D)({
                        symbol: 'line',
                        sinks: {
                            solid: {
                                stride: 12,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.extender = new Int8Array(t, 4)),
                                        (e.views.normal = new Int8Array(t, 6)),
                                        (e.views.localID = new Uint32Array(t, 8));
                                },
                                packObjectAttributes(e, t, i, n) {
                                    var o;
                                    const a =
                                        null !== (o = (0, s.tp)(n.tileProps, n.tileAttrs)) &&
                                        void 0 !== o
                                            ? o
                                            : n.tileAttrs[n.tileProps.drawLevel];
                                    return (0, r.v$)([e, t, a], i, n);
                                },
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    drawLevel: e[2] ? e[2] : void 0,
                                    tileData: e.slice(3),
                                }),
                            },
                        },
                        generate(e, t, i, n, r, s) {
                            const d = (0, c.q)(a.m, l.O, g)(i, n, r, s);
                            if (null === d) return;
                            const { tileAttrs: h, tileProps: u } = n,
                                m = !Number.isNaN(h[u.beginningIsCut]) && 0 !== h[u.beginningIsCut],
                                f = !Number.isNaN(h[u.endingIsCut]) && 0 !== h[u.endingIsCut],
                                p = e.idIndexer.getIndex({
                                    id: h[u.id],
                                    styleId: t,
                                    layer: i,
                                    sublayer: h[u.db_sublayer],
                                }),
                                _ = e.getBucket(
                                    i.type,
                                    'solid',
                                    y.sinks.solid.packObjectAttributes(t, i.innerId, i.dataKeys, n),
                                    y.sinks.solid.binder,
                                );
                            (0, o.e)(_, d[0], d[1], d[0].length, !m, !f, p);
                        },
                    });
                },
                3642: (e, t, i) => {
                    i.d(t, { _: () => m });
                    var n = i(9450),
                        o = i(5600),
                        r = i(2702),
                        s = i(6273),
                        a = i(6392),
                        l = i(9090);
                    const c = [0, 0, 0],
                        d = [0, 0, 0],
                        h = [0, 0, 0],
                        u = [0, 0, 0],
                        m = (0, o.D)({
                            symbol: 'mapMesh',
                            sinks: {
                                fill: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.extender = new Int16Array(t, 8)),
                                            (e.views.normal = new Int8Array(t, 12)),
                                            (e.views.gradient = new Int8Array(t, 15)),
                                            (e.views.demPosition = new Int16Array(t, 16));
                                    },
                                    packObjectAttributes: (e, t, i, n, o, s) =>
                                        (0, r.v$)([e, t, i, n], o, s),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        meshLevel: e[2],
                                        heightDelta: e[3],
                                        tileData: e.slice(4),
                                    }),
                                },
                            },
                            generate(e, t, i, o, r, _, v, g, y = 0) {
                                const b = r[0],
                                    w = r[1],
                                    x = r[3],
                                    S = r[4] ? r[4] : void 0,
                                    I = b.length,
                                    M = null == g ? void 0 : g[0],
                                    T = null == g ? void 0 : g[1];
                                if (I < 3) return;
                                const P = (0, a.aq)(v[2]),
                                    L = s.Bq / P,
                                    k = e.getBucket(
                                        'mapMesh',
                                        'fill',
                                        m.sinks.fill.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            _,
                                            y,
                                            i.dataKeys,
                                            o,
                                        ),
                                        m.sinks.fill.binder,
                                    ),
                                    E = k.indices.buffer;
                                let A = k.indices.offset;
                                const z = k.elements.offset;
                                for (let e = 2; e < I; e++) {
                                    const t = !(e % 2),
                                        i = t ? e - 2 : e - 1,
                                        o = t ? e - 1 : e - 2;
                                    f(E, A, z, 3 * (e - 2) + 2),
                                        n.t8(h, b[i], w[i], x[i] * L),
                                        n.t8(d, b[o], w[o], x[o] * L),
                                        n.t8(c, b[e], w[e], x[e] * L),
                                        (0, l.Cb)(u, h, d, c),
                                        p(k, b[i], w[i], x[i], null == S ? void 0 : S[i], u, M, T),
                                        p(k, b[o], w[o], x[o], null == S ? void 0 : S[o], u, M, T),
                                        p(k, b[e], w[e], x[e], null == S ? void 0 : S[e], u, M, T),
                                        (A += 3);
                                }
                                k.indices.offset = A;
                            },
                        });
                    function f(e, t, i, n) {
                        (e[t] = i + n - 2), (e[t + 1] = i + n - 1), (e[t + 2] = i + n);
                    }
                    function p(e, t, i, n, o, r, c = t, d = i) {
                        const h = e.elements.stride / e.views.position.BYTES_PER_ELEMENT,
                            u = e.elements.offset * h,
                            m = e.elements.stride / e.views.normal.BYTES_PER_ELEMENT,
                            f = e.elements.offset * m,
                            p = e.elements.stride / e.views.normal.BYTES_PER_ELEMENT,
                            _ = e.elements.offset * p;
                        (e.views.position[u] = s.jO + t),
                            (e.views.position[u + 1] = s.jO + i),
                            (e.views.position[u + 2] = (0, a.VW)(Math.max(0, n))),
                            (e.views.normal[f] = (0, l.i7)(r[0])),
                            (e.views.normal[f + 1] = (0, l.i7)(r[1])),
                            (e.views.normal[f + 2] = (0, l.i7)(r[2])),
                            (e.views.gradient[_] = null != o ? o : 0),
                            (e.views.demPosition[u] = c),
                            (e.views.demPosition[u + 1] = d),
                            e.elements.offset++;
                    }
                },
                8965: (e, t, i) => {
                    i.d(t, { j: () => v, z: () => n });
                    var n,
                        o = i(9450),
                        r = i(2702),
                        s = i(5600),
                        a = i(2618),
                        l = i(6273),
                        c = i(9090),
                        d = i(6392);
                    !(function (e) {
                        (e[(e.side = 0)] = 'side'),
                            (e[(e.top = 1)] = 'top'),
                            (e[(e.bottom = 2)] = 'bottom');
                    })(n || (n = {}));
                    const h = [0, 0, 0],
                        u = [0, 0, 0],
                        m = [0, 0, 0],
                        f = [0, 0, 0],
                        p = (e, t, i, n, o) => (0, r.v$)([e, t, i], n, o),
                        _ = (e) => ({
                            styleId: e[0],
                            layerId: e[1],
                            side: e[2],
                            tileData: e.slice(3),
                        }),
                        v = (0, s.D)({
                            symbol: 'mesh',
                            sinks: {
                                fill: {
                                    stride: 20,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.normal = new Int8Array(t, 8)),
                                            (e.views.gradient = new Int8Array(t, 11)),
                                            (e.views.localID = new Uint32Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16));
                                    },
                                    packObjectAttributes: p,
                                    unpackObjectAttributes: _,
                                },
                                raster: {
                                    stride: 24,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.normal = new Int8Array(t, 8)),
                                            (e.views.localID = new Uint32Array(t, 12)),
                                            (e.views.textCoord = new Uint16Array(t, 16)),
                                            (e.views.demPosition = new Int16Array(t, 20));
                                    },
                                    packObjectAttributes: (e, t, i, n, o) =>
                                        (0, r.v$)([e, t, i], n, o),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        textureIndex: e[2],
                                        tileData: e.slice(3),
                                    }),
                                },
                                stroke: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.directionDistance = new Int8Array(t, 8)),
                                            (e.views.demPosition = new Int16Array(t, 12));
                                    },
                                    packObjectAttributes: p,
                                    unpackObjectAttributes: _,
                                },
                            },
                            generate(e, t, i, n, r, s, p, _) {
                                var b, w, x;
                                const S = s[0],
                                    I = s[1],
                                    M = s[3] ? s[3] : void 0,
                                    T = s[4] ? s[4] : void 0,
                                    P = S.length,
                                    L = r.tileAttrs[r.tileProps.hovered],
                                    k = r.tileAttrs[r.tileProps.textureId],
                                    E = r.tileAttrs[r.tileProps.id],
                                    A = L
                                        ? a.gl
                                        : e.idIndexer.getIndex({
                                              id: E,
                                              styleId: t,
                                              layer: i,
                                              sublayer: r.tileAttrs[r.tileProps.db_sublayer],
                                          });
                                if (!k) {
                                    const s = e.getBucket(
                                        'mesh',
                                        'fill',
                                        v.sinks.fill.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            n,
                                            i.dataKeys,
                                            r,
                                        ),
                                        v.sinks.fill.binder,
                                    );
                                    for (let e = 0; e < P - 2; e++) {
                                        const t = !(e % 2);
                                        y(s);
                                        const i = t ? e + 1 : e + 2,
                                            n = t ? e + 2 : e + 1,
                                            r = (0, d.aq)(p[2]),
                                            a = l.Bq / r;
                                        o.t8(
                                            h,
                                            S[e],
                                            I[e],
                                            (null !== (b = null == M ? void 0 : M[e]) &&
                                            void 0 !== b
                                                ? b
                                                : 0) * a,
                                        ),
                                            o.t8(
                                                u,
                                                S[i],
                                                I[i],
                                                (null !== (w = null == M ? void 0 : M[i]) &&
                                                void 0 !== w
                                                    ? w
                                                    : 0) * a,
                                            ),
                                            o.t8(
                                                m,
                                                S[n],
                                                I[n],
                                                (null !== (x = null == M ? void 0 : M[n]) &&
                                                void 0 !== x
                                                    ? x
                                                    : 0) * a,
                                            ),
                                            (0, c.Cb)(f, h, u, m),
                                            (h[2] /= a),
                                            (u[2] /= a),
                                            (m[2] /= a),
                                            g(s, h, f, null == T ? void 0 : T[e], A, _),
                                            g(s, u, f, null == T ? void 0 : T[i], A, _),
                                            g(s, m, f, null == T ? void 0 : T[n], A, _);
                                    }
                                }
                            },
                        });
                    function g(e, t, i, n, o, r) {
                        var s, a;
                        const h = e.elements.offset,
                            u = e.elements.stride,
                            m = h * (u / e.views.position.BYTES_PER_ELEMENT),
                            f = h * (u / e.views.normal.BYTES_PER_ELEMENT),
                            p = h * (u / e.views.localID.BYTES_PER_ELEMENT),
                            _ = h * (u / e.views.gradient.BYTES_PER_ELEMENT);
                        (e.views.position[m] = l.jO + t[0]),
                            (e.views.position[m + 1] = l.jO + t[1]),
                            (e.views.position[m + 2] = Math.max(0, (0, d.VW)(t[2]))),
                            (e.views.normal[f] = (0, c.i7)(i[0])),
                            (e.views.normal[f + 1] = (0, c.i7)(i[1])),
                            (e.views.normal[f + 2] = (0, c.i7)(i[2])),
                            (e.views.demPosition[m] =
                                null !== (s = null == r ? void 0 : r[0]) && void 0 !== s
                                    ? s
                                    : t[0]),
                            (e.views.demPosition[m + 1] =
                                null !== (a = null == r ? void 0 : r[1]) && void 0 !== a
                                    ? a
                                    : t[1]),
                            (e.views.gradient[_] = null != n ? n : 0),
                            (e.views.localID[p] = o),
                            e.elements.offset++;
                    }
                    function y(e) {
                        const t = e.indices.buffer,
                            i = e.indices.offset,
                            n = e.elements.offset;
                        (t[i] = n), (t[i + 1] = n + 1), (t[i + 2] = n + 2), (e.indices.offset += 3);
                    }
                },
                1573: (e, t, i) => {
                    i.d(t, { tp: () => M, tw: () => T });
                    var n = i(378),
                        o = i(5600),
                        r = i(3376),
                        s = (i(3672), i(9073)),
                        a = i(6829),
                        l = i(3642),
                        c = i(2682),
                        d = i(8965),
                        h = i(6392),
                        u = i(9090),
                        m = i(6490),
                        f = i(6273),
                        p = i(2543),
                        _ = i(2097);
                    const v = [0, 0, 0],
                        g = [0, 0, 0],
                        y = [0, 0, 0],
                        b = [0, 0, 0],
                        w = [0, 0, 0],
                        x = [0, 0, 0];
                    let S = 0,
                        I = 0;
                    const M = (e, t) => {
                            const i = (0, r.P)(t[e.db_segment_begin_level], 0),
                                n = (0, r.P)(t[e.db_segment_end_level], 0);
                            if (i || n) {
                                return i < 0 || n < 0
                                    ? Math.floor(Math.min(i, n))
                                    : Math.ceil(Math.max(i, n));
                            }
                        },
                        T = (0, o.D)({
                            symbol: 'overpass',
                            sinks: {},
                            generate(e, t, i, o, c, m, g) {
                                var y;
                                const { tileProps: w, tileAttrs: x } = o,
                                    I = M(w, x);
                                if (!I) return;
                                const T = (0, h.Bs)(m);
                                n.t8(b, 0, 0);
                                const k = (0, h.iq)(T, b),
                                    z = (f.Bq / (0, h.aq)(m[2])) * k * s.C,
                                    C = (0, r.P)(x[w.db_begin_nominal_height], 0),
                                    F = (0, r.P)(x[w.db_end_nominal_height], 0);
                                if (!C && !F) return;
                                const O = (0, p.vn)(i.style.outerWidth, o, 0) * z,
                                    D = (0, p.vn)(i.style.outerHeight, o, 0) * z,
                                    R = (0, p.vn)(i.style.height, o, 1) * z,
                                    j = c[0],
                                    B = c[1],
                                    N = c[0].length,
                                    U = x[w.objectLength],
                                    Z =
                                        null !== (y = x[w.componentDistanceStart]) && void 0 !== y
                                            ? y
                                            : 0;
                                if (Number.isNaN(U) || Number.isNaN(Z) || 0 === U) return void 0;
                                const H = F - C,
                                    G = (C + (H * Z) / U) * s.C;
                                let V = Z;
                                for (let e = 0; e < N - 1; e++)
                                    V += n.TK([j[e], B[e]], [j[e + 1], B[e + 1]]);
                                const W = (C + (H * V) / U) * s.C,
                                    q = a.tX.generateGeometry(m, c, o, G, W, i.style.debug);
                                if (!q) return;
                                null == q ||
                                    q.forEach((n) => {
                                        const s = (0, a.Ie)(n);
                                        for (let n = 0; n < I; n++) {
                                            o.tileAttrs[o.tileProps.drawLevel] = n;
                                            do {
                                                _.a.generate(e, t, i, o, [s[0], s[1], []], g);
                                            } while (e.isOverloaded());
                                        }
                                        (o.tileAttrs[o.tileProps.drawLevel] = void 0),
                                            l._.generate(e, t, i, o, s, I, m);
                                        const c = (0, r.y)(s);
                                        for (let e = 0; e < c[3].length; e++) c[3][e] -= R;
                                        c[4].forEach((e, t) => (c[4][t] = 1));
                                        do {
                                            d.j.generate(e, t, i, d.z.bottom, o, c, m);
                                        } while (e.isOverloaded());
                                    });
                                const $ = d.j.sinks.stroke.packObjectAttributes(
                                    t,
                                    i.innerId,
                                    d.z.side,
                                    i.dataKeys,
                                    o,
                                );
                                null == q ||
                                    q.forEach((n) => {
                                        const r = (function (e) {
                                            const t = [];
                                            let i;
                                            const n = e.length;
                                            return (
                                                e.forEach((o, r) => {
                                                    o[3]
                                                        ? (i || ((i = [o.slice()]), t.push(i)),
                                                          i.push(e[(r + 1) % n].slice()))
                                                        : (i = void 0);
                                                }),
                                                t
                                            );
                                        })(n);
                                        r.forEach((e) =>
                                            e.forEach((e) => {
                                                e[4] = 0;
                                            }),
                                        ),
                                            r.forEach((n) => {
                                                E(e, $, n);
                                                const r = (function (e) {
                                                        const t = [];
                                                        (0, u.uI)(
                                                            v,
                                                            e[0][0],
                                                            e[0][1],
                                                            e[1][0],
                                                            e[1][1],
                                                        ),
                                                            (S = 0);
                                                        for (let i = 1; i < e.length; i++)
                                                            P(t, e, i);
                                                        return t;
                                                    })(n),
                                                    s = n.map((e) => {
                                                        const t = e.slice();
                                                        return (t[2] -= R), (t[4] = 1), t;
                                                    }),
                                                    a = L(n, r, O).map(
                                                        (e) => ((e[2] -= R), (e[4] = 1), e),
                                                    );
                                                E(e, $, a);
                                                const l = L(n, r, O).map((e) => ((e[2] += D), e));
                                                if ((E(e, $, l), D > 0)) {
                                                    const r = n.map((e) => {
                                                        const t = e.slice();
                                                        return (t[2] += D), t;
                                                    });
                                                    E(e, $, r);
                                                    const s = A(
                                                        r,
                                                        n.map((e) => {
                                                            const t = e.slice();
                                                            return (t[4] = 1), t;
                                                        }),
                                                    );
                                                    do {
                                                        d.j.generate(e, t, i, d.z.side, o, s, m);
                                                    } while (e.isOverloaded());
                                                    const a = A(l, r);
                                                    do {
                                                        d.j.generate(e, t, i, d.z.top, o, a, m);
                                                    } while (e.isOverloaded());
                                                } else {
                                                    const r = A(l, n);
                                                    do {
                                                        d.j.generate(e, t, i, d.z.top, o, r, m);
                                                    } while (e.isOverloaded());
                                                }
                                                const c = A(a, l);
                                                do {
                                                    d.j.generate(e, t, i, d.z.side, o, c, m);
                                                } while (e.isOverloaded());
                                                const h = A(s, a);
                                                do {
                                                    d.j.generate(e, t, i, d.z.bottom, o, h, m);
                                                } while (e.isOverloaded());
                                            });
                                    });
                            },
                        });
                    function P(e, t, i) {
                        const o = i === t.length - 1;
                        if (
                            (n.t8(y, t[i - 1][0], t[i - 1][1]),
                            n.t8(b, t[i][0], t[i][1]),
                            (0, u.IB)(x, v),
                            o)
                        )
                            I = 0;
                        else {
                            n.t8(w, t[i + 1][0], t[i + 1][1]), (0, u.uI)(g, b[0], b[1], w[0], w[1]);
                            const e = (0, m.uZ)(n.AK(v, g), -1, 1),
                                o = Math.sqrt((1 - e) / (1 + e)),
                                r = (0, m.Xx)(n.AK(x, g));
                            I = o * r;
                        }
                        let r = x[0] + v[0] * S,
                            s = x[1] + v[1] * S;
                        e.push([r, s]),
                            o && ((r = x[0] + v[0] * I), (s = x[1] + v[1] * I), e.push([r, s])),
                            o || (n.JG(v, g), (S = I));
                    }
                    function L(e, t, i) {
                        const o = [];
                        for (let r = 0; r < e.length; r++) {
                            const s = e[r].slice();
                            n.JG(x, t[r]), n.bA(x, x, i), n.IH(s, s, x), o.push(s);
                        }
                        return o;
                    }
                    function k(e) {
                        return Math.min(Math.max((0, h.VW)(e), 0), f._H);
                    }
                    function E(e, t, i) {
                        do {
                            const n = e.getBucket('mesh', 'stroke', t, d.j.sinks.stroke.binder),
                                o = i.length;
                            for (let e = 0; e < o - 1; e++) {
                                const t = e + 1;
                                (0, c.n)(
                                    n,
                                    i[e][0],
                                    i[e][1],
                                    k(i[e][2]),
                                    i[t][0],
                                    i[t][1],
                                    k(i[t][2]),
                                    [0, 0],
                                );
                            }
                        } while (e.isOverloaded());
                    }
                    function A(e, t) {
                        return (0, a.Ie)([e[0]].concat(e, t.reverse()));
                    }
                },
                7840: (e, t, i) => {
                    i.d(t, { bR: () => L, uF: () => B, GN: () => Z, vg: () => U, qp: () => N });
                    var n = i(3698),
                        o = i(6273);
                    function r(e, t) {
                        const i = e.reduce((e, t) => e.concat(t), [0]).concat(t),
                            n = i.length - 1;
                        return {
                            coords: i.slice(i[0] === i[1] ? 1 : 0, i[n - 1] === i[n] ? n : n + 1),
                            isOddStretchable: s(e),
                        };
                    }
                    function s(e) {
                        var t;
                        return !(null === (t = null == e ? void 0 : e[0]) || void 0 === t
                            ? void 0
                            : t[0]);
                    }
                    function a(e, t, i, n) {
                        if (e.coords.length < 2)
                            throw new Error(
                                'The source coords array must have at least two coordinates',
                            );
                        return e.coords.map(
                            (o, r) =>
                                (t + o + n * (0 === r ? -1 : r === e.coords.length - 1 ? 1 : 0)) /
                                i,
                        );
                    }
                    function l(e, t) {
                        const { stretchSize: i, fixSize: n } = c(e),
                            { coords: o, isOddStretchable: r } = e,
                            s = t < n ? n : t,
                            a = [o[0]];
                        for (let e = 1; e < o.length; e++) {
                            const t = o[e - 1],
                                l = o[e],
                                c = e % 2 == (r ? 1 : 0),
                                d = a[a.length - 1];
                            c ? a.push(Math.round(((s - n) * (l - t)) / i) + d) : a.push(d + l - t);
                        }
                        return a;
                    }
                    function c({ coords: e, isOddStretchable: t }) {
                        if (e.length < 2)
                            throw new Error('An axis must have at least two coordinates');
                        if (2 === e.length) return { stretchSize: e[e.length - 1], fixSize: 0 };
                        let i = 0;
                        for (let n = t ? 0 : 1; n < e.length - 1; n += 2) i += e[n + 1] - e[n];
                        return { stretchSize: i, fixSize: e[e.length - 1] - i };
                    }
                    function d(e, t, i = 0) {
                        const n = e[e.length - 1] - e[0],
                            o = e.map((e) => Math.round(e - n / 2 + i));
                        return (
                            2 === o.length
                                ? (o[o.length - 1] += 2 * t)
                                : ((o[0] -= t), (o[o.length - 1] += t)),
                            o
                        );
                    }
                    function h(e, t, i, n, s, c, h, u, m) {
                        const f = (function (e, t, i = [], n = []) {
                                return { x: r(i, e), y: r(n, t) };
                            })(i.w, i.h, u, m),
                            p = (function (e, t, i, n, o) {
                                return [a(e.x, t, n[0], o), a(e.y, i, n[1], o)];
                            })(f, i.x, i.y, t, o.CW),
                            _ = (function (e, t, i, n, o = 0, r = 0) {
                                return [d(l(e.x, t), n, o), d(l(e.y, i), n, r)];
                            })(f, n, s, o.CW, c, h);
                        e.set(_, p);
                    }
                    const u = [0, 0];
                    function m(e, t, i, r, s, a, l, c, d, h, u, m, f, p) {
                        let _ = 16 * e.elements.offset;
                        (e.views.position[_] = o.jO + t),
                            (e.views.position[_ + 1] = o.jO + i),
                            (e.views.position[_ + 2] = r),
                            (e.views.cornerOffset[_] = s),
                            (e.views.cornerOffset[_ + 1] = -a),
                            (e.views.checkPointOffset[_] = d),
                            (e.views.checkPointOffset[_ + 1] = h),
                            (e.views.texCoords[_] = (0, n.Bb)(l)),
                            (e.views.texCoords[_ + 1] = (0, n.Bb)(c)),
                            (e.views.scales[_] = (0, n.KF)(u)),
                            (e.views.scales[_ + 1] = (0, n.wj)(m)),
                            (_ >>= 1),
                            (e.views.localID[_] = f),
                            (e.views.labelingTextureID[_] = p),
                            e.elements.offset++;
                    }
                    function f(e, t, i, n, r, s, a) {
                        const l = e.elements,
                            c = (l.stride * l.offset) >> 1;
                        (e.views.position[c] = o.jO + t),
                            (e.views.position[c + 1] = o.jO + i),
                            (e.views.position[c + 2] = n),
                            (e.views.cornerOffset[c] = r),
                            (e.views.cornerOffset[c + 1] = -s),
                            (e.views.labelingTextureID[c >> 1] = a),
                            l.offset++;
                    }
                    function p(e, t, i, n, o, r, s) {
                        const { elements: a, indices: l } = e,
                            { buffer: c, offset: d } = l,
                            h = a.offset;
                        (c[d] = h + t),
                            (c[d + 1] = h + i),
                            (c[d + 2] = h + n),
                            (c[d + 3] = h + o),
                            (c[d + 4] = h + r),
                            (c[d + 5] = h + s),
                            (l.offset = d + 6);
                    }
                    var _ = i(4999),
                        v = i(5317),
                        g = i(9218),
                        y = i(2543);
                    function b(e, t, i, n, o, r) {
                        if (!e || (o && !r)) return [0, 0];
                        if (!r) return [e.w / t, e.h / t];
                        const s = S(i, n, r),
                            a = i.style.iconTextPadding;
                        return [a[3] + a[1] + s[0], a[0] + a[2] + s[1]];
                    }
                    function w(e, t, i) {
                        return I((0, y.vn)(e.style.textFontSize, t), e.style.textLineHeight, i);
                    }
                    function x(e, t, i) {
                        return I((0, y.vn)(e.style.textFontSize2, t), e.style.textLineHeight, i);
                    }
                    function S(e, t, i) {
                        return I(
                            (0, y.vn)(e.style.iconTextFontSize, t),
                            e.style.iconTextLineHeight,
                            i,
                        );
                    }
                    function I(e, t, i) {
                        return [(e / g.fonts.baseSize) * i.maxWidth, e * t * i.lines.length];
                    }
                    function M(e, t, i) {
                        var n, o;
                        const r = null !== (n = i[0]) && void 0 !== n ? n : 0,
                            s = null !== (o = i[1]) && void 0 !== o ? o : 0;
                        return [(0.5 - e.anchorX) * t[0] + r, (0.5 - e.anchorY) * t[1] + s];
                    }
                    function T(e, t, i, n, o) {
                        var r, s, a, l;
                        const c = null !== (r = i[0]) && void 0 !== r ? r : 0.5,
                            d = null !== (s = i[1]) && void 0 !== s ? s : 0.5,
                            h = null !== (a = o[0]) && void 0 !== a ? a : 0,
                            u = null !== (l = o[1]) && void 0 !== l ? l : 0;
                        return [e[0] / 2 - c * t[0] - n[3] + h, e[1] / 2 - d * t[1] - n[0] + u];
                    }
                    function P(e, t, i, n, o) {
                        const r = t[0],
                            s = t[1],
                            a = i[0],
                            l = i[1];
                        let c = 0,
                            d = 0;
                        const h = l / 2 + s / 2,
                            u = l / 2 - s / 2,
                            m = -h,
                            f = -u,
                            p = a / 2 + r / 2,
                            _ = a / 2 - r / 2,
                            v = -p,
                            g = -_;
                        switch (e) {
                            case 'bottomCenter':
                                d = h + o;
                                break;
                            case 'rightCenter':
                                c = p + o;
                                break;
                            case 'topCenter':
                                d = m - o;
                                break;
                            case 'leftCenter':
                                c = v - o;
                                break;
                            case 'bottomRight':
                                (c = _), (d = h + o);
                                break;
                            case 'topRight':
                                (c = _), (d = m - o);
                                break;
                            case 'bottomLeft':
                                (c = g), (d = h + o);
                                break;
                            case 'rightBottom':
                                (c = p + o), (d = f);
                                break;
                            case 'rightTop':
                                (c = p + o), (d = u);
                                break;
                            case 'topLeft':
                                (c = g), (d = m - o);
                                break;
                            case 'leftTop':
                                (c = v - o), (d = u);
                                break;
                            case 'leftBottom':
                                (c = v - o), (d = f);
                        }
                        return [c + n[0], d + n[1]];
                    }
                    var L,
                        k = i(5600),
                        E = i(6392),
                        A = i(2153),
                        z = i(7464),
                        C = i(7486),
                        F = i(2702),
                        O = i(1959),
                        D = i(7293);
                    !(function (e) {
                        (e[(e.Icon = 0)] = 'Icon'),
                            (e[(e.First = 1)] = 'First'),
                            (e[(e.Second = 2)] = 'Second');
                    })(L || (L = {}));
                    const R = new (class {
                            constructor() {
                                (this.countX = 0),
                                    (this.countY = 0),
                                    (this.textureX = []),
                                    (this.textureY = []),
                                    (this.stretchedX = []),
                                    (this.stretchedY = []);
                            }
                            reset() {
                                (this.countX = 0), (this.countY = 0);
                            }
                            set(e, t) {
                                (this.countX = t[0].length),
                                    (this.countY = t[1].length),
                                    (this.textureX = t[0]),
                                    (this.textureY = t[1]),
                                    (this.stretchedX = e[0]),
                                    (this.stretchedY = e[1]);
                            }
                            isEmpty() {
                                return 0 === this.countX || 0 === this.countY;
                            }
                        })(),
                        j = [0, 0, 0],
                        B = (0, k.D)({
                            symbol: 'point',
                            sinks: {
                                raster: {
                                    stride: 32,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.cornerOffset = new Int16Array(t, 8)),
                                            (e.views.checkPointOffset = new Int16Array(t, 12)),
                                            (e.views.texCoords = new Uint16Array(t, 16)),
                                            (e.views.scales = new Int16Array(t, 20)),
                                            (e.views.localID = new Uint32Array(t, 24)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 28));
                                    },
                                    packObjectAttributes: (e, t, i, n) =>
                                        (0, F.LY)([e.styleId, e.layer.innerId, t, i], n),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        animDirection: e[2],
                                        atlasIndex: e[3],
                                        tileData: e.slice(4),
                                    }),
                                },
                                text: {
                                    stride: 28,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.cornerOffset = new Int16Array(t, 8)),
                                            (e.views.checkPointOffset = new Int16Array(t, 12)),
                                            (e.views.texCoords = new Uint16Array(t, 16)),
                                            (e.views.localID = new Uint32Array(t, 20)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 24));
                                    },
                                    packObjectAttributes: (e, t, i, n, o, r, s) =>
                                        (0, F.LY)(
                                            [e.styleId, e.layer.innerId, t, i, n[0], -n[1], o, r],
                                            s,
                                        ),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        animDirection: e[2],
                                        range: e[3],
                                        offsetX: e[4],
                                        offsetY: e[5],
                                        labelIndex: e[6],
                                        fontIndex: e[7],
                                        tileData: e.slice(8),
                                    }),
                                },
                                labelingTexture: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.cornerOffset = new Int16Array(t, 8)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 12));
                                    },
                                    packObjectAttributes: (e, t = [0, 0]) =>
                                        (0, F.LY)([e.styleId, e.layer.innerId, t[0], -t[1]], []),
                                    unpackObjectAttributes: (e) => ({
                                        styleId: e[0],
                                        layerId: e[1],
                                        offsetX: e[2],
                                        offsetY: e[3],
                                        tileData: e.slice(4),
                                    }),
                                },
                            },
                            processElement(e, t, i, n, r, s, a) {
                                const { layer: l, label: c } = i;
                                if ('point' !== l.type) return;
                                const d = (0, y.bs)(s.styleZoom, s.styleState, !0, c.tileData),
                                    h = H(d, e, r, c),
                                    u = e.icons[(0, y.Q9)(l.style.iconImage, d)],
                                    m = (0, O.x)(u),
                                    f = b(h, r, l, d, m, c.iconTextMetrics);
                                let p,
                                    _ = [0, 0];
                                if (
                                    (h &&
                                        (c.iconTextMetrics
                                            ? ((p = S(l, d, c.iconTextMetrics)),
                                              (_ = T(
                                                  f,
                                                  p,
                                                  l.style.iconTextAnchor,
                                                  l.style.iconTextPadding,
                                                  l.style.iconTextOffset,
                                              )))
                                            : (_ = M(h, f, l.style.iconOffset))),
                                    (0, E.a2)(j, i.anchorWorld, a),
                                    (0, E.hm)(j))
                                )
                                    switch (i.type) {
                                        case A.Dl.Icon:
                                            if (!h || (m && !c.iconTextMetrics)) return;
                                            const a = m ? u.stretchX : void 0,
                                                d = m ? u.stretchY : void 0;
                                            if (
                                                (Z(
                                                    t,
                                                    c,
                                                    j,
                                                    n,
                                                    h,
                                                    f[0] * r,
                                                    f[1] * r,
                                                    _[0] * r,
                                                    _[1] * r,
                                                    r,
                                                    null == a
                                                        ? void 0
                                                        : a.map(([e, t]) => [e * r, t * r]),
                                                    null == d
                                                        ? void 0
                                                        : d.map(([e, t]) => [e * r, t * r]),
                                                ),
                                                !p)
                                            )
                                                return;
                                            return void (function (e, t, i, n, r, s, a, l, c) {
                                                var d;
                                                const { iconTextMetrics: h } = i;
                                                if (!h || !l.style.iconTextFont) return;
                                                const u = (0, y.bs)(
                                                        r.styleZoom,
                                                        r.styleState,
                                                        !1,
                                                        i.tileData,
                                                    ),
                                                    m = (0, y.Q9)(l.style.iconTextFont, u),
                                                    f =
                                                        null !== (d = e.fontNameToIndex[m]) &&
                                                        void 0 !== d
                                                            ? d
                                                            : e.fontNameToIndex[o.Uo];
                                                N(t, i, L.Icon, h, n, s, a, l, f, c);
                                            })(
                                                e,
                                                t,
                                                i.label,
                                                j,
                                                s,
                                                n,
                                                (function (e, t, i) {
                                                    var n, o, r, s;
                                                    const a =
                                                            null !== (n = t[0]) && void 0 !== n
                                                                ? n
                                                                : 0.5,
                                                        l =
                                                            null !== (o = t[1]) && void 0 !== o
                                                                ? o
                                                                : 0.5,
                                                        c =
                                                            null !== (r = i[0]) && void 0 !== r
                                                                ? r
                                                                : 0,
                                                        d =
                                                            null !== (s = i[1]) && void 0 !== s
                                                                ? s
                                                                : 0;
                                                    return [
                                                        (0.5 - a) * e[0] + c,
                                                        (0.5 - l) * e[1] + d,
                                                    ];
                                                })(
                                                    p,
                                                    l.style.iconTextAnchor,
                                                    l.style.iconTextOffset,
                                                ),
                                                l,
                                                r,
                                            );
                                        case A.Dl.PoiText:
                                            return void (function (e, t, i, n, r, s, a, l, c, d) {
                                                var h;
                                                const { label: u } = i,
                                                    { textMetrics: m } = u,
                                                    f = (0, y.bs)(
                                                        s.styleZoom,
                                                        s.styleState,
                                                        !1,
                                                        u.tileData,
                                                    ),
                                                    p = (0, y.Q9)(c.style.textFont, f);
                                                if (!p.length) return;
                                                const _ = w(c, f, m),
                                                    v =
                                                        null !== (h = e.fontNameToIndex[p]) &&
                                                        void 0 !== h
                                                            ? h
                                                            : e.fontNameToIndex[o.Uo],
                                                    g = i.parent
                                                        ? c.style.textPlacement
                                                        : 'centerCenter',
                                                    b = (0, y.vn)(c.style.textOffset, f),
                                                    x = P(g, r, _, l, b);
                                                N(t, u, L.First, u.textMetrics, n, a, x, c, v, d);
                                            })(e, t, i, j, f, s, n, _, l, r);
                                        case A.Dl.PoiText2:
                                            return void (function (e, t, i, n, r, s, a, l, c, d) {
                                                var h, u;
                                                const { label: m } = i,
                                                    { textMetrics: f, textMetrics2: p } = m;
                                                if (!p || !c.style.textFont2) return;
                                                const _ = (0, y.bs)(
                                                        s.styleZoom,
                                                        s.styleState,
                                                        !1,
                                                        m.tileData,
                                                    ),
                                                    v = w(c, _, f),
                                                    g = x(c, _, p),
                                                    b = (0, y.vn)(c.style.textOffset, _),
                                                    S = (0, y.vn)(
                                                        null !== (h = c.style.textOffset2) &&
                                                            void 0 !== h
                                                            ? h
                                                            : 0,
                                                        _,
                                                        0,
                                                    ),
                                                    I = (0, y.Q9)(c.style.textFont2, _),
                                                    M =
                                                        null !== (u = e.fontNameToIndex[I]) &&
                                                        void 0 !== u
                                                            ? u
                                                            : e.fontNameToIndex[o.Uo],
                                                    T = P(
                                                        c.style.textPlacement,
                                                        r,
                                                        [g[0], v[1]],
                                                        l,
                                                        b,
                                                    );
                                                (T[1] += (v[1] + g[1]) / 2 + S),
                                                    N(t, m, L.Second, p, n, a, T, c, M, d);
                                            })(e, t, i, j, f, s, n, _, l, r);
                                    }
                            },
                            getLabelingInfo(e, t, i, n, o, r) {
                                const { layer: s } = e;
                                if ('point' !== s.type) return;
                                e.labelingElements.length = 0;
                                const a = (0, y.bs)(n.styleZoom, n.styleState, !0, e.tileData),
                                    l = H(a, i, r, e),
                                    c = i.icons[(0, y.Q9)(s.style.iconImage, a)],
                                    d = (0, O.x)(c),
                                    h = b(l, r, s, a, d, e.iconTextMetrics);
                                let u,
                                    m = [0, 0];
                                if (l && (!d || e.iconTextMetrics)) {
                                    e.iconTextMetrics
                                        ? ((u = S(s, a, e.iconTextMetrics)),
                                          (m = T(
                                              h,
                                              u,
                                              s.style.iconTextAnchor,
                                              s.style.iconTextPadding,
                                              s.style.iconTextOffset,
                                          )))
                                        : (m = M(l, h, s.style.iconOffset));
                                    const r = new v.x(e, A.Dl.Icon, t, n.buildingHeight, o, i);
                                    r.boxes.push([
                                        -h[0] / 2 + m[0],
                                        -h[1] / 2 + m[1],
                                        h[0] / 2 + m[0],
                                        h[1] / 2 + m[1],
                                    ]),
                                        e.labelingElements.push(r);
                                }
                                const f = (0, y.Q9)(s.style.textFont, a);
                                e.label.length > 0 &&
                                    f.length &&
                                    ((function (e, t, i, n, o, r, s, a) {
                                        const { textMetrics: l } = e;
                                        if (!l) return;
                                        const c = (0, y.bs)(
                                                o.styleZoom,
                                                o.styleState,
                                                !1,
                                                e.tileData,
                                            ),
                                            d = (0, y.vn)(a.style.textOffset, c),
                                            h = w(a, c, l),
                                            u = new v.x(e, A.Dl.PoiText, t, o.buildingHeight, r, i);
                                        e.labelingElements.length > 0 &&
                                            (u.parent = e.labelingElements[0]);
                                        const m = P(
                                            u.parent ? a.style.textPlacement : 'centerCenter',
                                            n,
                                            h,
                                            s,
                                            d,
                                        );
                                        u.boxes.push([
                                            m[0] - h[0] / 2,
                                            m[1] - h[1] / 2,
                                            m[0] + h[0] / 2,
                                            m[1] + h[1] / 2,
                                        ]),
                                            e.labelingElements.push(u);
                                    })(e, t, i, h, n, o, m, s),
                                    e.label2 &&
                                        (function (e, t, i, n, o, r, s, a) {
                                            var l;
                                            const { textMetrics: c, textMetrics2: d } = e;
                                            if (!d) return;
                                            const h = (0, y.bs)(
                                                    o.styleZoom,
                                                    o.styleState,
                                                    !1,
                                                    e.tileData,
                                                ),
                                                u = w(a, h, c),
                                                m = x(a, h, d),
                                                f = (0, y.vn)(a.style.textOffset, h),
                                                p = (0, y.vn)(
                                                    null !== (l = a.style.textOffset2) &&
                                                        void 0 !== l
                                                        ? l
                                                        : 0,
                                                    h,
                                                    0,
                                                ),
                                                _ = new v.x(
                                                    e,
                                                    A.Dl.PoiText2,
                                                    t,
                                                    o.buildingHeight,
                                                    r,
                                                    i,
                                                );
                                            e.labelingElements.length > 1
                                                ? ((_.parent = e.labelingElements[0]),
                                                  (_.firstLabel = e.labelingElements[1]))
                                                : e.labelingElements.length > 0 &&
                                                  ((_.parent = e.labelingElements[0]),
                                                  (_.firstLabel = e.labelingElements[0]));
                                            const g = P(
                                                a.style.textPlacement,
                                                n,
                                                [m[0], u[1]],
                                                s,
                                                f,
                                            );
                                            (g[1] += (u[1] + m[1]) / 2 + p),
                                                _.boxes.push([
                                                    g[0] - m[0] / 2,
                                                    g[1] - m[1] / 2,
                                                    g[0] + m[0] / 2,
                                                    g[1] + m[1] / 2,
                                                ]),
                                                e.labelingElements.push(_);
                                        })(e, t, i, h, n, o, m, s));
                            },
                        });
                    function N(e, t, i, n, o, r, s, a, l, c) {
                        if (i === L.First && 1 === t.labelingElements.length) {
                            const i = e.getBucket(
                                'point',
                                'labelingTexture',
                                B.sinks.labelingTexture.packObjectAttributes(t),
                                B.sinks.labelingTexture.binder,
                            );
                            t.checkPointOffset = (0, _.MD)(i, o, n, a, c, t.labelingTextureIndex);
                        }
                        const d = {};
                        for (const n of t.ranges)
                            d[n] = e.getBucket(
                                'point',
                                'text',
                                B.sinks.text.packObjectAttributes(
                                    t,
                                    r,
                                    n,
                                    s,
                                    i,
                                    l,
                                    (0, D.uq)(t.tileData, a),
                                ),
                                B.sinks.text.binder,
                            );
                        (0, _.$Y)(d, t, o, n, a, i, t.checkPointOffset);
                    }
                    function U(e, t, i, n, o, r) {
                        return Z(
                            e,
                            t,
                            i,
                            n,
                            o,
                            o.w,
                            o.h,
                            o.w * (0.5 - o.anchorX),
                            o.h * (0.5 - o.anchorY),
                            r,
                            void 0,
                            void 0,
                        );
                    }
                    function Z(e, t, i, n, r, s, a, l, c, d, _, v) {
                        if (s <= 0 || a <= 0) return;
                        const y = t.layer;
                        if ('point' !== y.type) return;
                        h(R, g.atlasSize, r, s, a, l, c, _, v),
                            e.atlasPacker.addRastersToLoad(t.styleId, r);
                        const b = e.getBucket(
                            'point',
                            'labelingTexture',
                            B.sinks.labelingTexture.packObjectAttributes(t),
                            B.sinks.labelingTexture.binder,
                        );
                        t.checkPointOffset = (function (e, t, i, n, r, s, a) {
                            const { stretchedX: l, stretchedY: c } = n,
                                d = Math.ceil((l[l.length - 1] - l[0]) / 2),
                                h = Math.ceil((c[c.length - 1] - c[0]) / 2),
                                m = (s * o.Jv) / 2;
                            (u[0] = l[0] + d), (u[1] = c[0] + h);
                            const _ = u[0] - m,
                                v = u[0] + m,
                                g = u[1] - m,
                                y = u[1] + m;
                            return (
                                p(r, 0, 2, 1, 1, 2, 3),
                                f(r, e, t, i, _, g, a),
                                f(r, e, t, i, v, g, a),
                                f(r, e, t, i, _, y, a),
                                f(r, e, t, i, v, y, a),
                                u
                            );
                        })(i[0], i[1], i[2], R, b, d, t.labelingTextureIndex);
                        const w = e.getBucket(
                            'point',
                            'raster',
                            B.sinks.raster.packObjectAttributes(
                                t,
                                n,
                                r.atlasIndex,
                                (0, D.uq)(t.tileData, y),
                            ),
                            B.sinks.raster.binder,
                        );
                        !(function (e, t, i, n, r, s, a, l, c, d) {
                            const {
                                    textureX: h,
                                    textureY: u,
                                    stretchedX: f,
                                    stretchedY: _,
                                    countX: v,
                                    countY: g,
                                } = n,
                                y = s !== -1 / 0 ? s : o.vL,
                                b = a !== 1 / 0 ? a : o.Fv,
                                [w, x] = d;
                            for (let n = 0; n < v - 1; n++) {
                                const o = h[n],
                                    s = h[n + 1],
                                    a = f[n],
                                    d = f[n + 1];
                                for (let n = 0; n < g - 1; n++) {
                                    const h = u[n],
                                        f = u[n + 1],
                                        v = _[n],
                                        g = _[n + 1];
                                    p(r, 0, 2, 1, 1, 2, 3),
                                        m(r, e, t, i, a, v, o, h, w, x, y, b, l, c),
                                        m(r, e, t, i, d, v, s, h, w, x, y, b, l, c),
                                        m(r, e, t, i, a, g, o, f, w, x, y, b, l, c),
                                        m(r, e, t, i, d, g, s, f, w, x, y, b, l, c);
                                }
                            }
                        })(
                            i[0],
                            i[1],
                            i[2],
                            R,
                            w,
                            -1 / 0,
                            1 / 0,
                            t.identifyIndex,
                            t.labelingTextureIndex,
                            t.checkPointOffset,
                        );
                    }
                    function H(e, t, i, n) {
                        const { rasterSets: o } = t,
                            { layer: r } = n;
                        if ('point' !== r.type) return;
                        let s;
                        if (
                            n.pointType === A.a_.Commercial ||
                            n.pointType === A.a_.CommercialCity ||
                            n.pointType === A.a_.Landmark
                        )
                            s = o.byKey[(0, z.zV)(n.idLo, n.idHi)];
                        else {
                            const t = (0, y.Q9)(r.style.iconImage, e);
                            t.length &&
                                (s =
                                    o.byKey[
                                        (0, z.PR)(t, r.style.iconAnchor[0], r.style.iconAnchor[1])
                                    ]);
                        }
                        if (s) {
                            const t = (0, y.vn)(r.style.iconWidth, e),
                                n = (0, C.Bl)(s.rasters, t * i, !0);
                            if (void 0 !== n) return s.rasters[n];
                        }
                    }
                },
                2097: (e, t, i) => {
                    i.d(t, { a: () => v });
                    var n = i(5600),
                        o = i(3672),
                        r = i(143),
                        s = i(2682),
                        a = i(2618),
                        l = i(2702),
                        c = i(6273),
                        d = i(9981),
                        h = i(2543),
                        u = i(7464),
                        m = i(8450);
                    const f = (0, o.Ru)(NaN, NaN);
                    function p(e, t, i, n, o) {
                        return (0, l.v$)([e, t, i, o.tileAttrs[o.tileProps.drawLevel]], n, o);
                    }
                    const _ = (e) => ({
                            styleId: e[0],
                            layerId: e[1],
                            hiddenObjectId: Number.isNaN(e[2]) ? void 0 : (0, o.Ak)(e[2]),
                            drawLevel: e[3] ? e[3] : void 0,
                            tileData: e.slice(4),
                        }),
                        v = (0, n.D)({
                            symbol: 'polygon',
                            sinks: {
                                fill: {
                                    stride: 8,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.localID = new Uint32Array(t, 4));
                                    },
                                    packObjectAttributes: p,
                                    unpackObjectAttributes: _,
                                },
                                stroke: {
                                    stride: 8,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.directionDistance = new Int8Array(t, 4));
                                    },
                                    packObjectAttributes: p,
                                    unpackObjectAttributes: _,
                                },
                            },
                            generate(e, t, i, n, o, l, c, p, _) {
                                const { tileAttrs: b, tileProps: w } = n,
                                    x = o[0],
                                    S = o[1],
                                    I = o[2];
                                (0, m.nc)(i) &&
                                    c &&
                                    (function (e, t, i, n, o) {
                                        const r = (0, d.fL)(o);
                                        (0, h.EG)(n.style.textureImage).forEach((o) => {
                                            if (!o.length) return;
                                            const s = i.byKey[(0, u.FD)(o)];
                                            if (!s)
                                                return void console.error(
                                                    `Not found raster set with texture ${o}`,
                                                );
                                            if (!s.isSvg) return;
                                            const a = n.style.textureSize,
                                                [l, c] = Array.isArray(a) ? a : [a, a];
                                            e.atlasPacker.packSvg(s, [{ w: l, h: c }], r),
                                                s.rasters.forEach((i) =>
                                                    e.atlasPacker.addRastersToLoad(t, i),
                                                );
                                        });
                                    })(e, t, c, i, l);
                                const M = b[w.id],
                                    T = 'number' != typeof M && p && p.has(M) ? M : f,
                                    P = b[w.hovered]
                                        ? a.gl
                                        : e.idIndexer.getIndex({
                                              id: M,
                                              styleId: t,
                                              layer: i,
                                              sublayer: b[w.db_sublayer],
                                              floorId: _,
                                          });
                                !(function (e, t, i, n, o) {
                                    const r = e.indices.buffer;
                                    let s = e.indices.offset,
                                        a = e.elements.offset;
                                    const l = a;
                                    g(e, a++, i[0], n[0], o), g(e, a++, i[1], n[1], o);
                                    for (let c = 2; c < t; c++)
                                        y(r, s, l, c), g(e, a++, i[c], n[c], o), (s += 3);
                                    (e.elements.offset = a), (e.indices.offset = s);
                                })(
                                    e.getBucket(
                                        'polygon',
                                        'fill',
                                        v.sinks.fill.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            T,
                                            i.dataKeys,
                                            n,
                                        ),
                                        v.sinks.fill.binder,
                                    ),
                                    x.length,
                                    x,
                                    S,
                                    P,
                                );
                                !(function (e, t, i, n, o) {
                                    for (let a = 0; a < t; a++) {
                                        const l = (0, r.X)(a, t);
                                        if (1 === o[l]) {
                                            const o = (0, r.X)((a + 1) % t, t);
                                            (0, s.n)(e, i[l], n[l], 0, i[o], n[o], 0);
                                        }
                                    }
                                })(
                                    e.getBucket(
                                        'polygon',
                                        'stroke',
                                        v.sinks.stroke.packObjectAttributes(
                                            t,
                                            i.innerId,
                                            T,
                                            i.dataKeys,
                                            n,
                                        ),
                                        v.sinks.stroke.binder,
                                    ),
                                    x.length,
                                    x,
                                    S,
                                    I,
                                );
                            },
                        });
                    function g(e, t, i, n, o) {
                        (t *= 4),
                            (e.views.position[t] = c.jO + i),
                            (e.views.position[t + 1] = c.jO + n),
                            (t >>= 1),
                            (e.views.localID[t] = o);
                    }
                    function y(e, t, i, n) {
                        n % 2 == 0
                            ? ((e[t] = i + n - 2), (e[t + 1] = i + n - 1), (e[t + 2] = i + n))
                            : ((e[t] = i + n - 1), (e[t + 1] = i + n - 2), (e[t + 2] = i + n));
                    }
                },
                5970: (e, t, i) => {
                    i.d(t, { p: () => g });
                    var n = i(143),
                        o = i(6392),
                        r = i(3672),
                        s = i(5600),
                        a = i(1558),
                        l = i(8308),
                        c = i(2682),
                        d = i(2618),
                        h = i(2702),
                        u = i(8194),
                        m = i(6273);
                    const f = (0, r.Ru)(NaN, NaN),
                        p = m.Bq / 2,
                        _ = (e, t, i, n, o) => (0, h.v$)([e, t, i], n, o),
                        v = (e) => ({
                            styleId: e[0],
                            layerId: e[1],
                            hiddenObjectId: Number.isNaN(e[2]) ? void 0 : (0, r.Ak)(e[2]),
                            tileData: e.slice(3),
                        }),
                        g = (0, s.D)({
                            symbol: 'polygonExtrusion',
                            sinks: {
                                sideFill: {
                                    stride: 24,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.normal = new Int8Array(t, 8)),
                                            (e.views.localID = new Uint32Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 20));
                                    },
                                    packObjectAttributes: _,
                                    unpackObjectAttributes: v,
                                },
                                topFill: {
                                    stride: 24,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.normal = new Int8Array(t, 8)),
                                            (e.views.localID = new Uint32Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16)),
                                            (e.views.labelingTextureID = new Uint32Array(t, 20));
                                    },
                                    packObjectAttributes: _,
                                    unpackObjectAttributes: v,
                                },
                                sideStroke: {
                                    stride: 20,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.distance = new Int16Array(t, 6)),
                                            (e.views.normals = new Int8Array(t, 8)),
                                            (e.views.direction = new Int8Array(t, 12)),
                                            (e.views.demPosition = new Int16Array(t, 16));
                                    },
                                    packObjectAttributes: _,
                                    unpackObjectAttributes: v,
                                },
                                topStroke: {
                                    stride: 16,
                                    binder: (e, t) => {
                                        (e.views.position = new Uint16Array(t)),
                                            (e.views.directionDistance = new Int8Array(t, 8)),
                                            (e.views.demPosition = new Int16Array(t, 12));
                                    },
                                    packObjectAttributes: _,
                                    unpackObjectAttributes: v,
                                },
                            },
                            generate(e, t, i, r, s, h, p, v, S, I) {
                                const M = s[0],
                                    T = s[1],
                                    P = s[2],
                                    L = M.length;
                                v ||
                                    (v =
                                        r.tileProps.db_centroid_x &&
                                        r.tileProps.db_centroid_y &&
                                        !Number.isNaN(r.tileAttrs[r.tileProps.db_centroid_x]) &&
                                        !Number.isNaN(r.tileAttrs[r.tileProps.db_centroid_y])
                                            ? [
                                                  r.tileAttrs[r.tileProps.db_centroid_x],
                                                  r.tileAttrs[r.tileProps.db_centroid_y],
                                              ]
                                            : (function (e, t, i) {
                                                  let o,
                                                      r = Math.pow(m.Bq, 2);
                                                  const s = e.length,
                                                      a = u.Ue();
                                                  for (let l = 0; l < s; l++) {
                                                      o || u.aM(a, [e[l], t[l]]);
                                                      const c = (0, n.X)(l, s);
                                                      if (0 === i[c]) {
                                                          const i = [e[c], t[c]],
                                                              a = (0, n.X)((l + 1) % s, s),
                                                              d = [e[a], t[a]];
                                                          if (x(i)) {
                                                              const e = w(i);
                                                              e < r && ((o = i), (r = e));
                                                              const t = w(d);
                                                              t < r && ((o = d), (r = t));
                                                          } else
                                                              o = [
                                                                  (e[c] + e[a]) / 2,
                                                                  (t[c] + t[a]) / 2,
                                                              ];
                                                      }
                                                  }
                                                  o || ((o = []), u.be(o, a));
                                                  return o;
                                              })(M, T, P));
                                const k = r.tileAttrs[r.tileProps.hovered],
                                    E = Math.round((0, o.VW)(r.tileAttrs[r.tileProps.db_height])),
                                    A = r.tileAttrs[r.tileProps.id],
                                    z = k
                                        ? d.gl
                                        : e.idIndexer.getIndex({
                                              id: A,
                                              styleId: t,
                                              layer: i,
                                              sublayer: r.tileAttrs[r.tileProps.db_sublayer],
                                              floorId: S,
                                          }),
                                    C = e.buildingPointIndexer.getIndex(null != I ? I : A),
                                    F = 'number' != typeof A && p && p.has(A) ? A : f,
                                    O = _(t, i.innerId, F, i.dataKeys, r);
                                if (E > 0) {
                                    const t = e.getBucket(
                                        'polygonExtrusion',
                                        'sideFill',
                                        O,
                                        g.sinks.sideFill.binder,
                                    );
                                    (0, a.y)(t, L, M, T, P, E, z, C, v);
                                    const i = e.getBucket(
                                        'polygonExtrusion',
                                        'sideStroke',
                                        O,
                                        g.sinks.sideStroke.binder,
                                    );
                                    h &&
                                        ((0, l.C)(i, L, M, T, P, v), (0, l.b)(i, L, M, T, P, E, v));
                                }
                                !(function (e, t, i, n, o, r, s, a) {
                                    let l = e.elements.offset;
                                    const c = l;
                                    y(e, l++, i[0], n[0], o, r, s, a),
                                        y(e, l++, i[1], n[1], o, r, s, a);
                                    for (let d = 2; d < t; d++)
                                        b(e, c, d), y(e, l++, i[d], n[d], o, r, s, a);
                                    e.elements.offset = l;
                                })(
                                    e.getBucket(
                                        'polygonExtrusion',
                                        'topFill',
                                        O,
                                        g.sinks.topFill.binder,
                                    ),
                                    L,
                                    M,
                                    T,
                                    E,
                                    z,
                                    C,
                                    v,
                                );
                                !(function (e, t, i, o, r, s, a) {
                                    for (let l = 0; l < t; l++) {
                                        const d = (0, n.X)(l, t);
                                        if (r && 1 === r[d]) {
                                            const r = (0, n.X)((l + 1) % t, t);
                                            (0, c.n)(e, i[d], o[d], s, i[r], o[r], s, a);
                                        }
                                    }
                                })(
                                    e.getBucket(
                                        'polygonExtrusion',
                                        'topStroke',
                                        O,
                                        g.sinks.topStroke.binder,
                                    ),
                                    L,
                                    M,
                                    T,
                                    P,
                                    E,
                                    v,
                                );
                            },
                        });
                    function y(e, t, i, n, o, r, s, a) {
                        const l = e.elements.stride,
                            c = t * (l / e.views.position.BYTES_PER_ELEMENT),
                            d = t * (l / e.views.normal.BYTES_PER_ELEMENT);
                        (e.views.position[c] = m.jO + i),
                            (e.views.position[c + 1] = m.jO + n),
                            (e.views.position[c + 2] = o),
                            (e.views.normal[d] = 0),
                            (e.views.normal[d + 1] = 127),
                            (e.views.normal[d + 2] = 127),
                            (e.views.demPosition[c] = (m.jO + a[0]) / 8),
                            (e.views.demPosition[c + 1] = (m.jO + a[1]) / 8);
                        const h = t * (l / e.views.localID.BYTES_PER_ELEMENT);
                        (e.views.localID[h] = r), (e.views.labelingTextureID[h] = s);
                    }
                    function b(e, t, i) {
                        const n = e.indices.buffer;
                        let o = e.indices.offset;
                        i % 2 == 0
                            ? ((n[o++] = t + i - 2), (n[o++] = t + i - 1), (n[o++] = t + i))
                            : ((n[o++] = t + i - 1), (n[o++] = t + i - 2), (n[o++] = t + i)),
                            (e.indices.offset = o);
                    }
                    function w(e) {
                        return (
                            Math.pow(p - Math.abs(e[0] - p), 2) +
                            Math.pow(p - Math.abs(e[1] - p), 2)
                        );
                    }
                    function x(e) {
                        return 0 === e[0] || e[0] === m.Bq || 0 === e[1] || e[1] === m.Bq;
                    }
                },
                6201: (e, t, i) => {
                    i.d(t, { It: () => s, R2: () => n, hs: () => r });
                    var n,
                        o = i(2543);
                    function r(e, t) {
                        return Number.isNaN(e) ? t : e;
                    }
                    function s(e, t) {
                        if (!e) return '';
                        const i = (0, o.FR)(e, t);
                        return Number.isNaN(i) || (!i && 0 !== i) ? '' : String(i);
                    }
                    !(function (e) {
                        (e[(e.Point = 0)] = 'Point'),
                            (e[(e.Line = 1)] = 'Line'),
                            (e[(e.OneWayLine = 2)] = 'OneWayLine');
                    })(n || (n = {}));
                },
                4333: (e, t, i) => {
                    i.d(t, { p: () => _ });
                    var n = i(7609),
                        o = i(9218),
                        r = i(7486),
                        s = i(7464),
                        a = i(9981),
                        l = i(2543),
                        c = i(2618),
                        d = i(2702),
                        h = i(2153),
                        u = i(6201),
                        m = i(1959),
                        f = i(6392),
                        p = i(9073);
                    const _ = (e, t, i, _, v, g, y, b, w, x, S) => {
                        var I;
                        const { tileProps: M, tileAttrs: T } = _;
                        if (
                            ((function (e, t, i, c, d, h, u) {
                                const { rasterSets: f, icons: p } = t,
                                    _ = (0, a.fL)(h),
                                    v = (0, l.EG)(i.style.iconWidth),
                                    g = (0, n.Ty)(d[c.db_sublayer]),
                                    y = (0, n.Cz)(d[c.db_sublayer]),
                                    { iconAnchor: b } = i.style;
                                if (g || y) {
                                    if (u) return;
                                    const i = g
                                            ? o.commercialPoi.rasterSizes
                                            : o.landmarkRasterSizes,
                                        n = (0, r.rA)(
                                            d[c.id],
                                            i,
                                            d[c.db_region],
                                            b,
                                            c.url_src ? d[c.url_src] : void 0,
                                        );
                                    e.atlasPacker.addNewRasterSet(t.id, n),
                                        e.atlasPacker.pack(n, v, _);
                                } else
                                    (0, l.EG)(i.style.iconImage).forEach((i) => {
                                        if (!i.length) return;
                                        const n = f.byKey[(0, s.PR)(i, b[0], b[1])];
                                        if (!n)
                                            return void console.error(
                                                `Not found raster set with image ${i}, anchorX: ${b[0]}, anchorY: ${b[1]}`,
                                            );
                                        if (!n.isSvg) return;
                                        const o = p[i],
                                            r =
                                                o && (0, m.x)(o)
                                                    ? [{ w: o.width, h: o.height }]
                                                    : v.map((e) => ({ w: e, h: e }));
                                        e.atlasPacker.packSvg(n, r, _),
                                            u &&
                                                n.rasters.forEach((i) =>
                                                    e.atlasPacker.addRastersToLoad(t.id, i),
                                                );
                                    });
                            })(e, t, i, M, T, w, x),
                            x)
                        )
                            return;
                        let P = h.a_.Common;
                        (0, n.wu)(T[M.db_sublayer])
                            ? (P = h.a_.CommercialCity)
                            : (0, n.Ty)(T[M.db_sublayer])
                            ? (P = h.a_.Commercial)
                            : (0, n.Cz)(T[M.db_sublayer]) && (P = h.a_.Landmark);
                        const L = 1 === b[0].length ? h._r.Point : h._r.Line;
                        let k,
                            E = [];
                        if (L === h._r.Point) {
                            if (_ && i.style.allowElevation) {
                                const e = (0, l.vn)(i.style.elevation, _);
                                if (0 !== e) {
                                    const t = [0, 0, 0];
                                    (0, f.Z$)(t, [b[0][0], b[1][0], 0], (0, f.Bs)(g));
                                    const i = (0, p.PA)(t),
                                        n = (0, p.a4)(i, e),
                                        o = Math.round((0, f.VW)(n));
                                    b = [b[0], b[1], [o]];
                                }
                            }
                            (E = [[b[0][0]], [b[1][0]], 3 === b.length ? [b[2][0]] : [0]]),
                                (k = [0, 0, 0]),
                                (0, f.Z$)(k, [E[0][0], E[1][0], E[2][0]], (0, f.Bs)(g));
                        } else E = [b[0], b[1]];
                        const A = T[M.id];
                        let z = c.gl,
                            C = c.gl;
                        Number.isNaN(A) ||
                            ((z = e.idIndexer.getIndex({
                                id: A,
                                styleId: t.id,
                                layer: i,
                                sublayer: T[M.db_sublayer],
                                objectClass: T[M.db_object_class],
                                instanceId: 0,
                                metatile: v,
                                center: k,
                                floorId: S,
                            })),
                            (C = e.idIndexer.getIndex({
                                id: A,
                                styleId: t.id,
                                layer: i,
                                sublayer: T[M.db_sublayer],
                                objectClass: T[M.db_object_class],
                                instanceId: 1,
                                metatile: v,
                                center: k,
                                floorId: S,
                            })));
                        const F =
                                null !== (I = T[M.db_point_building_id]) && void 0 !== I ? I : NaN,
                            O = e.buildingPointIndexer.getIndex(F),
                            D = {
                                type: u.R2.Point,
                                pointType: P,
                                geometryType: L,
                                styleId: t.id,
                                layerId: i.innerId,
                                sourceId: y,
                                tileCoords: g,
                                id: T[M.id],
                                identifyIndex: z,
                                identifyPoiLabelIndex: C,
                                labelingTextureIndex: O,
                                labelPriority: (0, u.hs)(T[M.db_label_priority], 0),
                                label2Priority: (0, u.hs)(T[M.db_label2_priority], 0),
                                iconPriority: (0, u.hs)(T[M.db_icon_priority], 0),
                                hovered: (0, u.hs)(T[M.hovered], 0),
                                componentDistanceStart: (0, u.hs)(T[M.componentDistanceStart], 0),
                                componentDistanceEnd: (0, u.hs)(T[M.componentDistanceEnd], 0),
                                objectLength: (0, u.hs)(T[M.objectLength], 0),
                                vertices: E,
                                demElevation: NaN,
                                tileData: (0, d.v$)([], i.dataKeys, _),
                            };
                        e.addLabel(D);
                    };
                },
                6263: (e, t, i) => {
                    i.d(t, { h: () => s });
                    var n = i(5600),
                        o = i(3698),
                        r = i(6273);
                    const s = (0, n.D)({
                        symbol: 'raster',
                        sinks: {
                            fill: {
                                stride: 8,
                                binder: (e, t) => {
                                    (e.views.position = new Uint16Array(t)),
                                        (e.views.txtrCoords = new Uint16Array(t, 4));
                                },
                                packObjectAttributes: (e, t, i) => [e, t, i],
                                unpackObjectAttributes: (e) => ({
                                    styleId: e[0],
                                    layerId: e[1],
                                    textureIndex: e[2],
                                    tileData: e.slice(3),
                                }),
                            },
                        },
                        generate(e, t, i, n, o) {
                            const r = t[0],
                                l = t[1],
                                c = e.getBucket(
                                    n.type,
                                    'fill',
                                    s.sinks.fill.packObjectAttributes(i, n.innerId, o),
                                    s.sinks.fill.binder,
                                );
                            let d = c.elements.offset;
                            !(function (e, t, i, n, o, r, s, a) {
                                const l = e.buffer,
                                    c = e.offset;
                                (l[c] = t + i),
                                    (l[c + 1] = t + n),
                                    (l[c + 2] = t + o),
                                    (l[c + 3] = t + r),
                                    (l[c + 4] = t + s),
                                    (l[c + 5] = t + a),
                                    (e.offset = c + 6);
                            })(c.indices, d, 0, 1, 2, 2, 1, 3),
                                a(c, d++, r[0], l[0], 0, 1),
                                a(c, d++, r[1], l[1], 1, 1),
                                a(c, d++, r[2], l[2], 0, 0),
                                a(c, d++, r[3], l[3], 1, 0),
                                (c.elements.offset = d);
                        },
                    });
                    function a(e, t, i, n, s, a) {
                        (t *= 4),
                            (e.views.position[t] = r.jO + i),
                            (e.views.position[t + 1] = r.jO + n),
                            (e.views.txtrCoords[t] = (0, o.Bb)(s)),
                            (e.views.txtrCoords[t + 1] = (0, o.Bb)(a));
                    }
                },
                6829: (e, t, i) => {
                    i.d(t, { Ie: () => z, tX: () => T });
                    var n = i(8194),
                        o = i(378),
                        r = i(5600),
                        s = i(6273),
                        a = i(2097),
                        l = i(6490),
                        c = i(6392),
                        d = i(9090),
                        h = i(9073),
                        u = i(3376),
                        m = i(143),
                        f = i(2539),
                        p = i(1573);
                    const _ = (0, l.Id)(5),
                        v = Math.PI / 180,
                        g = [0, 0, 0],
                        y = [0, 0, 0],
                        b = [0, 0, 0],
                        w = [0, 0, 0],
                        x = [0, 0, 0],
                        S = [0, 0, 0];
                    let I = 0,
                        M = 0;
                    const T = (0, r.D)({
                        symbol: 'roadPolygon',
                        sinks: {},
                        generate(e, t, i, n, o, r, s, l = 0, c = 0) {
                            var d;
                            n.tileAttrs[n.tileProps.drawLevel] =
                                null !== (d = (0, p.tp)(n.tileProps, n.tileAttrs)) && void 0 !== d
                                    ? d
                                    : 0;
                            const h = this.generateGeometry(r, o, n, l, c, i.style.debug);
                            null == h || h.forEach((o) => a.a.generate(e, t.id, i, n, z(o), s));
                        },
                        generateGeometry(e, t, i, n = 0, r = 0, a = !1) {
                            const l = t[0],
                                m = t[1],
                                f = l.length;
                            if (f < 2) return;
                            const p = (0, u.P)(i.tileAttrs[i.tileProps.tech_db_road_left_width], 0),
                                _ = (0, u.P)(i.tileAttrs[i.tileProps.tech_db_road_right_width], 0);
                            if (_ + p === 0) return;
                            const v = (0, c.Bs)(e);
                            o.t8(w, l[0], m[0]),
                                (n *= (0, c.iq)(v, w)),
                                o.t8(w, l[f - 1], m[f - 1]),
                                (r *= (0, c.iq)(v, w)),
                                o.t8(w, 0, 0);
                            const y = (0, c.iq)(v, w),
                                x = (s.Bq / (0, c.aq)(e[2])) * h.C * y,
                                S = ((p + _) * x) / 2,
                                M = 6 * x,
                                T = (function (e, t) {
                                    const i = [];
                                    (0, d.uI)(g, e[0], t[0], e[1], t[1]), (I = 0);
                                    for (let n = 1; n < e.length; n++) A(i, e, t, n);
                                    return i;
                                })(l, m),
                                z = L(l, m, T, -S);
                            let C = 0,
                                F = 0;
                            const D = L(l, m, T, S);
                            let R = 0,
                                j = 0,
                                B = 1,
                                N = 1;
                            const U = [],
                                Z = [];
                            if (!a) {
                                const e = [
                                        i.tileAttrs[i.tileProps.tech_db_road_end_rightmost_x],
                                        i.tileAttrs[i.tileProps.tech_db_road_end_rightmost_y],
                                    ],
                                    t = [
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_end_rightmost_left_width
                                        ],
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_end_rightmost_right_width
                                        ],
                                    ],
                                    n = [
                                        i.tileAttrs[i.tileProps.tech_db_road_end_leftmost_x],
                                        i.tileAttrs[i.tileProps.tech_db_road_end_leftmost_y],
                                    ],
                                    r = [
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_end_leftmost_left_width
                                        ],
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_end_leftmost_right_width
                                        ],
                                    ];
                                if (
                                    (Number.isNaN(e[0]) && (o.JG(e, n), o.JG(t, r)),
                                    Number.isNaN(n[0]) && (o.JG(n, e), o.JG(r, t)),
                                    o.t8(w, l[f - 1], m[f - 1]),
                                    o.t8(b, l[f - 2], m[f - 2]),
                                    o.lu(g, b, w),
                                    i.tileAttrs[i.tileProps.endingIsCut] &&
                                        (o.t8(
                                            n,
                                            i.tileAttrs[i.tileProps.nextPointX],
                                            i.tileAttrs[i.tileProps.nextPointY],
                                        ),
                                        o.lu(n, n, w),
                                        o.JG(e, n),
                                        o.t8(r, p, _),
                                        o.t8(t, p, _)),
                                    !Number.isNaN(e[0]))
                                ) {
                                    const i = ((t[0] + t[1]) * x) / 2;
                                    F = P(
                                        (0, d.Y6)(g, e),
                                        S,
                                        i,
                                        M,
                                        w,
                                        e,
                                        z.slice(z.length - 2).map((e) => e.slice()),
                                        !1,
                                        U,
                                    );
                                }
                                if (!Number.isNaN(n[0])) {
                                    const e = ((r[0] + r[1]) * x) / 2;
                                    j = P(
                                        -(0, d.Y6)(g, n),
                                        S,
                                        -e,
                                        M,
                                        w,
                                        n,
                                        D.slice(D.length - 2).map((e) => e.slice()),
                                        !1,
                                        U,
                                    );
                                }
                                const s = [
                                        i.tileAttrs[i.tileProps.tech_db_road_begin_rightmost_x],
                                        i.tileAttrs[i.tileProps.tech_db_road_begin_rightmost_y],
                                    ],
                                    a = [
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_begin_rightmost_left_width
                                        ],
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_begin_rightmost_right_width
                                        ],
                                    ],
                                    c = [
                                        i.tileAttrs[i.tileProps.tech_db_road_begin_leftmost_x],
                                        i.tileAttrs[i.tileProps.tech_db_road_begin_leftmost_y],
                                    ],
                                    h = [
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_begin_leftmost_left_width
                                        ],
                                        i.tileAttrs[
                                            i.tileProps.tech_db_road_begin_leftmost_right_width
                                        ],
                                    ];
                                if (
                                    (Number.isNaN(s[0]) && (o.JG(s, c), o.JG(a, h)),
                                    Number.isNaN(c[0]) && (o.JG(c, s), o.JG(h, a)),
                                    o.t8(w, l[0], m[0]),
                                    o.t8(b, l[1], m[1]),
                                    o.lu(g, b, w),
                                    i.tileAttrs[i.tileProps.beginningIsCut] &&
                                        (o.t8(
                                            c,
                                            i.tileAttrs[i.tileProps.previousPointX],
                                            i.tileAttrs[i.tileProps.previousPointY],
                                        ),
                                        o.lu(c, c, w),
                                        o.JG(s, c),
                                        o.t8(h, _, _),
                                        o.t8(a, _, _)),
                                    !Number.isNaN(s[0]))
                                ) {
                                    const e = ((a[0] + a[1]) * x) / 2;
                                    R = P(
                                        (0, d.Y6)(g, s),
                                        S,
                                        e,
                                        M,
                                        w,
                                        s,
                                        D.slice(0, 2).map((e) => e.slice()),
                                        !0,
                                        Z,
                                    );
                                }
                                if (!Number.isNaN(c[0])) {
                                    const e = ((h[0] + h[1]) * x) / 2;
                                    C = P(
                                        -(0, d.Y6)(g, c),
                                        S,
                                        -e,
                                        M,
                                        w,
                                        c,
                                        z.slice(0, 2).map((e) => e.slice()),
                                        !0,
                                        Z,
                                    );
                                }
                                (B = 0), (N = 0);
                            }
                            const H = E(z),
                                G = F + C + 4;
                            if (G > H) {
                                const e = H / G;
                                (F *= e), (C *= e);
                            }
                            F && k(z, F), C && k(z, C, !0);
                            const V = E(D),
                                W = j + R + 4;
                            if (W > V) {
                                const e = V / W;
                                (j *= e), (R *= e);
                            }
                            j && k(D, j),
                                R && k(D, R, !0),
                                Z.forEach((e) =>
                                    e.forEach((t, i) => {
                                        e[i][2] = n;
                                    }),
                                ),
                                U.forEach((e) =>
                                    e.forEach((t, i) => {
                                        e[i][2] = r;
                                    }),
                                ),
                                O(D, n, r),
                                D.forEach((e) => {
                                    (e[3] = 1), (e[4] = -1);
                                }),
                                O(z, n, r),
                                z.forEach((e) => {
                                    (e[3] = 1), (e[4] = 1);
                                });
                            const q = [l[0], m[0], n, 0, 0],
                                $ = [[l[f - 1], m[f - 1], r, 0, 0]].concat(D.reverse(), [q, q], z);
                            $.forEach((e) => {
                                e[3] = 1;
                            }),
                                ($[0][3] = N),
                                ($[D.length][3] = B),
                                ($[D.length + 1][3] = B),
                                ($[$.length - 1][3] = N);
                            const X = [$];
                            return X.push(...Z), X.push(...U), X;
                        },
                    });
                    function P(e, t, i, n, r, s, a, l, c) {
                        let h = 0;
                        const u = Math.abs(e);
                        t = Math.abs(t);
                        const m = Math.max(t, Math.abs(i)),
                            f = 1 - Math.min(t, Math.abs(i)) / m;
                        if ((Math.PI - u > v && u > v) || 0 !== f) {
                            const u = (function (e, t, i) {
                                const n = [0, 0, e[2]],
                                    r = [0, 0, e[2]];
                                o.IH(r, e, t);
                                const s = [];
                                return (
                                    o.Fv(s, t),
                                    (0, d.fN)(s, s),
                                    o.bA(s, s, i),
                                    o.IH(n, e, s),
                                    o.IH(r, r, s),
                                    [n, r]
                                );
                            })(r, s, -i);
                            if (e > 0) {
                                const o = n * (f + Math.min(1, Math.PI - e) / (Math.PI / 2));
                                let s = 0,
                                    d = 0;
                                if (
                                    (e > _ &&
                                        ((s += F(e, t, Math.abs(i))), (d += F(e, Math.abs(i), t))),
                                    s > 0)
                                ) {
                                    const e = E(a),
                                        t = E(u);
                                    if (s + o > e - 2 || d + o > t - 2)
                                        (h = Math.min(s, e - 2)),
                                            k(a, h, l),
                                            k(u, Math.min(d, t - 2), !0);
                                    else {
                                        (h = s + o), k(a, h, l), k(u, d + o, !0);
                                        const e = l ? a[1] : a[a.length - 2],
                                            t = l ? a[0] : a[a.length - 1],
                                            n = C(
                                                e.slice(),
                                                t.slice(),
                                                u[0].slice(),
                                                u[1].slice(),
                                                7,
                                                0.5,
                                            );
                                        if (n) {
                                            const e = n.length - 1,
                                                t = e + (e % 2);
                                            n.forEach((e) => {
                                                (e[3] = 1), (e[4] = 1);
                                            });
                                            for (let e = 0; e < t; e++)
                                                n.push(r.slice()), (n[n.length - 1][3] = 0);
                                            i > 0
                                                ? ((n[n.length - e - 1][3] = 0), c.push(n))
                                                : ((n[0][3] = 0), c.push(n.reverse()));
                                        }
                                    }
                                }
                            } else {
                                const e = n * f;
                                if (e > 0) {
                                    const t = E(a),
                                        i = E(u);
                                    (h = Math.min(e, t - 2)),
                                        k(a, h, l),
                                        k(u, Math.min(e, i - 2), !0);
                                }
                                const t = l ? a[1] : a[a.length - 2],
                                    o = l ? a[0] : a[a.length - 1],
                                    s = C(t.slice(), o.slice(), u[0], u[1], 5, 0.5);
                                s &&
                                    (s.push(r.slice()),
                                    s.forEach((e) => {
                                        (e[3] = 1), (e[4] = 1);
                                    }),
                                    (s[s.length - 1][3] = 0),
                                    (s[s.length - 1][4] = 0),
                                    i > 0
                                        ? ((s[s.length - 2][3] = 0), c.push(s))
                                        : ((s[0][3] = 0), c.push(s.reverse())));
                            }
                        }
                        return h;
                    }
                    function L(e, t, i, n) {
                        const o = [];
                        for (let r = 0; r < e.length; r++) {
                            const s = [e[r] + i[r][0][0] * n, t[r] + i[r][0][1] * n, 0, 0, 0];
                            o.push(s);
                        }
                        return (
                            (function (e) {
                                for (let t = 1, i = e.length; t < i - 2; t++) {
                                    const n = e[t - 1],
                                        o = e[t];
                                    for (let r = t; r < i - 2; r++) {
                                        const i = e[r + 1],
                                            s = e[r + 2],
                                            a = D(n[0], n[1], o[0], o[1], i[0], i[1], s[0], s[1]);
                                        if (a) {
                                            const i = r - t + 2;
                                            e.splice(t, i);
                                            for (let n = 0; n < i; n++) e.splice(t, 0, a.slice());
                                            t += i - 1;
                                        }
                                    }
                                }
                            })(o),
                            o
                        );
                    }
                    function k(e, t, i = !1) {
                        const n = e.length;
                        let r = 0;
                        for (let s = 0; s < n - 1; s++) {
                            const a = i ? s + 1 : n - 2 - s,
                                l = i ? s : n - 1 - s,
                                c = o.TK(e[a], e[l]);
                            if (!(t >= c)) {
                                t > 0 && o.t7(e[l], e[l], e[a], t / c);
                                break;
                            }
                            (t -= c), r++;
                        }
                        r && e.splice(i ? 0 : n - r, r);
                    }
                    function E(e) {
                        let t = 0;
                        for (let i = 0; i < e.length - 1; i++) t += o.TE(e[i], e[i + 1]);
                        return t;
                    }
                    function A(e, t, i, n) {
                        const r = n === t.length - 1;
                        if ((o.t8(b, t[n - 1], i[n - 1]), o.t8(w, t[n], i[n]), (0, d.fN)(S, g), r))
                            M = 0;
                        else {
                            o.t8(x, t[n + 1], i[n + 1]), (0, d.uI)(y, w[0], w[1], x[0], x[1]);
                            const e = (0, l.uZ)(o.AK(g, y), -1, 1),
                                r = Math.sqrt((1 - e) / (1 + e)),
                                s = (0, l.Xx)(o.AK(S, y));
                            M = r * s;
                        }
                        let s = S[0] + g[0] * I,
                            a = S[1] + g[1] * I;
                        e.push([
                            [s, a],
                            [-s, -a],
                        ]),
                            r &&
                                ((s = S[0] + g[0] * M),
                                (a = S[1] + g[1] * M),
                                e.push([
                                    [s, a],
                                    [-s, -a],
                                ])),
                            r || (o.JG(g, y), (I = M));
                    }
                    function z(e) {
                        var t;
                        const i = e.length,
                            n = [[], [], [], [], []];
                        for (let o = 0; o < i; o++) {
                            const r = (0, m.X)(o, i),
                                s = e[o];
                            (n[0][r] = s[0]),
                                (n[1][r] = s[1]),
                                (n[2][r] = s[3]),
                                (n[3][r] = s[2]),
                                (n[4][r] = null !== (t = s[4]) && void 0 !== t ? t : 0);
                        }
                        return n;
                    }
                    function C(e, t, i, r, s, a = 1) {
                        o.Fv(e, o.lu(e, t, e)),
                            o.IH(e, e, t),
                            o.Fv(r, o.lu(r, i, r)),
                            o.IH(r, r, i);
                        const l = n.Ue();
                        n.aM(l, e),
                            n.aM(l, t),
                            n.aM(l, i),
                            n.aM(l, r),
                            o.lu(e, e, l.min),
                            o.lu(t, t, l.min),
                            o.lu(i, i, l.min),
                            o.lu(r, r, l.min);
                        const c = (0, f.LX)(e, t, i, r, s, a);
                        return (
                            o.IH(e, e, l.min),
                            o.IH(t, t, l.min),
                            o.IH(i, i, l.min),
                            o.IH(r, r, l.min),
                            null == c || c.forEach((e) => o.IH(e, e, l.min)),
                            c
                        );
                    }
                    function F(e, t, i) {
                        if (0 === Math.abs(e % Math.PI)) return 0;
                        let n =
                            ((o = (i / t + Math.cos(e)) / Math.sin(e)), Math.PI / 2 - Math.atan(o));
                        var o;
                        return (
                            (n = Math.min(Math.PI / 2, n)),
                            (n = Math.max(e - Math.PI / 2, n)),
                            t / Math.tan(n)
                        );
                    }
                    function O(e, t, i) {
                        if (((e[0][2] = t), e.length > 1)) {
                            const n = E(e),
                                r = i - t;
                            let s = 0;
                            for (let i = 1; i < e.length; i++)
                                (s += o.TK(e[i - 1], e[i])), (e[i][2] = (s / n) * r + t);
                        }
                    }
                    function D(e, t, i, n, o, r, s, a) {
                        if ((e === i && t === n) || (o === s && r === a)) return;
                        const l = (a - r) * (i - e) - (s - o) * (n - t);
                        if (0 === l) return;
                        const c = ((s - o) * (t - r) - (a - r) * (e - o)) / l,
                            d = ((i - e) * (t - r) - (n - t) * (e - o)) / l;
                        return c < 0 || c > 1 || d < 0 || d > 1
                            ? void 0
                            : [e + c * (i - e), t + c * (n - t)];
                    }
                },
                4847: (e, t, i) => {
                    i.d(t, { g: () => s });
                    var n = i(7188),
                        o = i(6273),
                        r = i(6490);
                    class s {
                        constructor() {
                            (this.dictionaries = {}),
                                (this.reverseDictionaries = {}),
                                (this.version = ''),
                                (this.defaultProps = {}),
                                (this.tileProps = n.Dz),
                                (this.tilePropsByIndex = (0, r.l4)(n.Dz)),
                                (this.hash = o.DL);
                        }
                    }
                },
                4288: (e, t, i) => {
                    i.d(t, { r: () => u });
                    var n = i(462),
                        o = i(4635),
                        r = i(6392);
                    function s(e) {
                        const t = e.currentMod;
                        return void 0 !== t && t.ready;
                    }
                    function a(e, t) {
                        const i = e.currentMod;
                        return void 0 !== i && void 0 !== t[i.key];
                    }
                    function l(e, t) {
                        const i = t.currentMod;
                        void 0 !== i && (e[i.key] = i);
                    }
                    function c(e, t) {
                        const i = t.currentMod;
                        void 0 !== i && delete e[i.key];
                    }
                    function d(e, t, i) {
                        for (const n of t) {
                            const t = (0, r.aM)(i, n);
                            for (const i of t) c(e, i);
                        }
                    }
                    var h = i(9833);
                    function u(e, t, i) {
                        m(e, t, i), f(e), p(e);
                        for (const t in e.displayedMods) e.tileModsCache.get(t);
                        _(e), v(e);
                    }
                    function m(e, t, i) {
                        for (const n in e.tiles) (0, h.qC)(e.tiles[n], e.tileModsCache, t, i);
                    }
                    function f(e) {
                        switch (e.tilesAppearance) {
                            case n.W.ByOne:
                                (0, o.TQ)(e);
                                break;
                            case n.W.WaitingLayer:
                                (0, o.ej)(e.tiles, e.viewportTiles) &&
                                    ((e.tilesAppearance = n.W.ByOne), (0, o.TQ)(e));
                            case n.W.GlobalWaiting:
                        }
                    }
                    function p(e) {
                        const {
                            tiles: t,
                            viewportTiles: i,
                            zoomDirection: o,
                            zoomStartZoom: c,
                            maxZoomLevel: h,
                            zoomLevel: u,
                            displayedMods: m,
                        } = e;
                        switch (o) {
                            case n.Y.Stationary:
                                e.displayedMods = (function (e, t) {
                                    const i = {};
                                    for (const n of t) {
                                        const t = e[n];
                                        s(t) && l(i, t);
                                    }
                                    return i;
                                })(t, i);
                                break;
                            case n.Y.ZoomingIn:
                                e.displayedMods = (function (e, t, i, n, o) {
                                    const c = {},
                                        h = [];
                                    for (const d of t) {
                                        const t = e[d];
                                        if (s(t)) l(c, t);
                                        else
                                            for (let d = t.detailLevel - 1; d >= n; d--) {
                                                const n = (0, r.xG)(e, t, d, o);
                                                if (
                                                    void 0 !== n &&
                                                    !h.includes(n) &&
                                                    s(n) &&
                                                    a(n, i)
                                                ) {
                                                    l(c, n), h.push(n);
                                                    break;
                                                }
                                            }
                                    }
                                    return d(c, h, e), c;
                                })(t, i, m, c, h);
                                break;
                            case n.Y.ZoomingOut:
                                e.displayedMods = (function (e, t, i, n, o, c) {
                                    const h = {},
                                        u = [],
                                        m = new Set(t);
                                    for (const t in e) {
                                        const d = e[t];
                                        m.has(d.key)
                                            ? s(d) && (l(h, d), u.push(d))
                                            : d.detailLevel > o ||
                                              d.detailLevel < n ||
                                              (m.has((0, r.pV)(d, n, c)) &&
                                                  s(d) &&
                                                  a(d, i) &&
                                                  (l(h, d), d.detailLevel < o && u.push(d)));
                                    }
                                    return d(h, u, e), h;
                                })(t, i, m, u, c, h);
                        }
                    }
                    function _({ tiles: e, displayedMods: t, viewportTiles: i }) {
                        for (const n in e) {
                            if (i.includes(n)) continue;
                            const o = e[n],
                                r = o.currentMod;
                            r && !t[r.key] && (0, h.U9)(o);
                        }
                    }
                    function v(e) {
                        switch (e.zoomDirection) {
                            case n.Y.ZoomingIn:
                                (e.zoomLevel <= e.zoomStartZoom || g(e)) &&
                                    ((e.zoomDirection = n.Y.Stationary),
                                    (e.zoomStartZoom = e.zoomLevel));
                                break;
                            case n.Y.ZoomingOut:
                                (e.zoomLevel >= e.zoomStartZoom || g(e)) &&
                                    ((e.zoomDirection = n.Y.Stationary),
                                    (e.zoomStartZoom = e.zoomLevel));
                        }
                    }
                    function g(e) {
                        const { tiles: t, viewportTiles: i, displayedMods: n } = e;
                        for (let e = 0; e < i.length; e++) {
                            const o = t[i[e]],
                                r = (0, h.hW)(o);
                            if (!r) return !1;
                            if (void 0 === n[r.key]) return !1;
                        }
                        return !0;
                    }
                },
                1285: (e, t, i) => {
                    i.d(t, { I2: () => c, TZ: () => l, YY: () => s, bj: () => a, cA: () => d });
                    var n = i(462),
                        o = i(4635),
                        r = i(9833);
                    function s(e, t, i, s) {
                        var a;
                        (i.selectedIds = s), (i.tilesAppearance = n.W.WaitingLayer), (0, o.eh)(i);
                        for (const n in i.tiles) {
                            const o = i.tiles[n];
                            (0, r.IF)(
                                e,
                                t,
                                o,
                                i.sourceId,
                                null === (a = o.hover) || void 0 === a ? void 0 : a.id,
                                !0,
                            );
                        }
                    }
                    function a(e, t, i, n) {
                        if (!t.disableHoverStyles) {
                            for (const o in i.tiles) {
                                const s = i.tiles[o];
                                (0, r.IF)(e, t, s, i.sourceId, n);
                            }
                            e.labeler.disableThrottleUpdateOnce();
                        }
                    }
                    function l(e, t) {
                        (e.styleState = t), (0, o.eh)(e);
                    }
                    function c(e, t, i, r) {
                        (e.tilesAppearance = r ? n.W.ByOne : n.W.GlobalWaiting),
                            (e.styleId = t),
                            (e.styleRevision = i),
                            (0, o.eh)(e);
                    }
                    function d(e) {
                        (e.tilesAppearance = n.W.ByOne), (0, o.TQ)(e);
                    }
                },
                9311: (e, t, i) => {
                    i.d(t, { o: () => l });
                    var n = i(462),
                        o = i(6490),
                        r = i(6392),
                        s = i(9218),
                        a = i(4635);
                    function l(e, t) {
                        c(e, t.styleZoom, t.zoom), d(e, t), h(e), (0, a.eh)(e);
                    }
                    function c(e, t, i) {
                        const o = (0, a.uk)(e.type, i, t),
                            r = o - e.zoomLevel;
                        e.zoomDirection === n.Y.Stationary &&
                            (r > 0
                                ? ((e.zoomDirection = n.Y.ZoomingIn),
                                  (e.zoomStartZoom = e.zoomLevel))
                                : r < 0 &&
                                  ((e.zoomDirection = n.Y.ZoomingOut),
                                  (e.zoomStartZoom = e.zoomLevel))),
                            (e.zoomLevel = o);
                    }
                    function d(e, t) {
                        if (e.zoomLevel < e.minZoomLevel) return void (e.viewportTiles = []);
                        const i = (0, o.uZ)(e.zoomLevel, e.minZoomLevel, e.maxZoomLevel),
                            n = (0, o.uZ)(e.zoomLevel, e.minDetailLevel, e.maxDetailLevel);
                        e.viewportTiles = (0, r.b5)(t, i, e.minZoomLevel, n).map(r.gx);
                    }
                    function h(e) {
                        const t = Math.round(
                            (Object.keys(e.displayedMods).length + e.viewportTiles.length) *
                                s.tiles.cacheRatio,
                        );
                        e.tileModsCacheMaxCount < t && (e.tileModsCacheMaxCount = t),
                            t > e.tileModsCacheMaxCount / 2 && e.tileModsCache.setSize(t);
                    }
                },
                4635: (e, t, i) => {
                    i.d(t, {
                        HM: () => _,
                        TQ: () => w,
                        aq: () => b,
                        d1: () => y,
                        e: () => p,
                        eh: () => h,
                        ej: () => u,
                        lH: () => f,
                        uk: () => g,
                        w1: () => m,
                        y7: () => v,
                    });
                    var n = i(6490),
                        o = i(9833),
                        r = i(6392),
                        s = i(3429),
                        a = i(462),
                        l = i(1683),
                        c = i(9218),
                        d = i(647);
                    function h(e) {
                        const t = e.viewportTiles;
                        for (const t in e.tiles) (0, o.bt)(e.tiles[t]);
                        for (let i = 0; i < t.length; i++) {
                            const n = t[i];
                            let s = e.tiles[n];
                            s ||
                                (s = e.tiles[n] =
                                    (0, o.Tp)(e.type, (0, r.cL)(n), e.sourceId, e.tileLayerId));
                            const a = new d.l(
                                e.selectedIds,
                                e.styleState,
                                s.revision,
                                e.styleId,
                                e.styleRevision,
                            );
                            (0, o.a7)(s, a, e.tileModsCache);
                        }
                    }
                    function u(e, t) {
                        for (let i = 0; i < t.length; i++) {
                            const n = e[t[i]],
                                r = (0, o.hW)(n);
                            if (!r || !r.ready) return !1;
                        }
                        return !0;
                    }
                    function m(e) {
                        const t = [];
                        for (const i in e.tiles) {
                            const n = e.tiles[i];
                            n.needFetch && ((n.needFetch = !1), t.push(n));
                        }
                        return t;
                    }
                    function f(e) {
                        const t = [];
                        for (const i in e.tiles) {
                            const n = e.tiles[i];
                            n.needAbortFetch && ((n.needAbortFetch = !1), t.push(n));
                        }
                        return t;
                    }
                    function p(e) {
                        const t = [];
                        for (const i in e.tiles) {
                            const n = e.tiles[i];
                            n.needGenerate && ((n.needGenerate = !1), t.push(n));
                        }
                        return t;
                    }
                    function _(e) {
                        const t = new Set(e.viewportTiles),
                            i = new Set(e.tileModsCache.getData().map((e) => e.tile)),
                            n = [];
                        for (const r in e.tiles) {
                            const s = e.tiles[r];
                            !(0, o.LC)(s) ||
                                t.has(r) ||
                                e.zoomDirection !== a.Y.Stationary ||
                                i.has(s) ||
                                n.push(s);
                        }
                        return n;
                    }
                    function v(e, t, i, n, o, r, c, d, h) {
                        const u = d.styleManager.getStyle(h.handyStyleId);
                        return {
                            type: e,
                            sourceId: t,
                            tileLayerId: i,
                            styleId: h.handyStyleId,
                            styleRevision: (null == u ? void 0 : u.id) || 0,
                            styleState: h.styleState,
                            minZoomLevel: n,
                            maxZoomLevel: o,
                            minDetailLevel: r,
                            maxDetailLevel: c,
                            tiles: {},
                            viewportTiles: [],
                            zoomLevel: g(e, h.zoom, h.styleZoom),
                            zoomDirection: a.Y.Stationary,
                            zoomStartZoom: 0,
                            tileModsCache: new s.L(0, (e, t) => {
                                d.labeler.removeLabels(t.labelsKey), (0, l.Bp)(t, h);
                            }),
                            tileModsCacheMaxCount: 0,
                            selectedIds: [],
                            displayedMods: {},
                            tilesAppearance: a.W.ByOne,
                            mapState: h,
                            stopLabelAnimation: !1,
                        };
                    }
                    function g(e, t, i) {
                        return 'raster' === e ? Math.round(t) : Math.floor(i);
                    }
                    function y(e) {
                        for (const t in e.tiles) (0, o.QT)(e.tiles[t], e.mapState);
                        (e.tiles = {}),
                            (e.viewportTiles = []),
                            (e.zoomDirection = a.Y.Stationary),
                            e.tileModsCache.reset(),
                            (e.displayedMods = {}),
                            (e.tilesAppearance = a.W.ByOne);
                    }
                    function b(e, t, i, o) {
                        const s = i.displayedMods,
                            a = (0, n.$X)(s, o);
                        a.forEach((i) => {
                            if (void 0 !== i.objects) {
                                let n = !0;
                                for (const e in o)
                                    if ((0, r.HL)(i.tile, o[e].tile)) {
                                        n = !1;
                                        break;
                                    }
                                i.objects.forEach((i) => {
                                    e.addObject(i),
                                        n &&
                                            i.startTicker(
                                                t,
                                                c.tileAnimation.type,
                                                c.tileAnimation.time,
                                                0,
                                                1,
                                            );
                                });
                            }
                        });
                        const l = (0, n.$X)(o, s);
                        l.forEach((t) => {
                            var i;
                            void 0 !== t.objects &&
                                (t.objects.forEach((t) => {
                                    e.removeObject(t);
                                }),
                                null === (i = t.tile.hover) ||
                                    void 0 === i ||
                                    i.tileObjects.forEach((t) => e.removeObject(t)));
                        });
                        const d = a.length > 0 || l.length > 0;
                        return d && ((t.needLabeling = !0), (t.needRerender = !0)), d;
                    }
                    function w(e) {
                        e.viewportTiles.forEach((t) => (0, o.bg)(e.tiles[t]));
                    }
                },
                9833: (e, t, i) => {
                    i.d(t, {
                        IF: () => m,
                        LC: () => _,
                        NQ: () => T,
                        QT: () => v,
                        Tp: () => u,
                        U9: () => g,
                        _v: () => p,
                        a7: () => w,
                        b9: () => M,
                        bg: () => I,
                        bt: () => b,
                        hW: () => y,
                        k$: () => L,
                        nR: () => P,
                        qC: () => S,
                        z3: () => n,
                    });
                    var n,
                        o = i(7204),
                        r = i(1683),
                        s = i(6392),
                        a = i(3672),
                        l = i(363),
                        c = i(9218),
                        d = i(647),
                        h = i(2153);
                    function u(e, t, i, o) {
                        return {
                            type: e,
                            sourceId: i,
                            key: (0, s.gx)(t),
                            labelsKey: `${e}_${i}_${o}`,
                            coords: t,
                            zoomLevel: t[2],
                            detailLevel: t[3],
                            needFetch: !1,
                            revision: 0,
                            needAbortFetch: !1,
                            needGenerate: !1,
                            status: n.Initial,
                            oldHoverTileObjects: [],
                        };
                    }
                    function m(e, t, i, n, o, r) {
                        const s = [];
                        i.oldHoverTileObjects.forEach((i) => {
                            i.tickerFinished(t)
                                ? (e.tileManager.removeObject(i), i.clean(t))
                                : s.push(i);
                        }),
                            (i.oldHoverTileObjects = s),
                            void 0 !== o
                                ? t.performanceCaveatEmitted ||
                                  ((r || !i.hover || (0, a.v7)(i.hover.id, o)) &&
                                      (function (e, t, i, n, o) {
                                          if (
                                              !i.idSet ||
                                              !i.idSet.has(n) ||
                                              !(function (e, t) {
                                                  const i = Math.min(
                                                          Math.floor(e.styleZoom),
                                                          c.tiles.maxDetailLevel,
                                                      ),
                                                      n = t.coords[3];
                                                  return i === n;
                                              })(t, i)
                                          )
                                              return void f(e, i, t);
                                          (function (e, t, i, n) {
                                              const o = t.newMod || t.currentMod,
                                                  r =
                                                      (null == o
                                                          ? void 0
                                                          : o.params.getSelectedIds()) || [],
                                                  s = e.map.state;
                                              return e.defaultSource.generateHoverTile(
                                                  s,
                                                  t.coords,
                                                  s.handyStyleId,
                                                  r,
                                                  self.devicePixelRatio,
                                                  {},
                                                  i,
                                                  n,
                                              );
                                          })(e, i, n, o).then((o) => {
                                              f(e, i, t);
                                              const r = {
                                                      id: n,
                                                      tileObjects: [],
                                                      generatedData: [],
                                                  },
                                                  s = [];
                                              o.results.forEach((n) => {
                                                  const o = new l.W(
                                                          'hover',
                                                          n.collectorOutput.data,
                                                          e.renderer,
                                                          i.coords,
                                                      ),
                                                      { packedRasters: a, rastersToLoad: d } =
                                                          n.collectorOutput;
                                                  void 0 !== a &&
                                                      e.assetManager.prepareRasters(n.styleId, a),
                                                      e.assetManager.loadRasters(d),
                                                      r.tileObjects.push(o),
                                                      e.tileManager.addObject(o),
                                                      o.startTicker(
                                                          t,
                                                          c.houseHover.inAnimationType,
                                                          c.houseHover.inAnimationTime,
                                                          0,
                                                          1,
                                                      ),
                                                      n.collectorOutput.labels.length &&
                                                          s.push({
                                                              metatileHash: n.metatileHash,
                                                              labels: n.collectorOutput.labels,
                                                              styleId: n.styleId,
                                                          });
                                              }),
                                                  (r.generatedData = o.results),
                                                  e.labeler.addLabels('label_hover', h.AL.Tile, s),
                                                  e.identifier.debouncedFillCache(),
                                                  (i.hover = r);
                                          });
                                      })(e, t, i, o, n))
                                : f(e, i, t);
                    }
                    function f(e, t, i) {
                        t.hover &&
                            (t.hover.tileObjects.forEach((e) => {
                                t.oldHoverTileObjects.push(e),
                                    e.startTicker(
                                        i,
                                        c.houseHover.outAnimationType,
                                        c.houseHover.outAnimationTime,
                                        1,
                                        0,
                                    );
                            }),
                            (t.hover = void 0),
                            e.labeler.removeLabels('label_hover'),
                            e.identifier.debouncedFillCache());
                    }
                    function p(e) {
                        if (e.newMod && e.newMod.needGenerate)
                            return (e.newMod.needGenerate = !1), e.newMod;
                    }
                    function _(e) {
                        return (
                            (!e.currentMod || (0, r.jW)(e.currentMod)) &&
                            (!e.newMod || (0, r.jW)(e.newMod))
                        );
                    }
                    function v(e, t) {
                        e.currentMod && (0, r.Bp)(e.currentMod, t),
                            e.newMod && (0, r.Bp)(e.newMod, t);
                    }
                    function g(e) {
                        e.currentMod = void 0;
                    }
                    function y(e) {
                        return e.currentMod && e.currentMod.useful
                            ? e.currentMod
                            : e.newMod && e.newMod.useful
                            ? e.newMod
                            : void 0;
                    }
                    function b(e) {
                        e.currentMod && (e.currentMod.useful = !1),
                            e.newMod && (e.newMod.useful = !1);
                    }
                    function w(e, t, i) {
                        if ((e.idSet && t.setTileIds(e.idSet), e.currentMod || e.newMod)) {
                            if (e.currentMod) {
                                if (d.l.equal(e.currentMod.params, t))
                                    return (e.currentMod.useful = !0), void (e.newMod = void 0);
                            }
                            if (e.newMod) {
                                d.l.equal(e.newMod.params, t) ? (e.newMod.useful = !0) : x(e, t, i);
                            } else x(e, t, i);
                        } else x(e, t, i);
                    }
                    function x(e, t, i) {
                        const n = (0, s.vl)(e.coords, t),
                            o = i.get(n);
                        o
                            ? ((e.newMod = o), (e.newMod.useful = !0))
                            : ((e.newMod = (0, r.es)(e, n, t)),
                              e.idSet && e.newMod.params.setTileIds(e.idSet));
                    }
                    function S(e, t, i, o) {
                        switch (e.status) {
                            case n.Initial:
                                e.newMod &&
                                    e.newMod.useful &&
                                    ((e.status = n.Loading), (e.needFetch = !0));
                                break;
                            case n.Loading:
                                e.newMod && e.newMod.useful
                                    ? e.serverMetadata && (e.status = n.Loaded)
                                    : ((e.status = n.Initial), (e.needAbortFetch = !0));
                            case n.Loaded:
                        }
                        e.currentMod && (0, r.zL)(e.currentMod, t, i, o),
                            e.newMod &&
                                ((0, r.zL)(e.newMod, t, i, o),
                                e.newMod.needGenerate && (e.needGenerate = !0));
                    }
                    function I(e) {
                        e.newMod &&
                            e.newMod.ready &&
                            ((e.currentMod = e.newMod), (e.newMod = void 0));
                    }
                    function M(e) {
                        const t = new o.c();
                        return (
                            e.forEach((e) => {
                                t.addFromFlatArray(e.collectorOutput.geoIds);
                            }),
                            t
                        );
                    }
                    function T(e) {
                        e.status === n.Loading && (e.needAbortFetch = !0),
                            (e.status = n.Initial),
                            (e.serverMetadata = void 0),
                            e.revision++;
                    }
                    function P(e) {
                        e.revision++;
                    }
                    function L(e, t) {
                        var i;
                        (null === (i = e.idSet) || void 0 === i ? void 0 : i.hasSome(t)) &&
                            e.revision++;
                    }
                    !(function (e) {
                        (e[(e.Initial = 0)] = 'Initial'),
                            (e[(e.Loading = 1)] = 'Loading'),
                            (e[(e.Loaded = 2)] = 'Loaded');
                    })(n || (n = {}));
                },
                3338: (e, t, i) => {
                    i.d(t, { I: () => v });
                    var n = i(6392),
                        o = i(9311),
                        r = i(9833),
                        s = i(1683),
                        a = i(4245),
                        l = i(2153),
                        c = i(4635),
                        d = i(4288),
                        h = i(1285),
                        u = i(462);
                    function m(e) {
                        (e.tilesAppearance = u.W.WaitingLayer),
                            (e.stopLabelAnimation = !0),
                            Object.keys(e.tiles).forEach((t) => {
                                (0, r.NQ)(e.tiles[t]);
                            }),
                            (0, c.eh)(e);
                    }
                    var f = i(6874);
                    function p(e) {
                        (e.tilesAppearance = u.W.WaitingLayer),
                            Object.keys(e.tiles).forEach((t) => {
                                (0, r.nR)(e.tiles[t]);
                            }),
                            (0, c.eh)(e);
                    }
                    function _(e, t) {
                        (e.tilesAppearance = u.W.WaitingLayer),
                            Object.keys(e.tiles).forEach((i) => {
                                (0, r.k$)(e.tiles[i], t);
                            }),
                            (0, c.eh)(e);
                    }
                    class v {
                        constructor(e, t, i, n, o, r, s) {
                            (this.disabledRegions = null),
                                (this.isGenerating = !1),
                                (this.tilesGenerationQueue = []),
                                (this.modules = o),
                                (this.mapState = r),
                                (this.prevStyleState = r.styleState),
                                (this.sourceCore = s),
                                (this.id = (0, f.f)()),
                                (this.gridState = (0, c.y7)(
                                    s.type,
                                    s.id,
                                    this.id,
                                    e,
                                    t,
                                    i,
                                    n,
                                    o,
                                    this.mapState,
                                ));
                        }
                        destroy() {
                            (0, c.d1)(this.gridState);
                        }
                        redraw() {
                            (0, c.d1)(this.gridState), (0, o.o)(this.gridState, this.mapState);
                        }
                        getDisplayedIdentifyData() {
                            var e, t;
                            const i = [];
                            for (const n in this.gridState.displayedMods) {
                                const o = this.gridState.displayedMods[n];
                                null === (e = o.generatedData) ||
                                    void 0 === e ||
                                    e
                                        .concat(
                                            (null === (t = o.tile.hover) || void 0 === t
                                                ? void 0
                                                : t.generatedData) || [],
                                        )
                                        .forEach((e) =>
                                            i.push({
                                                ids: e.collectorOutput.identifyIds,
                                                metatileHash: e.metatileHash,
                                                sourceId: o.tile.sourceId,
                                                tileKey: o.tile.key,
                                            }),
                                        );
                            }
                            return i;
                        }
                        getLabelingData() {
                            const e = {
                                sourceId: this.gridState.sourceId,
                                animate: !this.gridState.stopLabelAnimation,
                                labelsKeys: [],
                            };
                            for (const t in this.gridState.displayedMods) {
                                const i = this.gridState.displayedMods[t];
                                e.labelsKeys.push(i.labelsKey);
                            }
                            return (
                                this.gridState.stopLabelAnimation &&
                                    this.viewportTilesReady() &&
                                    (this.gridState.stopLabelAnimation = !1),
                                e
                            );
                        }
                        getViewportTiles() {
                            const e = [],
                                t = this.gridState.viewportTiles;
                            for (let i = 0; i < t.length; i++) {
                                const n = this.gridState.tiles[t[i]];
                                n && e.push(n);
                            }
                            return e;
                        }
                        viewportTilesReady() {
                            return (0, c.ej)(this.gridState.tiles, this.gridState.viewportTiles);
                        }
                        displayedTilesAnimationFinished() {
                            for (const e in this.gridState.displayedMods) {
                                const t = this.gridState.displayedMods[e];
                                if (t.objects)
                                    for (const e of t.objects)
                                        if (!e.tickerFinished(this.mapState)) return !1;
                            }
                            return !0;
                        }
                        activateStyleUpdating() {
                            (0, h.I2)(
                                this.gridState,
                                this.mapState.handyStyleId,
                                this.modules.styleManager.getStyleRevision(
                                    this.mapState.handyStyleId,
                                ),
                                this.modules.map.core.getIsFirstStyleUpdate(),
                            );
                        }
                        finishStyleUpdating() {
                            (0, h.cA)(this.gridState);
                        }
                        setSelectedIds() {
                            (0, h.YY)(
                                this.modules,
                                this.mapState,
                                this.gridState,
                                this.mapState.selectedIds,
                            );
                        }
                        setHoverId(e) {
                            (0, h.bj)(this.modules, this.mapState, this.gridState, e);
                        }
                        resetHoverId() {
                            (0, h.bj)(this.modules, this.mapState, this.gridState);
                        }
                        onSourceDataChange() {
                            m(this.gridState);
                        }
                        onFeatureStateMapChange() {
                            p(this.gridState);
                        }
                        onHiddenBuildingsChange(e) {
                            _(this.gridState, e);
                        }
                        getTileCount() {
                            let e = 0;
                            for (const t in this.gridState.displayedMods) {
                                const i = this.gridState.displayedMods[t].objects;
                                void 0 !== i && (e += i.length);
                            }
                            return e;
                        }
                        isBlank() {
                            for (const e of this.gridState.viewportTiles) {
                                const t = this.gridState.tiles[e],
                                    { serverMetadata: i } = t;
                                if (void 0 === i || 0 === i.length) continue;
                                const n = (0, r.hW)(t);
                                if (n && n.ready) return !1;
                            }
                            return !0;
                        }
                        updateViewport() {
                            (0, o.o)(this.gridState, this.mapState);
                        }
                        update() {
                            const e = Object.assign({}, this.gridState.displayedMods);
                            this.mapState.styleState !== this.prevStyleState &&
                                (0, h.TZ)(this.gridState, this.mapState.styleState),
                                (0, d.r)(this.gridState, this.mapState, this.modules);
                            const { demManager: t, labeler: i } = this.modules;
                            !(function (e, t, i) {
                                for (const n of e.viewportTiles) {
                                    const o = e.tiles[n],
                                        a = (0, r.hW)(o);
                                    if (!a) continue;
                                    const c = (0, s.Hd)(a);
                                    if (0 === c.length) continue;
                                    const d = t.getLabelsDemKey(c);
                                    a.demKey !== d &&
                                        ((a.demKey = d),
                                        i.addTileLabels(a.labelsKey, l.AL.Tile, c));
                                }
                            })(this.gridState, t, i),
                                this.fetch((0, c.w1)(this.gridState)),
                                this.abortFetch((0, c.lH)(this.gridState)),
                                this.generate((0, c.e)(this.gridState)),
                                this.clearTiles((0, c.HM)(this.gridState)),
                                (0, c.aq)(
                                    this.modules.tileManager,
                                    this.mapState,
                                    this.gridState,
                                    e,
                                );
                        }
                        fetch(e) {
                            e.sort((e, t) => (0, n.qu)(this.mapState.center, e, t)).forEach((e) => {
                                this.sourceCore.fetchTile(e.coords, this.mapState).then((t) => {
                                    e.status === r.z3.Loading && (e.serverMetadata = t);
                                });
                            });
                        }
                        abortFetch(e) {
                            e.forEach((e) => this.sourceCore.abortTileFetch(e.coords));
                        }
                        updateGenerationQueue() {
                            if (this.isGenerating) return;
                            const e = this.getTileToGenerate();
                            if (!e) return;
                            this.isGenerating = !0;
                            const { tile: t, mod: i } = e,
                                n = {
                                    tileCoords: t.coords,
                                    selectedIds: i.params.getSelectedIds(),
                                    styleId: i.params.styleId,
                                },
                                o = this.disabledRegions,
                                c = { areTileBoundsVisible: this.mapState.showDefaultTileBounds };
                            this.sourceCore
                                .generateTile(
                                    this.mapState,
                                    n.tileCoords,
                                    n.styleId,
                                    n.selectedIds,
                                    devicePixelRatio,
                                    c,
                                )
                                .then((e) => {
                                    let { results: n } = e;
                                    o && (n = n.filter((e) => !o.includes(e.regionId))),
                                        n.forEach((e) => {
                                            const {
                                                    styleId: t,
                                                    metatileHash: i,
                                                    regionId: n,
                                                    collectorOutput: o,
                                                } = e,
                                                {
                                                    packedRasters: r,
                                                    rastersToLoad: s,
                                                    floorHidingMap: l,
                                                    modelsToLoad: c,
                                                } = o;
                                            void 0 !== r &&
                                                this.modules.assetManager.prepareRasters(t, r),
                                                c.forEach((e) =>
                                                    this.modules.assetManager.addModel(e),
                                                ),
                                                this.modules.assetManager.loadRasters(s),
                                                this.modules.floorManager.prepareFloors(
                                                    n,
                                                    i,
                                                    new a.g(l),
                                                    this.sourceCore.type,
                                                );
                                        }),
                                        (t.idSet = (0, r.b9)(n)),
                                        (0, s.aK)(i, n, t.idSet),
                                        this.modules.labeler.addTileLabels(
                                            i.labelsKey,
                                            l.AL.Tile,
                                            (0, s.Hd)(i),
                                        );
                                })
                                .finally(() => {
                                    (this.isGenerating = !1), this.updateGenerationQueue();
                                });
                        }
                        getTileToGenerate() {
                            this.tilesGenerationQueue.sort((e, t) =>
                                (0, n.qu)(this.mapState.center, e, t),
                            );
                            let e = this.tilesGenerationQueue.shift();
                            for (; e; ) {
                                const t = (0, r._v)(e);
                                if (t) {
                                    if (t.useful) return { mod: t, tile: e };
                                    e.newMod = void 0;
                                }
                                e = this.tilesGenerationQueue.shift();
                            }
                            return null;
                        }
                        addTileToGenerationQueue(e) {
                            this.tilesGenerationQueue.push(e), this.updateGenerationQueue();
                        }
                        generate(e) {
                            e.sort((e, t) => (0, n.qu)(this.mapState.center, e, t)).forEach((e) => {
                                var t;
                                (null === (t = e.newMod) || void 0 === t
                                    ? void 0
                                    : t.needGenerate) &&
                                    !this.tilesGenerationQueue.includes(e) &&
                                    this.addTileToGenerationQueue(e);
                            });
                        }
                        clearTiles(e) {
                            for (const t of e)
                                this.sourceCore.deleteTile(t.coords),
                                    delete this.gridState.tiles[t.key];
                        }
                    }
                },
                1683: (e, t, i) => {
                    i.d(t, {
                        Bp: () => c,
                        Hd: () => l,
                        aK: () => a,
                        es: () => s,
                        jW: () => d,
                        zL: () => h,
                    });
                    var n,
                        o = i(363),
                        r = i(9218);
                    function s(e, t, i) {
                        return {
                            key: t,
                            labelsKey: `${e.labelsKey}_${t}`,
                            useful: !0,
                            ready: !1,
                            needGenerate: !1,
                            tile: e,
                            status: n.Initial,
                            params: i.clone(),
                        };
                    }
                    function a(e, t, i) {
                        (e.generatedData = t), i && e.params.setTileIds(i);
                    }
                    function l(e) {
                        const t = e.generatedData,
                            i = [];
                        if (!t) return i;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            n.collectorOutput.labels &&
                                i.push({
                                    metatileHash: n.metatileHash,
                                    labels: n.collectorOutput.labels,
                                    styleId: n.styleId,
                                });
                        }
                        return i;
                    }
                    function c(e, t) {
                        (e.status = n.Initial),
                            (e.generatedData = void 0),
                            void 0 !== e.objects && e.objects.forEach((e) => e.clean(t)),
                            (e.objects = void 0),
                            (e.ready = !1),
                            e.tile.currentMod === e && (e.tile.currentMod = void 0);
                    }
                    function d(e) {
                        return e.status === n.Initial;
                    }
                    function h(e, t, i, s) {
                        const { renderer: a } = s;
                        switch (e.status) {
                            case n.Initial:
                                e.useful && (e.status = n.Loading);
                                break;
                            case n.Loading:
                                e.useful
                                    ? e.tile.serverMetadata && (e.status = n.Loaded)
                                    : (e.status = n.Initial);
                                break;
                            case n.Loaded:
                                (function (e, t, i) {
                                    switch (e.tile.type) {
                                        case 'zenith':
                                            return Boolean(
                                                e.useful &&
                                                    e.tile.serverMetadata &&
                                                    (function (e, t, i) {
                                                        const { assetManager: n, modelLayer: o } =
                                                            i;
                                                        for (let i = 0; i < e.length; i++) {
                                                            const { regionId: s, metatileHash: a } =
                                                                e[i];
                                                            if (
                                                                !n.getMetatile(a) ||
                                                                (t.styleZoom >
                                                                    r.loadModelsInfoStyleZoom &&
                                                                    !o.isModelsInfoLoaded(s))
                                                            )
                                                                return !1;
                                                        }
                                                        return !0;
                                                    })(e.tile.serverMetadata, t, i),
                                            );
                                        case 'traffic':
                                            return Boolean(e.useful && e.tile.serverMetadata);
                                        case 'raster':
                                        case 'geojson':
                                        case 'dem':
                                            return Boolean(e.useful);
                                        default:
                                            return !1;
                                    }
                                })(e, i, s) &&
                                    ((e.status = n.InGenerationQueue), (e.needGenerate = !0));
                                break;
                            case n.InGenerationQueue:
                                !1 === e.needGenerate && (e.status = n.Generating);
                                break;
                            case n.Generating:
                                e.generatedData &&
                                    ((e.status = n.Generated),
                                    (e.ready = !0),
                                    (e.objects = e.generatedData.map((t) => {
                                        const {
                                            collectorOutput: { data: i },
                                        } = t;
                                        return new o.W(e.tile.type, i, a, e.tile.coords, void 0);
                                    })),
                                    t.add(e.key, e));
                        }
                    }
                    !(function (e) {
                        (e[(e.Initial = 0)] = 'Initial'),
                            (e[(e.Loading = 1)] = 'Loading'),
                            (e[(e.Loaded = 2)] = 'Loaded'),
                            (e[(e.InGenerationQueue = 3)] = 'InGenerationQueue'),
                            (e[(e.Generating = 4)] = 'Generating'),
                            (e[(e.Generated = 5)] = 'Generated');
                    })(n || (n = {}));
                },
                647: (e, t, i) => {
                    i.d(t, { l: () => s });
                    var n = i(3672),
                        o = i(6490),
                        r = i(6392);
                    class s {
                        constructor(e, t, i, n, o) {
                            (this.selectedIds = e.slice()),
                                (this.styleState = Object.assign({}, t)),
                                (this.tileRevision = i),
                                (this.styleRevision = o),
                                (this.styleId = n);
                        }
                        static equal(e, t) {
                            return (
                                e.tileRevision === t.tileRevision &&
                                e.styleId === t.styleId &&
                                e.styleRevision === t.styleRevision &&
                                (0, n.y5)(e.getSelectedIds(), t.getSelectedIds()) &&
                                (0, o.vZ)(e.styleState, t.styleState)
                            );
                        }
                        clone() {
                            return new s(
                                this.selectedIds,
                                this.styleState,
                                this.tileRevision,
                                this.styleId,
                                this.styleRevision,
                            );
                        }
                        stringify() {
                            const e = this.selectedIds.map((e) => `${e.lo},${e.hi}`).join('|');
                            return `sId=${this.styleId}_sRev=${this.styleRevision}_tRev=${
                                this.tileRevision
                            }_sel=${e}_sSt=${JSON.stringify(this.styleState)}`;
                        }
                        getSelectedIds() {
                            return this.tileIds
                                ? (0, r.vX)(this.selectedIds, this.tileIds)
                                : this.selectedIds.slice();
                        }
                        setTileIds(e) {
                            this.tileIds = e;
                        }
                    }
                },
                363: (e, t, i) => {
                    i.d(t, { W: () => _, Y: () => p });
                    var n = i(127),
                        o = i(9450),
                        r = i(6392),
                        s = i(878),
                        a = i(4713),
                        l = i(4372),
                        c = i(6874);
                    function d(e, t, i, n, o, r, d) {
                        const { symbol: h, sink: u, generatedObjects: m, buffer: f } = i,
                            p = e.symbolSettingsList[h];
                        if (void 0 === p) return;
                        const _ = p[u];
                        if (void 0 === _) return;
                        const { buffers: v, objectVaos: g } = (function (e, t, i, n) {
                            const o = [],
                                r = [];
                            for (const s of n) {
                                const n = new DataView(i, s.rangeStart, s.rangeEnd - s.rangeStart),
                                    l = new a.l(n);
                                (l.drawType = a.l.StaticDraw), l.prepare(e.getRenderingContext());
                                const c = [];
                                t.forEach((t) => {
                                    const i = e.getShaderProgram(t.programName);
                                    c.push(t.vaoCreator(l, i));
                                }),
                                    o.push(l),
                                    r.push(c);
                            }
                            return { buffers: o, objectVaos: r };
                        })(e, _, f, m);
                        for (const e of v) n.push(e);
                        for (let e = 0; e < m.length; e++) {
                            const {
                                    rangeStart: i,
                                    rangeEnd: n,
                                    attributes: a,
                                    drawMode: f,
                                    meta: p,
                                } = m[e],
                                v = l.kF[h].sinks[u].unpackObjectAttributes(a);
                            for (let m = 0; m < _.length; m++) {
                                const y = _[m],
                                    b = y.uniformSet || 'fill',
                                    w = {
                                        id: (0, c.f)(),
                                        type: s.H.Tile,
                                        layerSettings: y,
                                        stride: (0, l.vP)(h, u),
                                        rangeStart: 0,
                                        rangeEnd: n - i,
                                        attributes: v,
                                        attributesHash:
                                            JSON.stringify(a) + '_' + b + '_' + t.detailLevel,
                                        vao: g[e][m],
                                        drawMode: f,
                                        tile: t,
                                        symbol: h,
                                        sink: u,
                                        meta: p,
                                    };
                                y.identify ? r.push(w) : y.depthTest ? d.push(w) : o.push(w);
                            }
                        }
                    }
                    function h(e, t, i, n, o, r, d) {
                        const { symbol: h, sink: u, generatedObjects: m, buffer: f } = i,
                            p = e.symbolSettingsList[h];
                        if (void 0 === p) return;
                        const _ = p[u];
                        if (void 0 === _) return;
                        const { buffer: v, vaos: g } = (function (e, t, i) {
                            const n = new a.l(i);
                            (n.drawType = a.l.StaticDraw), n.prepare(e.getRenderingContext());
                            const o = [];
                            return (
                                t.forEach((t) => {
                                    const i = e.getShaderProgram(t.programName);
                                    o.push(t.vaoCreator(n, i));
                                }),
                                { buffer: n, vaos: o }
                            );
                        })(e, _, f);
                        n.push(v);
                        for (let e = 0; e < m.length; e++) {
                            const {
                                    rangeStart: i,
                                    rangeEnd: n,
                                    attributes: a,
                                    drawMode: f,
                                    meta: p,
                                } = m[e],
                                v = l.kF[h].sinks[u].unpackObjectAttributes(a);
                            for (let e = 0; e < _.length; e++) {
                                const m = _[e],
                                    y = m.uniformSet || 'fill',
                                    b = {
                                        id: (0, c.f)(),
                                        type: s.H.Tile,
                                        layerSettings: m,
                                        stride: (0, l.vP)(h, u),
                                        rangeStart: i,
                                        rangeEnd: n,
                                        attributes: v,
                                        attributesHash:
                                            JSON.stringify(a) + '_' + y + '_' + t.detailLevel,
                                        vao: g[e],
                                        drawMode: f,
                                        tile: t,
                                        symbol: h,
                                        sink: u,
                                        meta: p,
                                    };
                                m.identify ? r.push(b) : m.depthTest ? d.push(b) : o.push(b);
                            }
                        }
                    }
                    var u = i(6273),
                        m = i(1913);
                    let f = 0;
                    class p {
                        constructor(e, t) {
                            (this.coords = t),
                                (this.bounds = { min: [], max: [] }),
                                (this.tickerName = `tile-fade-${e}-${f++}`),
                                (this.readiness = 1),
                                (this.modelMatrix = n.Ue()),
                                (this.mvpMatrix = new Float32Array(16)),
                                (this.demMatrix = new Float32Array(16)),
                                (this.purpose = e),
                                (this.buffers = []),
                                (this.children = []),
                                (this.identifyChildren = []),
                                (this.depthTestChildren = []);
                        }
                        updateMvpMatrix(e, t) {
                            n.dC(this.mvpMatrix, e, this.modelMatrix),
                                void 0 !== t && n.dC(this.demMatrix, t, this.modelMatrix);
                        }
                        clean(e) {
                            var t;
                            for (const e of this.buffers) e.remove();
                            (this.buffers = []),
                                (this.children = []),
                                (this.identifyChildren = []),
                                (this.depthTestChildren = []),
                                m.sT(this.tickerName, e),
                                null === (t = this.onClean) || void 0 === t || t.call(this);
                        }
                        updateTicker(e) {
                            m.Vx(
                                this.tickerName,
                                {
                                    step: (e, t) => {
                                        this.readiness = t;
                                    },
                                },
                                e,
                            );
                        }
                        startTicker(e, t, i, n, o) {
                            m.BL(this.tickerName, { easing: t }, e, n, o, i);
                        }
                        tickerFinished(e) {
                            return !m.rS(this.tickerName, e);
                        }
                    }
                    class _ extends p {
                        constructor(e, t, i, n = [0, 0, 0, 0], o) {
                            super(e, n), (this.dynamicObject = o);
                            const {
                                buffers: r,
                                objects: s,
                                identifyObjects: a,
                                depthTestObjects: l,
                            } = (function (e, t, i) {
                                const n = [],
                                    o = [],
                                    r = [],
                                    s = [];
                                for (let a = 0; a < t.length; a++) {
                                    const l = t[a];
                                    'instances' === l.sink
                                        ? d(e, i, l, n, o, r, s)
                                        : h(e, i, l, n, o, r, s);
                                }
                                return {
                                    buffers: n,
                                    objects: o,
                                    identifyObjects: r,
                                    depthTestObjects: s,
                                };
                            })(i, t, this);
                            (this.buffers = r),
                                (this.children = s),
                                (this.identifyChildren = a),
                                (this.depthTestChildren = l),
                                this.setTileCoords(n);
                        }
                        setTileCoords(e) {
                            const t = e[2],
                                i = e[3],
                                s = (0, r.aq)(t);
                            (this.coords = e),
                                (this.size = s),
                                (this.zoomLevel = t),
                                (this.detailLevel = i);
                            const a = (0, r.Oy)(e);
                            (this.bounds.min = [a[0], a[1]]),
                                (this.bounds.max = [a[0] + s, a[1] + s]);
                            const l = (u.jO / u.Bq) * s;
                            n.wA(
                                this.modelMatrix,
                                [a[0] - l, a[1] - l, 0],
                                o.al(s / u.gt, s / u.gt, u._9 / u.gt),
                            );
                        }
                    }
                },
                5600: (e, t, i) => {
                    function n(e) {
                        return e;
                    }
                    i.d(t, { D: () => n });
                },
                2153: (e, t, i) => {
                    var n, o, r, s, a;
                    i.d(t, { AL: () => r, Dl: () => a, _r: () => o, a_: () => n, m3: () => s }),
                        (function (e) {
                            (e[(e.Common = 0)] = 'Common'),
                                (e[(e.Commercial = 1)] = 'Commercial'),
                                (e[(e.CommercialCity = 2)] = 'CommercialCity'),
                                (e[(e.Landmark = 3)] = 'Landmark');
                        })(n || (n = {})),
                        (function (e) {
                            (e[(e.Point = 0)] = 'Point'), (e[(e.Line = 1)] = 'Line');
                        })(o || (o = {})),
                        (function (e) {
                            (e[(e.Tile = 0)] = 'Tile'),
                                (e[(e.Floor = 1)] = 'Floor'),
                                (e[(e.DynamicObject = 2)] = 'DynamicObject'),
                                (e[(e.PersonalPoi = 3)] = 'PersonalPoi');
                        })(r || (r = {})),
                        (function (e) {
                            (e[(e.Dead = 0)] = 'Dead'),
                                (e[(e.Alive = 1)] = 'Alive'),
                                (e[(e.Unused = 2)] = 'Unused'),
                                (e[(e.CommercialAlive = 3)] = 'CommercialAlive'),
                                (e[(e.CommercialDead = 4)] = 'CommercialDead');
                        })(s || (s = {})),
                        (function (e) {
                            (e[(e.Text = 0)] = 'Text'),
                                (e[(e.Icon = 1)] = 'Icon'),
                                (e[(e.PoiText = 2)] = 'PoiText'),
                                (e[(e.PoiText2 = 3)] = 'PoiText2'),
                                (e[(e.OneWayLine = 4)] = 'OneWayLine'),
                                (e[(e.LineText = 5)] = 'LineText'),
                                (e[(e.Box = 6)] = 'Box');
                        })(a || (a = {}));
                },
                6479: (e, t, i) => {
                    var n;
                    i.d(t, { f: () => n }),
                        (function (e) {
                            (e[(e.Static = 0)] = 'Static'),
                                (e[(e.Unique = 1)] = 'Unique'),
                                (e[(e.Loaded = 2)] = 'Loaded');
                        })(n || (n = {}));
                },
                878: (e, t, i) => {
                    var n;
                    i.d(t, { H: () => n }),
                        (function (e) {
                            (e[(e.Tile = 0)] = 'Tile'), (e[(e.Custom = 1)] = 'Custom');
                        })(n || (n = {}));
                },
                462: (e, t, i) => {
                    var n, o;
                    i.d(t, { W: () => o, Y: () => n }),
                        (function (e) {
                            (e[(e.Stationary = 0)] = 'Stationary'),
                                (e[(e.ZoomingIn = 1)] = 'ZoomingIn'),
                                (e[(e.ZoomingOut = 2)] = 'ZoomingOut');
                        })(n || (n = {})),
                        (function (e) {
                            (e[(e.ByOne = 0)] = 'ByOne'),
                                (e[(e.WaitingLayer = 1)] = 'WaitingLayer'),
                                (e[(e.GlobalWaiting = 2)] = 'GlobalWaiting');
                        })(o || (o = {}));
                },
                5095: (e, t, i) => {
                    function n(e, t) {
                        const i = new XMLHttpRequest();
                        if ((i.open('GET', e.url, !0), (i.responseType = 'arraybuffer'), e.headers))
                            for (const t in e.headers) i.setRequestHeader(t, e.headers[t]);
                        return (
                            (i.onerror = function () {
                                t({ status: 0, message: 'Network error' }, new ArrayBuffer(0));
                            }),
                            (i.onload = function () {
                                i.status >= 200 && i.status < 300 && i.response
                                    ? t(void 0, i.response)
                                    : t(
                                          { status: i.status, message: i.statusText },
                                          new ArrayBuffer(0),
                                      );
                            }),
                            i.send(),
                            i
                        );
                    }
                    function o(e, t) {
                        const i = new XMLHttpRequest();
                        if ((i.open('GET', e.url, !0), e.headers))
                            for (const t in e.headers) i.setRequestHeader(t, e.headers[t]);
                        return (
                            (i.onerror = function () {
                                t({ status: 0, message: 'Network error' }, {});
                            }),
                            (i.onload = function () {
                                if (0 === i.response.byteLength && 200 === i.status)
                                    return t({ status: 0, message: 'No content' }, {});
                                if (
                                    i.status >= 200 &&
                                    i.status < 300 &&
                                    i.response &&
                                    i.response.length
                                ) {
                                    let n;
                                    try {
                                        (n = JSON.parse(i.response)), t(void 0, n);
                                    } catch (i) {
                                        t(
                                            {
                                                status: 0,
                                                message: `Json parse data error from url ${e.url}`,
                                            },
                                            {},
                                        );
                                    }
                                } else t({ status: i.status, message: i.statusText }, {});
                            }),
                            i.send(),
                            i
                        );
                    }
                    i.d(t, { L: () => o, n: () => n });
                },
                7966: (e, t, i) => {
                    i.d(t, {
                        As: () => a,
                        bX: () => r,
                        fb: () => o,
                        gA: () => s,
                        i8: () => h,
                        pv: () => u,
                        sD: () => d,
                        z: () => l,
                    });
                    var n = i(2435);
                    function o(e, t, i) {
                        return (0, n.IG)(i.fontUrlTemplate, { name: e, range: String(t) });
                    }
                    function r(e, t, i) {
                        const o = d(e) ? e : u(t.iconBaseUrl, e);
                        return (0, n.IG)(o, { subdomain: i, appHost: window.location.host });
                    }
                    function s(e, t) {
                        return d(e) ? e : u(t.modelsBaseUrl, e);
                    }
                    function a(e, t) {
                        const i = d(t.fontsPath) ? t.fontsPath : u(t.rootUrl, t.fontsPath);
                        (e.fontUrlTemplate = u(i, '{name}_{range}.pbf')),
                            (e.iconBaseUrl = d(t.iconsPath)
                                ? t.iconsPath
                                : u(t.rootUrl, t.iconsPath)),
                            (e.modelsBaseUrl = d(t.modelsPath)
                                ? t.modelsPath
                                : u(t.rootUrl, t.modelsPath));
                    }
                    function l(e) {
                        return d(e.stylePath) ? e.stylePath : u(e.rootUrl, e.stylePath);
                    }
                    const c = new RegExp('^(?:[a-z]+:)?//', 'i');
                    function d(e) {
                        return c.test(e);
                    }
                    function h(e) {
                        return /{\w+}/g.test(e);
                    }
                    function u(...e) {
                        const t = e.filter((e) => e.length > 0);
                        let i = t[0];
                        for (let e = 1; e < t.length; e++) {
                            '/' !== i[i.length - 1] && (i += '/');
                            const n = t[e];
                            '/' === n[0] ? (i += n.slice(1)) : (i += n);
                        }
                        return i;
                    }
                },
                1274: (e, t, i) => {
                    function n(e, t, i) {
                        const n = e.getBoundingClientRect();
                        return [t - n.left - e.clientLeft, i - n.top - e.clientTop];
                    }
                    function o(e, t) {
                        const i = [];
                        for (let o = 0; o < e.length; o++) i[o] = n(t, e[o].clientX, e[o].clientY);
                        return i;
                    }
                    function r(e) {
                        return e.touches.length > 1;
                    }
                    i.d(t, { KK: () => o, N2: () => r, yK: () => n });
                },
                6490: (e, t, i) => {
                    i.d(t, {
                        $X: () => f,
                        AB: () => h,
                        Id: () => l,
                        Kh: () => v,
                        Kv: () => d,
                        TH: () => g,
                        Te: () => a,
                        VJ: () => b,
                        Xx: () => s,
                        ZY: () => c,
                        kn: () => u,
                        l4: () => m,
                        sB: () => p,
                        t7: () => w,
                        uZ: () => r,
                        vO: () => _,
                        vZ: () => y,
                    });
                    var n = i(9450),
                        o = i(4874);
                    function r(e, t, i) {
                        return (e = Math.max(e, t)), (e = Math.min(e, i));
                    }
                    function s(e) {
                        return 0 === e || Number.isNaN(e) ? e : e > 0 ? 1 : -1;
                    }
                    function a(e, t) {
                        return [(t[0] / e[0]) * 2 - 1, (-t[1] / e[1]) * 2 + 1];
                    }
                    function l(e) {
                        return (e * Math.PI) / 180;
                    }
                    function c(e) {
                        return (e / Math.PI) * 180;
                    }
                    function d(e, t, i) {
                        void 0 !== i.zoom && (i.zoom = r(i.zoom, e.minZoom, e.maxZoom));
                        const s = new o.V(e),
                            a = s.unproject(t);
                        s.setState(Object.assign(Object.assign({}, e), i));
                        const l = s.unproject(t),
                            c = n.Ue();
                        return n.lu(c, a, l), c;
                    }
                    function h(e) {
                        return (
                            (e >>>= 0),
                            (e -= 1),
                            (e |= e >> 1),
                            (e |= e >> 2),
                            (e |= e >> 4),
                            (e |= e >> 8),
                            (e |= e >> 16) + 1
                        );
                    }
                    function u(e, t) {
                        const i = Object.assign({}, t);
                        for (const t in e) void 0 !== e[t] && (i[t] = e[t]);
                        return i;
                    }
                    function m(e) {
                        const t = {};
                        for (const i in e) {
                            t[e[i]] = i;
                        }
                        return t;
                    }
                    function f(e, t) {
                        const i = [];
                        for (const n in e) t[n] || i.push(e[n]);
                        return i;
                    }
                    function p(e, t, i) {
                        return r((i - e) / (t - e), 0, 1);
                    }
                    function _(e) {
                        return e % 1;
                    }
                    function v(e, t, i) {
                        return e >= t && e <= i;
                    }
                    function g(e, t) {
                        if (e.size !== t.size) return !1;
                        for (const i of Array.from(e)) if (!t.has(i)) return !1;
                        return !0;
                    }
                    function y(e, t) {
                        if (e === t) return !0;
                        if (e && t && 'object' == typeof e && 'object' == typeof t) {
                            const i = Array.isArray(e),
                                n = Array.isArray(t);
                            let o, r, s;
                            if (i && n) {
                                if (((r = e.length), r !== t.length)) return !1;
                                for (o = r; 0 != o--; ) if (!y(e[o], t[o])) return !1;
                                return !0;
                            }
                            if (i !== n) return !1;
                            const a = e instanceof Date,
                                l = t instanceof Date;
                            if (a !== l) return !1;
                            if (a && l) return e.getTime() === t.getTime();
                            const c = e instanceof RegExp,
                                d = t instanceof RegExp;
                            if (c !== d) return !1;
                            if (c && d) return e.toString() === t.toString();
                            const h = Object.keys(e);
                            if (((r = h.length), r !== Object.keys(t).length)) return !1;
                            for (o = r; 0 != o--; )
                                if (!Object.prototype.hasOwnProperty.call(t, h[o])) return !1;
                            for (o = r; 0 != o--; ) if (((s = h[o]), !y(e[s], t[s]))) return !1;
                            return !0;
                        }
                        return e != e && t != t;
                    }
                    function b(e, t) {
                        const i = e.indexOf(t);
                        return -1 !== i && (e.splice(i, 1), !0);
                    }
                    function w(e, t, i) {
                        return e + (t - e) * i;
                    }
                },
                1375: (e, t, i) => {
                    i.d(t, { cX: () => d });
                    i(4713), i(9218);
                    var n = i(3249),
                        o = i(7188),
                        r = i(4372),
                        s = i(8799),
                        a = i(6273),
                        l = i(2543),
                        c = i(6392);
                    function d(e, t, i) {
                        const d = a.Bq,
                            h = [
                                new Uint16Array([0, d, d, 0, 0]),
                                new Uint16Array([0, 0, d, d, 0]),
                            ],
                            u = (0, n.FJ)({}),
                            m = (0, l.Yi)(i, o.i4, o.Dz, u, o.wz);
                        (0, r.XI)({
                            collector: e,
                            generator: s.z.generate,
                            args: [n.jf, t, m, (0, c.Bs)([0, 0, 0, 0]), h],
                        });
                    }
                },
                4576: (e, t, i) => {
                    i.d(t, { dm: () => w, rq: () => x, JA: () => b, Xq: () => S });
                    var n = i(6208),
                        o = i.n(n),
                        r = i(9899),
                        s = i(7999);
                    class a {
                        constructor() {
                            (this.name = ''), (this.range = ''), (this.glyphs = {});
                        }
                    }
                    class l {
                        constructor() {
                            (this.id = 0),
                                (this.range = 0),
                                (this.bitmap = null),
                                (this.top = 0),
                                (this.left = 0),
                                (this.advance = 0),
                                (this.x = 0),
                                (this.y = 0),
                                (this.width = 0),
                                (this.height = 0),
                                (this.texTop = 0),
                                (this.texLeft = 0),
                                (this.texRight = 0),
                                (this.texBottom = 0);
                        }
                    }
                    class c {
                        constructor(e, t) {
                            this.stacks = e.readFields(d, [], t);
                        }
                    }
                    function d(e, t, i) {
                        if (1 === e) {
                            const e = i.readMessage(h, new a());
                            t.push(e);
                        }
                    }
                    function h(e, t, i) {
                        switch (e) {
                            case 1:
                                t.name = i.readString();
                                break;
                            case 2:
                                t.range = i.readString();
                                break;
                            case 3: {
                                const e = i.readMessage(u, new l());
                                t.glyphs[e.id] = e;
                                break;
                            }
                        }
                    }
                    function u(e, t, i) {
                        switch (e) {
                            case 1:
                                (t.id = i.readVarint()), (t.range = (0, s.rx)(t.id));
                                break;
                            case 2:
                                t.bitmap = i.readBytes();
                                break;
                            case 3:
                                t.width = i.readVarint() + 6;
                                break;
                            case 4:
                                t.height = i.readVarint() + 6;
                                break;
                            case 5:
                                t.left = i.readSVarint() - 3;
                                break;
                            case 6:
                                t.top = i.readSVarint() + 17 + 3;
                                break;
                            case 7:
                                t.advance = i.readVarint();
                        }
                    }
                    var m = i(3698),
                        f = i(6490),
                        p = i(9218),
                        _ = i(309),
                        v = i(2543),
                        g = i(6273);
                    class y {
                        constructor(e, t, i) {
                            const n = [];
                            let o = 0;
                            for (let i = 0; i < e.length; i++) {
                                const r = e.charCodeAt(i),
                                    s = t && t[r];
                                s
                                    ? (n.push(s), (o += s.advance))
                                    : r !== p.fonts.bomCharCode && (0, _.Q7)(e[i], r);
                            }
                            (this.glyphs = n),
                                (this.width = o + p.fonts.baseSize * i * (e.length - 1));
                        }
                    }
                    function b(e, t, i) {
                        const n = { lines: [], maxWidth: 0 },
                            o = e.split('\n');
                        for (let e = 0; e < o.length; e++) {
                            const r = new y(o[e], i, t);
                            n.lines.push(r), r.width > n.maxWidth && (n.maxWidth = r.width);
                        }
                        return n;
                    }
                    function w(e, t, i) {
                        for (const n of t) if (!i.has(e, n)) return !1;
                        return !0;
                    }
                    function x(e, t, i) {
                        if (void 0 === e) return;
                        const n = (0, v.Q9)(e, t);
                        return '' !== n ? (void 0 === i.fontNameToIndex[n] ? g.Uo : n) : void 0;
                    }
                    function S(e) {
                        const t = new c(new (o())(new Uint8Array(e))).stacks[0].glyphs,
                            { width: i, height: n } = (function (e) {
                                const t = [],
                                    i = new r.Z(512, 512, { autoResize: !0 }),
                                    n = Object.keys(e);
                                for (let i = 0; i < n.length; i++) {
                                    const o = e[Number(n[i])];
                                    o.bitmap &&
                                        t.push({ glyph: o, width: o.width, height: o.height });
                                }
                                i.pack(t, { inPlace: !0 }), i.shrink();
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e].glyph;
                                    (i.x = t[e].x), (i.y = t[e].y);
                                }
                                return { width: (0, f.AB)(i.w), height: (0, f.AB)(i.h) };
                            })(t);
                        !(function (e, t, i) {
                            const n = Object.keys(e);
                            for (let o = 0; o < n.length; o++) {
                                const r = e[Number(n[o])];
                                r.bitmap &&
                                    ((r.texTop = (0, m.Bb)(r.y / i)),
                                    (r.texLeft = (0, m.Bb)(r.x / t)),
                                    (r.texBottom = (0, m.Bb)((r.y + r.height) / i)),
                                    (r.texRight = (0, m.Bb)((r.x + r.width) / t)));
                            }
                        })(t, i, n);
                        const s = (function (e, t, i) {
                            const n = new Uint8Array(t * i),
                                o = Object.keys(e);
                            for (let i = 0; i < o.length; i++) {
                                const r = e[Number(o[i])];
                                if (r.bitmap)
                                    for (let e = 0; e < r.height; e++) {
                                        const i = t * (r.y + e) + r.x,
                                            o = r.width * e;
                                        for (let e = 0; e < r.width; e++)
                                            n[i + e] = r.bitmap[o + e];
                                    }
                            }
                            return n.buffer;
                        })(t, i, n);
                        return { glyphData: t, bitmap: s, width: i, height: n };
                    }
                },
                9073: (e, t, i) => {
                    i.d(t, {
                        $X: () => R,
                        A5: () => h,
                        C: () => u,
                        EO: () => b,
                        Iy: () => D,
                        LX: () => f,
                        PA: () => _,
                        Qn: () => I,
                        TD: () => m,
                        Vv: () => k,
                        X$: () => x,
                        XV: () => L,
                        Xg: () => T,
                        Z3: () => S,
                        a4: () => M,
                        gr: () => O,
                        h0: () => E,
                        ik: () => A,
                        nn: () => y,
                        pc: () => v,
                        r9: () => g,
                        to: () => z,
                        v3: () => j,
                        vn: () => P,
                        yq: () => p,
                    });
                    var n = i(378),
                        o = i(9450),
                        r = i(127),
                        s = i(9218),
                        a = i(6273),
                        l = i(6490),
                        c = i(8194),
                        d = i(4874);
                    const h = 2 * Math.PI * 6378137,
                        u = a.sX / h,
                        m = r.wA([], [-1, -1, 0], [2, 2, 1]),
                        f = r.wA([], [0.5, 0.5, 0], [0.5, 0.5, 1]);
                    function p(e) {
                        const t = a.sX / 2,
                            i = Math.sin((0, l.Id)(e[1])),
                            n = (e[0] * a.sX) / 360,
                            r = (Math.log((1 + i) / (1 - i)) * a.sX) / (4 * Math.PI);
                        return o.al((0, l.uZ)(n, -t, t), (0, l.uZ)(r, -t, t), 0);
                    }
                    function _(e) {
                        const t = [0, 0];
                        t[0] = (360 * e[0]) / a.sX;
                        const i = (-2 * Math.PI) / a.sX;
                        return (t[1] = 90 - 2 * (0, l.ZY)(Math.atan(Math.exp(e[1] * i)))), t;
                    }
                    function v(e) {
                        return Math.max(e, s.camera.minCalculationScreenHeight);
                    }
                    function g(e, t) {
                        const i = v(t[1]) / 2,
                            n = a.sX / Math.pow(2, e);
                        return ((i / a.y4) * n) / Math.tan(s.camera.fov / 2);
                    }
                    function y(e, t) {
                        return (
                            Math.log(
                                (v(t[1]) * a.sX) / (2 * a.y4 * Math.tan(s.camera.fov / 2) * e),
                            ) / Math.LN2
                        );
                    }
                    function b(e) {
                        return a.ax * Math.pow(2, -e);
                    }
                    function w(e) {
                        const t = _(e)[1],
                            i = 1 / (2 * Math.cos((0, l.Id)(t)));
                        return Math.log(i) / Math.log(2);
                    }
                    function x(e, t) {
                        const i = w(t) * (0, l.sB)(9, 10, e);
                        return e + (0, l.uZ)(i, -1, 0);
                    }
                    function S(e, t) {
                        const i = w(t),
                            n = i * (0, l.sB)(9, 10 + i, e);
                        return e - (0, l.uZ)(n, -1, 0);
                    }
                    function I(e, t) {
                        return (a.LF * (e / a.$U)) / t;
                    }
                    function M(e, t) {
                        return t * u * T(e[1]);
                    }
                    function T(e) {
                        return 1 / Math.cos((0, l.Id)(e));
                    }
                    function P(e, t) {
                        const i = Math.PI / 180,
                            n = e[1] * i,
                            o = t[1] * i,
                            r = Math.sin(((t[1] - e[1]) * i) / 2),
                            s = Math.sin(((t[0] - e[0]) * i) / 2),
                            a = r * r + Math.cos(n) * Math.cos(o) * s * s,
                            l = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                        return Math.round(6371e3 * l);
                    }
                    function L(e) {
                        let t = 0;
                        if (e.length > 1)
                            for (let i = 0; i < e.length - 1; i++) t += P(e[i], e[i + 1]);
                        return t;
                    }
                    const k = c.Ue([-a.sX / 2, -a.sX / 2], [a.sX / 2, a.sX / 2]);
                    function E(e, t) {
                        return (e * Math.pow(2, -t) * a.sX) / a.y4;
                    }
                    function A(e, t) {
                        return (e * Math.pow(2, t) * a.y4) / a.sX;
                    }
                    function z(e, t) {
                        return 0 === e ? -1 / 0 : -Math.log((t * a.y4) / (e * a.sX)) / Math.LN2;
                    }
                    const C = n.Ue(),
                        F = n.Ue();
                    function O(e, t, i) {
                        n.$X(C, i, e), n.$X(F, t, e);
                        const o = n.AK(C, F) / n.kE(C);
                        return Math.atan2(o, e[2]);
                    }
                    function D(e) {
                        const t = e[0],
                            i = e[1];
                        return (0, l.Kh)(t, -180, 180) && (0, l.Kh)(i, -90, 90);
                    }
                    function R(
                        e,
                        t,
                        i,
                        n,
                        o,
                        r,
                        s = { top: 0, right: 0, bottom: 0, left: 0 },
                        a = { top: 0, right: 0, bottom: 0, left: 0 },
                        c,
                        h,
                    ) {
                        const u = new d.V({
                                center: p(e),
                                zoom: t,
                                rotation: (0, l.Id)(i),
                                size: n,
                                pitch: (0, l.Id)(o),
                                viewport: s,
                                padding: a,
                            }),
                            m = _(u.unproject(r)),
                            f = _(u.unproject([r[0] + c, r[1] + h]));
                        return Math.max(1, P(m, f));
                    }
                    function j(e) {
                        const t = 2 * Math.PI;
                        return (e %= t) < 0 && (e += t), e;
                    }
                },
                1959: (e, t, i) => {
                    function n(e) {
                        return (
                            !!e &&
                            'stretchX' in e &&
                            Array.isArray(e.stretchX) &&
                            'stretchY' in e &&
                            Array.isArray(e.stretchY) &&
                            'width' in e &&
                            'number' == typeof e.width &&
                            'height' in e &&
                            'number' == typeof e.height
                        );
                    }
                    i.d(t, { x: () => n });
                },
                309: (e, t, i) => {
                    i.d(t, { $z: () => s, Q7: () => o, cM: () => a });
                    var n = i(7999);
                    function o(e, t) {
                        a(`No glyph for character ${e} (code = ${t}, range = ${(0, n.rx)(t)})`);
                    }
                    const r = new Set();
                    function s(e) {
                        console.group('Gltf model error'),
                            console.warn('Stage:', e.layer),
                            e.message && console.warn('Message:', e.message),
                            e.originalError &&
                                (console.groupCollapsed('Original error'),
                                console.warn(e.originalError),
                                console.groupEnd()),
                            console.groupEnd();
                    }
                    function a(e) {
                        r.has(e) || (console.log(e), r.add(e));
                    }
                },
                7636: (e, t, i) => {
                    i.d(t, { g: () => l });
                    var n = i(9450),
                        o = i(8194),
                        r = i(6490),
                        s = i(9073),
                        a = i(9090);
                    function l(e, t, i) {
                        if (0 === e.length) return;
                        const l = (0, r.Id)(t),
                            d = o.Ue();
                        for (const t of e) {
                            const e = (0, s.yq)(t);
                            (0, a.hk)(e, -l), o.aM(d, e);
                        }
                        const h = n.Ue();
                        return o.be(h, d), (0, a.hk)(h, l), { center: h, zoom: c(d, i) };
                    }
                    function c(e, t) {
                        return Math.min(
                            (0, s.to)(t[0], Math.abs(e.max[0] - e.min[0])),
                            (0, s.to)(t[1], Math.abs(e.max[1] - e.min[1])),
                        );
                    }
                },
                8194: (e, t, i) => {
                    i.d(t, {
                        JG: () => c,
                        Rk: () => u,
                        Ue: () => s,
                        X3: () => a,
                        aM: () => l,
                        bA: () => _,
                        be: () => h,
                        jV: () => p,
                        kK: () => f,
                        mc: () => d,
                        r3: () => m,
                    });
                    var n = i(378),
                        o = i(6490),
                        r = i(9073);
                    function s(e, t) {
                        return { min: e || n.al(1 / 0, 1 / 0), max: t || n.al(-1 / 0, -1 / 0) };
                    }
                    function a(e) {
                        return s((0, r.yq)(e.southWest), (0, r.yq)(e.northEast));
                    }
                    function l(e, t) {
                        n.VV(e.min, e.min, t), n.Fp(e.max, e.max, t);
                    }
                    function c(e, t) {
                        (e.min[0] = t.min[0]),
                            (e.max[0] = t.max[0]),
                            (e.min[1] = t.min[1]),
                            (e.max[1] = t.max[1]);
                    }
                    function d(e) {
                        (e.min[0] = 1 / 0),
                            (e.max[0] = -1 / 0),
                            (e.min[1] = 1 / 0),
                            (e.max[1] = -1 / 0);
                    }
                    function h(e, t) {
                        return (
                            (e[0] = t.min[0] + (t.max[0] - t.min[0]) / 2),
                            (e[1] = t.min[1] + (t.max[1] - t.min[1]) / 2),
                            e
                        );
                    }
                    function u(e, t, i) {
                        (e[0] = (0, o.uZ)(i[0], t.min[0], t.max[0])),
                            (e[1] = (0, o.uZ)(i[1], t.min[1], t.max[1]));
                    }
                    function m(e, t) {
                        return (
                            t[0] <= e.max[0] &&
                            t[0] >= e.min[0] &&
                            t[1] <= e.max[1] &&
                            t[1] >= e.min[1]
                        );
                    }
                    function f(e, t) {
                        const i = e.min[0] <= t.max[0] && t.min[0] <= e.max[0],
                            n = e.min[1] <= t.max[1] && t.min[1] <= e.max[1];
                        return i && n;
                    }
                    function p(e, t) {
                        return {
                            min: [Math.max(e.min[0], t.min[0]), Math.max(e.min[1], t.min[1])],
                            max: [Math.min(e.max[0], t.max[0]), Math.min(e.max[1], t.max[1])],
                        };
                    }
                    function _(e, t) {
                        const i = h([], e),
                            n = ((e.max[0] - e.min[0]) / 2) * t,
                            o = ((e.max[1] - e.min[1]) / 2) * t;
                        (e.min[0] = i[0] - n),
                            (e.min[1] = i[1] - o),
                            (e.max[0] = i[0] + n),
                            (e.max[1] = i[1] + o);
                    }
                },
                2539: (e, t, i) => {
                    i.d(t, {
                        Jh: () => M,
                        LX: () => p,
                        Oy: () => g,
                        Z4: () => T,
                        hS: () => f,
                        iE: () => y,
                        z_: () => I,
                    });
                    var n = i(1245),
                        o = i(9450),
                        r = i(378),
                        s = i(127),
                        a = i(8194);
                    const l = [0, 0, 0, 0],
                        c = Array(16),
                        d = [0, 0, 0, 0],
                        h = [0, 0, 0, 0],
                        u = [0, 0, 0, 0],
                        m = [0, 0, 0, 0];
                    function f(e, t) {
                        return { a: e[1] - t[1], b: t[0] - e[0], c: e[0] * t[1] - t[0] * e[1] };
                    }
                    function p(e, t, i, o, a, f = 1) {
                        r.lu(l, t, i), r.Fv(l, l);
                        const p = l[0],
                            g = l[1];
                        if (
                            (v(d, e, -p, g),
                            v(h, t, -p, g),
                            v(u, i, -p, g),
                            v(m, o, -p, g),
                            !(function (e, t, i, o, r) {
                                return (
                                    s.t8(
                                        c,
                                        Math.pow(t[0], 3),
                                        Math.pow(i[0], 3),
                                        Math.pow(o[0], 3),
                                        Math.pow(r[0], 3),
                                        Math.pow(t[0], 2),
                                        Math.pow(i[0], 2),
                                        Math.pow(o[0], 2),
                                        Math.pow(r[0], 2),
                                        t[0],
                                        i[0],
                                        o[0],
                                        r[0],
                                        1,
                                        1,
                                        1,
                                        1,
                                    ),
                                    n.t8(e, t[1], i[1], o[1], r[1]),
                                    null !== s.U_(c, c) && (n.fF(e, e, c), !0)
                                );
                            })(l, d, h, u, m))
                        )
                            return;
                        const y = ((u[0] - h[0]) * f) / (a - 1),
                            b = ((u[2] - h[2]) * f) / (a - 1),
                            w = [];
                        for (let e = 0; e < a; e++) {
                            const t = h[0] + y * e,
                                i = _(l, t),
                                n = h[2] + b * e;
                            w.push([t, i, n]);
                        }
                        return w.forEach((e) => v(e, e, -p, -g)), w;
                    }
                    function _(e, t) {
                        return e[0] * Math.pow(t, 3) + e[1] * Math.pow(t, 2) + e[2] * t + e[3];
                    }
                    function v(e, t, i, n) {
                        const o = i * t[0] - n * t[1],
                            s = n * t[0] + i * t[1];
                        r.t8(e, o, s);
                    }
                    function g(e, t) {
                        return Math.abs(y(e, t));
                    }
                    function y(e, t) {
                        return (t.a * e[0] + t.b * e[1] + t.c) / Math.sqrt(t.a * t.a + t.b * t.b);
                    }
                    function b(e, t, i) {
                        const { a: n, b: r, c: s } = f(e, t);
                        return o.al(i, -(n * i + s) / r, 0);
                    }
                    function w(e, t, i) {
                        const { a: n, b: r, c: s } = f(e, t);
                        return o.al(-(r * i + s) / n, i, 0);
                    }
                    const x = a.Ue(),
                        S = a.Ue();
                    function I(e, t, i) {
                        const n = t[t.length - 1] * i;
                        let o = e[0],
                            s = 0;
                        const a = [o];
                        let l,
                            c = 1;
                        for (; c < e.length && !l; ) {
                            const i = e[c],
                                d = t[c];
                            let h = i;
                            if (d > n) {
                                if (!l) {
                                    const e = (n - s) / (d - s);
                                    (l = []), r.t7(l, o, i, e);
                                }
                                h = l;
                            }
                            a.push(h), (o = h), (s = t[c]), c++;
                        }
                        return a;
                    }
                    function M(e, t) {
                        let i = e[0];
                        a.mc(x), a.aM(x, i);
                        let n = [i];
                        const o = [n];
                        let r = 1;
                        for (; r < e.length; ) {
                            const s = e[r];
                            let l = !1,
                                c = s;
                            if ((a.JG(S, x), a.aM(S, c), S.max[0] - S.min[0] > t)) {
                                (c = b(i, c, S.max[0] === c[0] ? S.min[0] + t : S.max[0] - t)),
                                    (l = !0);
                            }
                            if ((l && (a.JG(S, x), a.aM(S, c)), S.max[1] - S.min[1] > t)) {
                                (c = w(i, c, S.max[1] === c[1] ? S.min[1] + t : S.max[1] - t)),
                                    (l = !0);
                            }
                            l
                                ? (n.push(c), a.mc(x), a.aM(x, c), (n = [c]), o.push(n), (i = c))
                                : (n.push(s), a.aM(x, s), (i = s), r++);
                        }
                        return o;
                    }
                    function T(e, t, i) {
                        const n = e[0] - t[0],
                            o = e[1] - t[1],
                            r = i[0] - t[0],
                            s = i[1] - t[1],
                            a = r * r + s * s,
                            l = 0 !== a ? (n * r + o * s) / a : 0;
                        return l < 0 ? t : l > 1 ? i : [t[0] + l * r, t[1] + l * s];
                    }
                },
                4091: (e, t, i) => {
                    i.d(t, { bu: () => n, qt: () => o });
                    const n = (e) =>
                        ((e) => {
                            if (e.length > 2) {
                                let t = 0;
                                for (let i = e.length - 1, n = i, o = 0; o <= i; o++) {
                                    const i = e[n],
                                        r = e[o];
                                    (t += (i[0] + r[0]) * (i[1] - r[1])), (n = o);
                                }
                                return t / 2;
                            }
                            return 0;
                        })(e) > 0;
                    function o(e) {
                        const t = (e = e.slice().sort(s)).length,
                            i = new Array(2 * t);
                        let n = 0;
                        for (let o = 0; o < t; o++) {
                            const t = e[o];
                            for (; n >= 2 && r(i[n - 2], i[n - 1], t) <= 0; ) n--;
                            i[n++] = t;
                        }
                        const o = n + 1;
                        for (let s = t - 2; s >= 0; s--) {
                            const t = e[s];
                            for (; n >= o && r(i[n - 2], i[n - 1], t) <= 0; ) n--;
                            i[n++] = t;
                        }
                        return i.slice(0, n - 1);
                    }
                    function r(e, t, i) {
                        return (t[1] - e[1]) * (i[0] - e[0]) - (t[0] - e[0]) * (i[1] - e[1]);
                    }
                    function s(e, t) {
                        return e[0] === t[0] ? e[1] - t[1] : e[0] - t[0];
                    }
                },
                267: (e, t, i) => {
                    i.d(t, { BS: () => s, By: () => a, M4: () => l, mW: () => c });
                    var n = i(9450),
                        o = i(8194),
                        r = i(2539);
                    function s(e) {
                        const t = e[0][0],
                            i = e[0][1],
                            n = e[1][0],
                            o = e[1][1],
                            r = e[2][0],
                            s = e[2][1],
                            a = e[3][0],
                            l = e[3][1];
                        return {
                            min: [Math.min(t, n, r, a), Math.min(i, o, s, l)],
                            max: [Math.max(t, n, r, a), Math.max(i, o, s, l)],
                        };
                    }
                    function a(e) {
                        return [
                            [e[0][0], e[0][1], e[0][2]],
                            [e[1][0], e[1][1], e[1][2]],
                            [e[2][0], e[2][1], e[2][2]],
                            [e[3][0], e[3][1], e[3][2]],
                        ];
                    }
                    function l(e, t) {
                        const i = s(e);
                        if (!(0, o.kK)(t, i)) return !1;
                        const n = [
                                (0, r.hS)(e[3], e[2]),
                                (0, r.hS)(e[1], e[0]),
                                (0, r.hS)(e[0], e[3]),
                                (0, r.hS)(e[2], e[1]),
                            ],
                            a = [t.min, t.max, [t.min[0], t.max[1]], [t.max[0], t.min[1]]];
                        for (const e of n) {
                            let t = !0;
                            for (let i = 0; i < a.length; i++) {
                                const n = a[i];
                                if (e.a * n[0] + e.b * n[1] + e.c < 0) {
                                    t = !1;
                                    break;
                                }
                            }
                            if (t) return !1;
                        }
                        return !0;
                    }
                    function c(e, t, i) {
                        e.forEach((e) => {
                            const o = 1 + t / n.TE(i, e);
                            n.t7(e, i, e, o);
                        });
                    }
                },
                9090: (e, t, i) => {
                    i.d(t, {
                        AE: () => l,
                        Cb: () => c,
                        Hl: () => g,
                        IB: () => _,
                        L$: () => b,
                        Y6: () => y,
                        af: () => m,
                        ax: () => h,
                        fN: () => p,
                        hk: () => w,
                        i7: () => u,
                        m2: () => f,
                        se: () => v,
                        tG: () => x,
                        uI: () => d,
                    });
                    var n = i(378),
                        o = i(9450),
                        r = i(6490);
                    const s = [0, 0, 0],
                        a = [0, 0, 0];
                    function l(e, t, i, n, o) {
                        if (t !== n || i !== o) {
                            const r = o - i,
                                s = t - n,
                                a = 1 / Math.sqrt(r * r + s * s);
                            (e[0] = r * a), (e[1] = s * a);
                        } else (e[0] = 0), (e[1] = 0);
                    }
                    function c(e, t, i, n) {
                        return o.lu(s, i, t), o.lu(a, i, n), o.kC(e, a, s), o.Fv(e, e), e;
                    }
                    function d(e, t, i, n, o) {
                        if (t !== n || i !== o) {
                            const r = n - t,
                                s = o - i,
                                a = 1 / Math.sqrt(r * r + s * s);
                            (e[0] = r * a), (e[1] = s * a);
                        } else (e[0] = 0), (e[1] = 0);
                    }
                    function h(e, t, i, n, o) {
                        const r = t + n,
                            s = i + o,
                            a = t * r + i * s;
                        if (0 !== a) {
                            const t = 1 / a;
                            (e[0] = r * t), (e[1] = s * t);
                        } else (e[0] = 0), (e[1] = 0);
                    }
                    function u(e) {
                        return (0, r.uZ)(127 * e, -127, 127);
                    }
                    function m(e, t = e) {
                        return (e[0] = u(t[0])), (e[1] = u(t[1])), e;
                    }
                    function f(e, t, i, n, o) {
                        (e[0] = t * n + i * o), (e[1] = i * n - t * o);
                    }
                    function p(e, t) {
                        const i = t[0];
                        (e[0] = -t[1]), (e[1] = i);
                    }
                    function _(e, t) {
                        const i = t[0];
                        (e[0] = t[1]), (e[1] = -i);
                    }
                    function v(e) {
                        return 0 === e[0] && 0 === e[1];
                    }
                    function g(e, t) {
                        return Math.atan2(t[1] - e[1], t[0] - e[0]);
                    }
                    function y(e, t) {
                        p(s, e);
                        const i = n.AK(t, e),
                            o = n.AK(t, s);
                        return Math.atan2(o, i);
                    }
                    function b(e, t) {
                        return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2];
                    }
                    function w(e, t) {
                        const i = Math.sin(t),
                            o = Math.cos(t),
                            r = o * e[0] - i * e[1],
                            s = i * e[0] + o * e[1];
                        n.t8(e, r, s);
                    }
                    function x(e, t, i, o, r = !0) {
                        n.I6(t, i) || n.I6(i, o)
                            ? n.t8(e, 0, 0)
                            : (n.lu(s, i, t),
                              n.lu(a, o, i),
                              r ? (p(s, s), p(a, a)) : (_(s, s), _(a, a)),
                              n.Fv(s, s),
                              n.Fv(a, a),
                              n.IH(e, s, a),
                              n.Fv(e, e));
                    }
                },
                7188: (e, t, i) => {
                    i.d(t, {
                        Dz: () => h,
                        GG: () => s,
                        KP: () => l,
                        Qy: () => c,
                        SD: () => r,
                        ev: () => a,
                        i4: () => f,
                        nF: () => u,
                        so: () => p,
                        wz: () => m,
                    });
                    var n = i(6490),
                        o = i(4716);
                    function r(e) {
                        let t = 0;
                        for (let i = 0; i < e.length; i++)
                            t += e[i] * Math.pow(256, e.length - 1 - i);
                        return t;
                    }
                    function s(e) {
                        const t = new Uint8Array(6);
                        for (let i = 0; i < 6; i++)
                            t[i] = 255 & Math.floor(e / Math.pow(256, 5 - i));
                        return encodeURIComponent(o.c(t));
                    }
                    function a(e) {
                        const t = (function (e, t) {
                                var i, n, o, r, s, a;
                                const l = {};
                                e.forEach((e, t) => {
                                    l[e] = t;
                                });
                                let c = e.length;
                                (l.selected = null !== (i = l.selected) && void 0 !== i ? i : c++),
                                    (l.hovered =
                                        null !== (n = l.hovered) && void 0 !== n ? n : c++),
                                    (l.dpi = null !== (o = l.dpi) && void 0 !== o ? o : c++),
                                    (l.isRealtime =
                                        null !== (r = l.isRealtime) && void 0 !== r ? r : c++),
                                    (l.pixelDensityPreset =
                                        null !== (s = l.pixelDensityPreset) && void 0 !== s
                                            ? s
                                            : c++),
                                    (l.drawLevel =
                                        null !== (a = l.drawLevel) && void 0 !== a ? a : c++);
                                for (const e in t) void 0 === l[e] && (l[e] = c++);
                                return l;
                            })(e.tileProps, e.defaultProps),
                            i = {};
                        for (const n in e.defaultProps)
                            i[n] = { index: t[n], value: e.defaultProps[n] };
                        return {
                            version: e.version,
                            dictionaries: e.enumerationValues,
                            reverseDictionaries: Object.keys(e.enumerationValues).reduce(
                                (t, i) => ((t[i] = (0, n.l4)(e.enumerationValues[i])), t),
                                {},
                            ),
                            tileProps: t,
                            tilePropsByIndex: (0, n.l4)(t),
                            defaultProps: i,
                        };
                    }
                    function l(e, t) {
                        const i = {};
                        if (t) for (let e = 0; e < t.length; e++) i[t[e]] = e;
                        return a({
                            enumerationValues: { db_sublayer: i },
                            version: '',
                            zenithVersion: '',
                            date: '',
                            defaultProps: {},
                            tileProps: e,
                        });
                    }
                    function c(e, t) {
                        const { tileProps: i } = e;
                        let n = Object.keys(i).length;
                        for (const e of t) void 0 === i[e] && ((i[e] = n), (n += 1));
                    }
                    let d = 0;
                    const h = {
                            beginningIsCut: d++,
                            class: d++,
                            componentDistanceEnd: d++,
                            componentDistanceStart: d++,
                            db_icon_priority: d++,
                            db_label_priority: d++,
                            db_label2_priority: d++,
                            dpi: d++,
                            endingIsCut: d++,
                            height: d++,
                            db_hidden_by_plan_building_id: d++,
                            id: d++,
                            isRealtime: d++,
                            db_label: d++,
                            db_label2: d++,
                            nextPointX: d++,
                            nextPointY: d++,
                            db_object_class: d++,
                            objectLength: d++,
                            pixelDensityPreset: d++,
                            previousPointX: d++,
                            previousPointY: d++,
                            db_region: d++,
                            selected: d++,
                            hovered: d++,
                            db_sublayer: d++,
                            traffic_color: d++,
                            traffic_road_class: d++,
                            traffic_road_z_level: d++,
                            drawLevel: d++,
                        },
                        u = {
                            version: '0.0.0',
                            tileProps: h,
                            tilePropsByIndex: (0, n.l4)(h),
                            defaultProps: {},
                            dictionaries: {},
                            reverseDictionaries: {},
                        },
                        m = [],
                        f = {},
                        p = { sourceName: 'zenith' };
                },
                2702: (e, t, i) => {
                    function n(e, t, i) {
                        for (let n = 0, o = t.length; n < o; n++) {
                            const o = t[n];
                            let r = 0;
                            switch (o.type) {
                                case 'get':
                                    r = i.tileAttrs[i.tileProps[o.key]];
                                    break;
                                case 'sourceAttr':
                                    i.sourceAttrs && (r = i.sourceAttrs[o.key]);
                                    break;
                                case 'featureState':
                                    r = i.featureAttrs[i.tileProps[o.key]];
                            }
                            e.push(r);
                        }
                        return e;
                    }
                    function o(e, t) {
                        for (let i = 0, n = t.length; i < n; i++) e.push(t[i]);
                        return e;
                    }
                    function r(e, t) {
                        if (e.length !== t.length) return !1;
                        for (let i = 0; i < e.length; i++) {
                            const n = e[i],
                                o = t[i];
                            if (Array.isArray(n)) return !!Array.isArray(o) && r(n, o);
                            if (
                                !(
                                    n === o ||
                                    ('number' == typeof n &&
                                        'number' == typeof o &&
                                        Number.isNaN(n) &&
                                        Number.isNaN(o))
                                )
                            )
                                return !1;
                        }
                        return !0;
                    }
                    i.d(t, { LY: () => o, v$: () => n, wy: () => r });
                },
                3698: (e, t, i) => {
                    function n(e) {
                        const t = 256 * Math.log(e);
                        return ((t + (t < 0 ? -0.5 : 0.5)) << 16) >> 16;
                    }
                    function o(e) {
                        return ((32768 * e + 0.5) << 16) >>> 16;
                    }
                    function r(e) {
                        return ((256 * Math.log(e) + 0.5) << 16) >> 16;
                    }
                    i.d(t, { Bb: () => o, KF: () => r, wj: () => n });
                },
                173: (e, t, i) => {
                    function n(e) {
                        return () => ((e = (16807 * e) % 2147483647) - 1) / 2147483646;
                    }
                    function o(e, t, i) {
                        return ('function' == typeof e ? e() : 0.5) * (i - t) + t;
                    }
                    i.d(t, { O: () => n, f: () => o });
                },
                7486: (e, t, i) => {
                    i.d(t, { Bl: () => d, W8: () => c, rA: () => l });
                    var n = i(6479),
                        o = i(7464);
                    let r = 10001;
                    const s = { w: 0, h: 0, x: 0, y: 0, atlasIndex: 0, isPacked: !1 },
                        a = {};
                    function l(e, t, i, l, c) {
                        const d = (0, o.zV)(e.lo, e.hi);
                        if (!a[d]) {
                            const o = r++;
                            a[d] = {
                                type: n.f.Unique,
                                isSvg: !1,
                                index: o,
                                key: d,
                                name: '',
                                fileName: '',
                                id: e,
                                regionId: i,
                                url: c,
                                rasters: t.map((e, t) =>
                                    Object.assign(Object.assign({}, s), {
                                        rasterSetIndex: o,
                                        rasterIndex: t,
                                        w: e,
                                        h: e,
                                        anchorX: l[0],
                                        anchorY: l[1],
                                    }),
                                ),
                            };
                        }
                        return a[d];
                    }
                    function c(e) {
                        const t = r++;
                        return {
                            type: n.f.Loaded,
                            isSvg: !1,
                            index: t,
                            key: `loaded-${t}`,
                            name: '',
                            fileName: '',
                            rasters: e.map((e, i) =>
                                Object.assign(Object.assign({}, e), {
                                    rasterIndex: i,
                                    rasterSetIndex: t,
                                }),
                            ),
                        };
                    }
                    function d(e, t, i) {
                        let n,
                            o = 1 / 0;
                        for (let r = 0; r < e.length; r++) {
                            const s = e[r];
                            if (i && !s.isPacked) continue;
                            const a = Math.abs(s.w - t);
                            a < o && ((n = r), (o = a));
                        }
                        return n;
                    }
                },
                297: (e, t, i) => {
                    i.d(t, {
                        ng: () => d,
                        Iw: () => l,
                        dp: () => o,
                        iY: () => n,
                        GY: () => s,
                        rJ: () => r,
                        w7: () => c,
                    });
                    let n = (e) => e,
                        o = null,
                        r = !1;
                    const s = new Promise((e) => {
                            o = () => {
                                (r = !0), e();
                            };
                        }),
                        a = new Set(['ar']);
                    function l(e, t) {
                        return 'always-on' === e || ('depends-on-language' === e && a.has(t));
                    }
                    function c(e, t, i) {
                        const n = t.workers.labeling;
                        function r() {
                            n.markRtlPluginLoaded().then(() => {
                                null !== o && o();
                            });
                        }
                        return l(e.scenario, i)
                            ? fetch(e.url, { integrity: e.hash })
                                  .then((e) => e.text())
                                  .then((e) =>
                                      Promise.all([n.loadRtlPlugin(e), Promise.resolve(d(e))]),
                                  )
                                  .catch((e) => {
                                      r();
                                      const t = new Error(),
                                          i = '[RTL Plugin]: loading failed.';
                                      var n;
                                      throw (
                                          ((t.message =
                                              'object' == typeof (n = e) &&
                                              Boolean(n) &&
                                              'message' in n
                                                  ? `${i} ${e.message}`
                                                  : i),
                                          t)
                                      );
                                  })
                            : (r(), Promise.resolve());
                    }
                    const d = (function (e) {
                        let t,
                            i = !1;
                        return function (...n) {
                            return i || ((i = !0), (t = e.apply(this, n))), t;
                        };
                    })(function (e) {
                        new Function(e)(), (n = self.mapglRtlPlugin.processRtl), o && o();
                    });
                },
                7999: (e, t, i) => {
                    i.d(t, { Go: () => a, lD: () => r, rx: () => s, zT: () => o });
                    var n = i(9218);
                    function o(e) {
                        let t = '',
                            i = 0;
                        for (; i < e.length; ) {
                            let n = e[i++];
                            if (n > 127) {
                                if (n > 191 && n < 224) {
                                    if (i >= e.length)
                                        return console.error('Incomplete 2-byte sequence'), t;
                                    n = ((31 & n) << 6) | (63 & e[i]);
                                } else if (n > 223 && n < 240) {
                                    if (i + 1 >= e.length)
                                        return console.error('Incomplete 3-byte sequence'), t;
                                    n = ((15 & n) << 12) | ((63 & e[i]) << 6) | (63 & e[++i]);
                                } else {
                                    if (!(n > 239 && n < 248))
                                        return (
                                            console.error(
                                                `Unknown multibyte start 0x${n.toString(
                                                    16,
                                                )} at index ${i - 1}`,
                                            ),
                                            t
                                        );
                                    if (i + 2 >= e.length)
                                        return console.error('Incomplete 4-byte sequence'), t;
                                    n =
                                        ((7 & n) << 18) |
                                        ((63 & e[i]) << 12) |
                                        ((63 & e[++i]) << 6) |
                                        (63 & e[++i]);
                                }
                                ++i;
                            }
                            if (n <= 65535) t += String.fromCharCode(n);
                            else {
                                if (!(n <= 1114111))
                                    return (
                                        console.error(
                                            `Code point 0x${n.toString(16)} exceeds UTF-16 reach`,
                                        ),
                                        t
                                    );
                                (n -= 65536),
                                    (t += String.fromCharCode((n >> 10) | 55296)),
                                    (t += String.fromCharCode((1023 & n) | 56320));
                            }
                        }
                        return t;
                    }
                    function r(e, t) {
                        if (e.length <= t || -1 !== e.indexOf('\n')) return e;
                        const i = [];
                        return (
                            e.split(' ').forEach((e) => {
                                const n = i.length - 1;
                                0 === i.length || i[n].length + e.length >= t
                                    ? i.push(e)
                                    : (i[n] += ' ' + e);
                            }),
                            i.join('\n')
                        );
                    }
                    function s(e) {
                        return Math.floor(e / 256);
                    }
                    function a(e) {
                        const t = new Set();
                        return (
                            e.forEach((e) => {
                                if (void 0 !== e)
                                    for (let i = 0; i < e.length; i++) {
                                        const o = e.charCodeAt(i);
                                        o !== n.fonts.bomCharCode && t.add(s(o));
                                    }
                            }),
                            Array.from(t)
                        );
                    }
                },
                2743: (e, t, i) => {
                    function n(e) {
                        return e instanceof Array ? e : Array.from(e);
                    }
                    i.d(t, { O: () => n });
                },
                2398: (e, t, i) => {
                    i.d(t, { U: () => r });
                    var n = i(6392),
                        o = i(5095);
                    class r {
                        constructor(e, t = !1) {
                            (this.dataType = e),
                                (this.pendingRequests = new Map()),
                                (this.ignoredStatusCodes = t ? [204, 404] : [204]);
                        }
                        fetch(e, t) {
                            return new Promise((i) => {
                                const r = t(e),
                                    s = (0, n.gx)(e),
                                    a = ('json' === this.dataType ? o.L : o.n)(
                                        { url: r },
                                        (e, t) => {
                                            if ((this.pendingRequests.delete(s), void 0 !== e))
                                                return (
                                                    this.ignoredStatusCodes.includes(e.status) ||
                                                        console.error(e),
                                                    void i({})
                                                );
                                            i({ data: t });
                                        },
                                    );
                                this.pendingRequests.set(s, { xhr: a, resolve: i });
                            });
                        }
                        destroy() {
                            this.pendingRequests.forEach((e, t) => {
                                this.abortRequest(t);
                            });
                        }
                        abortRequest(e) {
                            const t = this.pendingRequests.get(e);
                            void 0 !== t &&
                                (t.xhr.abort(),
                                t.resolve({ rejected: !0 }),
                                this.pendingRequests.delete(e));
                        }
                    }
                },
                3675: (e, t, i) => {
                    i.d(t, { c: () => n });
                    class n {
                        constructor() {
                            this.events = {};
                        }
                        on(e, t) {
                            let i = this.events[e];
                            return i || (i = this.events[e] = []), i.push(t), this;
                        }
                        once(e, t) {
                            const i = (n) => {
                                this.off(e, i), t.call(this, n);
                            };
                            return this.on(e, i), this;
                        }
                        off(e, t) {
                            const i = this.events[e];
                            if (!i) return this;
                            const n = i.indexOf(t);
                            return -1 !== n && i.splice(n, 1), this;
                        }
                        emit(e, t) {
                            const i = this.events[e];
                            if (!i) return this;
                            const n = i.slice();
                            for (let e = 0; e < n.length; e++) n[e].call(this, t);
                            return this;
                        }
                    }
                },
                4245: (e, t, i) => {
                    i.d(t, { g: () => o });
                    var n = i(3672);
                    class o {
                        constructor(e = {}) {
                            this.map = e;
                        }
                        set(e, t) {
                            let i = this.map[e.lo];
                            void 0 === i && (i = this.map[e.lo] = {}), (i[e.hi] = t);
                        }
                        get(e) {
                            if (void 0 !== this.map[e.lo]) return this.map[e.lo][e.hi];
                        }
                        serialize() {
                            return this.map;
                        }
                        forEach(e) {
                            for (const t in this.map)
                                for (const i in this.map[t])
                                    e(this.map[t][i], (0, n.Ru)(Number(t), Number(i)));
                        }
                        clear() {
                            this.map = {};
                        }
                    }
                },
                7204: (e, t, i) => {
                    i.d(t, { c: () => n });
                    class n {
                        constructor(e = []) {
                            this.map = {};
                            for (const t of e) this.add(t);
                        }
                        has(e) {
                            const t = this.map[e.hi];
                            return void 0 !== (null == t ? void 0 : t[e.lo]);
                        }
                        hasSome(e) {
                            return e.some((e) => this.has(e));
                        }
                        add(e) {
                            let t = this.map[e.hi];
                            t || (t = this.map[e.hi] = {}), (t[e.lo] = !0);
                        }
                        delete(e) {
                            const t = this.map[e.hi];
                            return !(!t || !t[e.lo]) && delete t[e.lo];
                        }
                        addFromFlatArray(e) {
                            const t = this.map;
                            for (let i = 0; i < e.length / 2; i++) {
                                const n = e[2 * i + 1];
                                let o = t[n];
                                o || (o = t[n] = {}), (o[e[2 * i]] = !0);
                            }
                        }
                        toFlatArray() {
                            const e = this.map,
                                t = [];
                            for (const i in e) {
                                const n = e[i];
                                for (const e in n) t.push(Number(e), Number(i));
                            }
                            return t;
                        }
                    }
                },
                3672: (e, t, i) => {
                    i.d(t, {
                        Ak: () => l,
                        IL: () => c,
                        Ru: () => o,
                        nI: () => r,
                        v7: () => s,
                        y5: () => a,
                    });
                    const n = 1e5;
                    function o(e, t) {
                        return { type: 64, lo: e, hi: t };
                    }
                    function r(e) {
                        return null !== e && 'object' == typeof e && 64 === e.type;
                    }
                    function s(e, t) {
                        return e.lo === t.lo && e.hi === t.hi;
                    }
                    function a(e, t) {
                        if (e.length !== t.length) return !1;
                        for (let i = 0; i < e.length; i++) if (!s(e[i], t[i])) return !1;
                        return !0;
                    }
                    function l(e) {
                        return g(e.lo, e.hi);
                    }
                    function c(e) {
                        const t = y(e);
                        return o(t[0], t[1]);
                    }
                    function d(e) {
                        return [e % n, Math.floor(e / n) % n, 0, 0];
                    }
                    function h(e) {
                        let t = 0;
                        for (let i = 0; i < 4; i++) {
                            const o = 4294967296 * e[i] + t;
                            (t = Math.floor(o / n)), (e[i] = o % n);
                        }
                    }
                    function u(e, t) {
                        const i = 4294967296;
                        let o = 4,
                            r = 0;
                        for (; --o >= 0; ) {
                            const s = r * n + t[o],
                                a = Math.floor(s / i);
                            (r = s - a * i), (e[o] = a);
                        }
                    }
                    function m(e, t) {
                        let i = 0;
                        for (let o = 0; o < 4; o++) {
                            const r = e[o] + t[o] + i;
                            (i = Math.floor(r / n)), (e[o] = r % n);
                        }
                    }
                    function f(e, t) {
                        let i = 0;
                        for (let o = 0; o < 4; o++) {
                            let r = e[o] - t[o] - i;
                            r < 0 ? ((r += n), (i = 1)) : (i = 0), (e[o] = r);
                        }
                    }
                    function p(e) {
                        let t = !0,
                            i = 4,
                            n = '';
                        for (; --i >= 0; ) {
                            const o = String(e[i]);
                            t
                                ? 0 !== e[i] && ((n += o), (t = !1))
                                : (n += '00000'.slice(o.length) + o);
                        }
                        return n.length || (n = '0'), n;
                    }
                    function _(e) {
                        let t = 4,
                            i = 0;
                        for (; --t >= 0; ) i = i * n + e[t];
                        return i;
                    }
                    function v(e) {
                        e = '00000000000000000000'.slice(e.length) + e;
                        const t = [0, 0, 0, 0];
                        for (let i = 0; i < 4; i++) {
                            const n = parseInt(e.slice(5 * i, 5 * (i + 1)), 10);
                            t[3 - i] = n;
                        }
                        return t;
                    }
                    function g(e, t) {
                        const i = d(e),
                            n = d(t);
                        return h(n), m(n, i), p(n);
                    }
                    function y(e) {
                        const t = v(e),
                            i = d(0);
                        u(i, t);
                        const n = _(i);
                        return h(i), f(t, i), [_(t), n];
                    }
                },
                3429: (e, t, i) => {
                    i.d(t, { L: () => o });
                    const n = () => {};
                    class o {
                        constructor(e, t = n) {
                            (this.queue = []),
                                (this.data = {}),
                                (this.size = e),
                                (this.onRemove = t);
                        }
                        add(e, t) {
                            this.data[e] ||
                                (this.queue.push(e), (this.data[e] = t), this.shrink(this.size));
                        }
                        remove(e) {
                            this.data[e] &&
                                (this.queue.splice(this.queue.indexOf(e), 1), delete this.data[e]);
                        }
                        get(e) {
                            const t = this.data[e];
                            return (
                                t &&
                                    (this.queue.splice(this.queue.indexOf(e), 1),
                                    this.queue.push(e)),
                                t
                            );
                        }
                        reset() {
                            this.shrink(0);
                        }
                        setSize(e) {
                            (this.size = e), this.shrink(e);
                        }
                        getSize() {
                            return this.size;
                        }
                        keys() {
                            return this.queue;
                        }
                        getData() {
                            return Object.keys(this.data).map((e) => this.data[e]);
                        }
                        shrink(e) {
                            for (; this.queue.length > e; ) {
                                const e = this.queue.shift(),
                                    t = this.data[e];
                                delete this.data[e], this.onRemove(e, t);
                            }
                        }
                    }
                },
                3487: (e, t, i) => {
                    i.d(t, { c: () => n });
                    class n {
                        constructor(e) {
                            this.map = (null == e ? void 0 : e.map) || {};
                        }
                        set(e, t, i) {
                            void 0 === this.map[e] && (this.map[e] = {}), (this.map[e][t] = i);
                        }
                        get(e, t) {
                            const i = this.map[e];
                            if (void 0 !== i) return i[t];
                        }
                        has(e, t) {
                            const i = this.map[e];
                            return void 0 !== i && void 0 !== i[t];
                        }
                    }
                },
                9981: (e, t, i) => {
                    i.d(t, { aU: () => s, fL: () => r, o1: () => o });
                    var n = i(6273);
                    function o(e) {
                        return n.$U * e;
                    }
                    function r(e) {
                        return e / n.$U;
                    }
                    function s(e) {
                        return !!e.match(
                            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
                        );
                    }
                },
                7609: (e, t, i) => {
                    i.d(t, { Cz: () => h, Ty: () => l, h3: () => d, wu: () => c });
                    var n = i(9218);
                    const o = new Set(n.commercialSublayers),
                        r = new Set(n.commercialCitySublayers),
                        s = new Set(n.personalSublayers),
                        a = new Set(n.landmarkPoiSublayers);
                    function l(e) {
                        return o.has(e);
                    }
                    function c(e) {
                        return r.has(e);
                    }
                    function d(e) {
                        return s.has(e);
                    }
                    function h(e) {
                        return a.has(e);
                    }
                },
                4411: (e, t, i) => {
                    i.d(t, { Z: () => n });
                    class n {
                        constructor(e) {
                            (this.fnRegistry = e),
                                (this.onClassCreate = ({ id: e, name: t, args: i }) => {
                                    const n = this.classes.get(t);
                                    if (!n)
                                        return void console.error(
                                            `ClassRegistry#onClassCreate: class ${t} not found`,
                                        );
                                    const o = n.scope
                                        ? new n.ClassConstructor(n.scope, ...i)
                                        : new n.ClassConstructor(...i);
                                    n.hosts.set(e, o);
                                }),
                                (this.onMethodUse = ({ id: e, name: t, method: i, args: n }) => {
                                    const o = this.classes.get(t);
                                    if (!o)
                                        return void console.error(
                                            `ClassRegistry#onMethodUse: class ${t} not found`,
                                        );
                                    const r = o.hosts.get(e);
                                    if (r) {
                                        if (r[i])
                                            return 'destroy' === i && o.hosts.delete(e), r[i](...n);
                                        console.error(
                                            `ClassRegistry#onMethodUse: method ${i} in instance ${e} in class ${t} not found`,
                                        );
                                    } else
                                        console.error(
                                            `ClassRegistry#onMethodUse: instance ${e} in class ${t} not found`,
                                        );
                                }),
                                (this.classes = new Map()),
                                (this.idCounter = 0),
                                this.fnRegistry.set('createClass', this.onClassCreate),
                                this.fnRegistry.set('classMethodUse', this.onMethodUse);
                        }
                        set(e, t, i) {
                            const n = this,
                                o = {
                                    ClassConstructor: t,
                                    hosts: new Map(),
                                    proxies: new Map(),
                                    scope: i,
                                };
                            return (
                                this.classes.set(e, o),
                                {
                                    get: (i) => {
                                        class o {
                                            constructor(...t) {
                                                (this.id = n.idCounter++),
                                                    n.fnRegistry.get(
                                                        i,
                                                        'createClass',
                                                    )({ id: this.id, args: t, name: e });
                                            }
                                        }
                                        return (
                                            Object.getOwnPropertyNames(t.prototype).forEach((t) => {
                                                'constructor' !== t &&
                                                    (o.prototype[t] = function (...o) {
                                                        return n.fnRegistry.get(
                                                            i,
                                                            'classMethodUse',
                                                        )({
                                                            id: this.id,
                                                            name: e,
                                                            method: t,
                                                            args: o,
                                                        });
                                                    });
                                            }),
                                            o
                                        );
                                    },
                                }
                            );
                        }
                    }
                },
                7256: (e, t, i) => {
                    i.d(t, { D: () => s, H: () => r });
                    var n = i(5549),
                        o = i(3675);
                    class r extends o.c {
                        constructor() {
                            super(), (this.workers = new Map());
                        }
                        addWorker(e, t) {
                            this.workers.set(e, t),
                                t.addEventListener('message', (t) => {
                                    const { to: i, msg: n, transferable: o } = t.data,
                                        r = { from: e, to: i, msg: n, transferable: o };
                                    this.routeMessage(r);
                                });
                        }
                        send(e, t, i) {
                            const o = this.workers.get(e);
                            if (o) {
                                const r = { to: e, from: n.P.Main, msg: t, transferable: i };
                                void 0 !== i ? o.postMessage(r, i) : o.postMessage(r);
                            }
                        }
                        broadcast(e) {
                            this.workers.forEach((t, i) => {
                                const o = { to: i, from: n.P.Main, msg: e };
                                t.postMessage(o);
                            });
                        }
                        routeMessage(e) {
                            const {
                                from: t,
                                to: i,
                                transferable: o,
                                msg: { type: r },
                            } = e;
                            if (i === n.P.Main) this.emit('message', e);
                            else if (i === n.P.All)
                                t !== n.P.Main && this.emit(r, e),
                                    this.workers.forEach((i, n) => {
                                        n !== t &&
                                            (void 0 !== o ? i.postMessage(e, o) : i.postMessage(e));
                                    });
                            else {
                                const t = this.workers.get(i);
                                t && (void 0 !== o ? t.postMessage(e, o) : t.postMessage(e));
                            }
                        }
                    }
                    class s extends o.c {
                        constructor(e) {
                            super(),
                                (this.worker = e),
                                e.addEventListener('message', (e) => {
                                    const t = e.data;
                                    this.emit('message', t);
                                });
                        }
                        send(e, t, i) {
                            const n = { to: e, msg: t, transferable: i };
                            this.worker.postMessage(n, i);
                        }
                        broadcast(e) {
                            const t = { to: n.P.All, msg: e };
                            this.worker.postMessage(t);
                        }
                    }
                },
                4500: (e, t, i) => {
                    i.d(t, { J: () => o });
                    var n = i(5549);
                    class o {
                        constructor(e) {
                            (this.onMessage = (e) => {
                                const { from: t, msg: i } = e;
                                switch (i.type) {
                                    case n.C.FunctionUse:
                                        this.onFunctionUse(i, t);
                                        break;
                                    case n.C.FunctionResult:
                                        this.onFunctionResult(i);
                                }
                            }),
                                (this.connector = e),
                                (this.functions = new Map()),
                                (this.functionIdCounter = 0),
                                (this.pendingFunctions = new Map()),
                                e.on('message', this.onMessage);
                        }
                        set(e, t) {
                            this.functions.set(e, t);
                        }
                        get(e, t) {
                            return (...i) => {
                                const o = this.functionIdCounter++,
                                    r = new Promise((e) => {
                                        this.pendingFunctions.set(o, e);
                                    }),
                                    s = {
                                        type: n.C.FunctionUse,
                                        data: { id: o, name: t, args: i },
                                    };
                                return this.connector.send(e, s), r;
                            };
                        }
                        onFunctionUse(e, t) {
                            const {
                                    data: { name: i, args: n, id: o },
                                } = e,
                                r = this.functions.get(i);
                            if (r) {
                                const e = r(...n);
                                e && e.then
                                    ? Promise.resolve(e).then((e) =>
                                          this.sendFunctionResult(t, o, e),
                                      )
                                    : this.sendFunctionResult(t, o, e);
                            } else
                                console.error(`FnRegistry#onFunctionUse: function ${i} not found`);
                        }
                        sendFunctionResult(e, t, i) {
                            const o = { type: n.C.FunctionResult, data: { id: t, result: i } };
                            i && i.transferable
                                ? this.connector.send(e, o, i.transferable)
                                : this.connector.send(e, o);
                        }
                        onFunctionResult(e) {
                            const {
                                    data: { id: t, result: i },
                                } = e,
                                n = this.pendingFunctions.get(t);
                            n
                                ? (n(i), this.pendingFunctions.delete(t))
                                : console.error(
                                      `FnRegistry#onFunctionResult: pending function ${t} not found`,
                                  );
                        }
                    }
                },
                5549: (e, t, i) => {
                    var n, o;
                    i.d(t, { C: () => o, P: () => n }),
                        (function (e) {
                            (e[(e.Main = 0)] = 'Main'),
                                (e[(e.Parser = 1)] = 'Parser'),
                                (e[(e.Labeling = 2)] = 'Labeling'),
                                (e[(e.All = 3)] = 'All');
                        })(n || (n = {})),
                        (function (e) {
                            (e[(e.FunctionUse = 0)] = 'FunctionUse'),
                                (e[(e.FunctionResult = 1)] = 'FunctionResult');
                        })(o || (o = {}));
                },
                1913: (e, t, i) => {
                    i.d(t, { rS: () => U, U2: () => j, BL: () => B, sT: () => N, Vx: () => Z });
                    var n = {};
                    i.r(n),
                        i.d(n, {
                            ease: () => a,
                            easeInBack: () => z,
                            easeInCirc: () => T,
                            easeInCubic: () => h,
                            easeInElastic: () => k,
                            easeInExpo: () => S,
                            easeInOutBack: () => F,
                            easeInOutCirc: () => L,
                            easeInOutCubic: () => m,
                            easeInOutElastic: () => A,
                            easeInOutExpo: () => M,
                            easeInOutQuad: () => d,
                            easeInOutQuart: () => _,
                            easeInOutQuint: () => y,
                            easeInOutSine: () => x,
                            easeInQuad: () => l,
                            easeInQuart: () => f,
                            easeInQuint: () => v,
                            easeInSine: () => b,
                            easeOutBack: () => C,
                            easeOutBounce: () => O,
                            easeOutCirc: () => P,
                            easeOutCubic: () => u,
                            easeOutElastic: () => E,
                            easeOutExpo: () => I,
                            easeOutQuad: () => c,
                            easeOutQuart: () => p,
                            easeOutQuint: () => g,
                            easeOutSine: () => w,
                            inertia: () => D,
                            linear: () => r,
                        });
                    var o = i(9218);
                    function r(e, t, i, n) {
                        return t + (i / n) * e;
                    }
                    const s = i(6636)(0.25, 0.1, 0.25, 1);
                    function a(e, t, i, n) {
                        return t + i * s(e / n);
                    }
                    function l(e, t, i, n) {
                        return i * (e /= n) * e + t;
                    }
                    function c(e, t, i, n) {
                        return -i * (e /= n) * (e - 2) + t;
                    }
                    function d(e, t, i, n) {
                        return (e /= n / 2) < 1
                            ? (i / 2) * e * e + t
                            : (-i / 2) * (--e * (e - 2) - 1) + t;
                    }
                    function h(e, t, i, n) {
                        return i * (e /= n) * e * e + t;
                    }
                    function u(e, t, i, n) {
                        return i * ((e = e / n - 1) * e * e + 1) + t;
                    }
                    function m(e, t, i, n) {
                        return (e /= n / 2) < 1
                            ? (i / 2) * e * e * e + t
                            : (i / 2) * ((e -= 2) * e * e + 2) + t;
                    }
                    function f(e, t, i, n) {
                        return i * (e /= n) * e * e * e + t;
                    }
                    function p(e, t, i, n) {
                        return -i * ((e = e / n - 1) * e * e * e - 1) + t;
                    }
                    function _(e, t, i, n) {
                        return (e /= n / 2) < 1
                            ? (i / 2) * e * e * e * e + t
                            : (-i / 2) * ((e -= 2) * e * e * e - 2) + t;
                    }
                    function v(e, t, i, n) {
                        return i * (e /= n) * e * e * e * e + t;
                    }
                    function g(e, t, i, n) {
                        return i * ((e = e / n - 1) * e * e * e * e + 1) + t;
                    }
                    function y(e, t, i, n) {
                        return (e /= n / 2) < 1
                            ? (i / 2) * e * e * e * e * e + t
                            : (i / 2) * ((e -= 2) * e * e * e * e + 2) + t;
                    }
                    function b(e, t, i, n) {
                        return -i * Math.cos((e / n) * (Math.PI / 2)) + i + t;
                    }
                    function w(e, t, i, n) {
                        return i * Math.sin((e / n) * (Math.PI / 2)) + t;
                    }
                    function x(e, t, i, n) {
                        return (-i / 2) * (Math.cos((Math.PI * e) / n) - 1) + t;
                    }
                    function S(e, t, i, n) {
                        return 0 == e ? t : i * Math.pow(2, 10 * (e / n - 1)) + t;
                    }
                    function I(e, t, i, n) {
                        return e == n ? t + i : i * (1 - Math.pow(2, (-10 * e) / n)) + t;
                    }
                    function M(e, t, i, n) {
                        return 0 == e
                            ? t
                            : e == n
                            ? t + i
                            : (e /= n / 2) < 1
                            ? (i / 2) * Math.pow(2, 10 * (e - 1)) + t
                            : (i / 2) * (2 - Math.pow(2, -10 * --e)) + t;
                    }
                    function T(e, t, i, n) {
                        return -i * (Math.sqrt(1 - (e /= n) * e) - 1) + t;
                    }
                    function P(e, t, i, n) {
                        return i * Math.sqrt(1 - (e = e / n - 1) * e) + t;
                    }
                    function L(e, t, i, n) {
                        return (e /= n / 2) < 1
                            ? (-i / 2) * (Math.sqrt(1 - e * e) - 1) + t
                            : (i / 2) * (Math.sqrt(1 - (e -= 2) * e) + 1) + t;
                    }
                    function k(e, t, i, n) {
                        var o = 1.70158,
                            r = 0,
                            s = i;
                        if (0 == e) return t;
                        if (1 == (e /= n)) return t + i;
                        if ((r || (r = 0.3 * n), s < Math.abs(i))) {
                            s = i;
                            o = r / 4;
                        } else o = (r / (2 * Math.PI)) * Math.asin(i / s);
                        return (
                            -s *
                                Math.pow(2, 10 * (e -= 1)) *
                                Math.sin(((e * n - o) * (2 * Math.PI)) / r) +
                            t
                        );
                    }
                    function E(e, t, i, n) {
                        var o = 1.70158,
                            r = 0,
                            s = i;
                        if (0 == e) return t;
                        if (1 == (e /= n)) return t + i;
                        if ((r || (r = 0.3 * n), s < Math.abs(i))) {
                            s = i;
                            o = r / 4;
                        } else o = (r / (2 * Math.PI)) * Math.asin(i / s);
                        return (
                            s * Math.pow(2, -10 * e) * Math.sin(((e * n - o) * (2 * Math.PI)) / r) +
                            i +
                            t
                        );
                    }
                    function A(e, t, i, n) {
                        var o = 1.70158,
                            r = 0,
                            s = i;
                        if (0 == e) return t;
                        if (2 == (e /= n / 2)) return t + i;
                        if ((r || (r = n * (0.3 * 1.5)), s < Math.abs(i))) {
                            s = i;
                            o = r / 4;
                        } else o = (r / (2 * Math.PI)) * Math.asin(i / s);
                        return e < 1
                            ? s *
                                  Math.pow(2, 10 * (e -= 1)) *
                                  Math.sin(((e * n - o) * (2 * Math.PI)) / r) *
                                  -0.5 +
                                  t
                            : s *
                                  Math.pow(2, -10 * (e -= 1)) *
                                  Math.sin(((e * n - o) * (2 * Math.PI)) / r) *
                                  0.5 +
                                  i +
                                  t;
                    }
                    function z(e, t, i, n, o) {
                        return null == o && (o = 1.70158), i * (e /= n) * e * ((o + 1) * e - o) + t;
                    }
                    function C(e, t, i, n, o) {
                        return (
                            null == o && (o = 1.70158),
                            i * ((e = e / n - 1) * e * ((o + 1) * e + o) + 1) + t
                        );
                    }
                    function F(e, t, i, n, o) {
                        return (
                            null == o && (o = 1.70158),
                            (e /= n / 2) < 1
                                ? (i / 2) * (e * e * ((1 + (o *= 1.525)) * e - o)) + t
                                : (i / 2) * ((e -= 2) * e * ((1 + (o *= 1.525)) * e + o) + 2) + t
                        );
                    }
                    function O(e, t, i, n) {
                        return (e /= n) < 1 / 2.75
                            ? i * (7.5625 * e * e) + t
                            : e < 2 / 2.75
                            ? i * (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) + t
                            : e < 2.5 / 2.75
                            ? i * (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) + t
                            : i * (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375) + t;
                    }
                    function D(e, t, i, n) {
                        return i * (1 - Math.pow(1 - e / n, o.inertia.nonLinearity + 1)) + t;
                    }
                    const R = {
                        easing: 'easeInOutQuad',
                        forceFinalValue: !0,
                        renderAfterUpdate: !0,
                    };
                    function j(e, t) {
                        return t.tickers[e];
                    }
                    function B(e, t, i, n, o, r, s) {
                        let a;
                        t.animationGroup &&
                            (a = Object.keys(i.tickers).filter(
                                (e) => i.tickers[e].animationGroup === t.animationGroup,
                            )),
                            (i.tickers[e] = Object.assign(Object.assign(Object.assign({}, R), t), {
                                from: n,
                                to: o,
                                duration: r,
                                attributes: s,
                                startTime: i.time,
                                alreadyStartedGroupTickers: a,
                            }));
                    }
                    function N(e, t) {
                        delete t.tickers[e];
                    }
                    function U(e, t) {
                        return !!t.tickers[e];
                    }
                    function Z(e, t, i) {
                        const n = i.tickers[e];
                        if (!n) return;
                        if (
                            n.alreadyStartedGroupTickers &&
                            n.alreadyStartedGroupTickers.some((e) => !!i.tickers[e])
                        )
                            return void (n.startTime = i.time);
                        const o = i.time - n.startTime;
                        let r;
                        if (n.from.length) {
                            r = [];
                            for (let e = 0; e < n.from.length; e++) {
                                const t = H(n.easing, n.from[e], n.to[e], n.duration, o);
                                r.push(t);
                            }
                        } else r = H(n.easing, n.from, n.to, n.duration, o);
                        let s = !1;
                        o >= n.duration && (n.forceFinalValue && (r = n.to), (s = !0)),
                            t.step && t.step(i, r, n.attributes),
                            s && (N(e, i), t.complete && t.complete(i)),
                            n.renderAfterUpdate && (i.needRerender = !0);
                    }
                    function H(e, t, i, o, r) {
                        return n[e](r, t, i - t, o);
                    }
                },
                6392: (e, t, i) => {
                    i.d(t, {
                        Bs: () => v,
                        C5: () => G,
                        CJ: () => x,
                        HL: () => A,
                        IR: () => q,
                        Kn: () => w,
                        L7: () => N,
                        Ny: () => T,
                        Oy: () => W,
                        Sl: () => M,
                        VV: () => I,
                        VW: () => V,
                        Z$: () => j,
                        _W: () => K,
                        a2: () => U,
                        aM: () => O,
                        aq: () => Z,
                        b5: () => P,
                        cL: () => b,
                        gx: () => g,
                        hm: () => H,
                        iq: () => J,
                        pV: () => C,
                        qu: () => D,
                        rL: () => E,
                        vX: () => R,
                        vl: () => y,
                        x7: () => Y,
                        xG: () => F,
                        xH: () => S,
                        z6: () => X,
                    });
                    var n = i(378),
                        o = i(9450),
                        r = i(4716),
                        s = i(6208),
                        a = i.n(s),
                        l = i(7188),
                        c = i(2435),
                        d = i(267),
                        h = i(9748),
                        u = i(6273),
                        m = i(8194),
                        f = i(9073),
                        p = i(9218);
                    const _ = [0, 0, 0];
                    function v(e) {
                        return { coords: e, size: Z(e[2]), offset: W(e) };
                    }
                    function g(e) {
                        return `${e[0]}_${e[1]}_${e[2]}_${e[3]}`;
                    }
                    function y(e, t) {
                        return `${g(e)}_${t.stringify()}`;
                    }
                    function b(e) {
                        const t = e.split('_');
                        return [
                            parseInt(t[0], 10),
                            parseInt(t[1], 10),
                            parseInt(t[2], 10),
                            parseInt(t[3], 10),
                        ];
                    }
                    function w(e) {
                        return p.tiles.subdomains[
                            Math.abs(e[0] + e[1]) % p.tiles.subdomains.length
                        ];
                    }
                    function x(e) {
                        const t = new (a())(e),
                            i = h.F.read(t),
                            { x: n, y: o, zoom: r, tiles: s } = i.tileGroups[0];
                        return s.map(
                            ({ regionId: e, hash: t, data: i }) => (
                                i ||
                                    (console.warn(
                                        `Tile ${r}_${n}_${o} from region ${e} is corrupt (has no data)`,
                                    ),
                                    (i = new Uint8Array(0))),
                                { data: i, regionId: e, metatileHash: (0, l.SD)(t) }
                            ),
                        );
                    }
                    function S(e) {
                        return e.map((e) => ({
                            regionId: e.regionId,
                            metatileHash: e.metatileHash,
                        }));
                    }
                    function I(e) {
                        const t = 4 * Math.ceil(e.byteLength / 4),
                            i = new ArrayBuffer(t);
                        return new Uint8Array(i).set(e), i;
                    }
                    function M(e) {
                        const [t, i, n] = e;
                        return { min: W([t, i, n, n]), max: W([t + 1, i + 1, n, n]) };
                    }
                    function T(e, t) {
                        const i = M(e);
                        return (0, d.M4)(t, i);
                    }
                    function P(e, t, i, n) {
                        const o = (0, d.BS)(e.tilesBounds),
                            r = Z(t),
                            s = Math.pow(2, t) - 1,
                            a = Math.max(Math.floor((o.min[0] + u.ed) / r), 0),
                            l = Math.min(Math.floor((o.max[0] + u.ed) / r), s),
                            c = Math.max(Math.floor((o.min[1] + u.ed) / r), 0),
                            h = Math.min(Math.floor((o.max[1] + u.ed) / r), s),
                            m = [];
                        for (let i = a; i <= l; i++)
                            for (let o = c; o <= h; o++) {
                                const r = [i, o, t, n];
                                T(r, e.tilesBounds) && m.push(r);
                            }
                        return (
                            e.demMode &&
                                (function (e, t, i, n, o) {
                                    const r = e.reduce((e, t) => (e.add(g(t)), e), new Set()),
                                        s = new Set(),
                                        a = (0, d.By)(t.tilesBounds);
                                    let l = e.slice();
                                    for (let c = i; c >= n; c--) {
                                        let n = 0;
                                        const h = [];
                                        l.forEach((i) => {
                                            const o = L(i),
                                                a = g(o);
                                            s.has(a) ||
                                                (h.push(o),
                                                s.add(a),
                                                k(o, (i) => {
                                                    const o = g(i);
                                                    r.has(o) ||
                                                        s.has(o) ||
                                                        !T(i, t.demTilesBounds) ||
                                                        (e.push(i), r.add(o), n++);
                                                }));
                                        });
                                        const m = Z(c - 1);
                                        (0, d.mW)(a, m, t.center);
                                        const f = (0, d.BS)(a),
                                            p = Math.pow(2, i) - 1,
                                            _ = Math.max(Math.floor((f.min[0] + u.ed) / m), 0),
                                            v = Math.min(Math.floor((f.max[0] + u.ed) / m), p),
                                            y = Math.max(Math.floor((f.min[1] + u.ed) / m), 0),
                                            b = Math.min(Math.floor((f.max[1] + u.ed) / m), p);
                                        for (let e = _; e <= v; e++)
                                            for (let t = y; t <= b; t++) {
                                                const i = [e, t, c - 1, o],
                                                    r = g(i);
                                                !s.has(r) && T(i, a) && (h.push(i), n++);
                                            }
                                        if (!n) break;
                                        l = h;
                                    }
                                })(m, e, t, i, n),
                            m
                        );
                    }
                    function L(e, t = 1) {
                        const [i, n, o, r] = e,
                            s = Math.pow(2, t);
                        return [Math.trunc(i / s), Math.trunc(n / s), o - t, r];
                    }
                    function k(e, t) {
                        let [i, n, o] = e;
                        const r = e[3];
                        (i *= 2),
                            (n *= 2),
                            o++,
                            t([i, n, o, r]),
                            t([i + 1, n, o, r]),
                            t([i, n + 1, o, r]),
                            t([i + 1, n + 1, o, r]);
                    }
                    function E(e, t, i, n, o, s, l, d, u, m) {
                        const f = new (a())(),
                            p = { tiles: [{ x: o[0], y: o[1], zoom: o[2] }] };
                        return (
                            h.w.write(p, f),
                            (0, c.Gr)('tiles', {
                                host: e,
                                tileSet: t,
                                tileKey: s,
                                sessionId: m,
                                protocol: i,
                                appId: l,
                                lang: d,
                                defaultLang: u,
                                subdomain: n[Math.abs(o[0] + o[1]) % n.length],
                                request: encodeURIComponent(r.c(f.finish())),
                            })
                        );
                    }
                    function A(e, t) {
                        const i = e.coords,
                            n = t.coords,
                            o = i[2],
                            r = n[2];
                        return o === r ? i[0] === n[0] && i[1] === n[1] : o < r ? z(e, t) : z(t, e);
                    }
                    function z(e, t) {
                        if (t.zoomLevel < e.zoomLevel) return !1;
                        if (t.zoomLevel === e.zoomLevel)
                            return (
                                t.coords[0] === e.coords[0] &&
                                t.coords[1] === e.coords[1] &&
                                t.detailLevel > e.detailLevel
                            );
                        const i = Math.pow(2, t.coords[2] - e.coords[2]),
                            n = e.coords[0] * i,
                            o = n + i,
                            r = e.coords[1] * i,
                            s = r + i,
                            a = t.coords[0],
                            l = t.coords[1];
                        return a >= n && a < o && l >= r && l < s;
                    }
                    function C(e, t, i) {
                        const { coords: n } = e,
                            o = Math.min(t, i),
                            r = Math.pow(2, e.zoomLevel - o);
                        return g([Math.floor(n[0] / r), Math.floor(n[1] / r), o, t]);
                    }
                    function F(e, t, i, n) {
                        return e[C(t, i, n)];
                    }
                    function O(e, t) {
                        const i = [];
                        for (const n in e) {
                            const o = e[n];
                            z(t, o) && i.push(o);
                        }
                        return i;
                    }
                    function D(e, t, i) {
                        return n.TE(e, $(t.coords)) - n.TE(e, $(i.coords));
                    }
                    function R(e, t) {
                        return e.filter((e) => t.has(e));
                    }
                    function j(e, t, i) {
                        (e[0] = (t[0] * i.size) / u.Bq + i.offset[0]),
                            (e[1] = (t[1] * i.size) / u.Bq + i.offset[1]),
                            (e[2] = (t[2] * u._9) / u.Bq);
                    }
                    const B = o.Ue();
                    function N(e, t, i, n) {
                        var o;
                        (B[0] = t[0][i]),
                            (B[1] = t[1][i]),
                            (B[2] = (null !== (o = t[2]) && void 0 !== o ? o : [])[i]),
                            j(e, B, n);
                    }
                    function U(e, t, i) {
                        (e[0] = ((t[0] - i.offset[0]) * u.Bq) / i.size),
                            (e[1] = ((t[1] - i.offset[1]) * u.Bq) / i.size),
                            (e[2] = (t[2] * u.Bq) / u._9);
                    }
                    function Z(e) {
                        return Math.pow(2, 32 - e);
                    }
                    function H(e) {
                        return e[0] >= 0 && e[0] <= u.Bq && e[1] >= 0 && e[1] <= u.Bq;
                    }
                    function G(e, t) {
                        return (e * u.sX) / (u.Bq * Math.pow(2, t));
                    }
                    function V(e) {
                        return (e / u._9) * u.Bq;
                    }
                    function W(e) {
                        const t = Z(e[2]),
                            i = 2147483648;
                        return o.al(e[0] * t - i, e[1] * t - i, 0);
                    }
                    function q(e) {
                        const t = 2147483648;
                        return [e[0] + t, e[1] + t, 32, 32];
                    }
                    function $(e) {
                        const t = Z(e[2]),
                            i = 2147483648;
                        return o.al((e[0] + 0.5) * t - i, (e[1] + 0.5) * t - i, 0);
                    }
                    function X(e, t) {
                        const i = 2147483648,
                            n = Z(t);
                        return [(e[0] - n / 2 + i) / n, (e[1] - n / 2 + i) / n, t, t];
                    }
                    function Y(e, t = 1) {
                        const i = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], 1) * t,
                            o = 32 - Math.log(i) / Math.LN2,
                            r = n.Ue();
                        return (0, m.be)(r, e), X(r, o);
                    }
                    const K = (e) => {
                            const [t, i, n, o] = e;
                            return [t, Math.pow(2, n) - 1 - i, n, o];
                        },
                        J = (e, t) => {
                            j(_, t, e);
                            const i = (0, f.PA)(_);
                            return (0, f.Xg)(i[1]);
                        };
                },
                9476: (e, t, i) => {
                    function n(e, t, i) {
                        let n, o, r, s;
                        const a = function () {
                            const l = Date.now() - r;
                            l < t && l >= 0
                                ? (n = setTimeout(a, t - l))
                                : ((n = null), i || ((s = e(...o)), n || (o = null)));
                        };
                        return function (...l) {
                            (o = l), (r = Date.now());
                            const c = i && !n;
                            return n || (n = setTimeout(a, t)), c && ((s = e(...o)), (o = null)), s;
                        };
                    }
                    i.d(t, { D: () => n });
                },
                6874: (e, t, i) => {
                    i.d(t, { H: () => s, f: () => o });
                    let n = 1;
                    function o() {
                        return n++;
                    }
                    let r = 3;
                    const s = () => r++;
                },
                2435: (e, t, i) => {
                    i.d(t, { Gr: () => l, IG: () => c, Nt: () => a, Sy: () => d, XK: () => r });
                    var n = i(9218);
                    const o = /\{(\w+)\}/g;
                    function r(e, t) {
                        return e.replace(o, (e, i) => t[i]);
                    }
                    function s(e) {
                        const [t, i] = e.split('?');
                        if (!i) return t;
                        const n = i
                            .split('&')
                            .map((e) => e.split('='))
                            .filter(([, e]) => 'undefined' !== e)
                            .map((e) => e.join('='))
                            .join('&');
                        return n.length ? `${t}?${n}` : t;
                    }
                    function a(e, t) {
                        return ('object' == typeof e ? e.url : n.urls[e])
                            .replace(o, (e, i) => {
                                var n;
                                return null !== (n = t[i]) && void 0 !== n ? n : e;
                            })
                            .replace(o, (e, i) => {
                                var n;
                                return null !== (n = t[i]) && void 0 !== n ? n : e;
                            });
                    }
                    function l(e, t) {
                        const i = r(t.host, { subdomain: t.subdomain });
                        return s(r(n.urls[e], Object.assign(Object.assign({}, t), { host: i })));
                    }
                    function c(e, t) {
                        return s(r(e, t));
                    }
                    function d(e, t) {
                        let i = 0;
                        for (let e = 0; e < t.length; e++) i += t.charCodeAt(e);
                        return e[i % e.length];
                    }
                },
                2618: (e, t, i) => {
                    i.d(t, { TD: () => c, gl: () => o });
                    var n = i(6273);
                    const o = 4294967295,
                        r = o - 1,
                        s = {},
                        a = ['main', 'parser', 'labeling'];
                    let l = 0;
                    a.forEach((e) => {
                        const t = l + Math.floor(r / a.length);
                        (s[e] = { min: l, max: t - 1e6 }), (l = t);
                    });
                    class c {
                        constructor(e) {
                            (this.ids = []),
                                (this.phases = []),
                                (this.sublayers = []),
                                (this.styleIds = []),
                                (this.layerIds = []),
                                (this.instanceIds = []),
                                (this.objectClasses = []),
                                (this.floorIds = []),
                                (this.center = []),
                                (this.strings = {}),
                                (this.minIdentifyIndex = s[e].min),
                                (this.maxIdentifyIndex = s[e].max),
                                (this.index = this.minIdentifyIndex);
                        }
                        getIndex(e) {
                            var t, i, r, s, a, l, c, d, h, u;
                            if ('number' == typeof e.id) return o;
                            const m = this.index + this.ids.length / 2;
                            this.ids.push(e.id.lo, e.id.hi),
                                this.floorIds.push(
                                    null !==
                                        (i =
                                            null === (t = e.floorId) || void 0 === t
                                                ? void 0
                                                : t.lo) && void 0 !== i
                                        ? i
                                        : o,
                                    null !==
                                        (s =
                                            null === (r = e.floorId) || void 0 === r
                                                ? void 0
                                                : r.hi) && void 0 !== s
                                        ? s
                                        : o,
                                ),
                                this.phases.push(e.layer.renderIndex),
                                this.sublayers.push(
                                    null !==
                                        (c =
                                            null ===
                                                (l =
                                                    null === (a = e.metatile) || void 0 === a
                                                        ? void 0
                                                        : a.dictionaries.db_sublayer) ||
                                            void 0 === l
                                                ? void 0
                                                : l[e.sublayer]) && void 0 !== c
                                        ? c
                                        : NaN,
                                ),
                                this.styleIds.push(e.styleId),
                                this.layerIds.push(e.layer.innerId),
                                this.instanceIds.push(
                                    null !== (d = e.instanceId) && void 0 !== d ? d : 0,
                                );
                            const { center: f, objectClass: p } = e;
                            if (
                                (f
                                    ? this.center.push(Math.round(f[0]), Math.round(f[1]))
                                    : this.center.push(n.Cd, n.Cd),
                                'string' == typeof p)
                            ) {
                                const t =
                                    null ===
                                        (u =
                                            null === (h = e.metatile) || void 0 === h
                                                ? void 0
                                                : h.dictionaries.db_object_class) || void 0 === u
                                        ? void 0
                                        : u[p];
                                t
                                    ? this.objectClasses.push(t)
                                    : (this.objectClasses.push(0),
                                      (this.strings[m] = { objectClass: p }));
                            } else this.objectClasses.push(o);
                            return m;
                        }
                        getPacked() {
                            const e = new Uint32Array(this.ids).buffer,
                                t = new Uint32Array(this.floorIds).buffer,
                                i = new Float32Array(this.phases).buffer,
                                n = new Uint32Array(this.sublayers).buffer,
                                o = new Uint16Array(this.styleIds).buffer,
                                r = new Uint32Array(this.layerIds).buffer,
                                s = new Uint8Array(this.instanceIds).buffer,
                                a = new Uint32Array(this.objectClasses).buffer,
                                l = new Int32Array(this.center).buffer,
                                c = this.index,
                                d = this.index + this.ids.length - 1;
                            (this.index = this.index + this.ids.length),
                                this.index > this.maxIdentifyIndex &&
                                    (this.index = this.minIdentifyIndex);
                            const h = this.strings;
                            return (
                                (this.ids = []),
                                (this.floorIds = []),
                                (this.phases = []),
                                (this.sublayers = []),
                                (this.styleIds = []),
                                (this.layerIds = []),
                                (this.instanceIds = []),
                                (this.objectClasses = []),
                                (this.strings = {}),
                                (this.center = []),
                                {
                                    idBuffer: e,
                                    floorIdBuffer: t,
                                    startIndex: c,
                                    endIndex: d,
                                    phaseBuffer: i,
                                    sublayerBuffer: n,
                                    styleIdBuffer: o,
                                    layerIdBuffer: r,
                                    instanceIdBuffer: s,
                                    objectClassBuffer: a,
                                    centerBuffer: l,
                                    strings: h,
                                }
                            );
                        }
                    }
                },
                8575: (e, t, i) => {
                    i.d(t, { P: () => y });
                    var n = i(4372);
                    const o = 0.8;
                    class r {
                        constructor(e, t) {
                            (this.offset = 0),
                                (this.stride = t),
                                (this.buffer = new ArrayBuffer(e)),
                                (this.view = new Int32Array(this.buffer)),
                                (this.comittedOffsets = 0),
                                (this.watermark = (e / t) * o);
                        }
                        extend() {
                            const e = 2 * this.buffer.byteLength;
                            this.watermark = (e / this.stride) * o;
                            const t = new ArrayBuffer(e),
                                i = new Int32Array(t);
                            return i.set(this.view), (this.buffer = t), (this.view = i), t;
                        }
                    }
                    class s {
                        constructor(e) {
                            (this.offset = 0),
                                (this.buffer = new Int32Array(e)),
                                (this.comittedOffsets = 0),
                                (this.watermark = e * o);
                        }
                        extend() {
                            const e = 2 * this.buffer.length;
                            this.watermark = e * o;
                            const t = new Int32Array(e);
                            t.set(this.buffer), (this.buffer = t);
                        }
                    }
                    class a {
                        constructor(e, t, i, o, a) {
                            this.drawMode = a;
                            const l = 'buildingModel' !== e ? 67200 : 336e3,
                                c = (0, n.vP)(e, t);
                            (this.elements = new r(l, c)),
                                (this.indices = new s((2 * l) / c)),
                                (this.views = {}),
                                (this.binder = o),
                                o(this, this.elements.buffer),
                                (this.attributes = i);
                        }
                        resetOffsets() {
                            (this.elements.offset = 0),
                                (this.elements.comittedOffsets = 0),
                                (this.indices.offset = 0),
                                (this.indices.comittedOffsets = 0);
                        }
                        commit() {
                            (this.elements.comittedOffsets = this.elements.offset),
                                (this.indices.comittedOffsets = this.indices.offset);
                        }
                        rollback() {
                            (this.elements.offset = this.elements.comittedOffsets),
                                (this.indices.offset = this.indices.comittedOffsets);
                        }
                        checkWatermarks() {
                            let e = 0;
                            const t = this.elements;
                            t.offset > t.watermark &&
                                (t.offset >= t.buffer.byteLength / t.stride && (e = 1),
                                this.binder(this, t.extend()));
                            const i = this.indices;
                            return (
                                i.offset > i.watermark &&
                                    (i.offset >= i.buffer.length && (e = 1), i.extend()),
                                e
                            );
                        }
                    }
                    var l = i(2618),
                        c = i(9899),
                        d = i(9218),
                        h = i(7486);
                    class u {
                        constructor() {
                            (this.packer = new c.Z(d.atlasSize[0], d.atlasSize[1])),
                                (this.currentAtlasIndex = 0),
                                (this.packedRasters = []),
                                (this.rastersToLoad = []),
                                (this.newRasterSets = new Map());
                        }
                        addNewRasterSet(e, t) {
                            let i = this.newRasterSets.get(e);
                            i || ((i = []), this.newRasterSets.set(e, i)), i.push(t);
                        }
                        pack(e, t, i) {
                            e.isSvg
                                ? this.packSvg(
                                      e,
                                      t.map((e) => ({ w: e, h: e })),
                                      i,
                                  )
                                : this.packPng(e, t, i);
                        }
                        packSvg(e, t, i) {
                            const { rasters: n } = e,
                                o = new Set();
                            for (const { w: e, h: t } of n) o.add(`${e}_${t}`);
                            for (const r of t) {
                                const t = r.w * i,
                                    s = r.h * i;
                                if (o.has(`${t}_${s}`)) continue;
                                let a = this.packer.packOne(t + 2, s + 2);
                                null === a &&
                                    ((this.packer = new c.Z(d.atlasSize[0], d.atlasSize[1])),
                                    this.currentAtlasIndex++,
                                    (a = this.packer.packOne(t + 2, s + 2)));
                                const l = n.length,
                                    h = {
                                        rasterSetIndex: e.index,
                                        rasterIndex: l,
                                        w: t,
                                        h: s,
                                        x: a.x + 1,
                                        y: a.y + 1,
                                        anchorX: e.anchorX,
                                        anchorY: e.anchorY,
                                        atlasIndex: this.currentAtlasIndex,
                                        isPacked: !0,
                                    };
                                n.push(h),
                                    this.packedRasters.push(
                                        e.index,
                                        l,
                                        h.x,
                                        h.y,
                                        h.w,
                                        h.h,
                                        this.currentAtlasIndex,
                                    );
                            }
                        }
                        addRastersToLoad(e, t) {
                            this.rastersToLoad.push(e, t.rasterSetIndex, t.rasterIndex);
                        }
                        getNewRasterSets() {
                            const e = this.newRasterSets;
                            return (this.newRasterSets = new Map()), e;
                        }
                        getPackedRasters() {
                            if (0 === this.packedRasters.length) return;
                            const e = new Uint16Array(this.packedRasters);
                            return (this.packedRasters = []), e;
                        }
                        getRastersToLoad() {
                            const e = new Float64Array(this.rastersToLoad);
                            return (this.rastersToLoad = []), e;
                        }
                        packPng(e, t, i) {
                            const { rasters: n } = e;
                            for (const o of t) {
                                const t = o * i,
                                    r = (0, h.Bl)(n, t, !1);
                                if (void 0 === r) continue;
                                const s = e.rasters[r];
                                if (s.isPacked) continue;
                                let a = this.packer.packOne(s.w + 2, s.h + 2);
                                null === a &&
                                    ((this.packer = new c.Z(d.atlasSize[0], d.atlasSize[1])),
                                    this.currentAtlasIndex++,
                                    (a = this.packer.packOne(s.w + 2, s.h + 2))),
                                    (s.x = a.x + 1),
                                    (s.y = a.y + 1),
                                    (s.atlasIndex = this.currentAtlasIndex),
                                    (s.isPacked = !0),
                                    this.packedRasters.push(
                                        e.index,
                                        r,
                                        s.x,
                                        s.y,
                                        s.w,
                                        s.h,
                                        this.currentAtlasIndex,
                                    );
                            }
                        }
                    }
                    var m = i(2702),
                        f = i(4245),
                        p = i(6273),
                        _ = i(3672);
                    const v = Math.pow(2, 32) - 1;
                    class g {
                        constructor() {
                            (this.colorById = new Map()), (this.index = 0);
                        }
                        getIndex(e) {
                            if ('number' == typeof e) return this.nextIndex();
                            const t = 'string' == typeof e ? e : (0, _.Ak)(e),
                                i = this.colorById.get(t);
                            if (void 0 !== i) return i;
                            const n = this.nextIndex();
                            return this.colorById.set(t, n), n;
                        }
                        nextIndex() {
                            return ++this.index % v;
                        }
                    }
                    class y {
                        constructor(e) {
                            (this.atlasPacker = new u()),
                                (this.buildingPointIndexer = new g()),
                                (this.geoIds = new Uint32Array(0)),
                                (this.floorHidingMap = new f.g()),
                                (this.modelsToLoad = new Set()),
                                (this.dataModels = new Map()),
                                (this.dataModelsIndex = 0),
                                (this.addedBuckets = []),
                                (this.labels = []),
                                (this.idIndexer = new l.TD(e)),
                                (this.buckets = {}),
                                this.reset();
                        }
                        reset() {
                            (this.buckets = {}),
                                (this.addedBuckets = []),
                                (this.geoIds = new Uint32Array(0)),
                                this.floorHidingMap.clear(),
                                (this.labels = []),
                                this.modelsToLoad.clear();
                        }
                        addLabel(e) {
                            this.labels.push(e);
                        }
                        addModelToLoad(e) {
                            this.modelsToLoad.add(e);
                        }
                        addModelToLoadByUrl(e) {
                            const t = this.dataModels.get(e);
                            if (t) return t;
                            this.dataModelsIndex++;
                            const i = -this.dataModelsIndex;
                            return this.dataModels.set(e, i), i;
                        }
                        getDataModelUrl(e) {
                            let t;
                            return (
                                this.dataModels.forEach((i, n) => {
                                    i === e && (t = n);
                                }),
                                t
                            );
                        }
                        getBucket(e, t, i, n, o = p.Fg) {
                            let r = this.buckets[e];
                            void 0 === r && ((r = {}), (this.buckets[e] = r));
                            let s = r[t];
                            void 0 === s && (s = r[t] = []);
                            for (let e = s.length - 1; e >= 0; e--) {
                                const t = s[e];
                                if ((0, m.wy)(i, t.attributes)) return this.addedBuckets.push(t), t;
                            }
                            const l = new a(e, t, i, n, o);
                            return s.push(l), this.addedBuckets.push(l), l;
                        }
                        isOverloaded() {
                            const e = this.addedBuckets;
                            let t = 0,
                                i = 0;
                            for (; i < e.length; ) t += e[i++].checkWatermarks();
                            const n = t > 0;
                            if (n) for (; i--; ) e[i].rollback();
                            else for (; i--; ) e[i].commit();
                            return (e.length = 0), n;
                        }
                        setGeoIds(e) {
                            this.geoIds = e;
                        }
                        addFloorHidingMap(e, t) {
                            let i = this.floorHidingMap.get(t);
                            void 0 === i && (i = []),
                                i.push(e.lo, e.hi),
                                this.floorHidingMap.set(t, i);
                        }
                        getAccumulatedData() {
                            const e = this.buckets,
                                t = [],
                                i = [];
                            for (const o in e) {
                                const r = o,
                                    s = e[r];
                                if (s)
                                    for (const e in s) {
                                        const o = e,
                                            a = s[o];
                                        if (!a) continue;
                                        const l = (0, n.vP)(r, o) / 4;
                                        let c = 0;
                                        for (let e = 0; e < a.length; e++) c += a[e].indices.offset;
                                        if (0 === c) continue;
                                        const d = [],
                                            h = new Int32Array(c * l);
                                        let u = 0;
                                        for (let e = 0; e < a.length; e++) {
                                            const t = a[e],
                                                {
                                                    elements: i,
                                                    indices: n,
                                                    attributes: o,
                                                    meta: r,
                                                } = t,
                                                { view: s } = i,
                                                { buffer: c } = n;
                                            if (0 === i.offset) continue;
                                            const m = u;
                                            for (let e = 0; e < n.offset; e++) {
                                                const t = c[e] * l;
                                                for (let e = 0; e < l; e++) h[u++] = s[t + e];
                                            }
                                            d.push({
                                                attributes: o,
                                                drawMode: t.drawMode,
                                                rangeStart: 4 * m,
                                                rangeEnd: 4 * u,
                                                meta: r,
                                            }),
                                                t.resetOffsets();
                                        }
                                        t.push({
                                            symbol: r,
                                            sink: o,
                                            buffer: h.buffer,
                                            generatedObjects: d,
                                        }),
                                            i.push(h.buffer);
                                    }
                            }
                            const o = this.idIndexer.getPacked();
                            i.push(o.idBuffer, o.phaseBuffer, o.floorIdBuffer);
                            const r = this.atlasPacker.getPackedRasters();
                            void 0 !== r && i.push(r.buffer);
                            const s = this.atlasPacker.getRastersToLoad();
                            i.push(s.buffer);
                            const a = new Int32Array(this.modelsToLoad);
                            i.push(a.buffer), (this.modelsToLoad = new Set());
                            const l = new Uint32Array(this.geoIds);
                            i.push(l.buffer);
                            const c = this.floorHidingMap.serialize();
                            this.floorHidingMap.clear();
                            const d = this.labels;
                            return (
                                (this.labels = []),
                                {
                                    data: t,
                                    labels: d,
                                    geoIds: l,
                                    floorHidingMap: c,
                                    packedRasters: r,
                                    rastersToLoad: s,
                                    modelsToLoad: a,
                                    identifyIds: o,
                                    transferable: i,
                                }
                            );
                        }
                    }
                },
                5317: (e, t, i) => {
                    i.d(t, { x: () => l });
                    var n = i(2153),
                        o = i(3754),
                        r = i(1245),
                        s = i(6336);
                    const a = new Map();
                    class l {
                        constructor(e, t, i, l, c, d) {
                            switch (
                                ((this.anchorWorld = [0, 0, 0, 0]),
                                (this.groupPriority = 0),
                                (this.labelingGroup = o.T_),
                                (this.marginTopBottom = 0),
                                (this.marginLeftRight = 0),
                                (this.elevation = 0),
                                (this.type = t),
                                (this.label = e),
                                (this.layer = e.layer),
                                (this.elevation = e.elevation),
                                (this.id =
                                    e.id +
                                    '_' +
                                    t +
                                    '_' +
                                    Math.floor(i[0] / 1e3) +
                                    '_' +
                                    Math.floor(i[1] / 1e3) +
                                    this.getIconLabelPriorityToId(e)),
                                r.JG(this.anchorWorld, i),
                                0 !== l && (this.anchorWorld[2] *= l),
                                (this.anchorScreen = c.project([
                                    this.anchorWorld[0],
                                    this.anchorWorld[1],
                                    this.anchorWorld[2] + this.elevation,
                                    0,
                                ])),
                                (this.anchorPosition = 0),
                                (this.anchorSegmentIndex = 0),
                                (this.halfLabelWidth = 0),
                                (this.commPriorityRandomFactor = NaN),
                                (this.itemPriority =
                                    t === n.Dl.Icon ? e.iconPriority : e.labelPriority),
                                this.layer.type)
                            ) {
                                case 'labelLine':
                                    (this.labelingGroup = this.layer.style.labelingGroup),
                                        (this.groupPriority = this.layer.style.textPriority);
                                    break;
                                case 'oneWayLine':
                                    (this.labelingGroup = this.layer.style.labelingGroup),
                                        (this.groupPriority = this.layer.style.priority);
                                    break;
                                case 'point':
                                    if (
                                        e.pointType === n.a_.Commercial ||
                                        e.pointType === n.a_.CommercialCity
                                    )
                                        if (a.has(this.label.id))
                                            this.commPriorityRandomFactor = a.get(this.label.id);
                                        else {
                                            const e = (0, s.M)();
                                            (this.commPriorityRandomFactor = e),
                                                a.set(this.label.id, e);
                                        }
                                    t === n.Dl.PoiText
                                        ? ((this.labelingGroup = this.layer.style.allowOverlap
                                              ? o.R_
                                              : this.layer.style.textLabelingGroup),
                                          (this.groupPriority = this.layer.style.iconImage
                                              ? Math.min(
                                                    this.layer.style.textPriority,
                                                    this.layer.style.iconPriority,
                                                )
                                              : this.layer.style.textPriority),
                                          (this.marginTopBottom =
                                              this.layer.style.textLabelingMargin.topBottom),
                                          (this.marginLeftRight =
                                              this.layer.style.textLabelingMargin.leftRight))
                                        : t === n.Dl.PoiText2
                                        ? ((this.labelingGroup = this.layer.style.allowOverlap
                                              ? o.R_
                                              : this.layer.style.textLabelingGroup2),
                                          (this.groupPriority = Math.min(
                                              this.layer.style.textPriority,
                                              this.layer.style.iconPriority,
                                          )),
                                          (this.marginTopBottom =
                                              this.layer.style.textLabelingMargin.topBottom),
                                          (this.marginLeftRight =
                                              this.layer.style.textLabelingMargin.leftRight))
                                        : ((this.labelingGroup = this.layer.style.allowOverlap
                                              ? o.R_
                                              : this.layer.style.iconLabelingGroup),
                                          (this.groupPriority = this.layer.style.iconPriority),
                                          (this.marginTopBottom =
                                              this.layer.style.iconLabelingMargin.topBottom),
                                          (this.marginLeftRight =
                                              this.layer.style.iconLabelingMargin.leftRight));
                            }
                            (this.labelingGroupTable = d.labelingGroups.table),
                                (this.overflowStyleZoom = -1 / 0),
                                (this.boxes = []),
                                (this.placementIndex = 0);
                        }
                        getIconLabelPriorityToId(e) {
                            const { layer: t } = e;
                            if ('point' === t.type) {
                                return (
                                    '_' +
                                    t.style.iconPriority.toFixed(0) +
                                    '_' +
                                    t.style.textPriority.toFixed(0)
                                );
                            }
                            return '';
                        }
                    }
                },
                4009: (e, t, i) => {
                    var n = i(9218),
                        o = i(4372),
                        r = i(9476),
                        s = i(9808),
                        a = i(2153);
                    function l(e, t, i) {
                        const n = e[t];
                        if (void 0 !== n) return n[i];
                    }
                    var c = i(7123);
                    function d(e, t, i) {
                        const { minX: n, maxX: o, minY: r, maxY: s } = i;
                        e.push(n, r, o - n, s - r, t);
                    }
                    function h(e, t, i, n) {
                        const o = e.anchorScreen,
                            r = e.boxes[t];
                        return {
                            element: e,
                            minX: (o[0] + r[0] - i) | 0,
                            maxX: (o[0] + r[2] + i) | 0,
                            minY: (o[1] + r[1] - n) | 0,
                            maxY: (o[1] + r[3] + n) | 0,
                        };
                    }
                    function u(e, t) {
                        if (
                            e.parent === t ||
                            e.firstLabel === t ||
                            t.parent === e ||
                            t.firstLabel === e
                        )
                            return !1;
                        const i = e.labelingGroup,
                            n = t.labelingGroup;
                        return (function (e, t, i, n) {
                            const o = l(e, i, n),
                                r = l(t, i, n);
                            return (
                                (void 0 === o && void 0 === r) ||
                                (void 0 === o
                                    ? void 0 === r || r
                                    : void 0 === r
                                    ? void 0 === o || o
                                    : o || r)
                            );
                        })(e.labelingGroupTable, t.labelingGroupTable, i, n);
                    }
                    function m(e, t, i, n, o, r) {
                        const s = h(t, i, n, o);
                        if (
                            s.minX > r.maxX ||
                            s.maxX < r.minX ||
                            s.minY > r.maxY ||
                            s.maxY < r.minY
                        )
                            return !0;
                        const a = e.search(s);
                        for (let e = 0; e < a.length; e++) if (u(t, a[e].element)) return !0;
                        return !1;
                    }
                    function f(e, t, i, n, o) {
                        if (m(t, e, 0, n.leftRight, n.topBottom, i))
                            (e.placementIndex = -1),
                                o && d(o, a.m3.CommercialDead, h(e, 0, n.leftRight, n.topBottom));
                        else {
                            e.placementIndex = 0;
                            const i = h(e, 0, n.leftRight, n.topBottom);
                            t.insert(i), o && d(o, a.m3.CommercialAlive, i);
                        }
                    }
                    function p(e, t, i, n) {
                        let o = !0;
                        for (let r = 0; r < e.boxes.length; r++)
                            if (m(t, e, r, e.marginLeftRight, e.marginTopBottom, i)) {
                                if (((o = !1), n))
                                    for (let t = 0; t < e.boxes.length; t++) {
                                        const i = h(e, t, e.marginLeftRight, e.marginTopBottom);
                                        let o;
                                        (o =
                                            t === r ? a.m3.Dead : t < r ? a.m3.Alive : a.m3.Unused),
                                            d(n, o, i);
                                    }
                                break;
                            }
                        if (o)
                            for (let i = 0; i < e.boxes.length; i++) {
                                const o = h(e, i, e.marginLeftRight, e.marginTopBottom);
                                t.insert(o), n && d(n, a.m3.Alive, o);
                            }
                        e.placementIndex = o ? 0 : -1;
                    }
                    function _(e, t, i, n) {
                        e.placementIndex = -1;
                        for (let o = 0; o < e.boxes.length; o++)
                            if (!e.firstLabel || e.firstLabel.placementIndex === o) {
                                if (!m(t, e, o, e.marginLeftRight, e.marginTopBottom, i)) {
                                    const i = h(e, o, e.marginLeftRight, e.marginTopBottom);
                                    if ((t.insert(i), (e.placementIndex = o), n)) {
                                        d(n, a.m3.Alive, i);
                                        for (let t = o + 1; t < e.boxes.length; t++)
                                            d(
                                                n,
                                                a.m3.Unused,
                                                h(e, t, e.marginLeftRight, e.marginTopBottom),
                                            );
                                    }
                                    break;
                                }
                                n && d(n, a.m3.Dead, h(e, o, e.marginLeftRight, e.marginTopBottom));
                            }
                    }
                    function v(e, t) {
                        return e.sort(
                            (e, i) =>
                                i.groupPriority - e.groupPriority ||
                                (t.has(i.id) ? 1 : 0) - (t.has(e.id) ? 1 : 0) ||
                                i.commPriorityRandomFactor - e.commPriorityRandomFactor,
                        );
                    }
                    function g(e) {
                        return e.type !== a.Dl.Box && !Number.isNaN(e.commPriorityRandomFactor);
                    }
                    function y(e) {
                        return (
                            e.type !== a.Dl.Box &&
                            !Number.isNaN(e.commPriorityRandomFactor) &&
                            e.label.pointType === a.a_.CommercialCity
                        );
                    }
                    function b(e) {
                        return (
                            e.type !== a.Dl.Box &&
                            !Number.isNaN(e.commPriorityRandomFactor) &&
                            (e.label.pointType !== a.a_.CommercialCity ||
                                (-1 !== e.placementIndex &&
                                    e.label.pointType === a.a_.CommercialCity))
                        );
                    }
                    function w(e, t, i, n, o, r, s) {
                        let a = v(t.filter(y), o);
                        if (void 0 !== i) {
                            const e = a.indexOf(i);
                            if (e === a.length - 1) return;
                            a = a.slice(e + 1);
                        }
                        a.forEach((t) => {
                            f(t, e, n, r.city, s);
                        }),
                            e.clear(),
                            v(t.filter(b), o).forEach((t) => {
                                f(t, e, n, r.default, s);
                            }),
                            e.clear();
                    }
                    var x = i(8575);
                    class S {
                        constructor(e, t, i) {
                            (this.line = e), (this.lengths = []), (this.angles = []);
                            let n = t,
                                o = e[0],
                                r = e[1];
                            const s = e.length / 3;
                            for (let t = 0; t < s; t++) {
                                const i = e[3 * t] - o,
                                    s = e[3 * t + 1] - r;
                                (n += Math.sqrt(i * i + s * s)),
                                    this.lengths.push(n),
                                    (o += i),
                                    (r += s);
                            }
                            (this.finishLength = this.lengths[this.lengths.length - 1]),
                                (this.startLength = this.lengths[0]),
                                (this.midLength = i / 2),
                                (this.vertexCount = s),
                                this.angles.push(0);
                            for (let e = 1; e < s; e++) {
                                const t = this.line[3 * (e - 1)],
                                    i = this.line[3 * e],
                                    n = this.line[3 * (e - 1) + 1],
                                    o = this.line[3 * e + 1];
                                this.angles.push(Math.atan2(o - n, i - t));
                            }
                        }
                        interpolate(e, t) {
                            const i = t,
                                n = i - 1,
                                o = this.lengths[n],
                                r = (e - o) / (this.lengths[i] - o);
                            return [
                                (1 - r) * this.line[3 * n] + r * this.line[3 * i],
                                (1 - r) * this.line[3 * n + 1] + r * this.line[3 * i + 1],
                                0,
                                this.angles[t],
                            ];
                        }
                        getSegmentIndex(e) {
                            for (let t = 0; t < this.lengths.length; t++)
                                if (e < this.lengths[t]) return t;
                            return this.lengths.length;
                        }
                    }
                    class I {
                        constructor() {
                            this.labels = {};
                        }
                        add(e) {
                            const t = e.id,
                                i = e.componentDistanceStart;
                            void 0 === this.labels[t] && (this.labels[t] = {});
                            const n = this.labels[t];
                            void 0 === n[i] && (n[i] = []), n[i].push(e);
                        }
                        merge() {
                            const e = [];
                            for (const t in this.labels) {
                                const i = this.labels[t],
                                    n = Object.keys(i).sort((e, t) => Number(e) - Number(t));
                                let o = 0;
                                for (; o < n.length; ) {
                                    const t = n[o];
                                    if (0 === i[t].length) {
                                        o++;
                                        continue;
                                    }
                                    const r = [];
                                    let s = i[t].pop();
                                    for (; void 0 !== s; )
                                        r.push(s),
                                            (s =
                                                (0 === s.componentDistanceStart &&
                                                    0 === s.componentDistanceEnd) ||
                                                void 0 === i[s.componentDistanceEnd]
                                                    ? void 0
                                                    : i[s.componentDistanceEnd].pop());
                                    if (1 === r.length) {
                                        const t = r[0];
                                        (t.axis = new S(
                                            t.mapPointVertices,
                                            t.componentDistanceStartWorld,
                                            t.objectLengthWorld,
                                        )),
                                            e.push(t);
                                    } else r.length > 1 && e.push(this.stitch(r));
                                }
                            }
                            return e;
                        }
                        stitch(e) {
                            let t = 0;
                            for (let i = 0; i < e.length; i++) t += e[i].mapPointVertices.length;
                            t -= 3 * (e.length - 1);
                            const i = new Int32Array(t);
                            let n = 0;
                            for (let t = 0; t < e.length; t++) {
                                const o = e[t].mapPointVertices;
                                for (let e = t > 0 ? 3 : 0; e < o.length; e++) i[n++] = o[e];
                            }
                            const o = e[0];
                            return (
                                (o.axis = new S(
                                    i,
                                    o.componentDistanceStartWorld,
                                    o.objectLengthWorld,
                                )),
                                e[0]
                            );
                        }
                    }
                    var M = i(5317),
                        T = i(378),
                        P = i(9450),
                        L = i(6273);
                    class k {
                        constructor(e, t, i, n, o, r, s, l, c, d, h, u) {
                            (this.type = a.Dl.Box),
                                (this.marginTopBottom = 0),
                                (this.marginLeftRight = 0),
                                (this.id = String(e)),
                                (this.label = {
                                    layer: { innerId: 0 },
                                    styleId: -100,
                                    idLo: e,
                                    idHi: 0,
                                    symbol: 'nevermind',
                                    phase: NaN,
                                }),
                                (this.groupPriority = null != u ? u : L.Rw),
                                (this.itemPriority = null != h ? h : 1),
                                (this.parent = d),
                                (this.placementIndex = 0),
                                (this.labelingGroup = c),
                                (this.labelingGroupTable = l.labelingGroups.table),
                                (this.anchorWorld = P.Ue()),
                                P.JG(this.anchorWorld, n),
                                0 !== r && (this.anchorWorld[2] *= r),
                                (this.anchorScreen = s.project(this.anchorWorld)),
                                T.IH(this.anchorScreen, this.anchorScreen, o),
                                (this.boxes = [[0, 0, t, i]]);
                        }
                    }
                    var E = i(9073),
                        A = i(6490),
                        z = i(4576),
                        C = i(2543),
                        F = i(3249),
                        O = i(3754),
                        D = i(297);
                    const R = (0, A.Id)(n.labeling.axisAngleToleranceDeg),
                        j = n.labeling.axisCheckDistancePx,
                        B = (0, A.Id)(n.labeling.lineLabelsHidePitchDeg);
                    function N(e, t, i, n, o, r, s, l, c, d, h) {
                        const u = [],
                            m = [],
                            f = [],
                            p = [],
                            _ = {},
                            v = (function (e, t) {
                                const i = { personalPoi: new Set(), commercialPoi: new Set() };
                                for (const n of e) {
                                    const e = t.get(n);
                                    if (void 0 !== e)
                                        for (const t of e)
                                            t.source === a.AL.PersonalPoi
                                                ? i.personalPoi.add(t.id)
                                                : (t.pointType !== a.a_.Commercial &&
                                                      t.pointType !== a.a_.CommercialCity) ||
                                                  i.commercialPoi.add(t.id);
                                }
                                return i;
                            })(e, o),
                            g = new I();
                        for (let r = 0; r < e.length; r++) {
                            const u = e[r],
                                m = o.get(u);
                            if (void 0 !== m)
                                for (let e = 0; e < m.length; e++) {
                                    const o = m[e],
                                        r = n.getStyle(o.styleId);
                                    if (r) {
                                        if (
                                            !(
                                                (o.source === a.AL.Tile && d.has(o.id)) ||
                                                (o.source !== a.AL.PersonalPoi &&
                                                    v.personalPoi.has(o.id) &&
                                                    o.pointType !== a.a_.Commercial &&
                                                    o.pointType !== a.a_.CommercialCity) ||
                                                (o.source === a.AL.PersonalPoi &&
                                                    v.commercialPoi.has(o.id))
                                            )
                                        )
                                            switch (o.layer.type) {
                                                case 'point':
                                                    if (
                                                        U(
                                                            o,
                                                            s,
                                                            l,
                                                            t.styleState,
                                                            t.styleZoom,
                                                            r,
                                                            h,
                                                            t.elevation,
                                                        ) &&
                                                        X(o, t.styleZoom)
                                                    )
                                                        if (o.geometryType === a._r.Line) g.add(o);
                                                        else {
                                                            const e = [
                                                                o.mapPointVertices[0],
                                                                o.mapPointVertices[1],
                                                                o.mapPointVertices[2],
                                                                0,
                                                            ];
                                                            Z(p, f, _, o, e, i, t, r, c);
                                                        }
                                                    break;
                                                case 'labelLine':
                                                    U(
                                                        o,
                                                        s,
                                                        l,
                                                        t.styleState,
                                                        t.styleZoom,
                                                        r,
                                                        h,
                                                        t.elevation,
                                                    ) &&
                                                        X(o, t.styleZoom) &&
                                                        g.add(o);
                                                    break;
                                                case 'oneWayLine':
                                                    X(o, t.styleZoom) && g.add(o);
                                            }
                                    } else
                                        console.error(
                                            `Not found style ${o.styleId} in labeling#collectLabelingElements`,
                                        );
                                }
                        }
                        const y = g.merge();
                        for (let e = 0; e < y.length; e++) {
                            const o = y[e],
                                r = n.getStyle(o.styleId);
                            r
                                ? 'point' === o.layer.type
                                    ? H(p, f, _, o, r, i, t, c)
                                    : G(m, p, o, r, i, t)
                                : console.error(
                                      `Not found style ${o.styleId} in labeling#collectLabelingElements`,
                                  );
                        }
                        return (
                            r.forEach(
                                ({
                                    id: e,
                                    width: o,
                                    height: r,
                                    position: s,
                                    offset: a,
                                    labelingGroup: l,
                                    parentPoiId: c,
                                }) => {
                                    let d;
                                    if (c && ((d = _[c]), !d)) return;
                                    const h = n.getStyle(F.jf);
                                    if (!h)
                                        return void console.error(
                                            `Not found style ${F.jf} in labeling#collectLabelingElements`,
                                        );
                                    const m = new k(
                                        e,
                                        o,
                                        r,
                                        s,
                                        a,
                                        t.buildingHeight,
                                        i,
                                        h,
                                        l,
                                        d,
                                        null == d ? void 0 : d.itemPriority,
                                        null == d ? void 0 : d.groupPriority,
                                    );
                                    u.push(m);
                                },
                            ),
                            {
                                boxElements: u,
                                oneWayTileElements: m,
                                noLabelingElements: f,
                                otherTileElements: p,
                            }
                        );
                    }
                    function U(e, t, i, n, o, r, s, a) {
                        var l;
                        const { layer: c } = e;
                        if ('point' !== c.type && 'labelLine' !== c.type) return !1;
                        Number.isNaN(e.demElevation)
                            ? (e.elevation = 0)
                            : (e.elevation = (e.demElevation - (null != a ? a : 0)) * E.C);
                        const d = (0, C.bs)(o, n, !1, e.tileData);
                        if (
                            (D.rJ &&
                                !e.rtlProcessed &&
                                ((e.label =
                                    null !== (l = (0, D.iY)(e.label)) && void 0 !== l ? l : ''),
                                (e.label2 = (0, D.iY)(e.label2)),
                                (e.iconLabel = (0, D.iY)(e.iconLabel)),
                                e.updateRanges(),
                                s(L.Uo, e.ranges),
                                (0, C.EG)(c.style.textFont).forEach((t) => {
                                    t.length && s(t, e.ranges);
                                }),
                                'point' === c.type &&
                                    c.style.textFont2 &&
                                    (0, C.EG)(c.style.textFont2).forEach((t) => {
                                        t.length && s(t, e.ranges);
                                    }),
                                'point' === c.type &&
                                    c.style.iconTextFont &&
                                    (0, C.EG)(c.style.iconTextFont).forEach((t) => {
                                        t.length && s(t, e.ranges);
                                    }),
                                (e.rtlProcessed = !0)),
                            !e.rtlProcessed)
                        )
                            return !1;
                        const { ranges: h } = e,
                            u = (0, z.rq)(c.style.textFont, d, r);
                        let m;
                        if (
                            (u &&
                                e.label &&
                                (0, z.dm)(u, h, i) &&
                                ((m = (0, z.JA)(e.label, c.style.textLetterSpacing, t[u])),
                                (e.textMetrics = m)),
                            'labelLine' === c.type)
                        )
                            return !u || !!m;
                        const f = (0, z.rq)(c.style.iconTextFont, d, r);
                        f &&
                            e.iconLabel &&
                            (0, z.dm)(f, h, i) &&
                            (e.iconTextMetrics = (0, z.JA)(
                                e.iconLabel,
                                c.style.iconTextLetterSpacing,
                                t[f],
                            ));
                        const p = (0, z.rq)(c.style.textFont2, d, r);
                        return (
                            u &&
                                e.label &&
                                p &&
                                e.label2 &&
                                (0, z.dm)(p, h, i) &&
                                (e.textMetrics2 = (0, z.JA)(
                                    e.label2,
                                    c.style.textLetterSpacing,
                                    t[p],
                                )),
                            u && e.label
                                ? !(
                                      !m ||
                                      (f && e.iconLabel && !e.iconTextMetrics) ||
                                      (p && e.label2 && !e.textMetrics2)
                                  )
                                : !f || !e.iconLabel || !!e.iconTextMetrics
                        );
                    }
                    function Z(e, t, i, n, r, s, l, c, d) {
                        var h;
                        (0, o.Pn)(n, r, c, n.layer, l, s, d);
                        for (let o = 0; o < n.labelingElements.length; o++) {
                            const r = n.labelingElements[o];
                            r.labelingGroup !== O.R_ &&
                            (null === (h = r.parent) || void 0 === h ? void 0 : h.labelingGroup) !==
                                O.R_
                                ? (e.push(r), r.type === a.Dl.Icon && (i[r.label.id] = r))
                                : t.push(r);
                        }
                    }
                    function H(e, t, i, n, o, r, s, a) {
                        const { layer: l } = n;
                        if ('point' !== l.type) return;
                        const { zoom: c, styleZoom: d } = s,
                            h = Math.floor(d),
                            u = c + (h - d),
                            { startLength: m, midLength: f, finishLength: p } = n.axis,
                            _ = (0, C.bs)(h, s.styleState, !1, n.tileData),
                            v = Math.max((0, E.h0)((0, C.vn)(l.style.duplicationSpacing, _), u), 1),
                            g = (0, E.h0)(l.style.endingOffsets, c),
                            y = m + g,
                            b = p - g;
                        for (let l = m + ((f - m) % v); l < b; l += v)
                            if (l > y) {
                                const c = n.axis,
                                    d = l,
                                    h = c.getSegmentIndex(d);
                                Z(e, t, i, n, c.interpolate(d, h), r, s, o, a);
                            }
                    }
                    function G(e, t, i, o, r, s) {
                        const { layer: a } = i;
                        if ('labelLine' !== a.type && 'oneWayLine' !== a.type) return;
                        const { zoom: l, styleZoom: c } = s,
                            d = Math.floor(c),
                            h = l + (d - c),
                            { startLength: u, midLength: m, finishLength: f } = i.axis,
                            p = (0, C.bs)(c, s.styleState, !1, i.tileData),
                            _ = (0, C.bs)(d, s.styleState, !1, i.tileData);
                        let v, g, y, b;
                        if ('labelLine' === a.type) {
                            const e = (0, C.vn)(a.style.textFontSize, p) / n.fonts.baseSize,
                                t = (0, C.vn)(a.style.textFontSize, _) / n.fonts.baseSize;
                            (v = i.textMetrics.maxWidth * e),
                                (g = i.textMetrics.maxWidth * t),
                                (y = (0, E.h0)((0, C.vn)(a.style.textDuplicationSpacing, _), h)),
                                (b = (0, E.h0)(a.style.lineEndingOffsets, l));
                        } else
                            (v = (0, C.vn)(a.style.lineLength, p)),
                                (g = (0, C.vn)(a.style.lineLength, _)),
                                (y = (0, E.h0)((0, C.vn)(a.style.duplicationSpacing, _), h)),
                                (b = (0, E.h0)(a.style.endingOffsets, l));
                        const w = (0, E.h0)(g, h),
                            x = (0, E.h0)(v, l) / 2,
                            S = y + w,
                            I = u + ((m - u) % S),
                            M = u + x + b,
                            T = f - x - b,
                            P = 'labelLine' !== a.type ? e : t;
                        for (let e = I; e < T; e += S) e > M && V(P, i, e, x, v, r, s, o);
                    }
                    function V(e, t, i, o, r, s, l, c) {
                        const d = t.axis,
                            { zoom: h, styleZoom: u } = l,
                            { startLength: m, finishLength: f } = d,
                            p = d.getSegmentIndex(i),
                            _ = d.interpolate(i, p);
                        if (
                            (0, E.gr)(s.position, _, l.center) > B ||
                            !(function (e, t, i, o, r, s) {
                                if ('oneWayLine' === e.layer.type) return !0;
                                const a = e.axis,
                                    l = (0, C.bs)(r, s, !1, e.tileData),
                                    c = (0, C.vn)(e.layer.style.textFontSize, l) / n.fonts.baseSize,
                                    d = a.getSegmentIndex(t - i),
                                    h = a.getSegmentIndex(t + i),
                                    u = (0, E.h0)(j * c, o);
                                for (let e = d; e < h; e++) {
                                    if (e > 1 && W(a.angles[e - 1], a.angles[e]) > R) return !1;
                                    const t = a.getSegmentIndex(a.lengths[e] - u);
                                    if (0 !== t) {
                                        if (
                                            W(
                                                a.angles[t],
                                                a.angles[a.getSegmentIndex(a.lengths[e] + u)],
                                            ) > R
                                        )
                                            return !1;
                                    }
                                }
                                return !0;
                            })(t, i, o, h, u, l.styleState)
                        )
                            return;
                        const v = 'oneWayLine' === t.layer.type,
                            g = v ? a.Dl.OneWayLine : a.Dl.LineText,
                            y = new M.x(t, g, _, l.buildingHeight, s, c);
                        (y.anchorPosition = i),
                            (y.anchorSegmentIndex = p),
                            (y.halfLabelWidth = o),
                            v ||
                                ((y.overflowStyleZoom = (0, E.X$)((0, E.to)(r, f - m), _)),
                                (function (e, t, i, n, o, r) {
                                    const { axis: s, layer: a } = t;
                                    if ('labelLine' !== a.type) return;
                                    const { zoom: l, styleZoom: c } = o,
                                        d = (0, C.bs)(c, o.styleState, !1, t.tileData),
                                        h = (0, C.vn)(a.style.textFontSize, d),
                                        u = h / 2,
                                        m = (0, E.h0)(h, l),
                                        f = (0, E.h0)(a.style.textLabelingSideMargin, l),
                                        p = i - n + m / 2 - f,
                                        _ = i + n - m / 2 + f;
                                    let v = s.getSegmentIndex(p);
                                    for (let t = p; t < _; t += m) {
                                        for (; s.lengths[v] < t; ) v++;
                                        $(e, s, t, v, r, u);
                                    }
                                    for (; s.lengths[v] < _; ) v++;
                                    $(e, s, _, v, r, u);
                                })(y, t, i, o, l, s)),
                            e.push(y);
                    }
                    function W(e, t) {
                        const i = Math.abs(e - t);
                        return i > Math.PI ? 2 * Math.PI - i : i;
                    }
                    const q = [0, 0];
                    function $(e, t, i, n, o, r) {
                        o.putProject(q, t.interpolate(i, n)),
                            (q[0] = q[0] - e.anchorScreen[0]),
                            (q[1] = q[1] - e.anchorScreen[1]),
                            e.boxes.push([q[0] - r, q[1] - r, q[0] + r, q[1] + r]);
                    }
                    function X(e, t) {
                        const {
                                source: i,
                                detailLevel: o,
                                layer: { minzoom: r, maxzoom: s },
                            } = e,
                            l = i === a.AL.PersonalPoi,
                            c = l || r > o,
                            d = l || s < o + 1 || o === n.tiles.maxDetailLevel;
                        return (!c || t >= r) && (!d || t < s);
                    }
                    var Y = i(7256),
                        K = i(4500),
                        J = i(3487),
                        Q = i(5549),
                        ee = i(7436),
                        te = i(267),
                        ie = i(8194),
                        ne = i(4874),
                        oe = i(6336);
                    const re = new Map();
                    !(function (e) {
                        const t = new Y.D(e),
                            i = new K.J(t),
                            l = new x.P('labeling'),
                            d = new ee.h(),
                            h = i.get(Q.P.Main, 'loadFont'),
                            u = new Map(),
                            m = new Map();
                        let f = [],
                            v = new Map();
                        const b = new J.c(),
                            S = new J.c(),
                            I = {},
                            M = (0, r.D)(() => l.reset(), n.workerResetDebounceTime);
                        function T(e, t) {
                            for (const i of t) b.has(e, i) || (h(e, i), b.set(e, i, !0));
                        }
                        function P(e, t, i) {
                            if (e.has(i.label.sourceId)) return 0;
                            const n = t.get(i.id);
                            return void 0 === n ||
                                void 0 === n.placementIndex ||
                                (n.type === a.Dl.Icon && n.layer.innerId !== i.layer.innerId)
                                ? 1
                                : n.placementIndex === i.placementIndex
                                ? 0
                                : 1;
                        }
                        i.set('setComPoiRandomSeed', (e) => {
                            (0, oe.P)(e);
                        }),
                            i.set('appendLabels', (e, t, i, n, o) => {
                                const r = (0, s.v)(i, t, d, n, o);
                                u.set(e, r);
                            }),
                            i.set('appendLabelBox', (e, t) => {
                                m.set(e, t);
                            }),
                            i.set('removeEmptyBoxLabel', (e) => {
                                m.delete(e);
                            }),
                            i.set('removeLabels', (e) => {
                                u.delete(e), m.delete(e);
                            }),
                            i.set('processLabels', (e, t, i, r, h, b, x, L) => {
                                const k = new Set(b),
                                    E = new ne.V(i),
                                    A = new Set(),
                                    z = t;
                                e.forEach(({ sourceId: e, animate: t, labelsKeys: i }) => {
                                    t || A.add(e), z.push(...i);
                                });
                                const {
                                        boxElements: C,
                                        oneWayTileElements: F,
                                        otherTileElements: O,
                                        noLabelingElements: D,
                                    } = N(z, i, E, d, u, m, I, S, h, k, T),
                                    R = (function (e, t, i, o) {
                                        const r = t.debugLabels ? [] : void 0,
                                            { size: l, viewport: d } = t,
                                            h = l[0],
                                            u = l[1],
                                            m = (n.labeling.tileMultiplier - 1) / 2,
                                            f = Math.round(h * m),
                                            v = Math.round(u * m),
                                            b = {
                                                minX: d.left - f,
                                                maxX: d.left + h + f,
                                                minY: d.top - v,
                                                maxY: d.top + u + v,
                                            },
                                            x = c(),
                                            S = c();
                                        w(S, e, void 0, b, i, o, r);
                                        const I = e.sort((e, n) => {
                                            const o = e.label instanceof s._ ? e.label.hovered : 0,
                                                r = n.label instanceof s._ ? n.label.hovered : 0,
                                                a = t.disableSurvivedPoiPrevalence
                                                    ? 0
                                                    : (i.has(n.id) ? 1 : 0) - (i.has(e.id) ? 1 : 0);
                                            return (
                                                n.groupPriority - e.groupPriority ||
                                                (g(n) ? n.commPriorityRandomFactor : 0) -
                                                    (g(e) ? e.commPriorityRandomFactor : 0) ||
                                                a ||
                                                r - o ||
                                                n.itemPriority - e.itemPriority ||
                                                n.label.idHi - e.label.idHi ||
                                                n.label.idLo - e.label.idLo ||
                                                n.label.layer.innerId - e.label.layer.innerId ||
                                                n.anchorWorld[0] - e.anchorWorld[0] ||
                                                n.anchorWorld[1] - e.anchorWorld[1]
                                            );
                                        });
                                        for (let t = 0; t < I.length; t++) {
                                            const n = I[t];
                                            if (-1 !== n.placementIndex)
                                                switch (n.type) {
                                                    case a.Dl.LineText:
                                                    case a.Dl.Icon:
                                                        p(n, x, b, r),
                                                            y(n) &&
                                                                -1 === n.placementIndex &&
                                                                w(S, e, n, b, i, o, r);
                                                        break;
                                                    case a.Dl.Box:
                                                        if (
                                                            !n.parent ||
                                                            (n.parent &&
                                                                -1 !== n.parent.placementIndex)
                                                        ) {
                                                            p(n, x, b, r);
                                                            break;
                                                        }
                                                        n.placementIndex = -1;
                                                        break;
                                                    case a.Dl.PoiText:
                                                    case a.Dl.PoiText2:
                                                        (n.parent &&
                                                            -1 === n.parent.placementIndex) ||
                                                        (n.firstLabel &&
                                                            -1 === n.firstLabel.placementIndex)
                                                            ? (n.placementIndex = -1)
                                                            : _(n, x, b, r);
                                                }
                                        }
                                        return r;
                                    })([...O, ...C], i, L ? re : v, x),
                                    j = [...D, ...F, ...O],
                                    B = new Map();
                                for (let e = 0; e < j.length; e++) {
                                    const t = j[e];
                                    -1 !== t.placementIndex && B.set(t.id, t);
                                }
                                for (let e = 0; e < j.length; e++) {
                                    const t = j[e],
                                        {
                                            label: { styleId: n, layer: s },
                                        } = t;
                                    if (-1 === t.placementIndex) continue;
                                    const a = P(A, v, t),
                                        c = d.getStyle(n);
                                    c
                                        ? (0, o.SV)(c, s, l, t, a, h, i, r)
                                        : console.error(
                                              `Not found style ${n} in labeling#processLabels`,
                                          );
                                }
                                for (let e = 0; e < f.length; e++) {
                                    const t = f[e],
                                        { id: n, label: s, layer: c } = t,
                                        { styleId: u } = s,
                                        m = d.getStyle(u);
                                    if (!m) {
                                        console.error(
                                            `Not found style ${u} in labeling#processLabels`,
                                        );
                                        continue;
                                    }
                                    if (A.has(t.label.sourceId)) continue;
                                    const p = t.placementIndex,
                                        _ = B.get(n);
                                    -1 !== p &&
                                        (t.placementIndex !==
                                            (null == _ ? void 0 : _.placementIndex) ||
                                            (t.type === a.Dl.Icon &&
                                                t.layer.innerId !==
                                                    (null == _ ? void 0 : _.layer.innerId))) &&
                                        (i.styleZoom < t.overflowStyleZoom ||
                                            i.styleZoom < c.minzoom ||
                                            i.styleZoom >= c.maxzoom ||
                                            (0, o.SV)(m, c, l, t, -1, h, i, r));
                                }
                                (f = j), (v = B);
                                const U = l.getAccumulatedData(),
                                    Z = [];
                                for (const e of C) -1 !== e.placementIndex && Z.push(e.label.idLo);
                                const H = new Map(),
                                    G = (0, te.BS)(i.tilesBounds);
                                for (const e of O)
                                    if (
                                        -1 !== e.placementIndex &&
                                        g(e) &&
                                        ie.r3(G, e.anchorWorld)
                                    ) {
                                        const t = {};
                                        y(e) && (t.adsPriority = 'city'), H.set(e.label.id, t);
                                    }
                                const V = {
                                    survivedLabelBoxIds: Z,
                                    survivedCommPois: Array.from(H).map((e) => {
                                        const t = { id: e[0] };
                                        return (
                                            void 0 !== e[1].adsPriority &&
                                                (t.adsPriority = e[1].adsPriority),
                                            t
                                        );
                                    }),
                                    collectorOutput: U,
                                    transferable: U.transferable,
                                };
                                if (R) {
                                    const e = new Int32Array(R.length);
                                    e.set(R), (V.labels = e.buffer);
                                }
                                return M(), V;
                            }),
                            i.set('appendFont', (e, t) => {
                                I[e] || (I[e] = {});
                                const i = I[e];
                                for (const e in t) i[e] = t[e];
                            }),
                            i.set('markFontAsLoaded', (e, t) => {
                                S.set(e, t, !0);
                            }),
                            i.set('addNewRasterSets', (e, t) => {
                                const i = d.getStyle(e);
                                if (!i)
                                    return void console.error(
                                        `Not found style ${e} in labeling#addNewRasterSets`,
                                    );
                                const { rasterSets: n } = i;
                                t.forEach((e) => {
                                    (n.byIndex[e.index] = e), (n.byKey[e.key] = e);
                                });
                            }),
                            i.set('updatePackingInfo', (e, t) => {
                                const i = d.getStyle(e);
                                if (!i)
                                    return void console.error(
                                        `Not found style ${e} in labeling#updatePackingInfo`,
                                    );
                                const { rasterSets: n } = i,
                                    o = t.length / 7;
                                for (let e = 0; e < o; e++) {
                                    const i = t[7 * e],
                                        o = t[7 * e + 1],
                                        r = t[7 * e + 6],
                                        s = t[7 * e + 2],
                                        a = t[7 * e + 3],
                                        l = t[7 * e + 4],
                                        c = t[7 * e + 5],
                                        d = n.byIndex[i];
                                    if (void 0 !== d)
                                        if (d.isSvg)
                                            d.rasters[o] = {
                                                rasterIndex: o,
                                                rasterSetIndex: i,
                                                x: s,
                                                y: a,
                                                w: l,
                                                h: c,
                                                anchorX: d.anchorX,
                                                anchorY: d.anchorY,
                                                atlasIndex: r,
                                                isPacked: !0,
                                            };
                                        else {
                                            const e = d.rasters[o];
                                            if (void 0 === e) {
                                                console.error(
                                                    `Not found raster with index ${o} and raster set index ${i}`,
                                                );
                                                continue;
                                            }
                                            (e.x = s),
                                                (e.y = a),
                                                (e.atlasIndex = r),
                                                (e.isPacked = !0);
                                        }
                                    else console.error(`Not found raster set with index ${i}`);
                                }
                            }),
                            i.set('clearPreviousLabels', () => {
                                (f = []), v.clear();
                            }),
                            i.set('syncStyle', (...e) => d.proxySyncStyle(...e)),
                            i.set('loadRtlPlugin', D.ng),
                            i.set('markRtlPluginLoaded', () => {
                                D.dp && (0, D.dp)();
                            });
                    })(self);
                },
                9808: (e, t, i) => {
                    i.d(t, { _: () => h, v: () => d });
                    var n = i(7999),
                        o = i(3672),
                        r = i(2153),
                        s = i(6392),
                        a = i(6201),
                        l = i(2618);
                    function c(e) {
                        return (
                            'labelLine' === e.type || 'point' === e.type || 'oneWayLine' === e.type
                        );
                    }
                    function d(e, t, i, n, o) {
                        const r = [];
                        for (const s of e)
                            for (const e of s.labels) {
                                const l = i.getStyle(e.styleId);
                                if (!l) {
                                    console.error(
                                        `Not found style ${e.styleId} in unpackPreLabelingResult`,
                                    );
                                    continue;
                                }
                                const d = l.layersById[e.layerId];
                                if (!d || !c(d)) {
                                    console.error(
                                        `Not found layer: ${e.layerId} in style ${e.styleId} in unpackPreLabelingResult`,
                                    );
                                    continue;
                                }
                                const u = new h(e, d, t, s.metatileHash);
                                switch (e.type) {
                                    case a.R2.Point:
                                        u.setSpecificPointAttributes(e, n, o);
                                        break;
                                    case a.R2.Line:
                                        u.setSpecificLineAttributes(e, n, o);
                                        break;
                                    case a.R2.OneWayLine:
                                        u.setSpecificOneWayAttributes(e);
                                }
                                r.push(u);
                            }
                        return r;
                    }
                    class h {
                        constructor(e, t, i, n) {
                            (this.rtlProcessed = !1),
                                (this.labelingElements = []),
                                (this.id = ''),
                                (this.idLo = 0),
                                (this.idHi = 0),
                                (this.detailLevel = 0),
                                (this.labelPriority = 0),
                                (this.label = ''),
                                (this.ranges = []),
                                (this.pointType = r.a_.Common),
                                (this.iconPriority = 0),
                                (this.identifyIndex = l.gl),
                                (this.identifyPoiLabelIndex = l.gl),
                                (this.labelingTextureIndex = l.gl),
                                (this.hovered = 0),
                                (this.label2Priority = 0),
                                (this.mapPointVertices = [0, 0, 0]),
                                (this.demElevation = 0),
                                (this.elevation = 0),
                                (this.componentDistanceStartWorld = 0),
                                (this.componentDistanceEnd = 0),
                                (this.componentDistanceStart = 0),
                                (this.objectLengthWorld = 0),
                                (this.checkPointOffset = [0, 0]),
                                (this.layer = t),
                                (this.styleId = e.styleId),
                                (this.source = i),
                                (this.sourceId = e.sourceId),
                                (this.metatileHash = n),
                                (this.geometryType =
                                    e.type === a.R2.Point ? e.geometryType : r._r.Line),
                                (this.tileData = e.tileData),
                                (this.labelPriority = e.labelPriority),
                                (this.detailLevel = e.tileCoords[2]),
                                (this.idLo = e.id.lo),
                                (this.idHi = e.id.hi),
                                (this.id = (0, o.Ak)(e.id));
                        }
                        setSpecificPointAttributes(e, t, i) {
                            if ('point' !== this.layer.type)
                                throw new Error('Label: layer type is not a point');
                            const o = this.layer.style;
                            (this.pointType = e.pointType),
                                (this.label2Priority = e.label2Priority),
                                (this.iconPriority = e.iconPriority),
                                (this.identifyIndex = e.identifyIndex),
                                (this.identifyPoiLabelIndex = e.identifyPoiLabelIndex),
                                (this.labelingTextureIndex = e.labelingTextureIndex),
                                (this.hovered = e.hovered),
                                (this.demElevation = e.demElevation);
                            const l = {
                                type: 'labeling',
                                interpolateExpressionAsStep: !0,
                                tileData: e.tileData,
                                styleState: t,
                                styleZoom: i,
                            };
                            (this.label = (0, n.lD)(
                                (0, a.It)(o.textField, l),
                                o.textMaxLengthPerLine,
                            )),
                                o.textField2 &&
                                    (this.label2 = (0, n.lD)(
                                        (0, a.It)(o.textField2, l),
                                        o.textMaxLengthPerLine,
                                    )),
                                'point' === this.layer.type &&
                                    o.iconTextField &&
                                    (this.iconLabel = (0, n.lD)(
                                        (0, a.It)(o.iconTextField, l),
                                        o.textMaxLengthPerLine,
                                    ));
                            const c = (0, s.Bs)(e.tileCoords);
                            this.mapPointVertices = [];
                            const d = [0, 0, 0],
                                h = [0, 0, 0];
                            if (e.geometryType === r._r.Point)
                                (0, s.L7)(this.mapPointVertices, e.vertices, 0, c),
                                    this.layer.style.allowElevation ||
                                        (this.mapPointVertices[2] = 0);
                            else {
                                for (let t = 0; t < e.vertices[0].length; t++)
                                    (d[0] = e.vertices[0][t]),
                                        (d[1] = e.vertices[1][t]),
                                        (0, s.Z$)(h, d, c),
                                        this.mapPointVertices.push(h[0], h[1], h[2]);
                                (this.componentDistanceStart = e.componentDistanceStart),
                                    (this.componentDistanceEnd = e.componentDistanceEnd),
                                    (this.componentDistanceStartWorld = (0, s.C5)(
                                        this.componentDistanceStart,
                                        e.tileCoords[2],
                                    )),
                                    (this.objectLengthWorld = (0, s.C5)(
                                        e.objectLength,
                                        e.tileCoords[2],
                                    ));
                            }
                        }
                        setSpecificLineAttributes(e, t, i) {
                            if ('labelLine' !== this.layer.type)
                                throw new Error('Label: layer type is not a labelLine');
                            const n = {
                                type: 'labeling',
                                interpolateExpressionAsStep: !0,
                                tileData: e.tileData,
                                styleState: t,
                                styleZoom: i,
                            };
                            this.label = (0, a.It)(this.layer.style.textField, n);
                            const o = (0, s.Bs)(e.tileCoords);
                            this.mapPointVertices = [];
                            const r = [0, 0, 0],
                                l = [0, 0, 0];
                            for (let t = 0; t < e.vertices[0].length; t++)
                                (r[0] = e.vertices[0][t]),
                                    (r[1] = e.vertices[1][t]),
                                    (0, s.Z$)(l, r, o),
                                    this.mapPointVertices.push(l[0], l[1], l[2]);
                            (this.componentDistanceStart = e.componentDistanceStart),
                                (this.componentDistanceEnd = e.componentDistanceEnd),
                                (this.componentDistanceStartWorld = (0, s.C5)(
                                    this.componentDistanceStart,
                                    e.tileCoords[2],
                                )),
                                (this.objectLengthWorld = (0, s.C5)(
                                    e.objectLength,
                                    e.tileCoords[2],
                                )),
                                (this.drawLevel = e.drawLevel);
                        }
                        setSpecificOneWayAttributes(e) {
                            const t = (0, s.Bs)(e.tileCoords);
                            this.mapPointVertices = [];
                            const i = [0, 0, 0],
                                n = [0, 0, 0];
                            for (let o = 0; o < e.vertices[0].length; o++)
                                (i[0] = e.vertices[0][o]),
                                    (i[1] = e.vertices[1][o]),
                                    (0, s.Z$)(n, i, t),
                                    this.mapPointVertices.push(n[0], n[1], n[2]);
                            (this.componentDistanceStart = e.componentDistanceStart),
                                (this.componentDistanceEnd = e.componentDistanceEnd),
                                (this.componentDistanceStartWorld = (0, s.C5)(
                                    this.componentDistanceStart,
                                    e.tileCoords[2],
                                )),
                                (this.objectLengthWorld = (0, s.C5)(
                                    e.objectLength,
                                    e.tileCoords[2],
                                )),
                                (this.drawLevel = e.drawLevel);
                        }
                        updateRanges() {
                            this.ranges = (0, n.Go)([this.label, this.label2, this.iconLabel]);
                        }
                    }
                },
                6336: (e, t, i) => {
                    i.d(t, { M: () => o, P: () => r });
                    var n = i(173);
                    let o = Math.random;
                    const r = (e) => {
                        o = (0, n.O)(e);
                    };
                },
                249: (e, t, i) => {
                    var n = i(7731),
                        o = i(6208),
                        r = i.n(o),
                        s = i(9476),
                        a = i(9218),
                        l = i(6273),
                        c = i(7084),
                        d = i(5970),
                        h = i(4922),
                        u = i(7609),
                        m = i(3672),
                        f = i(7204),
                        p = i(143),
                        _ = i(2543),
                        v = i(2097),
                        g = i(4333),
                        y = i(9981),
                        b = i(7188),
                        w = i(8194),
                        x = i(8183);
                    const S = [[0], [0], [0]],
                        I = [[0], [0], [0]],
                        M = [[0], [0], [0]];
                    function T(e, t, i, n, o, r) {
                        const { tileProps: s, tileAttrs: l } = i,
                            h = (0, m.IL)(e.floorId),
                            u = (0, m.IL)(e.buildingId);
                        (l[s.db_height] = a.floors.islandHeight),
                            (l[s.db_sublayer] = e.areaSublayer),
                            (l[s.selected] = r ? 1 : 0),
                            (l[s.db_region] = o),
                            t.layers.forEach((o) => {
                                if ('polygonExtrusion' !== o.type) return;
                                if ((0, _.FR)(o.filter, i))
                                    for (let r = 0; r < e.area.length; r++) {
                                        const s = new Uint16Array(e.area[r].slice().buffer);
                                        E(s);
                                        const a = k(s),
                                            l = c(s);
                                        (S[0].length = 0), (S[1].length = 0), (S[2].length = 0);
                                        for (let e = 0; e < l.length; e += 3) {
                                            for (let t = 0; t < 3; t++)
                                                (S[0][t] = a[l[e + t]][0]),
                                                    (S[1][t] = a[l[e + t]][1]),
                                                    (S[2][t] = 1);
                                            do {
                                                d.p.generate(
                                                    n,
                                                    t.id,
                                                    o,
                                                    i,
                                                    S,
                                                    !1,
                                                    void 0,
                                                    void 0,
                                                    h,
                                                    u,
                                                );
                                            } while (n.isOverloaded());
                                        }
                                    }
                            });
                    }
                    function P(e, t, i, n, o, r, s) {
                        const { tileProps: a, tileAttrs: l } = t,
                            d = (0, m.IL)(e.floorId),
                            u = 'Floor' === e.sublayer;
                        (l[a.db_sublayer] = e.areaSublayer),
                            (l[a.selected] = r ? 1 : 0),
                            (l[a.db_region] = o),
                            i.layers.forEach((o) => {
                                if ('polygon' !== o.type) return;
                                if ((0, _.FR)(o.filter, t))
                                    for (let r = 0; r < e.area.length; r++) {
                                        const a = new Uint16Array(e.area[r].slice().buffer);
                                        E(a);
                                        const l = k(a),
                                            m = [0, 0],
                                            f = u ? (0, x.y)(l) : [];
                                        if (u) {
                                            const e = w.Ue();
                                            for (let t = 0; t < l.length; t++) w.aM(e, l[t]);
                                            w.be(m, e);
                                        }
                                        const p = c(a);
                                        (S[0].length = 0), (S[1].length = 0), (S[2].length = 0);
                                        for (let e = 0; e < p.length; e += 3) {
                                            for (let t = 0; t < 3; t++) {
                                                const i = p[e + t];
                                                (S[0][t] = l[i][0]),
                                                    (S[1][t] = l[i][1]),
                                                    (S[2][t] = 0),
                                                    u && (I[t] = f[i]);
                                            }
                                            do {
                                                v.a.generate(
                                                    n,
                                                    i.id,
                                                    o,
                                                    t,
                                                    S,
                                                    s,
                                                    void 0,
                                                    void 0,
                                                    d,
                                                );
                                            } while (n.isOverloaded());
                                            if (u)
                                                do {
                                                    h._.generateFloorsBottomFill(n, i.id, S, I, m);
                                                } while (n.isOverloaded());
                                        }
                                    }
                            });
                    }
                    function L(e, t, i, n, o, r) {
                        if (!e.wallSublayer) return;
                        const { tileProps: s, tileAttrs: l } = t,
                            c = (0, m.IL)(e.floorId),
                            h = (0, m.IL)(e.buildingId);
                        (l[s.db_height] = a.floors.wallHeight),
                            (l[s.db_sublayer] = e.wallSublayer),
                            (l[s.selected] = r ? 1 : 0),
                            (l[s.db_region] = o),
                            i.layers.forEach((o) => {
                                if ('polygonExtrusion' !== o.type) return;
                                if ((0, _.FR)(o.filter, t))
                                    for (let r = 0; r < e.wallTop.length; r++) {
                                        const s = new Uint16Array(e.wallTop[r].slice().buffer);
                                        E(s);
                                        const a = k(s),
                                            l = w.Ue();
                                        for (let e = 0; e < a.length; e++) w.aM(l, a[e]);
                                        const u = [0, 0];
                                        w.be(u, l);
                                        const m = a.length;
                                        (S[0].length = 0), (S[1].length = 0), (S[2].length = 0);
                                        for (let e = 0; e < m; e++) {
                                            const t = (0, p.X)(e, m);
                                            (S[0][t] = a[e][0]), (S[1][t] = a[e][1]), (S[2][t] = 1);
                                        }
                                        do {
                                            d.p.generate(n, i.id, o, t, S, !1, void 0, u, c, h);
                                        } while (n.isOverloaded());
                                    }
                            });
                    }
                    function k(e) {
                        const t = [];
                        for (let i = 0; i < e.length / 2; i++) t.push([e[2 * i], e[2 * i + 1]]);
                        return t;
                    }
                    function E(e) {
                        e.forEach((t, i) => {
                            e[i] *= l.gt;
                        });
                    }
                    var A = i(8575),
                        z = i(5095),
                        C = i(7721),
                        F = i(6479),
                        O = i(7256),
                        D = i(4500),
                        R = i(5549),
                        j = i(6392),
                        B = i(4372);
                    var N = i(9450),
                        U = i(9073);
                    let Z = [];
                    var H = i(2435);
                    class G {
                        constructor() {
                            (this.cache = new Map()), (this.pendingRequests = new Map());
                        }
                        fetch(e, t, i, n, o) {
                            return new Promise((r) => {
                                const s = V(e, n, o, t, i),
                                    a = (0, j.gx)(e),
                                    l = (0, z.L)({ url: s }, (e, t) => {
                                        if ((this.pendingRequests.delete(a), void 0 !== e))
                                            return (
                                                204 !== e.status && console.error(e),
                                                this.cache.set(a, void 0),
                                                void r()
                                            );
                                        const i = t[0];
                                        i ? this.cache.set(a, i) : this.cache.set(a, void 0), r();
                                    });
                                this.pendingRequests.set(a, { xhr: l, resolve: r });
                            });
                        }
                        get(e) {
                            return this.cache.get(e);
                        }
                        delete(e) {
                            this.cache.delete(e);
                        }
                        abortRequest(e) {
                            const t = this.pendingRequests.get(e);
                            void 0 !== t &&
                                (t.xhr.abort(), t.resolve(), this.pendingRequests.delete(e));
                        }
                    }
                    function V(e, t, i, n, o) {
                        const r = Math.pow(2, e[2]) - 1,
                            s = e[0],
                            l = (16777215 & (r - e[1])) * (1 << 24) + (16777215 & s);
                        return (0, H.XK)(a.traffic.url, {
                            protocol: o,
                            host: n,
                            z: String(e[2]),
                            tiles: String(l),
                            regions: t.join(','),
                            time: String(i),
                        });
                    }
                    var W = i(7436),
                        q = i(4847);
                    class $ extends q.g {
                        constructor(e) {
                            super(),
                                (this.obClassEnumIndex = 0),
                                (this.sublayerEnumIndex = 0),
                                (this.workerParserSyncMetatile = e.get(R.P.Main, 'syncMetatile'));
                        }
                        addData(e) {
                            this.dictionaries.db_sublayer ||
                                ((this.dictionaries.db_sublayer = {}),
                                (this.reverseDictionaries.db_sublayer = {})),
                                e.sublayers.forEach((e) => {
                                    if (void 0 === this.dictionaries.db_sublayer[e]) {
                                        const t = this.sublayerEnumIndex++;
                                        (this.dictionaries.db_sublayer[e] = t),
                                            (this.reverseDictionaries.db_sublayer[t] = e);
                                    }
                                }),
                                this.dictionaries.db_object_class ||
                                    ((this.dictionaries.db_object_class = {}),
                                    (this.reverseDictionaries.db_object_class = {})),
                                e.objectClasses.forEach((e) => {
                                    if (void 0 === this.dictionaries.db_object_class[e]) {
                                        const t = this.obClassEnumIndex++;
                                        (this.dictionaries.db_object_class[e] = t),
                                            (this.reverseDictionaries.db_object_class[t] = e);
                                    }
                                }),
                                this.workerParserSyncMetatile({
                                    dictionaries: this.dictionaries,
                                    reverseDictionaries: this.reverseDictionaries,
                                });
                        }
                    }
                    var X = i(4411),
                        Y = i(2176),
                        K = i(603),
                        J = i(1245),
                        Q = i(127);
                    function ee(e) {
                        return {
                            copyright: e.copyright,
                            generator: e.generator,
                            version: e.version,
                            minVersion: e.minVersion,
                        };
                    }
                    function te(e = []) {
                        return e.map((e) => {
                            var t;
                            return {
                                bufferView: e.bufferView,
                                byteOffset: null !== (t = e.byteOffset) && void 0 !== t ? t : 0,
                                componentType: e.componentType,
                                normalized: e.normalized,
                                count: e.count,
                                type: e.type,
                                max: e.max,
                                min: e.min,
                                sparse: e.sparse,
                                name: e.name,
                                extensions: e.extensions,
                                extras: e.extras,
                            };
                        });
                    }
                    function ie(e = []) {
                        return e.map((e) => ({
                            channels: e.channels,
                            samplers: e.samplers,
                            name: e.name,
                            extensions: e.extensions,
                            extras: e.extras,
                        }));
                    }
                    function ne(e = []) {
                        return e.map((e) => ({
                            uri: e.uri,
                            byteLength: e.byteLength,
                            name: e.name,
                            extensions: e.extensions,
                            extras: e.extras,
                            buffer: void 0,
                        }));
                    }
                    function oe(e = []) {
                        return e.map((e) => ({
                            buffer: e.buffer,
                            byteOffset: e.byteOffset,
                            byteLength: e.byteLength,
                            byteStride: e.byteStride,
                            target: e.target,
                            name: e.name,
                            extensions: e.extensions,
                            extras: e.extras,
                        }));
                    }
                    function re(e = []) {
                        return e.map((e) => ({
                            type: e.type,
                            orthographic: e.orthographic,
                            perspective: e.perspective,
                            name: e.name,
                            extensions: e.extensions,
                            extras: e.extras,
                        }));
                    }
                    function se(e = []) {
                        return e.map((e) => ({
                            primitives: e.primitives,
                            name: e.name,
                            weights: e.weights,
                            extensions: e.extensions,
                            extras: e.extras,
                        }));
                    }
                    function ae(e = []) {
                        return e.map((e) => ({
                            alphaCutoff: e.alphaCutoff,
                            alphaMode: e.alphaMode,
                            doubleSided: e.doubleSided,
                            emissiveFactor: e.emissiveFactor,
                            emissiveTexture: e.emissiveTexture,
                            normalTexture: e.normalTexture,
                            occlusionTexture: e.occlusionTexture,
                            pbrMetallicRoughness: e.pbrMetallicRoughness,
                            name: e.name,
                            extras: e.extras,
                            extensions: e.extensions,
                        }));
                    }
                    function le(e = []) {
                        return e.map((e) => ({
                            nodes: e.nodes,
                            extensions: e.extensions,
                            extras: e.extras,
                            name: e.name,
                        }));
                    }
                    function ce(e = []) {
                        return e.map((e) => {
                            var t, i, n;
                            const o = null !== (t = e.rotation) && void 0 !== t ? t : [0, 0, 0, 1],
                                r = null !== (i = e.scale) && void 0 !== i ? i : [1, 1, 1],
                                s = null !== (n = e.translation) && void 0 !== n ? n : [0, 0, 0];
                            return {
                                camera: e.camera,
                                children: e.children,
                                matrix: e.matrix ? Q.al(...e.matrix) : void 0,
                                rotation: J.al(...o),
                                scale: N.al(...r),
                                translation: N.al(...s),
                                name: e.name,
                                mesh: e.mesh,
                                skin: e.skin,
                                extras: e.extras,
                                extensions: e.extensions,
                            };
                        });
                    }
                    function de(e = []) {
                        return e.map((e) => ({
                            bufferView: e.bufferView,
                            mimeType: e.mimeType,
                            name: e.name,
                            uri: e.uri,
                            extensions: e.extensions,
                            extras: e.extras,
                            image: void 0,
                        }));
                    }
                    function he(e = []) {
                        return e.map((e) => ({
                            extensions: e.extensions,
                            extras: e.extras,
                            name: e.name,
                            sampler: e.sampler,
                            source: e.source,
                        }));
                    }
                    function ue(e = []) {
                        return e.map((e) => ({
                            extensions: e.extensions,
                            extras: e.extras,
                            name: e.name,
                            magFilter: e.magFilter,
                            minFilter: e.minFilter,
                            wrapS: e.wrapS,
                            wrapT: e.wrapT,
                        }));
                    }
                    function me(e = []) {
                        return e.map((e) => ({
                            joints: e.joints,
                            extensions: e.extensions,
                            extras: e.extras,
                            inverseBindMatrices: e.inverseBindMatrices,
                            name: e.name,
                            skeleton: e.skeleton,
                        }));
                    }
                    const fe = 'image/jpeg',
                        pe = 'image/png',
                        _e = 'image/texture';
                    function ve(e) {
                        return e.substring(0, e.lastIndexOf('/') + 1);
                    }
                    function ge(e) {
                        const t = atob(e.split(',')[1]),
                            i = new ArrayBuffer(t.length),
                            n = new Uint8Array(i);
                        for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);
                        return i;
                    }
                    class ye {
                        constructor(e) {
                            this.data = e;
                        }
                        static isGlb(e) {
                            const t = new Uint32Array(e, 0, ye.glbHeaderInts),
                                i = t[0],
                                n = t[1];
                            return i === this.glbMagic && n === this.glbVersion;
                        }
                        extractGlbData() {
                            if (void 0 === this.getCheckedGlbInfo())
                                return { json: Ee, buffers: [] };
                            let e;
                            const t = [],
                                i = this.getAllChunkInfos();
                            for (const n of i)
                                n.type !== ye.jsonChunkType || e
                                    ? n.type === ye.binaryChunkType &&
                                      t.push(this.getBufferFromChunk(n))
                                    : (e = this.getJsonFromChunk(n));
                            return { json: e || Ee, buffers: t };
                        }
                        getCheckedGlbInfo() {
                            const e = new Uint32Array(this.data, 0, ye.glbHeaderInts),
                                t = e[0],
                                i = e[1],
                                n = e[2];
                            if (
                                this.checkEquality(t, ye.glbMagic, 'glb magic') &&
                                this.checkEquality(i, ye.glbVersion, 'glb header version') &&
                                this.checkEquality(n, this.data.byteLength, 'glb byte length')
                            )
                                return { magic: t, version: i, length: n };
                        }
                        getAllChunkInfos() {
                            const e = [];
                            let t = 4 * ye.glbHeaderInts;
                            for (; t < this.data.byteLength; ) {
                                const i = this.getChunkInfo(t);
                                e.push(i), (t += i.length + 4 * ye.glbChunkHeaderInts);
                            }
                            return e;
                        }
                        getChunkInfo(e) {
                            const t = new Uint32Array(this.data, e, ye.glbChunkHeaderInts);
                            return {
                                start: e + 4 * ye.glbChunkHeaderInts,
                                length: t[0],
                                type: t[1],
                            };
                        }
                        getJsonFromChunk(e) {
                            const t = e.length,
                                i = 4 * (ye.glbHeaderInts + ye.glbChunkHeaderInts),
                                n = new Uint8Array(this.data, i, t),
                                o = new TextDecoder('utf-8').decode(n);
                            return JSON.parse(o);
                        }
                        getBufferFromChunk(e) {
                            return this.data.slice(e.start, e.start + e.length);
                        }
                        checkEquality(e, t, i) {
                            return (
                                e === t ||
                                (console.error(
                                    `[GLB MODEL PARSING ERROR] Found invalid/unsupported ${i}, expected: ${t}, but was: ${e}`,
                                ),
                                !1)
                            );
                        }
                    }
                    (ye.glbHeaderInts = 3),
                        (ye.glbChunkHeaderInts = 2),
                        (ye.glbMagic = 1179937895),
                        (ye.glbVersion = 2),
                        (ye.jsonChunkType = 1313821514),
                        (ye.binaryChunkType = 5130562);
                    var be = i(6849);
                    let we;
                    function xe() {
                        we = (function () {
                            return (0, n.mG)(this, void 0, void 0, function* () {
                                const e = yield (function () {
                                    return (0, n.mG)(this, void 0, void 0, function* () {
                                        let e = yield fetch(be.Sl).then((e) => e.text());
                                        const t =
                                                "if (typeof exports === 'object' && typeof module === 'object')",
                                            i = e.indexOf(t);
                                        return (
                                            0 !== i &&
                                                ((e = e.slice(0, i)),
                                                (e += 'return DracoDecoderModule;')),
                                            e
                                        );
                                    });
                                })();
                                return new Function(e)()();
                            });
                        })()
                            .then((e) => e)
                            .catch((e) => {
                                const t =
                                    'Draco decoder module failed to initialize' +
                                    ((null == e ? void 0 : e.message)
                                        ? ` with the following error: ${e.message}`
                                        : '.');
                                throw new Error(t);
                            });
                    }
                    function Se(e) {
                        switch (e) {
                            case 5120:
                                return 'Int8Array';
                            case 5121:
                                return 'Uint8Array';
                            case 5122:
                                return 'Int16Array';
                            case 5123:
                                return 'Uint16Array';
                            case 5124:
                                return 'Int32Array';
                            case 5125:
                                return 'Uint32Array';
                            default:
                                return 'Float32Array';
                        }
                    }
                    function Ie(e, t, i, n, o, r) {
                        const s = o.num_components(),
                            a = i.num_points() * s;
                        let l, c, d;
                        switch (r) {
                            case 'Float32Array':
                                (d = 4 * a),
                                    (l = e._malloc(d)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_FLOAT32, d, l),
                                    (c = new Float32Array(e.HEAPF32.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Int8Array':
                                (l = e._malloc(a)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_INT8, a, l),
                                    (c = new Int8Array(e.HEAP8.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Int16Array':
                                (d = 2 * a),
                                    (l = e._malloc(d)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_INT16, d, l),
                                    (c = new Int16Array(e.HEAP16.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Int32Array':
                                (d = 4 * a),
                                    (l = e._malloc(d)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_INT32, d, l),
                                    (c = new Int32Array(e.HEAP32.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Uint8Array':
                                (l = e._malloc(a)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_UINT8, a, l),
                                    (c = new Uint8Array(e.HEAPU8.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Uint16Array':
                                (d = 2 * a),
                                    (l = e._malloc(d)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_UINT16, d, l),
                                    (c = new Uint16Array(e.HEAPU16.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            case 'Uint32Array':
                                (d = 4 * a),
                                    (l = e._malloc(d)),
                                    t.GetAttributeDataArrayForAllPoints(i, o, e.DT_UINT32, d, l),
                                    (c = new Uint32Array(e.HEAPU32.buffer, l, a).slice()),
                                    e._free(l);
                                break;
                            default:
                                throw new Error('DRACOLoader: Unexpected attribute type.');
                        }
                        return { name: n, array: c, itemSize: s, componentType: r };
                    }
                    function Me(e, t, i, n) {
                        const o = e.bufferView,
                            r = t.bufferViews[o],
                            s = t.buffers[r.buffer],
                            a = new Int8Array(s.buffer).slice(
                                r.byteOffset,
                                r.byteOffset + r.byteLength,
                            ),
                            l = new i.Decoder(),
                            c = new i.DecoderBuffer();
                        c.Init(a, r.byteLength);
                        const d = (function (e, t, i, n, o, r) {
                            let s, a;
                            const l = t.GetEncodedGeometryType(i);
                            if (l !== e.TRIANGULAR_MESH)
                                throw new Error('DRACOLoader: Unexpected geometry type.');
                            if (
                                ((s = new e.Mesh()),
                                (a = t.DecodeBufferToMesh(i, s)),
                                !a.ok() || 0 === s.ptr)
                            )
                                throw new Error('DRACOLoader: Decoding failed: ' + a.error_msg());
                            const c = { index: null, attributes: {} },
                                d = s.num_points();
                            for (const i in n) {
                                let a,
                                    l = 5120;
                                for (const [e, t] of Object.entries(r))
                                    if (e === i) {
                                        (l = o.accessors[t].componentType),
                                            (a = o.accessors[t].count);
                                        break;
                                    }
                                if (d !== a)
                                    throw new Error(
                                        `DRACOLoader: Accessor vertex count ${a} does not match draco decoder vertex count  ${d}`,
                                    );
                                l = Se(l);
                                const h = t.GetAttributeByUniqueId(s, n[i]),
                                    u = Ie(e, t, s, i, h, l);
                                c.attributes[u.name] = u;
                            }
                            if (l === e.TRIANGULAR_MESH) {
                                const i = 3 * s.num_faces(),
                                    n = 4 * i,
                                    o = e._malloc(n);
                                t.GetTrianglesUInt32Array(s, n, o);
                                const r = new Uint32Array(e.HEAPU32.buffer, o, i).slice();
                                e._free(o), (c.index = { array: r, itemSize: 1 });
                            }
                            return e.destroy(s), c;
                        })(i, l, c, e.attributes, t, n);
                        return i.destroy(c), d;
                    }
                    function Te(e, t, i, n, o) {
                        const r = {
                            buffer: e,
                            byteLength: e.byteLength,
                            extensions: void 0,
                            extras: void 0,
                            name: void 0,
                            uri: void 0,
                        };
                        t.buffers.push(r);
                        const s = {
                            buffer: t.buffers.length - 1,
                            byteLength: e.byteLength,
                            byteOffset: 0,
                            byteStride: 0,
                            extensions: void 0,
                            extras: void 0,
                            name: o,
                            target: n,
                        };
                        t.bufferViews.push(s),
                            (t.accessors[i].byteOffset = 0),
                            (t.accessors[i].bufferView = t.bufferViews.length - 1);
                    }
                    function Pe(e, t) {
                        let i;
                        switch (t) {
                            case 'Int8Array':
                                i = new ArrayBuffer(e.length);
                                new Int8Array(i).set(e);
                                break;
                            case 'Uint8Array':
                                i = new ArrayBuffer(e.length);
                                new Uint8Array(i).set(e);
                                break;
                            case 'Int16Array':
                                i = new ArrayBuffer(2 * e.length);
                                new Int16Array(i).set(e);
                                break;
                            case 'Uint16Array':
                                i = new ArrayBuffer(2 * e.length);
                                new Uint16Array(i).set(e);
                                break;
                            case 'Int32Array':
                                i = new ArrayBuffer(4 * e.length);
                                new Int32Array(i).set(e);
                                break;
                            case 'Uint32Array':
                                i = new ArrayBuffer(4 * e.length);
                                new Uint32Array(i).set(e);
                                break;
                            default:
                                i = new ArrayBuffer(4 * e.length);
                                new Float32Array(i).set(e);
                        }
                        return i;
                    }
                    function Le(e, t, i, n) {
                        const o = t.index.array;
                        if (
                            (void 0 !== n &&
                                (Te(o, e, n, 34963, 'index buffer view'),
                                (e.accessors[n].componentType = 5125)),
                            void 0 !== t.attributes.POSITION)
                        ) {
                            Te(
                                Pe(
                                    t.attributes.POSITION.array,
                                    t.attributes.POSITION.componentType,
                                ),
                                e,
                                i.POSITION,
                                34962,
                                'position buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.NORMAL) {
                            Te(
                                Pe(t.attributes.NORMAL.array, t.attributes.NORMAL.componentType),
                                e,
                                i.NORMAL,
                                34962,
                                'normal buffer view',
                            );
                        }
                        for (let n = 0; n < 4; ++n) {
                            const o = `TEXCOORD_${n}`;
                            if (void 0 !== t.attributes[o]) {
                                Te(
                                    Pe(t.attributes[o].array, t.attributes[o].componentType),
                                    e,
                                    i[o],
                                    34962,
                                    `${o} buffer view`,
                                );
                            }
                        }
                        if (void 0 !== t.attributes.TANGENT) {
                            Te(
                                Pe(t.attributes.TANGENT.array, t.attributes.TANGENT.componentType),
                                e,
                                i.TANGENT,
                                34962,
                                'Tangent buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.COLOR_0) {
                            Te(
                                Pe(t.attributes.COLOR_0.array, t.attributes.COLOR_0.componentType),
                                e,
                                i.COLOR_0,
                                34962,
                                'color buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.JOINTS_0) {
                            Te(
                                Pe(
                                    t.attributes.JOINTS_0.array,
                                    t.attributes.JOINTS_0.componentType,
                                ),
                                e,
                                i.JOINTS_0,
                                34963,
                                'JOINTS_0 buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.WEIGHTS_0) {
                            Te(
                                Pe(
                                    t.attributes.WEIGHTS_0.array,
                                    t.attributes.WEIGHTS_0.componentType,
                                ),
                                e,
                                i.WEIGHTS_0,
                                34963,
                                'WEIGHTS_0 buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.JOINTS_1) {
                            Te(
                                Pe(
                                    t.attributes.JOINTS_1.array,
                                    t.attributes.JOINTS_1.componentType,
                                ),
                                e,
                                i.JOINTS_1,
                                34963,
                                'JOINTS_1 buffer view',
                            );
                        }
                        if (void 0 !== t.attributes.WEIGHTS_1) {
                            Te(
                                Pe(
                                    t.attributes.WEIGHTS_1.array,
                                    t.attributes.WEIGHTS_1.componentType,
                                ),
                                e,
                                i.WEIGHTS_1,
                                34963,
                                'WEIGHTS_1 buffer view',
                            );
                        }
                    }
                    function ke(e) {
                        return (0, n.mG)(this, void 0, void 0, function* () {
                            const t = yield self.fetch(e);
                            if (!t.ok) throw new Error(`${t.status} ${t.statusText}: ${t.url}`);
                            return t;
                        });
                    }
                    const Ee = { asset: { version: '' } };
                    function Ae(e, t) {
                        return (0, n.mG)(this, void 0, void 0, function* () {
                            if (void 0 === t.uri) return !1;
                            const i =
                                t.mimeType ||
                                ((n = t.uri).startsWith('data:image')
                                    ? n.split(';')[0].split(':')[1]
                                    : '.png' === n.substring(n.lastIndexOf('.'))
                                    ? pe
                                    : fe);
                            var n;
                            if (
                                ((t.mimeType = i),
                                'undefined' == typeof createImageBitmap || (i !== fe && i !== pe))
                            )
                                return console.error(`Unsupported image type ${i}`), !1;
                            if (t.uri.startsWith('data:image')) {
                                const e = ge(t.uri);
                                t.image = yield createImageBitmap(new Blob([e], { type: i }));
                            } else {
                                const n = yield ke(`${ve(e.path)}${t.uri}`),
                                    o = yield n.arrayBuffer();
                                t.image = yield createImageBitmap(new Blob([o], { type: i }));
                            }
                            return !0;
                        });
                    }
                    function ze(e, t) {
                        return (0, n.mG)(this, void 0, void 0, function* () {
                            yield Promise.all(
                                e.images.map((i) =>
                                    (0, n.mG)(this, void 0, void 0, function* () {
                                        if (i.image)
                                            return void (
                                                i.mimeType !== _e &&
                                                console.error('Image has already been loaded')
                                            );
                                        const o = yield (function (e, t, i) {
                                            var o;
                                            return (0, n.mG)(this, void 0, void 0, function* () {
                                                if (!t.bufferView) return !1;
                                                const n = e.bufferViews[t.bufferView];
                                                if (void 0 === n) return !1;
                                                yield i;
                                                const r = e.buffers[n.buffer].buffer;
                                                if (!r) return !1;
                                                const s = new Uint8Array(
                                                    r,
                                                    n.byteOffset,
                                                    n.byteLength,
                                                );
                                                if ('undefined' == typeof createImageBitmap)
                                                    return !1;
                                                if (
                                                    !(function (e) {
                                                        const t =
                                                                137 === e[0] &&
                                                                80 === e[1] &&
                                                                78 === e[2] &&
                                                                71 === e[3] &&
                                                                13 === e[4] &&
                                                                10 === e[5] &&
                                                                26 === e[6] &&
                                                                10 === e[7],
                                                            i =
                                                                255 === e[0] &&
                                                                216 === e[1] &&
                                                                255 === e[2];
                                                        return t || i;
                                                    })(s)
                                                )
                                                    return (
                                                        console.error(
                                                            `Unsupported image type ${
                                                                null !== (o = t.mimeType) &&
                                                                void 0 !== o
                                                                    ? o
                                                                    : ''
                                                            }`,
                                                        ),
                                                        !1
                                                    );
                                                {
                                                    const e = new Blob([s], { type: t.mimeType });
                                                    t.image = yield createImageBitmap(e);
                                                }
                                                return !0;
                                            });
                                        })(e, i, t);
                                        if (o) return;
                                        (yield Ae(e, i)) ||
                                            console.error(
                                                `Was not able to resolve image with uri ${i.uri}`,
                                            );
                                    }),
                                ),
                            );
                        });
                    }
                    function Ce(e) {
                        return (0, n.mG)(this, void 0, void 0, function* () {
                            const t = (function (e) {
                                return e.startsWith('/') ? `${self.origin}${e}` : e;
                            })(e);
                            try {
                                const e = yield ke(t);
                                let i,
                                    o = Ee;
                                try {
                                    const r = yield e.arrayBuffer();
                                    if (ye.isGlb(r)) {
                                        const e = new ye(r).extractGlbData();
                                        (o = e.json), (i = e.buffers);
                                    } else o = yield e.json();
                                    const s = (function (e, t) {
                                            var i, n, o;
                                            return {
                                                path: t,
                                                extensions: e.extensions,
                                                extensionsRequired:
                                                    null !== (i = e.extensionsRequired) &&
                                                    void 0 !== i
                                                        ? i
                                                        : [],
                                                extensionsUsed:
                                                    null !== (n = e.extensionsUsed) && void 0 !== n
                                                        ? n
                                                        : [],
                                                extras: e.extras,
                                                accessors: te(e.accessors),
                                                buffers: ne(e.buffers),
                                                bufferViews: oe(e.bufferViews),
                                                cameras: re(e.cameras),
                                                scene:
                                                    null !== (o = e.scene) && void 0 !== o ? o : 0,
                                                scenes: le(e.scenes),
                                                nodes: ce(e.nodes),
                                                materials: ae(e.materials),
                                                meshes: se(e.meshes),
                                                asset: ee(e.asset),
                                                animations: ie(e.animations),
                                                images: de(e.images),
                                                textures: he(e.textures),
                                                samplers: ue(e.samplers),
                                                skins: me(e.skins),
                                            };
                                        })(o, t),
                                        a = (function (e, t) {
                                            return (0, n.mG)(this, void 0, void 0, function* () {
                                                t
                                                    ? (e.buffers[0].buffer = t[0] || [])
                                                    : yield Promise.all(
                                                          e.buffers.map((t) =>
                                                              (0, n.mG)(
                                                                  this,
                                                                  void 0,
                                                                  void 0,
                                                                  function* () {
                                                                      if (t.buffer)
                                                                          console.error(
                                                                              'Buffer is already loaded',
                                                                          );
                                                                      else if (t.uri)
                                                                          if (
                                                                              t.uri.startsWith(
                                                                                  'data:',
                                                                              )
                                                                          )
                                                                              t.buffer = ge(t.uri);
                                                                          else {
                                                                              const i = yield ke(
                                                                                  ve(e.path) +
                                                                                      t.uri,
                                                                              ).then((e) =>
                                                                                  e.arrayBuffer(),
                                                                              );
                                                                              t.buffer = i;
                                                                          }
                                                                      else
                                                                          console.error(
                                                                              'Buffer can not be loaded. No uri',
                                                                          );
                                                                  },
                                                              ),
                                                          ),
                                                      );
                                            });
                                        })(s, i),
                                        l = ze(s, a),
                                        c = (function (e) {
                                            var t;
                                            return (0, n.mG)(this, void 0, void 0, function* () {
                                                if (!Array.isArray(e.meshes))
                                                    return Promise.resolve();
                                                for (const i of e.meshes)
                                                    if (Array.isArray(i.primitives))
                                                        for (const n of i.primitives) {
                                                            if (
                                                                void 0 ===
                                                                (null === (t = n.extensions) ||
                                                                void 0 === t
                                                                    ? void 0
                                                                    : t.KHR_draco_mesh_compression)
                                                            )
                                                                continue;
                                                            we || xe();
                                                            const i = yield we;
                                                            if (!i) continue;
                                                            const o = Me(
                                                                n.extensions
                                                                    .KHR_draco_mesh_compression,
                                                                e,
                                                                i,
                                                                n.attributes,
                                                            );
                                                            Le(e, o, n.attributes, n.indices);
                                                        }
                                            });
                                        })(s);
                                    return yield Promise.all([a, l, c]), { type: 'ok', result: s };
                                } catch (e) {
                                    return { type: 'error', layer: 'parsing', originalError: e };
                                }
                            } catch (e) {
                                return { type: 'error', layer: 'network', originalError: e };
                            }
                        });
                    }
                    var Fe = i(7966);
                    !(function (e) {
                        const t = new O.D(e),
                            i = new D.J(t),
                            o = new X.Z(i),
                            c = new G(),
                            d = new W.h(),
                            h = {
                                main: { addNewRasterSets: i.get(R.P.Main, 'addNewRasterSets') },
                                labeling: {
                                    addNewRasterSets: i.get(R.P.Labeling, 'addNewRasterSets'),
                                },
                            },
                            p = {},
                            v = new f.c(),
                            x = {},
                            S = new A.P('parser'),
                            I = (0, s.D)(() => S.reset(), a.workerResetDebounceTime),
                            k = () => {
                                const e = S.atlasPacker.getNewRasterSets();
                                e.size &&
                                    e.forEach((e, t) => {
                                        h.main.addNewRasterSets(t, e),
                                            h.labeling.addNewRasterSets(t, e);
                                    });
                            },
                            E = {
                                sources: {},
                                collector: S,
                                styleManager: d,
                                syncNewRasterSets: k,
                                debouncedResetCollector: I,
                            };
                        o.set('GeoJsonSource', Y.T, E);
                        const H = {
                            hiddenObjectIds: v,
                            collector: S,
                            metatiles: p,
                            styleManager: d,
                            syncRasterSets: k,
                            resetCollector: I,
                            createImageBitmap: e.createImageBitmap,
                        };
                        o.set('ZenithWorker', K.Z, H);
                        const V = (e, t) => {
                            p[e] = t;
                        };
                        i.set('setMetatile', V);
                        const q = new $(i);
                        V(l.DL, q),
                            i.set('appendHiddenObjectIds', (e) => {
                                e.forEach((e) => v.add(e));
                            }),
                            i.set('removeHiddenObjectIds', (e) => {
                                e.forEach((e) => v.delete(e));
                            }),
                            i.set('syncStyle', (...e) => d.proxySyncStyle(...e)),
                            i.set(
                                'prepareAtlas',
                                (t) =>
                                    new Promise((i) => {
                                        (0, z.n)({ url: t }, (t, n) => {
                                            if (t || 0 === n.byteLength) i(void 0);
                                            else if (e.createImageBitmap) {
                                                const e = new Blob([n], { type: 'image/png' });
                                                createImageBitmap(e).then((e) => {
                                                    i({
                                                        isBitmap: !0,
                                                        data: [e],
                                                        transferable: [e],
                                                    });
                                                });
                                            } else
                                                i({ isBitmap: !1, data: [n], transferable: [n] });
                                        });
                                    }),
                            ),
                            i.set('packRasters', (e) => {
                                for (let t = 0; t < e.length; t += 3) {
                                    const i = e[t + 2],
                                        n = {
                                            type: F.f.Loaded,
                                            isSvg: !1,
                                            index: i,
                                            key: `loaded-${i}`,
                                            name: '',
                                            fileName: '',
                                            rasters: [
                                                {
                                                    rasterSetIndex: i,
                                                    rasterIndex: 0,
                                                    w: e[t],
                                                    h: e[t + 1],
                                                    atlasIndex: 0,
                                                    x: 0,
                                                    y: 0,
                                                    isPacked: !1,
                                                    anchorX: 0,
                                                    anchorY: 0,
                                                },
                                            ],
                                        };
                                    S.atlasPacker.pack(n, [e[t]], 1);
                                }
                                const t = S.atlasPacker.getPackedRasters(),
                                    i = [];
                                return (
                                    void 0 !== t && i.push(t.buffer),
                                    { packedRasters: t, transferable: i }
                                );
                            }),
                            i.set('fetchTrafficTile', (e) =>
                                c.fetch(
                                    e.coords,
                                    e.tileServer,
                                    e.tileProtocol,
                                    e.regionIds,
                                    e.timestamp,
                                ),
                            ),
                            i.set('deleteTrafficTile', (e) => {
                                c.delete(e);
                            }),
                            i.set('abortTrafficTileRequest', (e) => {
                                c.abortRequest(e);
                            });
                        const J = (0, b.KP)(
                            [
                                'db_sublayer',
                                'traffic_road_class',
                                'traffic_color',
                                'traffic_road_z_level',
                            ],
                            ['Traffic_jams'],
                        );
                        i.set(
                            'generateTrafficTile',
                            ({
                                coords: e,
                                pixelRatio: t,
                                styleState: i,
                                styleId: n,
                                sourceId: o,
                            }) => {
                                const r = (0, j.gx)(e),
                                    s = [],
                                    a = [],
                                    h = d.getStyle(n);
                                if (!h) return { results: s, transferable: a };
                                const u = c.get(r);
                                if (u) {
                                    const n = (function (e, t, i, n, o, r, s, a) {
                                        if (!i) return e.getAccumulatedData();
                                        const c = s[3],
                                            { tileProps: d } = t,
                                            h = Object.keys(d).length,
                                            u = [],
                                            m = (0, y.o1)(o),
                                            p = (0, _.Yi)(n, b.i4, d, u, b.wz);
                                        for (const n of r.tile) {
                                            const {
                                                color: o = 0,
                                                geo: r,
                                                road: v,
                                                normals: g,
                                                zLevel: y = 0,
                                            } = n;
                                            for (let e = 0; e < h; e++) u[e] = NaN;
                                            (u[d.db_sublayer] = 'Traffic_jams'),
                                                (u[d.traffic_color] = o),
                                                (u[d.traffic_road_class] = v),
                                                (u[d.traffic_road_z_level] = y),
                                                (u[d.drawLevel] = y),
                                                (u[d.beginningIsCut] = 0),
                                                (u[d.endingIsCut] = 0);
                                            for (let n = 0; n < r.length; n++) {
                                                const o = r[n],
                                                    d = g[n],
                                                    h = [[], [], [], []];
                                                for (let e = 0; e < o.length; e++)
                                                    (h[0][e] = o[e][0] * l.gt),
                                                        (h[1][e] = o[e][1] * l.gt),
                                                        (h[2][e] = d[e][0]),
                                                        (h[3][e] = d[e][1]);
                                                const u = i.layers.filter((e) =>
                                                    (0, _.FR)(e.filter, p),
                                                );
                                                (0, B.PA)(e, i, u, p, t, c, a, s, m, h, new f.c());
                                            }
                                        }
                                        return e.getAccumulatedData();
                                    })(S, J, h, i, t, u, e, o);
                                    s.push({
                                        regionId: 1,
                                        metatileHash: 0,
                                        styleId: h.id,
                                        collectorOutput: n,
                                    });
                                }
                                return { results: s, transferable: a };
                            },
                        ),
                            i.set(
                                'loadFloor',
                                (e, t) =>
                                    new Promise((i) => {
                                        (0, z.n)(
                                            {
                                                url: `${t}/complexes/${e}?fields=floorGeometries&format=pbf`,
                                            },
                                            (t, n) => {
                                                if (t || 0 === n.byteLength)
                                                    return void i({
                                                        type: 'error',
                                                        errorStatus: t ? t.status : 0,
                                                    });
                                                const o = new (r())(n),
                                                    s = C.Z.read(o),
                                                    a = s.tileCoords;
                                                (x[e] = Object.assign(Object.assign({}, s), {
                                                    tileCoords: [a[0], a[1], a[2], a[2]],
                                                })),
                                                    q.addData(
                                                        ((e) => {
                                                            const t = new Set(),
                                                                i = new Set(),
                                                                {
                                                                    floorGeometries: n,
                                                                    entities: o,
                                                                } = e;
                                                            for (let e = 0; e < n.length; e++) {
                                                                const { rooms: i } = n[e];
                                                                for (let e = 0; e < i.length; e++) {
                                                                    const {
                                                                        sublayer: n,
                                                                        areaSublayer: o,
                                                                        wallSublayer: r,
                                                                    } = i[e];
                                                                    t.add(n),
                                                                        r && t.add(r),
                                                                        t.add(o);
                                                                }
                                                            }
                                                            for (let e = 0; e < o.length; e++) {
                                                                const {
                                                                    humanReadableIconId: n,
                                                                    sublayer: r,
                                                                } = o[e];
                                                                t.add(r), n && i.add(n);
                                                            }
                                                            return {
                                                                sublayers: t,
                                                                objectClasses: i,
                                                            };
                                                        })(x[e]),
                                                    );
                                                const l = {};
                                                s.entities.forEach((e) => {
                                                    e.firmId && (l[e.firmId] = e.floorIndex);
                                                }),
                                                    i({
                                                        type: 'success',
                                                        center: s.center,
                                                        bound: s.bound,
                                                        defaultFloor: s.defaultFloor,
                                                        floors: s.floorGeometries.map(
                                                            ({ ids: e, name: t }) => ({
                                                                ids: e,
                                                                name: t,
                                                            }),
                                                        ),
                                                        buildings: s.buildings.concat(s.hybrids),
                                                        firmsToFloorIndexMap: l,
                                                    });
                                            },
                                        );
                                    }),
                            ),
                            i.set('generateFloor', (e, t, i, n, o, r, s, a, c) => {
                                const h = {
                                        tileCoords: x[e].tileCoords,
                                        collectorOutput: S.getAccumulatedData(),
                                        styleId: 0,
                                    },
                                    p = d.getStyle(r);
                                if (!p) return h;
                                let v;
                                return (
                                    (v = c
                                        ? S.getAccumulatedData()
                                        : (function (e, t, i, n, o, r, s, a, c, d) {
                                              var h;
                                              const {
                                                      floorGeometries: p,
                                                      defaultFloor: v,
                                                      tileCoords: w,
                                                      entities: x,
                                                  } = n,
                                                  { tileProps: S } = o,
                                                  I = (0, y.o1)(s),
                                                  k = new f.c(),
                                                  E = new f.c(c),
                                                  A = [],
                                                  z = Object.keys(S).length;
                                              Number.isNaN(a) && (a = v);
                                              const C = p[a],
                                                  F = (0, _.Yi)(t, b.i4, S, A, b.wz);
                                              for (let t = 0; t < C.rooms.length; t++) {
                                                  const n = C.rooms[t];
                                                  for (let e = 0; e < z; e++) A[e] = NaN;
                                                  const o = n.firmIds.length
                                                          ? n.firmIds[0]
                                                          : n.buildingId,
                                                      s = (0, m.IL)(o);
                                                  k.add(s);
                                                  const a = E.has(s);
                                                  (A[S.id] = s),
                                                      n.isIsland
                                                          ? T(n, e, F, i, r, a)
                                                          : (P(n, F, e, i, r, a, I),
                                                            L(n, F, e, i, r, a));
                                              }
                                              for (let t = 0; t < x.length; t++) {
                                                  const n = x[t],
                                                      s = n.sublayer;
                                                  if (n.floorIndex !== a) continue;
                                                  if ((0, u.Ty)(s)) continue;
                                                  for (let e = 0; e < z; e++) A[e] = NaN;
                                                  (M[0] = [n.coordinates[0] * l.gt]),
                                                      (M[1] = [n.coordinates[1] * l.gt]);
                                                  for (let e = 0; e < z; e++) A[e] = NaN;
                                                  (A[S.db_sublayer] = s),
                                                      (A[S.db_point_building_id] = n.buildingId);
                                                  let c = !1;
                                                  const f = n.firmId || n.id;
                                                  if (f) {
                                                      const e = (0, m.IL)(f);
                                                      (c = E.has(e)), k.add(e), (A[S.id] = e);
                                                  }
                                                  (A[S.selected] = c ? 1 : 0),
                                                      (A[S.db_region] = r),
                                                      (0, u.Ty)(s) ||
                                                          (A[S.db_object_class] =
                                                              null !==
                                                                  (h = n.humanReadableIconId) &&
                                                              void 0 !== h
                                                                  ? h
                                                                  : o.reverseDictionaries
                                                                        .db_object_class[n.iconId]),
                                                      (A[S.db_label] = n.text),
                                                      (A[S.db_label2] = n.text2),
                                                      (A[S.db_icon_priority] = n.priority),
                                                      (A[S.db_label_priority] = n.textPriority);
                                                  const p = (0, m.IL)(n.floorId);
                                                  e.layers.forEach((t) => {
                                                      'point' === t.type &&
                                                          (0, _.FR)(t.filter, F) &&
                                                          (0, g.p)(
                                                              i,
                                                              e,
                                                              t,
                                                              F,
                                                              o,
                                                              w,
                                                              d,
                                                              M,
                                                              I,
                                                              void 0,
                                                              p,
                                                          );
                                                  });
                                              }
                                              return (
                                                  i.setGeoIds(new Uint32Array(k.toFlatArray())),
                                                  i.getAccumulatedData()
                                              );
                                          })(p, s, S, x[e], q, t, i, n, o, a)),
                                    I(),
                                    k(),
                                    {
                                        tileCoords: x[e].tileCoords,
                                        collectorOutput: v,
                                        transferable: v.transferable,
                                        styleId: p.id,
                                    }
                                );
                            }),
                            i.set('generatePersonalPoi', (e, t, i, n, o, r, s, a) => {
                                const l = d.getStyle(r);
                                if (!l) return;
                                const c = (function (e, t, i, n, o, r, s, a, l) {
                                    var c, d, h;
                                    const { tileProps: u, dictionaries: p } = n,
                                        v = Object.keys(u).length,
                                        g = new f.c(s),
                                        x = [],
                                        S = (0, _.Yi)(i, b.i4, u, x, b.wz);
                                    if (
                                        void 0 ===
                                        (null === (c = p.db_sublayer) || void 0 === c
                                            ? void 0
                                            : c.s_personal_poi)
                                    )
                                        return e.getAccumulatedData();
                                    for (let e = 0; e < v; e++) x[e] = NaN;
                                    const I = (0, y.o1)(r),
                                        M = w.Ue(),
                                        T = [];
                                    for (const e of a) {
                                        const t = (0, U.yq)(e.point);
                                        w.aM(M, t), T.push(t);
                                    }
                                    const P = (0, j.x7)(M),
                                        L = (0, j.Bs)(P);
                                    for (let i = 0; i < a.length; i++) {
                                        const r = a[i],
                                            s = N.Ue();
                                        (0, j.a2)(s, T[i], L);
                                        const c = (0, m.IL)(r.id),
                                            p = [[s[0]], [s[1]]];
                                        for (let e = 0; e < v; e++) x[e] = NaN;
                                        (x[u.id] = (0, m.IL)(r.id)),
                                            (x[u.db_sublayer] = 's_personal_poi'),
                                            (x[u.db_object_class] =
                                                null !== (d = r.humanReadableClassId) &&
                                                void 0 !== d
                                                    ? d
                                                    : null ===
                                                          (h =
                                                              n.reverseDictionaries
                                                                  .db_object_class) || void 0 === h
                                                    ? void 0
                                                    : h[r.classId]),
                                            (x[u.db_label] = r.name),
                                            (x[u.db_icon_priority] = 1),
                                            (x[u.db_label_priority] = 0),
                                            (x[u.selected] = g.has(c) ? 1 : 0),
                                            (x[u.db_region] = o),
                                            (Z = t.layers.filter((e) => (0, _.FR)(e.filter, S)));
                                        const y = void 0,
                                            b = new f.c();
                                        (0, B.PA)(e, t, Z, S, n, y, l, P, I, p, b);
                                    }
                                    return e.getAccumulatedData();
                                })(S, l, s, p[i], t, n, o, e, a);
                                return (
                                    I(),
                                    k(),
                                    {
                                        collectorOutput: c,
                                        transferable: c.transferable,
                                        styleId: l.id,
                                    }
                                );
                            }),
                            i.set('loadModel', (e, t) =>
                                (0, n.mG)(this, void 0, void 0, function* () {
                                    let i;
                                    if (t >= 0) {
                                        const n = d.getStyle(e);
                                        if (void 0 === n) return { type: 'ok', result: void 0 };
                                        const o = n.models[t];
                                        i = (0, Fe.gA)(o.url, n);
                                    } else i = S.getDataModelUrl(t);
                                    return i
                                        ? yield Ce(i)
                                        : {
                                              type: 'error',
                                              layer: 'prepare',
                                              message: `No url for model with index = ${t}`,
                                          };
                                }),
                            );
                    })(self);
                },
                2205: () => {
                    setTimeout(() => {
                        if ('__mapglPlugins' in window)
                            for (const e in window.__mapglPlugins)
                                window.mapgl[e] = window.__mapglPlugins[e];
                    }, 0);
                },
                7721: (e, t) => {
                    var i = (t.Z = {});
                    (i.read = function (e, t) {
                        return e.readFields(
                            i._readField,
                            {
                                id: '',
                                name: '',
                                address: '',
                                type: 0,
                                regionId: 0,
                                branchId: '',
                                branchCount: 0,
                                buildings: [],
                                hull: [],
                                tileCoords: [],
                                center: [],
                                centroid: [],
                                scaleFactor: 0,
                                viewAngle: 0,
                                bound: null,
                                floorCount: 0,
                                defaultFloor: 0,
                                floorNames: [],
                                entities: [],
                                floorGeometries: [],
                                outdoors: [],
                                metaRubrics: [],
                                version: 0,
                                hybrids: [],
                            },
                            t,
                        );
                    }),
                        (i._readField = function (e, t, n) {
                            1 === e
                                ? (t.id = n.readString())
                                : 2 === e
                                ? (t.name = n.readString())
                                : 3 === e
                                ? (t.address = n.readString())
                                : 4 === e
                                ? (t.type = n.readVarint())
                                : 5 === e
                                ? (t.regionId = n.readVarint())
                                : 6 === e
                                ? (t.branchId = n.readString())
                                : 7 === e
                                ? (t.branchCount = n.readVarint())
                                : 8 === e
                                ? t.buildings.push(n.readString())
                                : 9 === e
                                ? n.readPackedSVarint(t.hull)
                                : 10 === e
                                ? n.readPackedDouble(t.tileCoords)
                                : 11 === e
                                ? n.readPackedSVarint(t.center)
                                : 12 === e
                                ? n.readPackedDouble(t.centroid)
                                : 13 === e
                                ? (t.scaleFactor = n.readDouble())
                                : 14 === e
                                ? (t.viewAngle = n.readDouble())
                                : 15 === e
                                ? (t.bound = i.Bound.read(n, n.readVarint() + n.pos))
                                : 16 === e
                                ? (t.floorCount = n.readVarint())
                                : 17 === e
                                ? (t.defaultFloor = n.readVarint())
                                : 18 === e
                                ? t.floorNames.push(n.readString())
                                : 19 === e
                                ? t.entities.push(i.Entity.read(n, n.readVarint() + n.pos))
                                : 20 === e
                                ? t.floorGeometries.push(i.Floor.read(n, n.readVarint() + n.pos))
                                : 21 === e
                                ? t.outdoors.push(i.OutdoorObject.read(n, n.readVarint() + n.pos))
                                : 22 === e
                                ? t.metaRubrics.push(i.Metarubric.read(n, n.readVarint() + n.pos))
                                : 23 === e
                                ? (t.version = n.readVarint())
                                : 24 === e && t.hybrids.push(n.readString());
                        }),
                        (i.write = function (e, t) {
                            if (
                                (e.id && t.writeStringField(1, e.id),
                                e.name && t.writeStringField(2, e.name),
                                e.address && t.writeStringField(3, e.address),
                                e.type && t.writeVarintField(4, e.type),
                                e.regionId && t.writeVarintField(5, e.regionId),
                                e.branchId && t.writeStringField(6, e.branchId),
                                e.branchCount && t.writeVarintField(7, e.branchCount),
                                e.buildings)
                            )
                                for (var n = 0; n < e.buildings.length; n++)
                                    t.writeStringField(8, e.buildings[n]);
                            if (
                                (e.hull && t.writePackedSVarint(9, e.hull),
                                e.tileCoords && t.writePackedDouble(10, e.tileCoords),
                                e.center && t.writePackedSVarint(11, e.center),
                                e.centroid && t.writePackedDouble(12, e.centroid),
                                e.scaleFactor && t.writeDoubleField(13, e.scaleFactor),
                                e.viewAngle && t.writeDoubleField(14, e.viewAngle),
                                e.bound && t.writeMessage(15, i.Bound.write, e.bound),
                                e.floorCount && t.writeVarintField(16, e.floorCount),
                                e.defaultFloor && t.writeVarintField(17, e.defaultFloor),
                                e.floorNames)
                            )
                                for (n = 0; n < e.floorNames.length; n++)
                                    t.writeStringField(18, e.floorNames[n]);
                            if (e.entities)
                                for (n = 0; n < e.entities.length; n++)
                                    t.writeMessage(19, i.Entity.write, e.entities[n]);
                            if (e.floorGeometries)
                                for (n = 0; n < e.floorGeometries.length; n++)
                                    t.writeMessage(20, i.Floor.write, e.floorGeometries[n]);
                            if (e.outdoors)
                                for (n = 0; n < e.outdoors.length; n++)
                                    t.writeMessage(21, i.OutdoorObject.write, e.outdoors[n]);
                            if (e.metaRubrics)
                                for (n = 0; n < e.metaRubrics.length; n++)
                                    t.writeMessage(22, i.Metarubric.write, e.metaRubrics[n]);
                            if ((e.version && t.writeVarintField(23, e.version), e.hybrids))
                                for (n = 0; n < e.hybrids.length; n++)
                                    t.writeStringField(24, e.hybrids[n]);
                        }),
                        (i.ComplexType = {
                            mall: { value: 0, options: {} },
                            other: { value: 1, options: {} },
                            office: { value: 2, options: {} },
                        }),
                        (i.Metarubric = {}),
                        (i.Metarubric.read = function (e, t) {
                            return e.readFields(
                                i.Metarubric._readField,
                                { id: '', orgCount: 0 },
                                t,
                            );
                        }),
                        (i.Metarubric._readField = function (e, t, i) {
                            1 === e
                                ? (t.id = i.readString())
                                : 2 === e && (t.orgCount = i.readVarint());
                        }),
                        (i.Metarubric.write = function (e, t) {
                            e.id && t.writeStringField(1, e.id),
                                e.orgCount && t.writeVarintField(2, e.orgCount);
                        }),
                        (i.Bound = {}),
                        (i.Bound.read = function (e, t) {
                            return e.readFields(i.Bound._readField, { min: [], max: [] }, t);
                        }),
                        (i.Bound._readField = function (e, t, i) {
                            1 === e
                                ? i.readPackedSVarint(t.min)
                                : 2 === e && i.readPackedSVarint(t.max);
                        }),
                        (i.Bound.write = function (e, t) {
                            e.min && t.writePackedSVarint(1, e.min),
                                e.max && t.writePackedSVarint(2, e.max);
                        }),
                        (i.Entity = {}),
                        (i.Entity.read = function (e, t) {
                            return e.readFields(
                                i.Entity._readField,
                                {
                                    id: '',
                                    sublayer: '',
                                    coordinates: [],
                                    iconId: 0,
                                    areaId: 0,
                                    firmId: '',
                                    floorIndex: 0,
                                    floorName: '',
                                    text: '',
                                    layer: '',
                                    priority: 0,
                                    textPriority: 0,
                                    type: 0,
                                    text2: '',
                                    humanReadableIconId: '',
                                    floorId: '',
                                    buildingId: '',
                                },
                                t,
                            );
                        }),
                        (i.Entity._readField = function (e, t, i) {
                            1 === e
                                ? (t.id = i.readString())
                                : 2 === e
                                ? (t.sublayer = i.readString())
                                : 3 === e
                                ? i.readPackedVarint(t.coordinates)
                                : 4 === e
                                ? (t.iconId = i.readVarint())
                                : 5 === e
                                ? (t.areaId = i.readVarint())
                                : 6 === e
                                ? (t.firmId = i.readString())
                                : 7 === e
                                ? (t.floorIndex = i.readVarint())
                                : 8 === e
                                ? (t.floorName = i.readString())
                                : 9 === e
                                ? (t.text = i.readString())
                                : 10 === e
                                ? (t.layer = i.readString())
                                : 11 === e
                                ? (t.priority = i.readVarint(!0))
                                : 12 === e
                                ? (t.textPriority = i.readVarint(!0))
                                : 13 === e
                                ? (t.type = i.readVarint())
                                : 14 === e
                                ? (t.text2 = i.readString())
                                : 15 === e
                                ? (t.humanReadableIconId = i.readString())
                                : 16 === e
                                ? (t.floorId = i.readString())
                                : 17 === e && (t.buildingId = i.readString());
                        }),
                        (i.Entity.write = function (e, t) {
                            e.id && t.writeStringField(1, e.id),
                                e.sublayer && t.writeStringField(2, e.sublayer),
                                e.coordinates && t.writePackedVarint(3, e.coordinates),
                                e.iconId && t.writeVarintField(4, e.iconId),
                                e.areaId && t.writeVarintField(5, e.areaId),
                                e.firmId && t.writeStringField(6, e.firmId),
                                e.floorIndex && t.writeVarintField(7, e.floorIndex),
                                e.floorName && t.writeStringField(8, e.floorName),
                                e.text && t.writeStringField(9, e.text),
                                e.layer && t.writeStringField(10, e.layer),
                                e.priority && t.writeVarintField(11, e.priority),
                                e.textPriority && t.writeVarintField(12, e.textPriority),
                                e.type && t.writeVarintField(13, e.type),
                                e.text2 && t.writeStringField(14, e.text2),
                                e.humanReadableIconId &&
                                    t.writeStringField(15, e.humanReadableIconId),
                                e.floorId && t.writeStringField(16, e.floorId),
                                e.buildingId && t.writeStringField(17, e.buildingId);
                        }),
                        (i.Floor = {}),
                        (i.Floor.read = function (e, t) {
                            return e.readFields(
                                i.Floor._readField,
                                { name: '', rooms: [], ids: [] },
                                t,
                            );
                        }),
                        (i.Floor._readField = function (e, t, n) {
                            1 === e
                                ? (t.name = n.readString())
                                : 2 === e
                                ? t.rooms.push(i.Room.read(n, n.readVarint() + n.pos))
                                : 3 === e && t.ids.push(n.readString());
                        }),
                        (i.Floor.write = function (e, t) {
                            if ((e.name && t.writeStringField(1, e.name), e.rooms))
                                for (var n = 0; n < e.rooms.length; n++)
                                    t.writeMessage(2, i.Room.write, e.rooms[n]);
                            if (e.ids)
                                for (n = 0; n < e.ids.length; n++) t.writeStringField(3, e.ids[n]);
                        }),
                        (i.Room = {}),
                        (i.Room.read = function (e, t) {
                            return e.readFields(
                                i.Room._readField,
                                {
                                    id: 0,
                                    type: 0,
                                    sublayer: '',
                                    isIsland: !1,
                                    firmIds: [],
                                    area: [],
                                    wallSide: [],
                                    wallTop: [],
                                    areaSublayer: '',
                                    wallSublayer: '',
                                    floorId: '',
                                    buildingId: '',
                                },
                                t,
                            );
                        }),
                        (i.Room._readField = function (e, t, i) {
                            1 === e
                                ? (t.id = i.readVarint())
                                : 2 === e
                                ? (t.type = i.readVarint())
                                : 3 === e
                                ? (t.sublayer = i.readString())
                                : 4 === e
                                ? (t.isIsland = i.readBoolean())
                                : 5 === e
                                ? t.firmIds.push(i.readString())
                                : 6 === e
                                ? t.area.push(i.readBytes())
                                : 7 === e
                                ? t.wallSide.push(i.readBytes())
                                : 8 === e
                                ? t.wallTop.push(i.readBytes())
                                : 9 === e
                                ? (t.areaSublayer = i.readString())
                                : 10 === e
                                ? (t.wallSublayer = i.readString())
                                : 11 === e
                                ? (t.floorId = i.readString())
                                : 12 === e && (t.buildingId = i.readString());
                        }),
                        (i.Room.write = function (e, t) {
                            if (
                                (e.id && t.writeVarintField(1, e.id),
                                e.type && t.writeVarintField(2, e.type),
                                e.sublayer && t.writeStringField(3, e.sublayer),
                                e.isIsland && t.writeBooleanField(4, e.isIsland),
                                e.firmIds)
                            )
                                for (var i = 0; i < e.firmIds.length; i++)
                                    t.writeStringField(5, e.firmIds[i]);
                            if (e.area)
                                for (i = 0; i < e.area.length; i++) t.writeBytesField(6, e.area[i]);
                            if (e.wallSide)
                                for (i = 0; i < e.wallSide.length; i++)
                                    t.writeBytesField(7, e.wallSide[i]);
                            if (e.wallTop)
                                for (i = 0; i < e.wallTop.length; i++)
                                    t.writeBytesField(8, e.wallTop[i]);
                            e.areaSublayer && t.writeStringField(9, e.areaSublayer),
                                e.wallSublayer && t.writeStringField(10, e.wallSublayer),
                                e.floorId && t.writeStringField(11, e.floorId),
                                e.buildingId && t.writeStringField(12, e.buildingId);
                        }),
                        (i.OutdoorObject = {}),
                        (i.OutdoorObject.read = function (e, t) {
                            return e.readFields(
                                i.OutdoorObject._readField,
                                { type: '', vertices: [], width: 0 },
                                t,
                            );
                        }),
                        (i.OutdoorObject._readField = function (e, t, i) {
                            1 === e
                                ? (t.type = i.readString())
                                : 2 === e
                                ? t.vertices.push(i.readBytes())
                                : 3 === e && (t.width = i.readDouble());
                        }),
                        (i.OutdoorObject.write = function (e, t) {
                            if ((e.type && t.writeStringField(1, e.type), e.vertices))
                                for (var i = 0; i < e.vertices.length; i++)
                                    t.writeBytesField(2, e.vertices[i]);
                            e.width && t.writeDoubleField(3, e.width);
                        });
                },
                9748: (e, t) => {
                    var i = (t.w = {});
                    (i.read = function (e, t) {
                        return e.readFields(i._readField, { tiles: [] }, t);
                    }),
                        (i._readField = function (e, t, n) {
                            1 === e && t.tiles.push(i.Tile.read(n, n.readVarint() + n.pos));
                        }),
                        (i.write = function (e, t) {
                            if (e.tiles)
                                for (var n = 0; n < e.tiles.length; n++)
                                    t.writeMessage(1, i.Tile.write, e.tiles[n]);
                        }),
                        (i.Tile = {}),
                        (i.Tile.read = function (e, t) {
                            return e.readFields(i.Tile._readField, { x: 0, y: 0, zoom: 0 }, t);
                        }),
                        (i.Tile._readField = function (e, t, i) {
                            1 === e
                                ? (t.x = i.readVarint())
                                : 2 === e
                                ? (t.y = i.readVarint())
                                : 3 === e && (t.zoom = i.readVarint());
                        }),
                        (i.Tile.write = function (e, t) {
                            e.x && t.writeVarintField(1, e.x),
                                e.y && t.writeVarintField(2, e.y),
                                e.zoom && t.writeVarintField(3, e.zoom);
                        });
                    var n = (t.F = {});
                    (n.read = function (e, t) {
                        return e.readFields(n._readField, { tileGroups: [] }, t);
                    }),
                        (n._readField = function (e, t, i) {
                            1 === e &&
                                t.tileGroups.push(n.TileGroup.read(i, i.readVarint() + i.pos));
                        }),
                        (n.write = function (e, t) {
                            if (e.tileGroups)
                                for (var i = 0; i < e.tileGroups.length; i++)
                                    t.writeMessage(1, n.TileGroup.write, e.tileGroups[i]);
                        }),
                        (n.TileGroup = {}),
                        (n.TileGroup.read = function (e, t) {
                            return e.readFields(
                                n.TileGroup._readField,
                                { x: 0, y: 0, zoom: 0, tiles: [] },
                                t,
                            );
                        }),
                        (n.TileGroup._readField = function (e, t, i) {
                            1 === e
                                ? (t.x = i.readVarint())
                                : 2 === e
                                ? (t.y = i.readVarint())
                                : 3 === e
                                ? (t.zoom = i.readVarint())
                                : 4 === e &&
                                  t.tiles.push(n.TileGroup.Tile.read(i, i.readVarint() + i.pos));
                        }),
                        (n.TileGroup.write = function (e, t) {
                            if (
                                (e.x && t.writeVarintField(1, e.x),
                                e.y && t.writeVarintField(2, e.y),
                                e.zoom && t.writeVarintField(3, e.zoom),
                                e.tiles)
                            )
                                for (var i = 0; i < e.tiles.length; i++)
                                    t.writeMessage(4, n.TileGroup.Tile.write, e.tiles[i]);
                        }),
                        (n.TileGroup.Tile = {}),
                        (n.TileGroup.Tile.read = function (e, t) {
                            return e.readFields(
                                n.TileGroup.Tile._readField,
                                { regionId: 0, hash: null, data: null },
                                t,
                            );
                        }),
                        (n.TileGroup.Tile._readField = function (e, t, i) {
                            1 === e
                                ? (t.regionId = i.readVarint())
                                : 2 === e
                                ? (t.hash = i.readBytes())
                                : 3 === e && (t.data = i.readBytes());
                        }),
                        (n.TileGroup.Tile.write = function (e, t) {
                            e.regionId && t.writeVarintField(1, e.regionId),
                                e.hash && t.writeBytesField(2, e.hash),
                                e.data && t.writeBytesField(3, e.data);
                        });
                },
                9899: (e, t, i) => {
                    i.d(t, { Z: () => n });
                    const n = o;
                    function o(e, t, i) {
                        (i = i || {}),
                            (this.w = e || 64),
                            (this.h = t || 64),
                            (this.autoResize = !!i.autoResize),
                            (this.shelves = []),
                            (this.freebins = []),
                            (this.stats = {}),
                            (this.bins = {}),
                            (this.maxId = 0);
                    }
                    function r(e, t, i) {
                        (this.x = 0), (this.y = e), (this.w = this.free = t), (this.h = i);
                    }
                    function s(e, t, i, n, o, r, s) {
                        (this.id = e),
                            (this.x = t),
                            (this.y = i),
                            (this.w = n),
                            (this.h = o),
                            (this.maxw = r || n),
                            (this.maxh = s || o),
                            (this.refcount = 0);
                    }
                    (o.prototype.pack = function (e, t) {
                        (e = [].concat(e)), (t = t || {});
                        for (var i, n, o, r, s = [], a = 0; a < e.length; a++)
                            if (
                                ((i = e[a].w || e[a].width),
                                (n = e[a].h || e[a].height),
                                (o = e[a].id),
                                i && n)
                            ) {
                                if (!(r = this.packOne(i, n, o))) continue;
                                t.inPlace && ((e[a].x = r.x), (e[a].y = r.y), (e[a].id = r.id)),
                                    s.push(r);
                            }
                        return this.shrink(), s;
                    }),
                        (o.prototype.packOne = function (e, t, i) {
                            var n,
                                o,
                                s,
                                a,
                                l,
                                c,
                                d,
                                h,
                                u = { freebin: -1, shelf: -1, waste: 1 / 0 },
                                m = 0;
                            if ('string' == typeof i || 'number' == typeof i) {
                                if ((n = this.getBin(i))) return this.ref(n), n;
                                'number' == typeof i && (this.maxId = Math.max(i, this.maxId));
                            } else i = ++this.maxId;
                            for (a = 0; a < this.freebins.length; a++) {
                                if (t === (n = this.freebins[a]).maxh && e === n.maxw)
                                    return this.allocFreebin(a, e, t, i);
                                t > n.maxh ||
                                    e > n.maxw ||
                                    (t <= n.maxh &&
                                        e <= n.maxw &&
                                        (s = n.maxw * n.maxh - e * t) < u.waste &&
                                        ((u.waste = s), (u.freebin = a)));
                            }
                            for (a = 0; a < this.shelves.length; a++)
                                if (((m += (o = this.shelves[a]).h), !(e > o.free))) {
                                    if (t === o.h) return this.allocShelf(a, e, t, i);
                                    t > o.h ||
                                        (t < o.h &&
                                            (s = (o.h - t) * e) < u.waste &&
                                            ((u.freebin = -1), (u.waste = s), (u.shelf = a)));
                                }
                            return -1 !== u.freebin
                                ? this.allocFreebin(u.freebin, e, t, i)
                                : -1 !== u.shelf
                                ? this.allocShelf(u.shelf, e, t, i)
                                : t <= this.h - m && e <= this.w
                                ? ((o = new r(m, this.w, t)),
                                  this.allocShelf(this.shelves.push(o) - 1, e, t, i))
                                : this.autoResize
                                ? ((l = c = this.h),
                                  ((d = h = this.w) <= l || e > d) && (h = 2 * Math.max(e, d)),
                                  (l < d || t > l) && (c = 2 * Math.max(t, l)),
                                  this.resize(h, c),
                                  this.packOne(e, t, i))
                                : null;
                        }),
                        (o.prototype.allocFreebin = function (e, t, i, n) {
                            var o = this.freebins.splice(e, 1)[0];
                            return (
                                (o.id = n),
                                (o.w = t),
                                (o.h = i),
                                (o.refcount = 0),
                                (this.bins[n] = o),
                                this.ref(o),
                                o
                            );
                        }),
                        (o.prototype.allocShelf = function (e, t, i, n) {
                            var o = this.shelves[e].alloc(t, i, n);
                            return (this.bins[n] = o), this.ref(o), o;
                        }),
                        (o.prototype.shrink = function () {
                            if (this.shelves.length > 0) {
                                for (var e = 0, t = 0, i = 0; i < this.shelves.length; i++) {
                                    var n = this.shelves[i];
                                    (t += n.h), (e = Math.max(n.w - n.free, e));
                                }
                                this.resize(e, t);
                            }
                        }),
                        (o.prototype.getBin = function (e) {
                            return this.bins[e];
                        }),
                        (o.prototype.ref = function (e) {
                            if (1 == ++e.refcount) {
                                var t = e.h;
                                this.stats[t] = 1 + (0 | this.stats[t]);
                            }
                            return e.refcount;
                        }),
                        (o.prototype.unref = function (e) {
                            return 0 === e.refcount
                                ? 0
                                : (0 == --e.refcount &&
                                      (this.stats[e.h]--,
                                      delete this.bins[e.id],
                                      this.freebins.push(e)),
                                  e.refcount);
                        }),
                        (o.prototype.clear = function () {
                            (this.shelves = []),
                                (this.freebins = []),
                                (this.stats = {}),
                                (this.bins = {}),
                                (this.maxId = 0);
                        }),
                        (o.prototype.resize = function (e, t) {
                            (this.w = e), (this.h = t);
                            for (var i = 0; i < this.shelves.length; i++) this.shelves[i].resize(e);
                            return !0;
                        }),
                        (r.prototype.alloc = function (e, t, i) {
                            if (e > this.free || t > this.h) return null;
                            var n = this.x;
                            return (
                                (this.x += e),
                                (this.free -= e),
                                new s(i, n, this.y, e, t, e, this.h)
                            );
                        }),
                        (r.prototype.resize = function (e) {
                            return (this.free += e - this.w), (this.w = e), !0;
                        });
                },
            },
            t = {};
        function i(n) {
            var o = t[n];
            if (void 0 !== o) return o.exports;
            var r = (t[n] = { id: n, exports: {} });
            return e[n].call(r.exports, r, r.exports, i), r.exports;
        }
        return (
            (i.m = e),
            (i.n = (e) => {
                var t = e && e.__esModule ? () => e.default : () => e;
                return i.d(t, { a: t }), t;
            }),
            (i.d = (e, t) => {
                for (var n in t)
                    i.o(t, n) &&
                        !i.o(e, n) &&
                        Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
            }),
            (i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
            (i.r = (e) => {
                'undefined' != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }),
                    Object.defineProperty(e, '__esModule', { value: !0 });
            }),
            (i.nc = void 0),
            i(7773)
        );
    })(),
);
